<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>nRF9160与nRF Cloud应用示例 | Jayant的个人博客</title><meta name="author" content="Jayant Tang"><meta name="copyright" content="Jayant Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="使用nRF9160-DK 连接 nRF Cloud示例1. 产品简介1.1. nRF Cloud  nRF Cloud是Nordic Semiconducotr公司为Nordic无线产品专门优化的物联网云平台，它可以为任何使用Nordic芯片的客户的原型产品、商业产品提供便捷的云连接、云服务。 nRF Cloud提供设备注册（Cloud Provisioning）、OTA升级、数据存储、位置定位等">
<meta property="og:type" content="article">
<meta property="og:title" content="nRF9160与nRF Cloud应用示例">
<meta property="og:url" content="https://jayant-tang.github.io/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/index.html">
<meta property="og:site_name" content="Jayant的个人博客">
<meta property="og:description" content="使用nRF9160-DK 连接 nRF Cloud示例1. 产品简介1.1. nRF Cloud  nRF Cloud是Nordic Semiconducotr公司为Nordic无线产品专门优化的物联网云平台，它可以为任何使用Nordic芯片的客户的原型产品、商业产品提供便捷的云连接、云服务。 nRF Cloud提供设备注册（Cloud Provisioning）、OTA升级、数据存储、位置定位等">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-01T06:49:44.789Z">
<meta property="article:modified_time" content="2022-12-01T06:50:50.088Z">
<meta property="article:author" content="Jayant Tang">
<meta property="article:tag" content="Nordic">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/jayant97.github.io/img/favicon.png"><link rel="canonical" href="https://jayant-tang.github.io/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/jayant97.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/jayant97.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nRF9160与nRF Cloud应用示例',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-01 14:50:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/jayant97.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/jayant97.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/jayant97.github.io/">Jayant的个人博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nRF9160与nRF Cloud应用示例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-01T06:49:44.789Z" title="Created 2022-12-01 14:49:44">2022-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-01T06:50:50.088Z" title="Updated 2022-12-01 14:50:50">2022-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nRF9160与nRF Cloud应用示例"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="使用nRF9160-DK-连接-nRF-Cloud示例"><a href="#使用nRF9160-DK-连接-nRF-Cloud示例" class="headerlink" title="使用nRF9160-DK 连接 nRF Cloud示例"></a>使用nRF9160-DK 连接 nRF Cloud示例</h1><h1 id="1-产品简介"><a href="#1-产品简介" class="headerlink" title="1. 产品简介"></a>1. 产品简介</h1><h2 id="1-1-nRF-Cloud"><a href="#1-1-nRF-Cloud" class="headerlink" title="1.1. nRF Cloud"></a>1.1. nRF Cloud</h2><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122150443236.png" style="zoom: 40%;" />

<p>nRF Cloud是Nordic Semiconducotr公司为Nordic无线产品专门优化的物联网云平台，它可以为任何使用Nordic芯片的客户的原型产品、商业产品提供便捷的云连接、云服务。</p>
<p>nRF Cloud提供<strong>设备注册（Cloud Provisioning）</strong>、<strong>OTA升级</strong>、<strong>数据存储</strong>、<strong>位置定位</strong>等服务。所有这些功能都可通过Web界面进行管理。客户可以为不同的团队配置不同级别的管理权限。</p>
<p>nRF Cloud目前有Devloper，Pro和Enterprise三种收费计划。其中开发者计划（Developer plan）是<strong>完全免费</strong>的，只要你有Nordic的开发板就可以最快最方便的方式接入并测试例程。</p>
<p>设备通过nRF Cloud APIs与nRF Cloud进行连接，如下图：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221125164136165.png" alt="image-20221125164136165"></p>
<p>设备可以直接通过MQTT API或REST API接入到云。nRF Cloud也通过REST API为客户提供了<strong>云-云对接</strong>的接口。</p>
<p>更多有关nRF Cloud的信息，可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/">nRF Cloud | nRF Cloud Docs</a></li>
</ul>
<h2 id="1-2-nRF9160-SiP"><a href="#1-2-nRF9160-SiP" class="headerlink" title="1.2. nRF9160 SiP"></a>1.2. nRF9160 SiP</h2><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/nRF9160-SiP-rev2-1016-front-and-back.webp" alt="application" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122134533863.png" alt="image-20221122134533863" style="zoom: 33%;" />

<p>nRF9160是一款高集成度的低功耗SiP（System-in-Package），具有完整的LTE-M&#x2F;NB-IoT Modem、射频前端、电源管理系统，还具有一颗Cortex-M33应用处理器，便于开发自定义应用。nRF9160是目前市面上<strong>最紧凑、最完整、功耗最低</strong>的蜂窝物联网解决方案。</p>
<p>nRF9160内置的Modem在全球范围内同时支持<strong>LTE-M</strong>和<strong>NB-IoT</strong>，并且在IPv4&#x2F;IPv6下均支持<strong>eDRX和PSM省电模式</strong>，支持到传输安全层（TCP&#x2F;TLS）。支持GNSS（含美国GPS和日本QZSS）。Modem固件可以通过加密OTA进行升级。</p>
<p>Cortex-M33应用处理器具有独享的1 MB Flash，256 KB SRAM和多种外设接口，便于在单颗设备中实现高级应用。</p>
<p>也可以把nRF9160当作外挂模组，让外部MCU通过AT指令进行操作，拓展连网能力。在 <a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>
<p>在安全方面：Arm TrustZone技术可为固件和外设提供安全隔离和保护。使应用可实现Secure Boot、受信任固件升级、受信任的Root等安全需求，且不影响性能。Arm CryptoCell通过加密和安全资源来保护物联网应用程序免受各种攻击威胁。</p>
<p>nRF9160支持SIM和eSIM。</p>
<p>更多信息，可参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/Translated-versions/04_nRF9160-SiP-1.4_SC.pdf?la=en&hash=A1F478B9D8593C70FA143C1CA09C2759C8ED51B6">nRF9160中文brief - Nordic Semiconductor - nordicsemi.com</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/nRF9160">nRF9160 - Nordic Semiconductor - nordicsemi.com</a></li>
<li><a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/pdf/nRF9160_PS_v2.1.pdf">nRF9160 Product Specifications v2.1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Low-power-cellular-IoT/nRF9160-Certifications">nRF9160 全球认证信息 - nordicsemi.com</a></li>
</ul>
<h2 id="1-3-nRF9160-DK"><a href="#1-3-nRF9160-DK" class="headerlink" title="1.3. nRF9160 DK"></a>1.3. nRF9160 DK</h2><p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/nRF9160-DK.webp" alt="nRF9160 DK promo"></p>
<p>nRF9160 DK是一款优秀设计的预认证开发套件，带有一颗nRF9160 SiP和一颗nRF52840低功耗蓝牙MCU（用于开发BLE网关产品）。</p>
<p>板载一个支持多个频段的LTE-M和NB-IoT天线、一个GPS贴片天线和一个2.4G陶瓷天线（用于BLE）。其中LTE和2.4G天线接口提供SWF射频连接端子，便于测量RF信号。所有三款连接器均允许使用外部天线。</p>
<p>开发板引出了所有GPIO和接口，兼容Arduino Uno Rev3。提供可编程LED(4)、按钮(2)、开关(2)。开发板还具有nano SIM卡插槽（J5）和eSIM贴片焊盘（U20）或eSIM直插接口（P28）。</p>
<p>板载正版Jlink OB，除可下载、调试板载的nRF9160外，也可对外调试其他产品。</p>
<p>更多信息，可参考：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN#infotabs">nRF9160 DK - nordicsemi.com</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/pdf/nRF9160_DK_HW_User_Guide_v1.1.0.pdf">nRF9160 DK HW User Guide v1.1.0.pdf</a></p>
</li>
</ul>
<h2 id="1-4-nRF-Connect-SDK"><a href="#1-4-nRF-Connect-SDK" class="headerlink" title="1.4. nRF Connect SDK"></a>1.4. nRF Connect SDK</h2><p>nRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台将支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>
<p>NCS内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统。利用Device Tree和Kconfig进行项目的硬件、软件配置。使用CMake和大量Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便，并且是跨平台的（Windows&#x2F;Linux&#x2F;OSX）。</p>
<p>NCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。</p>
<p>更多信息可参考：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html">About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iini/p/14174427.html">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
<div style=”page-break-after: always;”></div>

<h1 id="2-安装NCS开发环境"><a href="#2-安装NCS开发环境" class="headerlink" title="2. 安装NCS开发环境"></a>2. 安装NCS开发环境</h1><p>本节将会详细介绍如何在一台Windows 11的电脑上安装NCS开发环境（Windows 10也适用），包含NCS、编译器以及其他工具。<em>如果你已经安装好NCS开发环境，可以跳过本节</em>。</p>
<p>完整的中文教程，也可参考这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iini/p/14174427.html">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>
<p>也可参考官方安装教程：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html">Getting started — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
<p>安装内容列表：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">软件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a></td>
<td>代码文本编辑器，并且通过安装插件的方式为其他开发调试工具提供可视化界面</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Development-tools/nrf-command-line-tools">nRF Command Line Tools</a></td>
<td>Jlink驱动、nrfjprog等命令行工具和DLL</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop">nRF Connect for Desktop</a></td>
<td>桌面工具集合，含SDK安装器、功耗评估、射频抓包等工具</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a></td>
<td>版本管理工具</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.python.org/downloads/release/python-3913/">Python 3.9</a></td>
<td>为编译套件的python脚本提供运行环境</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a target="_blank" rel="noopener" href="https://ninja-build.org/">Ninja</a></td>
<td>快速构建工具（类似make）</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a target="_blank" rel="noopener" href="https://cmake.org/">CMake</a></td>
<td>根据配置生成.ninja或Makefile文件的工具</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a target="_blank" rel="noopener" href="https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html">Zephyr SDK</a></td>
<td>交叉编译工具链（编译器、链接器等）</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html">NCS 2.1.2</a></td>
<td>含nRF产品驱动包、内核、第三方库等代码和编译配置文件等</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">VS Code: nRF Connect插件包</td>
<td>在VS Code中为NCS功能提供可视化</td>
</tr>
</tbody></table>
<h2 id="2-1-通过安装包安装VS-Code，命令行工具和桌面工具"><a href="#2-1-通过安装包安装VS-Code，命令行工具和桌面工具" class="headerlink" title="2.1. 通过安装包安装VS Code，命令行工具和桌面工具"></a>2.1. 通过安装包安装VS Code，命令行工具和桌面工具</h2><p>上述安装列表中1~3号软件都是installer安装包的形式，点击表格中的链接进入官网，下载安装后可以直接双击安装。安装路径需要无中文、空格或“-”，“_”以外的特殊字符。下图仅示例官网nRF Connect for Desktop的下载方式。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214235111.png" alt="image-20221122214235111"></p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122213145436.png" alt="image-20221122213145436" style="zoom: 67%;" />

<center>“开始”菜单中安装好的工具（未完全展示）</center>

<h2 id="2-2-安装剩余部分（工具链和NCS）"><a href="#2-2-安装剩余部分（工具链和NCS）" class="headerlink" title="2.2. 安装剩余部分（工具链和NCS）"></a>2.2. 安装剩余部分（工具链和NCS）</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1. 概述"></a>2.2.1. 概述</h3><p>列表中4<del>10号软件有2种安装方式，<strong>自动安装</strong>和<strong>手动安装</strong>。自动安装是通过3号软件nRF Connect for Desktop中的工具安装的，这种安装方式会从github拉取NCS仓库的一个特定版本（如v2.1.2）。并把列表中剩余的软件工具（4</del>8号）放在toolchains文件夹下，与NCS的目录为并列关系。</p>
<p>自动安装可以同时安装多个版本的NCS，并在同一个toolchains文件夹下安装对应版本适合的工具，如下图：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214853721.png" alt="image-20221122214853721" style="zoom:67%;" />

<center>toolchains下仍有两个NCS单独的工具链</center>

<p>NCS大约有2.7GB，而toolchains大约有1.1GB。由于是从github拉取，在国内如果没有网络代理基本很难下载成功，或者下载很慢。</p>
<p><strong>自动安装与手动安装还有一个重要的区别</strong>：自动安装的工具不会添加到Windows全局的<code>PATH</code>环境变量中，因此打开VS Code后需要在nRF Connect插件的设置中选择工具链的路径。并且，随便打开一个终端（Cmd&#x2F;Powershell&#x2F;Git bash）是无法使用toolchains中的工具的。</p>
<blockquote>
<p>注：全部安装完毕后，可以重启电脑，以应用新的环境变量</p>
</blockquote>
<h3 id="2-2-2-自动安装方式"><a href="#2-2-2-自动安装方式" class="headerlink" title="2.2.2. 自动安装方式"></a>2.2.2. 自动安装方式</h3><p>打开nRF Connect for Desktop软件，找到<strong>Toolchain Manager</strong>（Toolchain Manager适合Windows和OSX，而Linux适合使用Getting Started Assistant），Install然后Open。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214549553.png" alt="image-20221122214549553" style="zoom: 50%;" />



<p>打开后，先在SETTINGS中选择自己想要存放NCS和toolchains的位置：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122215033170.png" alt="image-20221122215033170" style="zoom: 50%;" />



<p>然后，在SDK ENVIRONMENTS中选择想安装的SDK版本进行安装（如①）。安装过程根据网络状况不同，可能很久，也可能会失败。安装完毕后，可打开VS Code（如②）。也可以在对应目录下打开终端（如③④）。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122215310523.png" alt="image-20221122215310523" style="zoom: 50%;" />

<p>点击“打开VS Code”，会弹窗帮你自动安装VS Code的nRF Connect插件包，如下图：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123161445490.png" alt="image-20221123161445490" style="zoom: 50%;" />



<p>若没有自动安装插件包，可以自行在插件中心搜索nRF Connect for VS Code Extension Pack，这个插件包会自动安装其他nRF Connect所需的VS Code插件。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122220619736.png" alt="image-20221122220619736" style="zoom:67%;" />



<p>可以在VS Code的设置中对插件进行单独的设置，例如可以设置使用工具链的路径。可以对全局进行设置（USER），也可以单独对某个工作区进行设置（WORKSPACE）。<em><strong>关于工作区的概念，请见本节的后续第2.3小节</strong>。</em></p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122220941604.png" alt="image-20221122220941604" style="zoom: 80%;" />



<h3 id="2-2-3-手动安装方式"><a href="#2-2-3-手动安装方式" class="headerlink" title="2.2.3. 手动安装方式"></a>2.2.3. 手动安装方式</h3><p>安装过程需要网络代理（注意，命令行终端也需要被代理）</p>
<h4 id="（1）安装choco"><a href="#（1）安装choco" class="headerlink" title="（1）安装choco"></a>（1）安装choco</h4><p><code>choco</code>是一个类似于Ubuntu中<code>apt-get</code>的工具，可以通过命令行安装软件工具，<strong>并自动添加到全局PATH环境变量中</strong>。</p>
<p>首先右键开始菜单，然后打开管理员终端，输入以下命令。</p>
<pre><code class="powershell"># 设置脚本执行权限
&gt; Set-ExecutionPolicy AllSigned

# 从网络端执行安装脚本
&gt; Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://community.chocolatey.org/install.ps1&#39;))
</code></pre>
<p>测试是否安装成功：</p>
<pre><code class="powershell">&gt; choco
# 有版本号输出即为成功
</code></pre>
<h4 id="（2）利用choco安装其他工具"><a href="#（2）利用choco安装其他工具" class="headerlink" title="（2）利用choco安装其他工具"></a>（2）利用choco安装其他工具</h4><p>部分工具也可自己去官网下载，并用安装包安装，<strong>注意安装时要勾选“添加到PATH环境变量”</strong>。</p>
<pre><code class="powershell"># 设置choco
&gt; choco feature enable -n allowGlobalConfirmation

# 安装cmake (也可以把这步替换成从官网下载cmake安装包，注意安装时要勾选添加进PATH环境变量)
&gt; choco install cmake --installargs &#39;ADD_CMAKE_TO_PATH=System&#39;

# 安装git (也可以把这步替换成从官网下载git安装包，注意安装时要勾选添加到环境变量)
&gt; choco install git 

# 安装python (建议把这步换成从官网下载python3.9安装包，并勾选添加到环境变量,通过choco安装容易出错)
&gt; choco install python --version=3.9.13

# 安装其他工具
&gt; choco install ninja gperf dtc-msys2 wget unzip
</code></pre>
<h4 id="（3）安装GN工具（可选）"><a href="#（3）安装GN工具（可选）" class="headerlink" title="（3）安装GN工具（可选）"></a>（3）安装GN工具（可选）</h4><p>GN工具是开发<a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Matter">Matter</a>所需的工具。</p>
<p>从<a target="_blank" rel="noopener" href="https://gn.googlesource.com/gn/#getting-a-binary">GN网站</a>下载编译好的Windows压缩包（Getting a binary），在无中文、无空格的路径下解压。并且添加到PATH环境变量即可。</p>
<h4 id="（4）安装west"><a href="#（4）安装west" class="headerlink" title="（4）安装west"></a>（4）安装west</h4><p>west是一个多仓库管理工具（类似Android的repo），支持添加自定义插件。在NCS中除了可以管理NCS仓库外，也通过插件实现了板卡选择、触发编译动作、触发flash烧写的功能。</p>
<p>利用Python的pip进行安装</p>
<pre><code class="powershell">&gt;  pip3 install west
# 若不是python3.9，可能会报错
</code></pre>
<h4 id="（5）安装NCS"><a href="#（5）安装NCS" class="headerlink" title="（5）安装NCS"></a>（5）安装NCS</h4><p>nRF Connect SDK前面已经介绍过，含驱动、内核以及第三方库的源码。</p>
<ol>
<li>在一个无中文、无空格的合适路径下打开终端（powershell或bash）：</li>
</ol>
<pre><code class="powershell"> #创建并进入文件夹
&gt; mkdir ncs
&gt; cd ncs

# 初始化仓库（从github拉取）
&gt; west init -m https://github.com/nrfconnect/sdk-nrf --mr v2.1.2
# 也可选择其他版本，如：
# west init -m https://github.com/nrfconnect/sdk-nrf --mr main
</code></pre>
<blockquote>
<p>备注：</p>
<ul>
<li>这一步如果下载失败想重新下载，需要把创建的ncs文件夹下的所有内容删除干净，尤其是<code>.west</code>隐藏文件夹;</li>
<li>如果网络实在差，可以从百度网盘下载，见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iini/p/14174427.html">《开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序》 - iini - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
<ol start="2">
<li>更新仓库</li>
</ol>
<pre><code class="powershell">#更新仓库
&gt; west update
</code></pre>
<ol start="3">
<li>导出Zephyr CMake package，便于CMake自动识别Zephyr的模板，后续生成工程</li>
</ol>
<pre><code class="powershell">&gt; west zephyr-export
</code></pre>
<ol start="4">
<li>安装额外的python依赖</li>
</ol>
<p>安装python依赖之前，还需要安装”Microsoft Visual C++ Build Tools 14.0”或更高版本：<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Microsoft C++ Build Tools - Visual Studio</a>，用来编译这些python工具。在上述微软链接下载，会获得一个VS安装工具。只在Workloads栏里选择 **”Desktop Development with C++”**，然后安装即可。</p>
<p>​	然后再开始安装python依赖包：</p>
<pre><code class="powershell">&gt; pip3 install -r zephyr/scripts/requirements.txt
&gt; pip3 install -r nrf/scripts/requirements.txt
&gt; pip3 install -r bootloader/mcuboot/scripts/requirements.txt
</code></pre>
<ol start="5">
<li><p>切换到任意的正式版本</p>
<blockquote>
<p>​    NCS利用west管理多个git仓库（nrf, zephyr等），其中nrf是主仓库（Manifest）。主仓库的版本即代表整个west仓库（也就是SDK）的版本。</p>
</blockquote>
</li>
</ol>
<pre><code class="powershell"># 查看nfr仓库下有多少版本
&gt; cd nrf
&gt; git tag  # 按键盘上下键翻阅，按q退出

# 检出想要的版本
&gt; git checkout v2.1.2

# 更新整个仓库
&gt; west update
</code></pre>
<h4 id="（6）安装Zephyr-SDK工具链"><a href="#（6）安装Zephyr-SDK工具链" class="headerlink" title="（6）安装Zephyr SDK工具链"></a>（6）安装Zephyr SDK工具链</h4><p>Zephyr SDK是编译器、链接器等工具。建议放在用户目录下。</p>
<p>最新版本的下载地址可从 <a target="_blank" rel="noopener" href="https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html#install-zephyr-sdk-on-windows">Zephyr SDK — Zephyr Project Documentation</a> 获取。</p>
<pre><code class="powershell"># 进入到用户目录（c:\Users\[用户名]）
&gt; cd $HOME
# 如果是你的终端是bash而非powershell，则命令为
# cd ~

# 下载（最新版本的下载地址可从官网链接获取）
&gt; wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.1/zephyr-sdk-0.15.1_windows-x86_64.zip

# 解压
&gt; unzip zephyr-sdk-0.15.1_windows-x86_64.zip

# 配置
&gt; cd zephyr-sdk-0.15.1
setup.cmd
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li><code>setup.cmd</code>只需执行一次。如果改变了安装位置，需要再次执行。</li>
<li>Zephyr SDK安装完成后，会发现：如果在前面安装了ncs的目录下执行<code>west --help</code>会比其他目录下执行<code>west --help</code>多出一些扩展指令，如<code>build</code>,<code>board</code>等等。这是因为NCS中的<code>.west</code>文件夹的配置了Zephyer的base路径，提供了这个仓库独有的插件。这些扩展的指令就是调用了插件进行编译、调试、烧写等工作。<br> 为了让其他目录下也能使用Zephyr工具，需要设置全局环境变量：<br><strong>在Windows环境变量中新建<code>ZEPHYR_BASE</code>环境变量，并把其值设置为<code>ncs</code>安装目录下的<code>zephyr</code>目录的路径即可。</strong></li>
</ul>
<p>（这个效果和执行一次<code>ncs</code>目录下的<code>zephyr/zephyr-env.cmd</code>脚本是一样的，但这个脚本设置环境变量只是临时生效，关闭终端再另开一个终端就不起作用了。而设置全局环境变量是永久生效。）</p>
</blockquote>
<h4 id="（7）安装VS-Code插件"><a href="#（7）安装VS-Code插件" class="headerlink" title="（7）安装VS Code插件"></a>（7）安装VS Code插件</h4><p>见<strong>自动安装</strong>章节中最后对插件安装的介绍。并把插件设置的工具链路径设为<code>PATH</code>即可。</p>
<h2 id="2-3-打开一个或多个例程并保存工作区"><a href="#2-3-打开一个或多个例程并保存工作区" class="headerlink" title="2.3. 打开一个或多个例程并保存工作区"></a>2.3. 打开一个或多个例程并保存工作区</h2><p>在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择 “adding an existing application”：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225724875.png" alt="image-20221122225724875"></p>
<p>从ncs的<code>nrf</code>或者<code>zephyr</code>目录的<code>sample</code>子目录下随便选取一个项目，打开文件夹即可：</p>
<p>项目创建完毕后，默认存储在一个UNTITLED <strong>workspace</strong>中，这是一个<strong>临时的</strong>workspace。</p>
<h3 id="（1）理解VS-Code的Workspace（工作区）"><a href="#（1）理解VS-Code的Workspace（工作区）" class="headerlink" title="（1）理解VS Code的Workspace（工作区）"></a>（1）理解VS Code的Workspace（工作区）</h3><blockquote>
<p>workspace是VS Code中的一种设计，就是许多同类项目（目录）的集合。这种设计，方便同一类项目统一设定工具链路径、插件等。</p>
<p>在VS Code的settings中，可以看到设置分为User, Workspace, Folder三个级别。User就是全局的设置，Worksdpace和Folder就依次是更细一级的设置。后者可以覆盖前者的设置。</p>
<p>例如可以只创建一个Nordic NCS专用的workspace，只在这里面启用ncs 插件。在其他workspace中不启用。这样VS Code就可以在不同workspace下进行不同语言、不同领域的开发。（具体方法是：在不打开任何workspace的情况下，在插件管理中禁用nRF Connect for VS Code Extension pack，然后打开workspace时，在插件管理中选择Enable(workspace)，就可以只在这个workspace中使用ncs插件了）</p>
<p>VS Code中，工具栏”File”菜单中有workspace添加、保存等选项。</p>
<p>如果之前没接触过workspace，只是单独打开一个文件夹（File-Open Foledr…），那么就没有Workspace这一个层级，仅有Folder层级。Folder级别的设置就存储在当前目录的<code>.vscode/settings.json</code>中。</p>
</blockquote>
<p>可以在VS Code菜单栏中选择 File &gt; Save Workspace As … ，将工作区另存为一个<code>xxxxx.code-workspace</code>文件。这样每次打开这个<code>.code-workspace</code>文件就能打开整个工作区。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225912476.png" alt="image-20221122225912476"></p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225949921.png" alt="image-20221122225949921"></p>
<p>可以从工作区内移除项目文件夹：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122230432396.png" alt="image-20221122230432396" style="zoom: 50%;" />



<p>也可以向工作区内添加项目文件夹：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122230541745.png" alt="image-20221122230541745" style="zoom:50%;" />

<blockquote>
<p>注意:</p>
<ul>
<li>workspace只是一个集合，用<code>.code-workspace文件</code>来描述，并不一定是一个真实存在的大文件夹，更不需要所有的项目文件夹都是workspace的子文件夹。</li>
<li>如果已经保存了workspace，那么下次再打开这个workspace中的项目时，不要再用”adding an existing application”。因为这又会把此项目放入一个临时的UNTITLED workspace内。直接从上次保存的<code>xxxx.code-workspace</code>文件重新打开工作区即可。</li>
</ul>
</blockquote>
<h3 id="（2）理解nRF-Connect的workspace"><a href="#（2）理解nRF-Connect的workspace" class="headerlink" title="（2）理解nRF Connect的workspace"></a>（2）理解nRF Connect的workspace</h3><p>VS Code的workspace本质上是文件夹的集合，VS Code并不在乎文件夹的内容是什么。</p>
<p>但是在nRF Connect插件的APPLICATION视图中，可以看到当前工作区内nrf项目的集合，这些文件夹就必须是可以编译的nrf项目了，如下图：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122231125385.png" alt="image-20221122231125385"></p>
<p>有时在VS Code的workspace中添加、移除文件夹，nRF connect插件的APPLICATIONS视图不会一起同步。这时可以在APPLICATION视图中进行单独的添加或右键移除。“+”按钮的效果和“Add an existing application”是一样的。</p>
<p>此外，也可以在左下角齿轮Settings中，当前WORKSPACE下的<code>nrfconnect.applications</code>配置中，对当前工作区中的项目数量进行管理：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122231837769.png" alt="image-20221122231837769" style="zoom:80%;" />



<h2 id="2-4-创建一个新工程并用git管理"><a href="#2-4-创建一个新工程并用git管理" class="headerlink" title="2.4. 创建一个新工程并用git管理"></a>2.4. 创建一个新工程并用git管理</h2><p><strong>打开</strong>一个例程，例程的文件夹还是在ncs仓库内部，受到ncs的git仓库的管理。如果想自己开发项目，并用git管理版本，就需要<strong>创建</strong>新工程。</p>
<h3 id="（1）创建新工程"><a href="#（1）创建新工程" class="headerlink" title="（1）创建新工程"></a>（1）创建新工程</h3><p>NCS支持以例程作为模板，复制并创建新的工程。</p>
<p>在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择<code>create a new application</code>：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122232512218.png" alt="image-20221122232512218" style="zoom:80%;" />

<ul>
<li>需要设置项目的名称、路径。</li>
<li>需要从ncs的例程中选择一个作为模板（可以是nrf&#x2F;sample, nrf&#x2F;application, zephyr&#x2F;sample, zephyr&#x2F;application目录下的例程）</li>
<li>需要设置Application Type</li>
</ul>
<blockquote>
<h4 id="理解Application-Type"><a href="#理解Application-Type" class="headerlink" title="理解Application Type"></a>理解Application Type</h4><p>新项目的创建方式有freestanding和workspace两种：</p>
<ul>
<li><p>freestanding 就是不使用工作区，只使用文件夹来保存一个单独的工程。这种方式，要求电脑上已经装了一个NCS。</p>
</li>
<li><p>workspace就是在创建这个项目时，同时创建一个工作区，并且要设定这个工作区的名称。这种方式不需要安装NCS，它直接从github上拉取一个新的NCS。</p>
</li>
</ul>
<p><strong>【注意】如果创建新工程时，当前VS Code已经打开了一个workspace （临时UNTITLED的也算），那么就只能选择freestanding，不能选择workspace创建方式。并且这个freestanding的工程会强行加入到目前已经打开的workspace中。</strong>如果想避免这种情况，可以在VS Code菜单栏的File…选项中选择关闭当前workspace，或者打开一个新VS Code窗口，再进行操作。</p>
</blockquote>
<h3 id="（2）使用git管理你的新工程"><a href="#（2）使用git管理你的新工程" class="headerlink" title="（2）使用git管理你的新工程"></a>（2）使用git管理你的新工程</h3><p>创建好的新工程，可以使用git管理，按Ctrl + “`“ （波浪线那个键）打开终端，然后进入你刚刚创建的新工程的目录（打开终端时，默认的目录可能是workspace中其他的目录，需要手动切过去）。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233158710.png" alt="image-20221122233158710" style="zoom: 67%;" />



<p>如果你从没用过git，需要先配置用户名和邮箱。这个用户名和邮箱不是登陆什么网站用的，而是一个签名，用于提交代码时标记这段代码是谁提交的。这个配置存在你电脑的本地，并且是全局的。</p>
<pre><code class="bash">$ git config --global user.name &quot;Jayant.Tang&quot;

$ git config --global user.email &quot;jayant.tang@nordicsemi.no&quot;
</code></pre>
<p>在新的工程文件夹下创建新的仓库：</p>
<pre><code class="bash">$ git init
</code></pre>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233614502.png" alt="image-20221122233614502" style="zoom:50%;" />

<p>如果你的终端是git bash，右边已经出现了分支名。</p>
<p>初始化好仓库后，如果你之前build过，就可以看到左侧git窗口有大量的新文件：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233758040.png" alt="image-20221122233758040" style="zoom:50%;" />

<p>使用<code>git status</code>命令查看也会告诉你，当前有很多未被git仓库跟踪的文件。</p>
<p>但是其中很多文件是编译过程中自动生成的，甚至有些是二进制文件。我们并不关心这些文件的内容如何变化，因此可以在当前工程的根目录下创建一个<code>.gitignore</code>文件来配置我们想要忽略的文件或文件夹：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234108052.png" alt="image-20221122234108052" style="zoom:67%;" />

<p>例如<code>build/</code>就是忽略build下所有的文件的变化。</p>
<p>可以把所有修改添加到暂存区（效果等同于<code>git add .</code>）：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234334470.png" alt="image-20221122234334470" style="zoom:67%;" />



<p>可以把暂存区的修改全部提交，并添加描述（效果等同于<code>git commit -m &quot;init a new project&quot;</code> ）</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234752701.png" alt="image-20221122234752701"></p>
<p>如果安装了git history插件，就可以查看提交历史：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122235338251.png" alt="image-20221122235338251"></p>
<p>可以看到每次commit都改动了哪些代码和配置（左侧为旧的，右侧为新的）</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122235416865.png" alt="image-20221122235416865"></p>
<p>本文不详述git的使用，可以去网上了解其他教程。</p>
<h2 id="2-5-编译工程"><a href="#2-5-编译工程" class="headerlink" title="2.5. 编译工程"></a>2.5. 编译工程</h2><p>不论是打开的示例工程，还是创建的新工程，都遵循下列步骤进行编译和调试等。</p>
<ol>
<li>创建一个Build选项，需要选择自己使用的板卡。如果是自己的板子，也可以创建新板子，本文不介绍如何自定义板子。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123135000141.png" alt="image-20221123135000141"></p>
<ol start="2">
<li>在APPLICATIONS栏选中自己要编译的工程。然后在ACTIONS栏通过build<strong>按钮</strong>进行项目的构建。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123140646521.png" alt="image-20221123140646521"></p>
<blockquote>
<p>自动安装的SDK，可能由于网络原因而缺少文件，并且nRF Connect桌面版不会给出任何提示。</p>
<p>如果编译时提示：<code>No Such File or Directory...</code>之类的错误时，很可能就是SDK中缺少文件。</p>
<p>这时需要在SDK目录下打开终端，并执行：</p>
<pre><code class="bash"># 查看nfr仓库下有多少版本
cd nrf
git tag  # 按键盘上下键翻阅，按q退出

# 检出想要的版本
git checkout v2.1.2

# 更新整个仓库
west update
</code></pre>
<p>如果更新时出现问题，往往是网络问题</p>
</blockquote>
<p>另外，也可以通过Ctrl + ` 打开终端，输入命令进行编译：</p>
<pre><code class="bash">$ west build
</code></pre>
<h2 id="2-6-烧录hex"><a href="#2-6-烧录hex" class="headerlink" title="2.6. 烧录hex"></a>2.6. 烧录hex</h2><p>可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160139273.png" alt="image-20221123160139273" style="zoom: 80%;" />

<p>也可以在终端中输入:</p>
<pre><code class="bash">$ west flash
</code></pre>
<blockquote>
<p>这样直接烧录，有一部分项目可能会烧写失败，显示：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160245857.png" alt="image-20221123160245857"></p>
<p>这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。为了安全起见，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。</p>
<p>全片擦除然后烧录：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160832598.png" alt="image-20221123160832598"></p>
<p>或者使用命令行方式：</p>
<pre><code class="bash">$ west flash --force --erase
</code></pre>
</blockquote>
<div style=”page-break-after: always;”></div>

<h1 id="3-示例-使用nRF9160-DK连接到nRF-Cloud"><a href="#3-示例-使用nRF9160-DK连接到nRF-Cloud" class="headerlink" title="3. 示例: 使用nRF9160-DK连接到nRF Cloud"></a>3. 示例: 使用nRF9160-DK连接到nRF Cloud</h1><p>本节将会在nRF9160-DK开发板上，烧录<code>nrf/applications/asset_tracker_v2</code>例程。根据国内的网络进行配置，然后把板子连接到nRF Cloud上。</p>
<h2 id="3-1-前期准备"><a href="#3-1-前期准备" class="headerlink" title="3.1. 前期准备"></a>3.1. 前期准备</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN">nRF9160 DK开发板（本示例使用的版本：v1.1.0）</a>：其中nRF9160 SiP<strong>不能</strong>是Revision 1版本，必须是Revision 2或更高版本。<br>（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html">nRF9160 IC Revision Overview</a>）</li>
</ul>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124110534824.png" alt="image-20221124110534824" style="zoom:25%;" />

<ul>
<li>micro USB线缆一根</li>
<li>中国移动NB卡(物联网卡)</li>
<li>一台Windows10或以上版本操作系统的电脑，并按照前述第2节正确安装了NCS开发环境</li>
<li>注册一个 <a target="_blank" rel="noopener" href="https://nrfcloud.com/#/">nRF Cloud账号</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122191558453.png" alt="image-20221122191558453"></p>
<ul>
<li>将电源开关拨到on，并确保调试开关处于”nRF91”挡位</li>
<li>插好nano SIM卡，并通过microUSB线连接到电脑</li>
</ul>
<blockquote>
<p>注：DK附赠的iBASIS SIM卡为国外运营商产品，国内无法使用</p>
</blockquote>
<h2 id="3-2-烧录Modem固件"><a href="#3-2-烧录Modem固件" class="headerlink" title="3.2. 烧录Modem固件"></a>3.2. 烧录Modem固件</h2><p>nRF9160的Modem具有独立的固件，这部分固件是Nordic以zip包的形式提供的。</p>
<ol>
<li>在官网<a target="_blank" rel="noopener" href="https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK/Download#infotabs">nRF9160 DK - Downloads - nordicsemi.com</a>界面，选中最新的Modem固件版本并下载（必须大于1.3.0）。</li>
</ol>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143324324.png" alt="image-20221123143324324" style="zoom:50%;" />



<ol start="2">
<li>打开nRF Connect桌面版，找到Programmer工具并打开</li>
</ol>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143424410.png" alt="image-20221123143424410" style="zoom: 67%;" />



<ol start="3">
<li>先选择板卡，然后选择固件文件（.zip），最后烧录</li>
</ol>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143649354.png" alt="image-20221123143649354" style="zoom:50%;" />



<ol start="4">
<li>烧录完毕</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123144339925.png" alt="image-20221123144339925"></p>
<h2 id="3-3-配置、编译并烧录Application固件"><a href="#3-3-配置、编译并烧录Application固件" class="headerlink" title="3.3. 配置、编译并烧录Application固件"></a>3.3. 配置、编译并烧录Application固件</h2><h3 id="（1）以asset-tracker-v2为模板，创建新工程"><a href="#（1）以asset-tracker-v2为模板，创建新工程" class="headerlink" title="（1）以asset_tracker_v2为模板，创建新工程"></a>（1）以asset_tracker_v2为模板，创建新工程</h3><blockquote>
<p>asset_tracker_v2是applications目录下的例程。这个目录下的都是商业级例程，基本改一下就能作为产品使用了。</p>
</blockquote>
<p>创建新工程相比于打开例程的好处，在第2.4节中已经描述了。</p>
<p>通过nrf connect插件界面的”Create a new application”来创建新的工程。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123145304528.png" alt="image-20221123145304528"></p>
<p>从上到下，选项依次为：</p>
<ul>
<li>NCS路径</li>
<li>Zephyer SDK工具链路径</li>
<li>本项目的存储位置</li>
<li>选取作为模板的sample例程（NCS中的例程）</li>
<li>本项目的名称</li>
</ul>
<p>关于asset_tracker_v2的更多信息，可以参考：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
<blockquote>
<p>建议按照2.4.中的描述，为这个新工程创建一个git仓库，便于你记录自己修改了什么。</p>
</blockquote>
<h3 id="（2）为新工程创建编译选项"><a href="#（2）为新工程创建编译选项" class="headerlink" title="（2）为新工程创建编译选项"></a>（2）为新工程创建编译选项</h3><p>板卡选择<code>nrf9160dk_nrf9160_ns</code>，然后Build Configuration即可。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123145942948.png" alt="image-20221123145942948"></p>
<h3 id="（3）修改配置"><a href="#（3）修改配置" class="headerlink" title="（3）修改配置"></a>（3）修改配置</h3><p>打开工程根目录下的<code>prj.conf</code>文件，进行修改：</p>
<ol>
<li>与运营商有关的修改</li>
</ol>
<pre><code class="bash"># 由于使用移动的NB物联网卡，协议关闭LET-M，使用NB-IoT
CONFIG_LTE_NETWORK_MODE_LTE_M_GPS=n  # 由y改为n
CONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y  # 新增

# NB-IoT对ePCO支持的不好，故使用传统的PCO
CONFIG_PDN=y                         # 新增
CONFIG_PDN_LEGACY_PCO=y              # 新增
</code></pre>
<ol start="2">
<li>与nRF Cloud连接、注册有关的修改（后面小节会详细说明）</li>
</ol>
<pre><code class="bash"># 启用JWT和UUID的云端注册方式
CONFIG_MODEM_JWT=y                              # 新增
CONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y  # 新增
</code></pre>
<blockquote>
<p>【备注】<code>prj.conf</code>文件的作用：</p>
<p>在Zephyer编译系统中，Kconfig管理编译选项、各类功能选项的开关，而devicetree用来管理硬件。编译时，通过CMake和ninja会调用一系列python辅助脚本，把Kconfig和device tree变成c代码和头文件。然后进行编译。更多资料，可参考：<a target="_blank" rel="noopener" href="https://docs.zephyrproject.org/latest/build/index.html#build-and-configuration-systems">Build and Configuration Systems — Zephyr Project Documentation</a></p>
<p>开发时，只需关注Kconfig与device tree如何修改即可。Kconfig中的选项非常多，大多数情况下保持默认即可。Kconfig的默认配置保存在NCS中。</p>
<p><code>prj.conf</code>的作用，就是为这个工程单独修改部分Kconfig配置。编译时，构建系统会优先使用prj.conf里的配置来覆盖默认的Kconfig配置。这样每个工程都可以单独配置，不会影响到NCS中的默认配置。</p>
<p><code>prj.conf</code>中的选项都必须是Kconfig中可以找到的。</p>
<p>在VS Code中通过图形界面修改完Kconfig时，也可以通过”Save to file”按钮，来把修改的部分单独保存到<code>prj.conf</code>中，如下图：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123154242926.png" alt="image-20221123154242926"></p>
</blockquote>
<h3 id="（4）编译，烧录"><a href="#（4）编译，烧录" class="headerlink" title="（4）编译，烧录"></a>（4）编译，烧录</h3><p>参考2.5，2.6节</p>
<h2 id="3-4-联网测试"><a href="#3-4-联网测试" class="headerlink" title="3.4. 联网测试"></a>3.4. 联网测试</h2><p>在nRF Connect桌面版中，打开LTE Link Monitor工具。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123163321689.png" alt="image-20221123163321689" style="zoom:67%;" />



<p>然后左上角选择板卡，然后再打开串口。串口共有三个(都是Jlink提供的虚拟串口，在板子上2个连接到9160，1个连接到52840)，其中9160的串口只有一个用于AT Command。</p>
<p>需要依次尝试，点击“AT”按钮就会从串口发送一行“AT”命令，如果有回复OK，说明这个串口就是AT指令的串口。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173504262.png" alt="image-20221123173504262"></p>
<blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>
</blockquote>
<p>左侧的面板显示了联网状态、IP地址、信号强度等信息：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173600818.png" alt="image-20221123173600818"></p>
<p>注意，”<strong>Automatic Request</strong>“需要勾选上。勾选以后，在切换串口、点击“AT+CFUN?”指令时，才会自动发送相关AT指令，查询网络状态信息，面板上的信息才会更新。否则面板可能不更新。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173636098.png" alt="image-20221123173636098"></p>
<p>即是说，以下状态灯应当全绿，则说明联网成功。但若不是全绿，也不一定是联网失败，可能只是信息没有刷新，参照上一条勾选“<strong>自动请求</strong>”，然后点击“AT+CFUN?”指令再次查询即可。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173817830.png" alt="image-20221123173817830"></p>
<blockquote>
<p>含义：</p>
<ul>
<li>UART：串口状态</li>
<li>Modem：调制解调器状态</li>
<li>UICC：SIM卡状态</li>
<li>LTE：LTE联网状态</li>
<li>PDN：Packet Data Domain联网状态</li>
</ul>
</blockquote>
<h2 id="3-5-将设备注册到nRF-Cloud云端-Cloud-Provisioning"><a href="#3-5-将设备注册到nRF-Cloud云端-Cloud-Provisioning" class="headerlink" title="3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning)"></a>3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning)</h2><p>IoT设备是需要注册到云端的，并且通信都需要加密认证，否则任何人开发的设备都能连接到你的云，就不安全了。</p>
<p>设备注册的流程是：</p>
<ol>
<li>首先，要有一个自签CA证书，以及对应的密钥文件；</li>
<li>需要用自签CA证书+设备的UUID，给每个设备单独签发CA证书，并安装单独的私钥到设备中。</li>
<li>云端持有证书（公钥），这样设备和云端就可以加密通信了。</li>
</ol>
<p>即：</p>
<blockquote>
<p>【注】什么是非对称加密和CA证书？</p>
<p>CA证书具有证书文件（内含公钥）和私钥文件两个部分，公钥和私钥是用来做非对称加密的。公钥加密的数据，只能用私钥解密；用私钥加密的数据，只能用公钥解密。</p>
<p>私钥是自己持有的，而公钥公开给所有想与自己通信的对象。</p>
<p>假设A要给B发送一段消息M：</p>
<ol>
<li>对于这段消息M，发送者A先利用MD5或SHA256等方式生成一个数字摘要D，再用私钥把消息M加密得到密文C。最后把C+D一起发给接收者B。</li>
<li>B收到消息后，先用公钥解密C得到M’，再对比M’的数据摘要和D是否一致，若一致，则说明数据确实是<strong>公钥的所有者</strong>发出的。于是确信M’就是要接收的消息M。</li>
</ol>
<p>但B可能拿到假的公钥，黑客发出假的公钥，就可以冒充A给B发消息。为了避免这种情况发生，公钥需要被<strong>认证</strong>，这就是CA证书。</p>
<p>一个CA证书文件<code>ca1</code>包含公钥P、签名S、所有者信息（国家、城市、单位名称、邮箱等）。<code>ca1</code>的签名S，是用另一个证书<code>ca2</code>的私钥，对<code>ca1</code>的公钥P进行加密得到的。</p>
<p>所以利用公开的<code>ca2</code>的公钥对S进行解密，如果和P一致，则说明<code>ca1</code>是合法的。<code>ca1</code>的合法性由<code>ca2</code>证明。</p>
<p>一个CA证书的安全性由另一个CA证书来证明，这样层层递归下去，形成证书链。而最初的CA证书就是<strong>根证书</strong>。具有颁发<strong>根证书</strong>的资质的机关就是CA（Certificate Authority），也叫“证书授权中心”。CA具有根证书，然后给他信任的其他公司颁发CA证书，这些颁发的CA证书里的签名S就是用根证书的私钥加密的。</p>
</blockquote>
<p>目前nRF Cloud有两种注册方式，一种是通过JITP的方式（Just-in-Time Provisioning）,另一种是<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning">预连接（preconnect provisioning）</a>。</p>
<h3 id="JITP方式注册"><a href="#JITP方式注册" class="headerlink" title="JITP方式注册"></a>JITP方式注册</h3><p>JITP（Just-in-Time Provisioning）的方式利用开发板背面贴纸上的IMEI和PIN码，在云端控制台<strong>手动</strong>生成一个CA证书，然后下载到电脑，并通过LTE Link Monitor 工具生成<strong>设备证书</strong>，并把设备证书的私钥安装到9160中。这样设备就可以直接连接到云端并注册。这种方式便于快速开发、验证，但不适合量产，本文不详细介绍。若有兴趣可参考：<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Associations/Provisioning/#just-in-time-provisioning">Updating The nRF Cloud Certificate</a></p>
<h3 id="预连接方式注册"><a href="#预连接方式注册" class="headerlink" title="预连接方式注册"></a>预连接方式注册</h3><p><a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning">预连接（preconnect provisioning）</a>，是利用nRF Cloud提供的云端REST接口（接口文档见<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices">Provision Devices</a>），进行批量的设备注册。具体步骤为：</p>
<ol>
<li>首先需要一个CA证书（不一定要CA正规机构颁发，可以自己生成）；</li>
<li>电脑连接到nRF9160 AT串口，为设备分配UUID，并通过<strong>CA证书</strong>和<strong>UUID</strong>为每一个设备生成<strong>设备证书</strong>。通过串口安装这些证书，同时把这一批设备的UUID、公钥等信息记录到CSV表格中。</li>
<li>通过nRF Cloud的云端REST接口，把这一批设备一次性注册到云端，上传公钥。</li>
</ol>
<p>nRF Cloud提供了一套工具来帮助完成上述三项工作，可以用TypeScript脚本或Python脚本，官方的github的资料为 <a target="_blank" rel="noopener" href="https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#create-device-credentials">utils&#x2F;README.md at master · nRFCloud&#x2F;utils (github.com)</a>。</p>
<p>下面通过Python脚本进行示例：</p>
<h3 id="（1）前期准备"><a href="#（1）前期准备" class="headerlink" title="（1）前期准备"></a>（1）前期准备</h3><ul>
<li><p>确保9160SiP 为Revision 2或更高版本（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html">nRF9160 IC Revision Overview</a>）</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124110504562.png" alt="image-20221124110504562" style="zoom: 25%;" />
</li>
<li><p>确保已经按照[3.2](3.2. 烧录Modem固件)的步骤，烧录了1.3.0或更高版本的Modem固件（这些版本才支持新的安全AT指令，如<code>KEYGEN</code>）</p>
</li>
<li><p>确保你已经按照[3.3](3.3. 配置、编译并烧录Application固件)的步骤，修改了Application固件的配置参数，启用了JWT和UUID；</p>
</li>
<li><p>已经按照[3.4](3.4. 联网测试)的步骤，验证了设备已经成功联网；</p>
</li>
<li><p>已经 <a target="_blank" rel="noopener" href="https://nrfcloud.com/#/">注册了nRF Cloud账号，并登录</a>。</p>
</li>
</ul>
<h3 id="（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖"><a href="#（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖" class="headerlink" title="（2）获取最新的nRF Cloud Utils工具，并安装好依赖"></a>（2）获取最新的nRF Cloud Utils工具，并安装好依赖</h3><p>在一个无中文、无空格、无特殊字符的路径下，从github拷贝仓库：</p>
<pre><code class="bash">$ git clone https://github.com/nRFCloud/utils.git
</code></pre>
<p>进入modem firmware 1.3+ 子文件夹，然后安装其python依赖包</p>
<pre><code class="bash">$ cd utils/python/modem-firmware-1.3+/
$ pip3 install -r requirements.txt
</code></pre>
<h3 id="（3）生成你的自签CA证书"><a href="#（3）生成你的自签CA证书" class="headerlink" title="（3）生成你的自签CA证书"></a>（3）生成你的自签CA证书</h3><p>复制下方的命令，并把对应参数改成你自己需要的信息。</p>
<pre><code class="bash">$ python create_ca_cert.py \
-c CN \
-l Shanghai \
-o &quot;Nordic Semiconductor K.K.&quot; \
-ou &quot;Sales&quot; \
-cn nordic.cn \
-e jayant.tang@nordicsemi.no \
-p ./my_ca \
-f &quot;Jayant-&quot;
</code></pre>
<blockquote>
<p>参数释义（部分参数未使用）：</p>
<ul>
<li><code>-c</code> ：2字符的国家代码，<code>CN</code>为中国</li>
<li><code>-st</code>：州或省</li>
<li><code>-l</code>：地点</li>
<li><code>-o</code>：公司&#x2F;组织</li>
<li><code>-ou</code>：组织部门</li>
<li><code>-cn</code>：Common Name</li>
<li><code>-dv</code>：有效天数</li>
<li><code>-e</code>：电子邮箱地址</li>
<li><code>-p</code>：CA证书生成后存储的位置</li>
<li><code>-f</code>：给生成的三个证书文件的文件名添加前缀（字符串）</li>
</ul>
</blockquote>
<p>生成后，可以看到自己指定的目录下已经有了三个证书文件：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123223024181.png" alt="image-20221123223024181"></p>
<p>其中，ca是证书，prv是私钥，pub是公钥。</p>
<blockquote>
<p>本例程中，CA证书是我们自己签发的根证书，能让设备和云端的通信被加密即可。这个CA证书本身并不是CA机构签发的正规证书。</p>
<p>若想查看CA证书的信息，可以随便找一个<a target="_blank" rel="noopener" href="https://myssl.com/cert_decode.html">在线CA查看器</a>，把xxx_ca.pem拖进去就可以看到信息了：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123224514523.png" alt="image-20221123224514523"></p>
</blockquote>
<h3 id="（4）签发并安装设备证书"><a href="#（4）签发并安装设备证书" class="headerlink" title="（4）签发并安装设备证书"></a>（4）签发并安装设备证书</h3><p>需要使用<code>utils/python/modem-firmware-1.3+/</code>目录下的<code>device_credentials_installer.py</code>脚本。</p>
<p>如果想查看最新的脚本使用方式：</p>
<pre><code class="bash">$ python device_credentials_installer.py -h
</code></pre>
<p>此脚本的功能：</p>
<ol>
<li>这个脚本会调用同一目录下的<code>create_device_credentials.py</code>，给每个设备单独生成设备证书；</li>
<li>通过电脑串口，给你的设备发送AT指令，生成一个UUID；</li>
<li>通过电脑串口，给你的设备发送AT指令，把<strong>设备证书</strong>及其<strong>私钥</strong>安装到你的设备中；</li>
<li>记录这个设备的信息，把UUID等信息存储到2个csv表格文件中。</li>
<li>量产时，这个脚本可以重复执行。只需要在每次串口上换一个设备时，就执行一次这个脚本。这个设备就会被安装证书，并且设备的信息会记录到2个表格文件中。<strong>最多允许存1000台设备的信息。</strong></li>
<li>后续可以把这两个表格文件和证书上传到云端，便于批量注册设备。</li>
</ol>
<p>在执行这个脚本之前，确保第（2）步中的CA证书都生成好了。</p>
<p>脚本使用示例如下（windows环境），你需要根据实际情况改变命令的参数配置。</p>
<p>注意，示例执行脚本时，并未指定串口。因为脚本在windows下会自动检测哪个串口是AT指令串口。注意不要开着LTE Link Monitor等工具占用着串口导致安装失败。如果在linux下操作，请增加<code>--port /dev/ttyS??</code>来指定串口，详情可参考 <a target="_blank" rel="noopener" href="https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#device-credentials-installer">Device Credentials Installer</a>。</p>
<pre><code class="bash">$ python device_credentials_installer.py -d -t &quot;jayant-DK&quot; --ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem --ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem -a --devinfo_append --csv ./jayant_provision.csv --devinfo ./jayant_devinfo.csv --term CRLF
</code></pre>
<blockquote>
<p>参数释义：</p>
<ul>
<li><code>-d</code>：安装前先从Modem中删除sectag</li>
<li><code>-t</code>：用于设备分组管理的标签，是一个字符串</li>
<li><code>-T</code>：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置</li>
<li><code>--ca</code>：CA证书文件的路径</li>
<li><code>--ca_key</code>：CA证书私钥的路径(prv)</li>
<li><code>-a</code>或<code>--append</code>：保存<strong>设备注册信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>
<li><code>--devinfo_append </code>：保存<strong>设备信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>
<li><code>--csv</code>：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）</li>
<li><code>--devinfo</code>：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）</li>
<li><code>--term</code>：AT指令的结束符（<code>NULL</code>,<code>CRLF</code>,<code> CR</code> 或<code>LF</code>）</li>
<li><code>--port</code>：指定AT指令串口</li>
</ul>
</blockquote>
<p>我只有一块开发板，所以只执行一次。</p>
<h3 id="（5）把设备信息批量注册到云端"><a href="#（5）把设备信息批量注册到云端" class="headerlink" title="（5）把设备信息批量注册到云端"></a>（5）把设备信息批量注册到云端</h3><p>批量的在nRFCloud上进行设备注册（Cloud Provisioning）。</p>
<p>首先，在<a target="_blank" rel="noopener" href="https://nrfcloud.com/#/">nRF Cloud Portal</a> 登录你的nRF Cloud账号（前面应该已经注册好了）。然后获取nRF Cloud REST API key。</p>
<p>在右上角点击进入个人账户页面，然后在下面可以看到API key，复制出来即可。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123234437620.png" alt="image-20221123234437620"></p>
<p>接下来继续执行python脚本，进行云端注册：</p>
<pre><code class="bash">$ python ./nrf_cloud_provision.py --apikey 3c967ecbd9fxxxxxxxxxxxxxxxxa73cf37049983 --chk --csv ./jayant_provision.csv --devinfo jayant_devinfo.csv --set_mfwv --name_imei --name_pref &quot;my_dk_&quot; --res prov.log
</code></pre>
<blockquote>
<p>参数释义：</p>
<ul>
<li><code>--apikey</code>：刚刚复制的API key</li>
<li><code>--chk</code>：<strong>单个设备的注册才使用</strong>，注册前先检查设备是否存在</li>
<li><code>--csv</code> ：上一步生成的，存储着<strong>设备注册信息</strong>的csv表格文件，最多允许1000条数据</li>
<li>&#96;–devinfo ：上一步生成的，存储着<strong>设备信息</strong>的csv表格文件，最多允许1000条数据</li>
<li><code>--set_mfwv</code>：把<code>--devinfo</code>中记录的Modem固件版本存储到云端</li>
<li><code>--name_imei</code>：把<code>--devinfo</code>中记录的IMEI（芯片ID）作为friendly name</li>
<li><code>--name_pref</code>：给friendly name添加一个前缀字符串</li>
<li><code>--res</code>：存储注册结果的日志文件</li>
</ul>
</blockquote>
<p>完成后，可以看到成功注册的结果：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123235635167.png" alt="image-20221123235635167"></p>
<h3 id="（6）在云端查看刚刚注册的设备"><a href="#（6）在云端查看刚刚注册的设备" class="headerlink" title="（6）在云端查看刚刚注册的设备"></a>（6）在云端查看刚刚注册的设备</h3><p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123235940868.png" alt="image-20221123235940868"></p>
<p>可以在Device界面看到设备已经注册成功，设备的名称是“前缀字符串” + “IMEI”的形式。</p>
<p>但设备还处于Disconnect的状态。这是因为刚才下载私钥时，把设备设为了离线状态，可以通过LTE Link Monitor输入以下AT指令，也可以简单reset一下设备，或者重新通过LTE Link Monitor查看设备的状态。这样设备应该就会变成已连接了:</p>
<pre><code class="AT">AT%XSYSTEMMODE=0,1,0,0 // 选择NB网络
AT+CEREG=5             // 打开调制解调器
AT+CFUN=1              // 开始联网
</code></pre>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124000424393.png" alt="image-20221124000424393"></p>
<p>点进设备的详情页面，已经可以看到大量的信息（部分资源在墙外，加载不出属于正常现象，需要代理上网）：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124000623033.png" alt="image-20221124000623033"></p>
<p>可以通过terminal窗口，发送json消息，与设备进行交互。也可以进行OTA升级。</p>
<p>在本例程中，板子上的LED指示灯也可以展示状态：详见<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#led-indication">Led indication</a>。这里只列出DK板的行为。</p>
<table>
<thead>
<tr>
<th>State</th>
<th>nRF9160 DK solid LEDs</th>
</tr>
</thead>
<tbody><tr>
<td>LTE connection search</td>
<td>LED1 blinking</td>
</tr>
<tr>
<td>GNSS fix search</td>
<td>LED2 blinking</td>
</tr>
<tr>
<td>Cloud association</td>
<td>LED3 double pulse blinking</td>
</tr>
<tr>
<td>Connecting to cloud</td>
<td>LED3 triple pulse blinking</td>
</tr>
<tr>
<td>Publishing data</td>
<td>LED3 blinking</td>
</tr>
<tr>
<td>Active mode</td>
<td>LED4 blinking</td>
</tr>
<tr>
<td>Passive mode</td>
<td>LED3 and LED4 blinking</td>
</tr>
<tr>
<td>Error</td>
<td>All 4 LEDs blinking</td>
</tr>
<tr>
<td>FOTA update</td>
<td>LED1 and LED2 blinking</td>
</tr>
<tr>
<td>Completion of FOTA update</td>
<td>LED1 and LED2 static</td>
</tr>
</tbody></table>
<h3 id="（7）从云端删除设备"><a href="#（7）从云端删除设备" class="headerlink" title="（7）从云端删除设备"></a>（7）从云端删除设备</h3><p>如果你想从云端删除设备，可以直接在网页端操作，从右上角齿轮除点击删除即可。</p>
<p>也可以用云对云的REST API进行删除，后续章节讲解。</p>
<div style=”page-break-after: always;”></div>

<h1 id="4-nRF-Cloud-设备模型"><a href="#4-nRF-Cloud-设备模型" class="headerlink" title="4. nRF Cloud 设备模型"></a>4. nRF Cloud 设备模型</h1><p>本节简单介绍nRF Cloud如何定义设备（Device）的，详细的内容请查看官网资料：<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Overview/">Device overview | nRF Cloud Docs</a></p>
<h2 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1. 属性"></a>4.1. 属性</h2><h3 id="4-1-1-设备类型"><a href="#4-1-1-设备类型" class="headerlink" title="4.1.1. 设备类型"></a>4.1.1. 设备类型</h3><p>nRF Cloud将设备分为三大类，<strong>低功耗蓝牙设备（BLE）</strong>、<strong>网络设备（Internet Protocol）</strong>、<strong>用户自定义设备（Custom）</strong>。</p>
<p>其中，IP设备又有一些<strong>子类型</strong>设备：</p>
<ul>
<li>网关（Gateway）</li>
<li>通常联网设备（Generic）</li>
<li>软设备（Software）:用软件模拟的设备，可以连接MQTT</li>
</ul>
<p>除了IP设备自己的网关、通常设备等子类型以外，也可以（4）签发并安装设备证书。在<a href="#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6">3.5-(4)</a>中可以看到，注册设备时，可以用<code>-T</code>参数设置SubType。</p>
<h3 id="4-1-2-设备ID"><a href="#4-1-2-设备ID" class="headerlink" title="4.1.2. 设备ID"></a>4.1.2. 设备ID</h3><p>对于联网设备（IP devices），需要确保它<strong>具有全球连接到nRF Cloud的设备之中唯一的ID</strong>。如果使用MQTT，同时也需要把这个ID作为MQTT Client ID。</p>
<p>推荐使用UUID作为设备ID。所有nRF9160都出厂设定了一个UUID。在[第3节](3. 示例: 使用nRF9160-DK连接到nRF Cloud)中已经介绍了使用方法。</p>
<h3 id="4-1-3-数字孪生（Device-Shadow）"><a href="#4-1-3-数字孪生（Device-Shadow）" class="headerlink" title="4.1.3. 数字孪生（Device Shadow）"></a>4.1.3. 数字孪生（Device Shadow）</h3><p>Device Shadow或者说Digital Twin是一个包含了设备在云端存储的所有状态信息的Json。只有<strong>IP设备</strong>才拥有数字孪生。这个Json最大8 KB。</p>
<p>nRF Cloud提供了默认的模板。也可以往Json里加自定义字段。</p>
<p><strong>最好通过修改Device Shadow中属性值的方式来进行通信，而不是直接Send Message。</strong>比如说，设备连接到MQTT broker，并且订阅<code>/shadow/delta/delta</code>主题之后，Shadow值的改变就会可以触发Action。设备也可以设置为重新上线后从shadow同步，这样就不用担心设备掉线重连后的数据初始化问题了。</p>
<p>Device Shadow来源于亚马逊的AWS，可参考<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html">AWS IoT Device Shadow service - AWS IoT Core (amazon.com)</a>。</p>
<h2 id="4-2-安全性"><a href="#4-2-安全性" class="headerlink" title="4.2. 安全性"></a>4.2. 安全性</h2><p>安全性包含两个概念，身份验证（authentication）和授权（authorization）：</p>
<ul>
<li>身份验证：验证一个设备是否真实可信，不是仿冒的</li>
<li>授权：给不同的人员、设备不同的访问权限</li>
</ul>
<h3 id="4-2-1-身份验证"><a href="#4-2-1-身份验证" class="headerlink" title="4.2.1. 身份验证"></a>4.2.1. 身份验证</h3><p>身份验证靠<strong>凭证</strong>实现，拥有凭证的个体是<strong>持有者（bearer）</strong>，可以是一个用户或者一台设备。凭证不能给其他人。例如，nRF Cloud登录时输入的密码是一种凭证，通过REST接口调用API时，输入的API key是一种凭证。</p>
<p>不同的API使用不同的凭证：</p>
<table>
<thead>
<tr>
<th>API</th>
<th align="center">身份验证机制</th>
<th align="left">凭证</th>
</tr>
</thead>
<tbody><tr>
<td>MQTT</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mutual_authentication#mTLS">Mutual TLS</a></td>
<td align="left">两个证书：AWS根证书 和 设备证书<br />前者让设备认证AWS的合法性，后者让AWS认证设备的合法性。<br />如果换用其他云，就需要其他云的证书。</td>
</tr>
<tr>
<td>REST</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON_Web_Token">JSON Web Token (JWT)</a> over <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a></td>
<td align="left">用户访问云时，使用API Key;<br />设备和第三方云使用JWT，这里的JWT是使用ES256进行签名的Token。云端使用公钥验证签名。</td>
</tr>
</tbody></table>
<p>生成证书和密钥对的方式：</p>
<table>
<thead>
<tr>
<th>证书生成方式</th>
<th>证书注册方式</th>
<th>安全等级</th>
</tr>
</thead>
<tbody><tr>
<td>在设备上</td>
<td>通过<a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/index.jsp?topic=/ref_at_commands/REF/at_commands/security/keygen_set.html">CMNG</a> AT 指令直接在设备上生成证书和密钥对</td>
<td>高，私钥绝不会泄露</td>
</tr>
<tr>
<td>在电脑上</td>
<td>先生成证书和密钥对，然后通过<a target="_blank" rel="noopener" href="https://infocenter.nordicsemi.com/index.jsp?topic=/ref_at_commands/REF/at_commands/security/keygen_set.html">CMNG</a> AT 指令写入到设备中</td>
<td>较低</td>
</tr>
<tr>
<td>在nRF Cloud</td>
<td>通过REST接口 <a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/CreateDeviceCertificate">CreateDeviceCertificate</a>获得Nordic CA证书和设备证书以及密钥对，下载到电脑，然后通过AT指令安装到设备中</td>
<td>较低</td>
</tr>
</tbody></table>
<h3 id="4-2-2-授权"><a href="#4-2-2-授权" class="headerlink" title="4.2.2. 授权"></a>4.2.2. 授权</h3><p>MQTT授权由AWS IoT平台管理，根据设备被加入了哪个Thing Group来决定设备对资源的访问权限。</p>
<p>REST授权跟API key有关，直接在管理员账户的team管理中，就可以管理其他团队成员的账户权限。</p>
<h3 id="4-2-3-在9160上生成证书"><a href="#4-2-3-在9160上生成证书" class="headerlink" title="4.2.3. 在9160上生成证书"></a>4.2.3. 在9160上生成证书</h3><p>已在<a href="#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6">3.5-(3)</a>中演示在电脑上生成的方式。如要使用AT指令在设备上生成，可参考官方资料：<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Security/Credentials/">Securely generating credentials on the nRF9160 | nRF Cloud Docs</a></p>
<h3 id="4-2-4-JWT身份验证示例"><a href="#4-2-4-JWT身份验证示例" class="headerlink" title="4.2.4. JWT身份验证示例"></a>4.2.4. JWT身份验证示例</h3><p>见后续章节</p>
<h2 id="4-3-设备管理（Association）"><a href="#4-3-设备管理（Association）" class="headerlink" title="4.3. 设备管理（Association）"></a>4.3. 设备管理（Association）</h2><h3 id="4-3-1-设备注册方式"><a href="#4-3-1-设备注册方式" class="headerlink" title="4.3.1. 设备注册方式"></a>4.3.1. 设备注册方式</h3><p>在[3.5节](3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))中已经介绍</p>
<h3 id="4-3-2-添加与删除设备"><a href="#4-3-2-添加与删除设备" class="headerlink" title="4.3.2.  添加与删除设备"></a>4.3.2.  添加与删除设备</h3><p>通过REST接口即可操作，详见<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Associations/AddingAndRemovingDevices/">Adding and removing devices | nRF Cloud Docs</a></p>
<h3 id="4-3-3-设备组"><a href="#4-3-3-设备组" class="headerlink" title="4.3.3. 设备组"></a>4.3.3. 设备组</h3><p>可以把设备分成不同组，每个组可以自定义名称（不能带空格）。对每个组可以单独进行OTA升级等操作。详见<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Associations/DeviceGroups/">Device groups | nRF Cloud Docs</a></p>
<h2 id="4-4-设备固件升级"><a href="#4-4-设备固件升级" class="headerlink" title="4.4. 设备固件升级"></a>4.4. 设备固件升级</h2><p>nRF Cloud有一套完整的固件升级服务，详见：<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/FirmwareUpdate/FOTA/">Firmware update over-the-air | nRF Cloud Docs</a></p>
<h2 id="4-5-消息"><a href="#4-5-消息" class="headerlink" title="4.5. 消息"></a>4.5. 消息</h2><h3 id="4-5-1-设备消息"><a href="#4-5-1-设备消息" class="headerlink" title="4.5.1. 设备消息"></a>4.5.1. 设备消息</h3><p>设备通过<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics">支持消息存储的MQTT topic</a>，或者REST API <a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/SendDeviceMessage">SendDeviceMessage</a>，发送的消息可以存30天。</p>
<h3 id="4-5-2-消息桥接"><a href="#4-5-2-消息桥接" class="headerlink" title="4.5.2. 消息桥接"></a>4.5.2. 消息桥接</h3><p>消息可以通过建立桥接（bridge）的方式进行转发，详见<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Messages/SetupMessageBridge/">Setting up a message bridge | nRF Cloud Docs</a></p>
<div style=”page-break-after: always;”></div>

<h1 id="5-Asset-Tracker-v2-例程分析"><a href="#5-Asset-Tracker-v2-例程分析" class="headerlink" title="5. Asset Tracker v2 例程分析"></a>5. Asset Tracker v2 例程分析</h1><p>本节参考：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/asset_tracker_v2_description.html">Application description — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
<h2 id="5-1-本例程设计原则"><a href="#5-1-本例程设计原则" class="headerlink" title="5.1. 本例程设计原则"></a>5.1. 本例程设计原则</h2><ul>
<li>超低功耗</li>
<li>离线优先：本例程假设大多数情况下是离线的，连接是不可靠的。因此会有数据重发的机制。</li>
<li>时间戳机制：多时间源的时间戳机制，离线情况也可以计时</li>
<li>数据打包：多次数据打包，减少数据发送次数；离线时，数据会被存储，等到下次在线时一起发送</li>
<li>运行时参数修改：支持在运行时修改部分配置参数（例如加速度计灵敏度，或GNSS超时时间）</li>
</ul>
<h2 id="5-2-Zephyr构建系统简介"><a href="#5-2-Zephyr构建系统简介" class="headerlink" title="5.2. Zephyr构建系统简介"></a>5.2. Zephyr构建系统简介</h2><p>Zephyr Project是Linux基金会推出的一个Apache2.0开源项目，版权非常友好，适合用于商业项目开发。包含RTOS、编译系统、Zephyr组件。NCS中的例程基本都跑在[Zephyr RTOS](<a target="_blank" rel="noopener" href="https://docs.zephyrproject.org/latest/kernel/index.html">Kernel — Zephyr Project Documentation</a>)上。</p>
<p>Zephyr的构建系统（Build System）分为两个阶段，<strong>配置</strong>和<strong>编译</strong>。</p>
<p>本节介绍对初次接触的人比较费解的<strong>配置</strong>环节。</p>
<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>Zephyr构建系统使用CMake来进行<strong>配置</strong>。CMake首先根据配置自动生成<code>.ninja</code>配置文件，然后编译系统就可以用ninja来调用gcc进行编译和链接，最终生成可执行文件。</p>
<p>Zephyr沿用了CMake的目标文件（target）概念。target可以是一个库、hex或者可执行文件。Zephyr中几乎所有的组件都是被编译成一个库的，包括application程序的源码（如<code>src/main.c</code>）都会被编译并链接成一个<code>libapp.a</code>库文件。所有库文件最终会链接在一起成为MCU的可执行文件。</p>
<p>在例程的<code>CMakeList.txt</code>中，可以看到：</p>
<pre><code class="cmake">target_sources(app PRIVATE src/main.c) # 指定main.c为app这一target的源码
</code></pre>
<blockquote>
<ul>
<li>PRIVATE：源文件只被包含在这个app target中，修改源文件后，此target需要重新编译</li>
<li>PUBLIC：源文件也会被包含进所有与此app链接的其他target中，修改源文件后，所有与app链接的target都要重新编译。一般PUBLIC只用于Include路径的设置。</li>
</ul>
</blockquote>
<p><strong>配置</strong>时，CMake首先处理当前项目文件夹下的<code>CMakeList.txt</code>，而这个<code>CMakeList.txt</code>又包含了NCS中<code>zephyr</code>目录下的<code>CMakeList.txt</code>，并依次包含所有的构建树中的<code>CMakeList.txt</code>。最终生成<code>Ninja</code>配置文件。</p>
<p>除此之外CMake还会同时调用一些python脚本生成其他文件，用于后续的编译环节。如DeviceTree和Kconfig的处理都是在这一配置阶段进行的。</p>
<h3 id="DeviceTree"><a href="#DeviceTree" class="headerlink" title="DeviceTree"></a>DeviceTree</h3><p>Zephyr像Linux一样使用dts（设备树源码）来描述硬件，但Zephyr并不像Linux一样把dts编译成dtb，而是直接用python脚本把dts处理成头文件，直接编译进固件。</p>
<blockquote>
<p>硬件信息包括CPU数量和架构、内存基地址和大小、总线和桥、外设的连接、中断使用情况、GPIO使用情况、时钟使用情况等。最开始这些内容被hard code在Linux内核源码中，但是这让kernel源码非常庞大臃肿。后来就使用DTS来描述硬件，然后在编译时将其编译为DTB，并在运行时由bootloader传递给kernel。</p>
<p>但Zephyr在MCU上运行，资源受限。所以直接在编译前，构建系统使用python脚本将dts转换为<code>.h</code>头文件，并包含进项目代码。</p>
</blockquote>
<p>由于dts是描述硬件的，所以<strong>每块板子</strong>都可以用一个dts描述，如<code>nrf9160dk_nrf9160_ns.dts</code>。这个板子的配置文件是放在NCS目录下的<code>zephyr/boards</code>中的。</p>
<p><strong>不同的板子可能有共同的部分</strong>，比如使用相同的MCU。所以dts是可以包含其他dts的，通常描述<strong>芯片</strong>的文件为<code>.dtsi</code>，如<code>nrf9160_common.dtsi</code>。这个芯片的配置文件是放在NCS目录下的<code>zephyr/dts</code>中的。</p>
<p><strong>同一块板子可能配置成不同的功能</strong>，为了方便修改，可以在<strong>当前工程文件夹</strong>下，<code>boards</code>文件夹下的<code>&lt;board&gt;.overlay</code>来进行覆盖。overlay文件中只需要一小部分要修改的配置，在编译时，如果overlay和原板的dts配置了相同的项目，则优先采用overlay中的配置。</p>
<p>最终的配置生成顺序如下：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/1366713-20201222155014422-1085261766.png" alt="img"></p>
<p>通过板子本身标准的dts，以及覆盖的配置overlay，在<code>build/zephyr</code>路径下合并成完整的<code>zephyr.dts</code>。并最终转换成<code>build/zephyr/include/generated</code>目录下的<code>devicetree_unfixed.h</code>头文件。这就是最终源码中参考的头文件。</p>
<p>通常我们只修改overlay，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。</p>
<p>nRF Connect for VS Code插件提供了查看硬件配置的图形化界面。编译完毕后，就可以查看：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128153536593.png" alt="image-20221128153536593"></p>
<p>如上图，先选择工作区中想要查看的项目，然后下方就会出现板卡的硬件描述。点进每一个描述，就可以跳转到对应层级的设备树文件中（<code>dtsi</code>,<code>dts</code>或<code>overlay</code>）。</p>
<blockquote>
<p>安全特性：</p>
<p>Nordic开发板的硬件描述（dts）有<code>xxxdk_xxx.dts</code>和<code>xxxdk_xxx_ns.dts</code>两种。对应安全（secure）和非安全（<strong>n</strong>on-<strong>s</strong>ecure）两种配置。安全配置用到了TF-M，可参考<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/tfm/introduction/index.html">Introduction — Trusted Firmware-M documentation (nordicsemi.com)</a>。</p>
</blockquote>
<h3 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h3><p>Kconfig定义了配置项以及配置项之间的依赖关系。</p>
<p><strong>项目文件夹中的<code>Kconfig</code>文件定义了本项目包含了哪些模块。</strong>每个模块（如蓝牙controller、CAN总线controller等）都有自己的Kconfig选项配置。Kconfig之间也有包含关系。只要你的项目包含了这个模块，就要通过Kconfig的选项来配置这个模块。</p>
<p> 模块的配置、编译器的编译、链接器的relocation等都可以通过Kconfig来进行。此外，application也可以定义自己的配置项。这样，最终本项目的Kconfig就会组合形成一个有几千个配置项的大菜单。当然大多数情况下，我们只使用默认配置。</p>
<p>和device tree一样，Kconfig也是支持<strong>覆盖</strong>的。Kconfig中大多数都是模块自带的默认配置，要想覆盖其中的某些配置，只需修改项目文件夹下的<code>prj.conf</code>文件即可。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/1366713-20201222154609536-1676614851.png" alt="img"></p>
<p>如上图，<code>.conf</code>是最终合并的Kconfig，位于build目录下。而<code>autoconf.h</code>位于<code>build/zephyr/include/generated</code>目录下。</p>
<p>通常我们只修改<code>prj.conf</code>，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。</p>
<p>若想图形化地修改Kconfig，可以在VS Code的NCS Action栏中找到：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128162406563.png" alt="image-20221128162406563"></p>
<p>右侧三个点也支持使用<code>menuconfig</code>和<code>guiconfig</code>的方式进行查看。</p>
<p>保存Kconfig时，有三个选择：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128162604764.png" alt="image-20221128162604764" style="zoom: 80%;" />

<ul>
<li>Save：临时保存到build目录下的<code>.config</code>中。如果下次修改了其他配置，重新编译，此配置就会失效。</li>
<li>Save to file：只保存修改的部分，可以选择保存到工程目录下的<code>prj.conf</code>或<code>boards/&lt;board&gt;.conf</code>中，后者的配置比前者优先生效。<br>这个修改是永久的，只对本项目有效，且不会影响到NCS中模块本身的默认Kconfig。</li>
<li>Save (minimal) to new file：只保存修改的部分到一个新文件中。</li>
</ul>
<h2 id="5-3-例程代码分析"><a href="#5-3-例程代码分析" class="headerlink" title="5.3. 例程代码分析"></a>5.3. 例程代码分析</h2><h3 id="5-3-1-工程结构分析"><a href="#5-3-1-工程结构分析" class="headerlink" title="5.3.1. 工程结构分析"></a>5.3.1. 工程结构分析</h3><p>首先看项目根目录下的<code>Kconfig</code>的包含关系：</p>
<pre><code>Kconfig
|-- Asset Tracker v2  // 本应用的配置
|   |-- src/modules/Kconfig.modules_common
|   |-- src/modules/Kconfig.app_module
|   |-- src/modules/Kconfig.cloud_module
|   |-- src/cloud/Kconfig.lwm2m_integration
|   |-- src/modules/Kconfig.data_module
|   |-- src/modules/Kconfig.gnss_module
|   |-- src/modules/Kconfig.modem_module
|   |-- src/modules/Kconfig.sensor_module
|   |-- src/modules/Kconfig.ui_module
|   |-- src/modules/Kconfig.util_module
|   |-- src/modules/Kconfig.led_module
|   |-- src/modules/Kconfig.debug_module
|   |
|   |-- src/cloud/cloud_codec/Kconfig
|   |-- src/watchdog/Kconfig
|   |-- src/events/Kconfig
|   
|-- Zephyr Kernel  // 操作系统内核的配置
|	|-- Kconfig.zephyr
|
|-- 日志打印等级配置
</code></pre>
<p>可以看到，除了Zephyr操作系统内核外，还包含了src目录下许多的模组，这些模组不同于NCS中作为库的模组，而是Nordic官方为了Asset Tracker V2这个例程开发的应用模组。你也可以开发自己的模组。</p>
<p>直接用图形化界面查看，就可以看到Kconfig中的选项了：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129154636314.png" alt="image-20221129154636314" style="zoom: 67%;" />



<h3 id="5-3-2-main-c文件分析"><a href="#5-3-2-main-c文件分析" class="headerlink" title="5.3.2. main.c文件分析"></a>5.3.2. main.c文件分析</h3><p>我们进入到<code>src/main.c</code>中的<code>main()</code>函数，可以看到，首先是判断是否启用了<code>lwm2m</code>库：</p>
<pre><code class="c">if (!IS_ENABLED(CONFIG_LWM2M_CARRIER)) &#123;
        handle_nrf_modem_lib_init_ret();
&#125;
</code></pre>
<p>在[nRF Connect SDK](<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/index.html">Welcome to the nRF Connect SDK! — nRF Connect SDK 2.1.2 documentation</a>)官方文档中有丰富的资料，所有不懂的东西都可以在里面搜索，我们搜索<code>lwm2m</code>：</p>
<img src="./../../../AppData/Roaming/Typora/typora-user-images/image-20221129132733110.png" alt="image-20221129132733110" style="zoom: 50%;" />



<p>点进第一个搜索结果：</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129132903784.png" alt="image-20221129132903784" style="zoom: 50%;" />

<p>根据这个页面的内容我们可以知道，Nordic提供一个叫做Cloud wrapper API的东西，它把各种IoT云的客户端库接口都给封装起来，只暴露出发送、连接、断开之类的常用功能，把每个云端特定的接口给隐藏了。</p>
<p>那么Cloud wrapper API都封装了哪些云端提供的库呢？往下面翻可以看到，有亚马逊AWS IoT、微软Azure IoT Hub、nRF Cloud以及LwM2M。看到这里我们就知道LwM2M应该是某种云的客户端库。再往下就是介绍技术细节了。如果要详细了解LwM2M，就可以去其它搜索引擎继续搜索了。</p>
<p>由于我们使用的是nRF Cloud，因此本文不再探究LwM2M的内容。</p>
<blockquote>
<p>注意：</p>
<p>我们查资料时一定要注意资料的适用范围：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129160526320.png" alt="image-20221129160526320"></p>
<p>从这个资料的路径可以看出，Cloud wrapper API只是Nordic为了 Asset Tracker v2这个项目开发的一个API，是项目内部的一个实现，并非是NCS中通用的库。</p>
</blockquote>
<p>接着往下看可以看到，调用了一个App Event Manager的初始化函数。并且注释告诉我们这个App Event Manager必须初始化成功，否则就无法实现功能，需要重启。</p>
<pre><code class="c">if (app_event_manager_init()) &#123;
        /* Without the Application Event Manager, the application will not work
         * as intended. A reboot is required in an attempt to recover.
         */
        LOG_ERR(&quot;Application Event Manager could not be initialized, rebooting...&quot;);
        k_sleep(K_SECONDS(5));
        sys_reboot(SYS_REBOOT_COLD);
    &#125; else &#123;
        module_set_state(MODULE_STATE_READY);
        SEND_EVENT(app, APP_EVT_START);
    &#125;
</code></pre>
<p>我们可以右键跳转到对应的代码</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134046131.png" alt="image-20221129134046131"></p>
<p>在VS Code上方文件地址栏，就可以知道Application Event Manager是Nordic提供的<code>nrf</code>仓库下的一个subsystem。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134230597.png" alt="image-20221129134230597"></p>
<p>既然Application Event Manager是一个模组，那么当然在Kconfig中也是可以搜到它的配置的。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134432904.png" alt="image-20221129134432904"></p>
<p>由此我们可以体会到<code>Zephyr</code>这个配置系统的方便之处：只要是官方提供的模组，不论是nrf、zephyr还是第三方的模组，只要用Kconfig包含这个模组，就可以在本项目的Kconfig菜单中轻松的进行配置。</p>
<p>当然，在NCS官方文档中进行搜索也是可以的，这里给出链接<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/app_event_manager.html#application-event-manager">Application Event Manager — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134707130.png" alt="image-20221129134707130" style="zoom:67%;" />



<p>接下来，获取当前线程（main函数）的线程id，然后启动本模组：</p>
<pre><code class="c">    self.thread_id = k_current_get();

    err = module_start(&amp;self);
    if (err) &#123;
        LOG_ERR(&quot;Failed starting module, error: %d&quot;, err);
        SEND_ERROR(app, APP_EVT_ERROR, err);
    &#125;
</code></pre>
<p>这里，我们不知道<code>self</code>是什么意思，就查看前面的变量定义：</p>
<pre><code class="c">/* 消息结构体定义（联合体）：
 * 来自其他模块的事件（Event），会被Application Event Manager包装成
 * 消息（Message）。然后放入消息队列，供主程序app处理。
 *
 * 这里可以看到消息的来源就有各种模组，包括云、Ui、sensor等
 */
struct app_msg_data &#123;
    union &#123;
        struct cloud_module_event cloud;
        struct ui_module_event ui;
        struct sensor_module_event sensor;
        struct data_module_event data;
        struct util_module_event util;
        struct modem_module_event modem;
        struct app_module_event app;
    &#125; module;
&#125;;

/*
 * 消息队列的定义，这种用宏进行定义的方法是Zephyr提供的
 */
K_MSGQ_DEFINE(msgq_app, sizeof(struct app_msg_data), APP_QUEUE_ENTRY_COUNT,
          APP_QUEUE_BYTE_ALIGNMENT);

/* 
 * 用于保存app模组信息的数据结构。
 */
static struct module_data self = &#123;
    .name = &quot;app&quot;,
    .msg_q = &amp;msgq_app,
    .supports_shutdown = true,
&#125;;
</code></pre>
<p>我们就可以知道，这个项目把application也当成是一个模组，和其他官方提供模组的地位是等价的。模组之间通过消息队列进行通信。</p>
<p>接下来就可以看到，由于前面app模组获取的线程id正是main函数的id，所以app模组直接就在main函数中用while(1)循环来处理其他模组的消息了。</p>
<pre><code class="c">while (true) &#123;
    // 从队列中取出消息	
    module_get_next_msg(&amp;self, &amp;msg);
        
    // 主状态机
    switch (state) &#123;
        case STATE_INIT:
            on_state_init(&amp;msg);
            break;
        
        case STATE_RUNNING:
            switch (sub_state) &#123;
                case SUB_STATE_ACTIVE_MODE:
                    on_sub_state_active(&amp;msg);
                    break;
                case SUB_STATE_PASSIVE_MODE:
                    on_sub_state_passive(&amp;msg);
                    break;
                default:
                    LOG_WRN(&quot;Unknown application sub state&quot;);
                    break;
            &#125;

            on_state_running(&amp;msg);
            break;
        case STATE_SHUTDOWN:
            /* The shutdown state has no transition. */
            break;
        default:
            LOG_WRN(&quot;Unknown application state&quot;);
            break;
    &#125;

    on_all_events(&amp;msg); 
&#125;
</code></pre>
<p>接下来，看到在<code>main</code>文件末尾的定义：</p>
<pre><code class="c">// 这里MODULE的值是main
APP_EVENT_LISTENER(MODULE, app_event_handler);
APP_EVENT_SUBSCRIBE_EARLY(MODULE, cloud_module_event);
APP_EVENT_SUBSCRIBE(MODULE, app_module_event);
APP_EVENT_SUBSCRIBE(MODULE, data_module_event);
APP_EVENT_SUBSCRIBE(MODULE, util_module_event);
APP_EVENT_SUBSCRIBE_FINAL(MODULE, ui_module_event);
APP_EVENT_SUBSCRIBE_FINAL(MODULE, sensor_module_event);
APP_EVENT_SUBSCRIBE_FINAL(MODULE, modem_module_event);
</code></pre>
<p>根据前面的学习方法（搜索代码、文档），可以知道这些宏就是Application Event Manager模组提供的，可以参考其文档。这些宏的大概作用就是：给一个名为“MODULE”的模组（实际宏定义是main），定义了一个事件接收器，然后订阅了剩下那些模组的事件消息。</p>
<blockquote>
<p>Zephyr中有大量的在文件末尾通过宏定义进行配置的方法，它们往往都是描述一些<strong>运行时</strong>的配置。例如，把一个函数当作一个线程进行注册，或者把一个函数当成是初始化函数在开机初始化阶段运行。</p>
<p>例如<code>src/modules/ui_module.c</code>的最后一行：</p>
<pre><code class="c">SYS_INIT(setup, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);
</code></pre>
<p>就是让系统在初始化阶段自动调用<code>setup()</code>这个函数，不需要我们在main的开头显式地调用这个函数。假设我们有非常多模组，这样做就可以简化<code>main()</code>函数的代码，便于模块化的开发。</p>
<p>初始化等级是<code>APPLICATION</code>，这说明这个函数要在Zephyr操作系统的Kernel初始化完毕之后才运行。</p>
<p><code>CONFIG_APPLICATION_INIT_PRIORITY</code>是·<code>autoconf.h</code>中的，我们知道可以在Kconfig中配置它。在Kconfig菜单中搜索可以知道，这个配置是Zephyr Kernel的一个配置，是所有application级别的init函数的优先级。</p>
</blockquote>
<h3 id="5-3-3-云端连接相关模组的代码分析"><a href="#5-3-3-云端连接相关模组的代码分析" class="headerlink" title="5.3.3. 云端连接相关模组的代码分析"></a>5.3.3. 云端连接相关模组的代码分析</h3><p>在<code>src/modules/cloud_module.c</code>中，文件的最下方，可以看到：</p>
<pre><code class="c">K_THREAD_DEFINE(cloud_module_thread, CONFIG_CLOUD_THREAD_STACK_SIZE,
        module_thread_fn, NULL, NULL, NULL,
        K_LOWEST_APPLICATION_THREAD_PRIO, 0, 0);

// 这里MODULE宏的值是cloud_module
APP_EVENT_LISTENER(MODULE, app_event_handler);
APP_EVENT_SUBSCRIBE(MODULE, data_module_event);
APP_EVENT_SUBSCRIBE(MODULE, app_module_event);
APP_EVENT_SUBSCRIBE(MODULE, modem_module_event);
APP_EVENT_SUBSCRIBE_FIRST(MODULE, cloud_module_event);
APP_EVENT_SUBSCRIBE(MODULE, gnss_module_event);
APP_EVENT_SUBSCRIBE(MODULE, debug_module_event);
APP_EVENT_SUBSCRIBE_EARLY(MODULE, util_module_event);
</code></pre>
<p>和<code>main.c</code>一样，这里也使用Application Event Manager模组的功能，创建了一个event lisener，并且订阅了其他模组的消息。</p>
<p>并且这里定义了一个线程，<code>cloud_module_thread</code>，线程的函数是<code>module_thread_fn()</code>。</p>
<p>线程函数内部也是一个状态机：</p>
<pre><code class="c">static void module_thread_fn(void)
&#123;
    ...
    while (true) &#123;
        module_get_next_msg(&amp;self, &amp;msg);

        switch (state) &#123;
        case STATE_LTE_INIT:
            on_state_init(&amp;msg);
            break;
        case STATE_LTE_CONNECTED:
            ...
            break;
        case STATE_LTE_DISCONNECTED:
            on_state_lte_disconnected(&amp;msg);
            break;
        case STATE_SHUTDOWN:
            /* The shutdown state has no transition. */
            break;
        default:
            LOG_ERR(&quot;Unknown Cloud module state.&quot;);
            break;
        &#125;
        ...
    &#125;
&#125;
</code></pre>
<p>经过代码的分析可知，状态开始时从<code>STATE_LTE_INIT</code>进入到<code>STATE_LTE_DISCONNECTED</code>。在断开状态下，如果收到<code>MODEM_EVT_LTE_CONNECTED</code>的消息，就会把状态变为<code>CONNECTED</code>。</p>
<p>通过定义的跳转和搜索，可以知道<code>MODEM_EVT_LTE_CONNECTED</code>这条消息是从<code>src/modules/modem_module.c</code>中的模组发出的。</p>
<pre><code class="c">// src/modules/modem_module.c 的末尾定义，也是定义了一个线程和1个lisener.
K_THREAD_DEFINE(modem_module_thread, CONFIG_MODEM_THREAD_STACK_SIZE,
        module_thread_fn, NULL, NULL, NULL,
        K_LOWEST_APPLICATION_THREAD_PRIO, 0, 0);

APP_EVENT_LISTENER(MODULE, app_event_handler);
APP_EVENT_SUBSCRIBE_EARLY(MODULE, modem_module_event);
APP_EVENT_SUBSCRIBE(MODULE, app_module_event);
APP_EVENT_SUBSCRIBE(MODULE, cloud_module_event);
APP_EVENT_SUBSCRIBE_FINAL(MODULE, util_module_event);
</code></pre>
<p>层层搜索下去，可知<code>MODEM_EVT_LTE_CONNECTED</code>是PDN模组的消息，只要PDN模组收到了<code>PDN_EVENT_ACTIVATED</code>事件，就说明9160已经联网。PDN模组相关的文档，可参考：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/modem/pdn.html#pdn">PDN — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
<p>我们再回到<code>src/modules/cloud_module.c</code>中，进入线程的主状态机，可以看到在LTE已连接的状态下，还有两个子状态<code>SUB_STATE_CLOUD_CONNECTED</code>和<code>SUB_STATE_CLOUD_DISCONNECTED</code>。</p>
<p>为了了解设备是如何从未连接到云变成已连接到云的，我们进入未连接状态的回调函数。可以看到，它调用了一个连接到云的函数：</p>
<pre><code class="c">connect_cloud()；
</code></pre>
<p>并且，在LTE未连接状态下的回调函数中，第一次成功连网时，也会调用此函数去连云。说明这正是我们要找的连接云的函数:</p>
<pre><code class="c">static void connect_cloud(void)
&#123;
    ...
    ...
        
    err = cloud_wrap_connect();
    if (err) &#123;
        LOG_ERR(&quot;cloud_connect failed, error: %d&quot;, err);
    &#125;

    ...
    ...
        
    /* Start timer to check connection status after backoff */
    k_work_reschedule(&amp;connect_check_work, K_SECONDS(backoff_sec));
&#125;
</code></pre>
<p>其中的<code>cloud_wrap_connect()</code>正是前面搜索过的Cloud Wrapper API。</p>
<p>此函数在<code>src/cloud/cloud_wrapper.h</code>中声明，但是在以下多个文件中都被定义：</p>
<ul>
<li>亚马逊 AWS：<code>src/cloud/aws_iot_integration.c</code></li>
<li>微软 Azure：<code>src/cloud/azure_iot_hub_integration.c</code></li>
<li>Nordic nRF Cloud：<code>src/cloud/nrf_cloud_integration.c</code></li>
<li>LwM2M：<code>lwm2m_integration.c</code></li>
</ul>
<p>由于在<code>prj.conf</code>中，对Kconfig进行了覆盖：</p>
<pre><code class="bash"># Default cloud transport service
CONFIG_NRF_CLOUD_MQTT=y
</code></pre>
<p>默认选择了nRF Cloud的客户端库。</p>
<p>而在<code>src/cloud/cloud_codec/Kconfig</code>中，有如下描述：</p>
<pre><code class="Kconfig">choice
    prompt &quot;Application cloud codec backend&quot;
    default CLOUD_CODEC_NRF_CLOUD if NRF_CLOUD_MQTT
    default CLOUD_CODEC_AWS_IOT if AWS_IOT
    default CLOUD_CODEC_AZURE_IOT_HUB if AZURE_IOT_HUB
    default CLOUD_CODEC_LWM2M if LWM2M_INTEGRATION
</code></pre>
<p>即，只要<code>NRF_CLOUD_MQTT</code>被配置为<code>y</code>，就会自动选择<code>CLOUD_CODEC_NRF_CLOUD</code>作为云端。</p>
<p>我们从Kconfig的图形界面中也可以确认这点，打开Kconfig图形配置页面。在<code>Asset Tracker V2 -&gt; Application cloud codec -&gt; Application cloud codc backend</code>选项，可以看到默认选择了<code>nRF Cloud</code>作为我们的云端：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129155334071.png" alt="image-20221129155334071"></p>
<p>而在<code>src\cloud\cloud_codec\CMakeLists.txt</code>中，有如下描述:</p>
<pre><code class="cmake">target_sources_ifdef(CONFIG_CLOUD_CODEC_AWS_IOT app
                     PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/aws_iot/aws_iot_codec.c)

target_sources_ifdef(CONFIG_CLOUD_CODEC_AZURE_IOT_HUB app
                     PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/azure_iot_hub/azure_iot_hub_codec.c)

target_sources_ifdef(CONFIG_CLOUD_CODEC_NRF_CLOUD app
                     PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/nrf_cloud/nrf_cloud_codec.c)

target_sources_ifdef(CONFIG_CLOUD_CODEC_LWM2M app
                     PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lwm2m/lwm2m_codec.c)
</code></pre>
<p>可以看出，由于我们只定义了<code>CLOUD_CODEC_NRF_CLOUD</code>，CMake在编译时就只会包含<code>nrf_cloud_codec.c</code>中的函数。也就是wrapper的具体实现，最终只会使用连接到nRF Cloud的函数。</p>
<p>回到这个函数，在<code>src/cloud/nrf_cloud_integration.c</code>中，<code>cloud_wrap_connect()</code>调用了真正的连接函数，<code>nrf_cloud_connect()</code>。这是NCS库中的，nRF Cloud提供的客户端库提供的函数。关于这个库的介绍，可以参考：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html#nrf-cloud">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>
<p>所有连接、与云端通信的内容都是通过这个库完成的，所有资料都可以在上面链接里找到。而这个库是经过wrapper封装的，app代码实际调用的是wrapper。</p>
<h3 id="5-3-4-数据传输相关代码"><a href="#5-3-4-数据传输相关代码" class="headerlink" title="5.3.4. 数据传输相关代码"></a>5.3.4. 数据传输相关代码</h3><p>以Data模组为例，根据<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html">Asset Tracker v2官方说明</a>，本例程中的Data模组的作用是从其他模组中搜集数据，并上报给云端。而与云端交互的工作是Cloud模组实现的。</p>
<p>先看Data模组，在<code>src/modules/data_module.c</code>的末尾，可以看到线程的定义。</p>
<p>进入到线程函数<code>module_thread_fn()</code>中，也是有一个状态机：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129171438897.png" alt="image-20221129171438897"></p>
<p>在已连接到云的状态下（<code>STATE_CLOUD_CONNECTED</code>），查看对应的状态处理函数。当收到<code>DATA_EVT_DATA_READY</code>消息时，就会准备向云端发送数据：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129171800871.png" alt="image-20221129171800871"></p>
<p>我们分析这个<code>data_encode()</code>函数</p>
<ul>
<li>先使用<code>cloud_codec_encode_batch_data(...)</code>对所有数据进行json编码。由于不同的云端Json格式肯定不一样，所以这个函数也是Cloud API Wrapper提供的。</li>
<li><code>data_send(DATA_EVT_DATA_SEND_BATCH, &amp;codec)</code>发送这个json。<strong>但这并不是发送到云端</strong>，而是通过Application Event Manager发送到消息池中，事件类型是<code>DATA_EVT_DATA_SEND_BATCH</code>。</li>
</ul>
<p>接下来，通过VS Code左侧搜索<code>DATA_EVT_DATA_SEND_BATCH</code>，看这个消息被哪里接收了。可以知道此消息已经传输到Cloud模组，打开<code>src/modules/cloud_module.c</code>：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129172213052.png" alt="image-20221129172213052"></p>
<p>这里并没有直接发送到云端，而是调用了一个QoS（Quality of Service）库的函数。我们继续去NCS官方文档搜索<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/qos.html#quality-of-service">Quality of Service</a>。</p>
<p>根据文档内容，我们知道，NCS的QoS只提供两种服务质量：</p>
<ul>
<li><code>ACK_DISABLED</code>：只管发送，不管云端是否已收到</li>
<li><code>ACK_REQUIRED</code>：需要确保云端收到并回复，若超时未回复，需要重发。</li>
</ul>
<blockquote>
<p>还有一种服务质量是，需要确保对方收到，且仅收到一次。但嵌入式设备往往不能提供这样的QoS，而是要算力更强的云端去做消息去重。</p>
</blockquote>
<p>文档中的序列图给出了很详细的示例：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/qos_sequence.svg" alt="Sequence diagram general"></p>
<ol>
<li>当发送一个数据包需要ACK时，Application调用QoS库的<code>qos_add_message()</code>，将消息记录在一个列表中。</li>
<li>然后QoS库把一个回调函数放入kernel提供的工作队列（<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/services/threads/workqueue.html#c.k_work_reschedule">Workqueue</a>）中，并且设定为一个延时的工作。</li>
<li>接下来，QoS库通知给Application，消息已经记录好了，可以发送了。</li>
<li>Application接收到QoS库的消息<code>QOS_EVT_MESSAGE_NEW</code>，真正的发送数据。</li>
<li>根据数据的接收方是否按时回复ACK，有两种不同的行为：<ul>
<li>若接收方按时回复，则 Application 需要调用<code>qos_message_remove</code>函数，从列表中移除这个消息。然后从工作队列中取消之前注册的函数。</li>
<li>若接收方超时未回复，则工作队列中的回调函数被调用，QoS库发送消息<code>QOS_EVT_MESSAGE_EXPIRED</code>。Application收到此消息后，执行一次重发。</li>
</ul>
</li>
</ol>
<p>有了上面关于QoS的知识，我们就知道，只有收到QoS库的<code>QOS_EVT_MESSAGE_NEW</code>消息时，Application才会真正的把数据发送到云端：</p>
<p>在<code>src/moudles/cloud_module.c</code>中，有一个<code>qos_event_handler()</code>函数：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130113448664.png" alt="image-20221130113448664"></p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130113827493.png" alt="image-20221130113827493"></p>
<p>在初始化时，这个<code>qos_event_handler()</code>函数被注册到QoS库中，让Cloud模组能够处理来自QoS的消息。</p>
<blockquote>
<p>注意，QoS库与Cloud模组之间消息的传递，并不是通过Application Event Manager来进行的。而是通过回调函数的方式来进行的。</p>
</blockquote>
<p>这里又出现一个新的事件，<code>CLOUD_EVT_DATA_SEND_OQS</code>。搜索这个事件，可以发现这个事件是cloud模组接收的。在状态机中，<code>on_sub_state_cloud_connected()</code>和<code>on_sub_state_cloud_disconnected()</code>这两个函数中都有调用：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130114341395.png" alt="image-20221130114341395"></p>
<p>在这里，可以看到最初的Batch数据最终是通过Cloud Wrapper API的<code>cloud_wrapper_batch_send()</code>发送到云端。</p>
<h3 id="5-3-5-例程代码总结"><a href="#5-3-5-例程代码总结" class="headerlink" title="5.3.5. 例程代码总结"></a>5.3.5. 例程代码总结</h3><p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/asset_tracker_v2_module_hierarchy.svg" alt="Relationship between modules and the Application Event Manager"></p>
<ul>
<li>Zephyer风格的代码就是把一切都写成模组，每个模组可以有自己的线程、初始化代码。自己编写的模组之间通过Application Event Manager提供的消息机制进行通信。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/asset_tracker_v2_cloud_module_hierarchy.svg" alt="Cloud module hierarchy"></p>
<ul>
<li>设备和云端的连接是通过Cloud Wrapper API进行的，由于<code>prj.conf</code>中配置了<code>CONFIG_NRF_CLOUD_MQTT=y</code>，所以Kconfig就选择nRF Cloud Library作为客户端。CMake系统也只编译了与nRF Cloud有关的代码，并把其作为wrapper的内容。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130120212409.png" alt="image-20221130120212409"></p>
<ul>
<li><p>设备到云端的数据发送，经历了QoS库的处理，然后通过内部各种消息传输，最终通过Cloud Wrapper API发送到云端。上图仅展示数据是如何发送出去的，未展示QoS超时校验的部分。</p>
</li>
<li><p>要了解更多关于此项目的实现内容，可以参考例程的官方说明，非常详细：<a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>
</li>
</ul>
<div style=”page-break-after: always;”></div>

<h1 id="6-nRF-Cloud-API介绍"><a href="#6-nRF-Cloud-API介绍" class="headerlink" title="6. nRF Cloud API介绍"></a>6. nRF Cloud API介绍</h1><p>nRF Cloud提供REST和MQTT两种API。</p>
<ul>
<li>REST API 用于<strong>用户到云</strong>、<strong>第三方云到云</strong>的连接；其中少部分API也可被设备调用。</li>
<li>MQTT API用于<strong>设备和云</strong>的连接</li>
</ul>
<h2 id="6-1-REST-API"><a href="#6-1-REST-API" class="headerlink" title="6.1. REST API"></a>6.1. REST API</h2><p>nRF Cloud REST API文档，参考：<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1">nRF Cloud REST API Documentation</a></p>
<h3 id="REST-API-认证方式"><a href="#REST-API-认证方式" class="headerlink" title="REST API 认证方式"></a>REST API 认证方式</h3><p>在使用REST API时，用户、设备、nRF Cloud、第三方云端之间的通信都是需要认证的。在通讯的消息中需要一个key，来证明消息发出源是可信的。不同类型的对象之间访问，使用不同类型的key：</p>
<ul>
<li><p><strong>用户到设备</strong> 或者<strong>用户到云</strong>的认证：这种访问方式需要<strong>API key</strong>来认证，通常是用来做设备注册、获取设备数据、查看用户账户或使用信息的。在<a href="#%EF%BC%885%EF%BC%89%E6%8A%8A%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E5%88%B0%E4%BA%91%E7%AB%AF">3.5-(5)</a>小节中已经介绍如何从网页端获取这个Key；</p>
</li>
<li><p><strong>设备到云</strong>（D2C）的认证：使用<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/APIs/REST/RESTIntro/#authentication">JSON Web Token</a> (<strong>JWT</strong>)，确保安全性。</p>
</li>
<li><p><strong>云到云</strong>（C2C）的认证：也使用<strong>JWT</strong>进行认证。用来做像是通过代理服务器进行位置服务的集成的功能。云到云的API调用需要购买专业版（Pro）或者企业版（Enterprise）服务。</p>
</li>
</ul>
<h3 id="REST-API-调用示例"><a href="#REST-API-调用示例" class="headerlink" title="REST API 调用示例"></a>REST API 调用示例</h3><p>本小节将使用电脑模拟一台<strong>设备</strong>，通过REST接口注册设备，并使用JWT的认证方式，调用一个REST API。官方文档可参考：<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Security/JWT/">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>
<p>整个注册过程和[3.5小节](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))的流程是一模一样的。但是本小节中展示的注册过程没有使用python脚本，而是使用最基本的HTTP请求来展示API调用的过程。</p>
<p>在<strong>开始之前</strong>，找一个<a target="_blank" rel="noopener" href="https://www.uuidgenerator.net/">在线UUID生成器</a>，生成一个UUID。本例生成的是：<code>64520de4-e0a0-45cf-bf56-1f43f80a4f37</code>，这个UUID就代表一台设备，本例中代表的是这台电脑。</p>
<p><strong>（1）生成CA证书和设备证书</strong></p>
<p>在<a href="#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6">3.5-(3)</a>小节中，我们已经通过Nordic提供的python脚本生成了一套CA证书文件和私钥。这套utils工具中也包含一套TypeScript脚本。你也可以两种都不使用，而只使用OpenSSL进行生成，可参考<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Security/JWT/">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>
<p>后面在<a href="#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6">3.5-(4)</a>中，我们通过这个CA证书给nRF9160签发了设备证书，给设备安装了设备独立的私钥。</p>
<p>现在我们要用电脑模拟一台设备，就需要通过刚刚生成的UUID和<strong>CA证书</strong>，来生成一个新的<strong>设备证书</strong>。</p>
<p>进入[3.5-(2)](#（2）获取最新的nRF Cloud Utils工具，并安装好依赖)中安装utils的文件夹：</p>
<pre><code class="bash"># 在终端中进入utils文件夹后，再进行后续操作

# 进入python工具文件夹
$ cd python/modem-firmware-1.3+/

# 生成设备证书
$ python create_device_credentials.py \
-ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem \
-ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem \
-c CN \
-l Shanghai \
-o &quot;Nordic Semiconductor K.K.&quot; \
-ou &quot;Sales&quot; \
-cn 64520de4-e0a0-45cf-bf56-1f43f80a4f37 \
-e jayant.tang@nordicsemi.no \
-dv 2000 \
-p ./dev_credentials \
-f &quot;Jayant-Device-&quot;
</code></pre>
<blockquote>
<p>参数释义：</p>
<ul>
<li><code>-ca</code>：CA证书文件</li>
<li><code>-ca_key</code>：CA证书密钥文件</li>
<li><code>-c</code>：2字符国家代码</li>
<li><code>-st</code>：美国、加拿大的州或省代码</li>
<li><code>-l</code>：地点</li>
<li><code>-o</code>：组织</li>
<li><code>-o</code>u：组织部门</li>
<li><code>-cn</code>：Common Name。使用nRF CLoud Device ID 或者 MQTT Client ID。这里使用UUID。</li>
<li><code>-e</code>：e-mail</li>
<li><code>-dv</code>：证书合法天数</li>
<li><code>-p</code>：用于生成设备证书的目录</li>
<li><code>-f</code>：生成的证书文件名前缀</li>
</ul>
</blockquote>
<p><strong>（2）生成设备注册信息表格</strong></p>
<p>本小节参考 <a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices">REST 设备注册API （ProvisionDevices）</a>。</p>
<p>打开Excel，创建一个新的空表格，并另存为csv格式。</p>
<img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124150045752.png" alt="image-20221124150045752" style="zoom: 80%;" />

<p>在表格中从左往右填入以下内容：</p>
<ul>
<li><p>第一列：设备ID，这里是UUID</p>
</li>
<li><p>第二列：设备子类型，可以写温湿度传感器之类的文字，可以留空；</p>
</li>
<li><p>第三列：用于设备分类的标签，这里填<a href="#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6">3.5-(4)</a>中nRF9160一样的tag名称就行，也可以留空</p>
</li>
<li><p>第四列：固件类型，可以和9160例程填一样的，也可以留空</p>
</li>
<li><p>第五列：设备证书。从上一小节的设备证书中，把<code>xxxx_crt.pem</code>中的内容拷贝进去即可</p>
<p>（注意，excel单元格类型要设置成“文本”，否则可能把等号、加号识别为公式）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124150540606.png" alt="image-20221124150540606"></p>
<p>保存csv表格，此处给出我的csv文件内容，方便对比格式是否正确：</p>
<p><code>fake-device.csv</code></p>
<p>注意，逗号用于区分每一列，回车用于区分每一行，双引号中的内容为字符串（引号中的回车不算作换行）。</p>
<pre><code class="csv">64520de4-e0a0-45cf-bf56-1f43f80a4f37,fake-device,jayant-DK,APP|MODEM,&quot;-----BEGIN CERTIFICATE-----
MIICPTCCAeICFHx8JF+NRorZfBQF0sr+jzKSmg9gMAoGCCqGSM49BAMCMIGSMQsw
CQYDVQQGEwJDTjERMA8GA1UEBwwIU2hhbmdoYWkxIjAgBgNVBAoMGU5vcmRpYyBT
ZW1pY29uZHVjdG9yIEsuSy4xDjAMBgNVBAsMBVNhbGVzMRIwEAYDVQQDDAlub3Jk
aWMuY24xKDAmBgkqhkiG9w0BCQEWGWpheWFudC50YW5nQG5vcmRpY3NlbWkubm8w
HhcNMjIxMTI0MDY1MjEwWhcNMjgwNTE2MDY1MjEwWjCBrTELMAkGA1UEBhMCQ04x
ETAPBgNVBAcMCFNoYW5naGFpMSIwIAYDVQQKDBlOb3JkaWMgU2VtaWNvbmR1Y3Rv
ciBLLksuMQ4wDAYDVQQLDAVTYWxlczEtMCsGA1UEAwwkNjQ1MjBkZTQtZTBhMC00
NWNmLWJmNTYtMWY0M2Y4MGE0ZjM3MSgwJgYJKoZIhvcNAQkBFhlqYXlhbnQudGFu
Z0Bub3JkaWNzZW1pLm5vMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6OIeO6C0
/kJzfaWUHt/Xg4J6bdAphzmX5sCLGV+oEeSi1sUQKpBLugda2OwG9FxOCikg8ih7
CvMm7C98+fr+nTAKBggqhkjOPQQDAgNJADBGAiEAuCdq6D1K329hwU9e+4S5//2b
upwtaqT+j6Mckpmj6XUCIQCaAqjWRMXMiOd/pXRkcf7SjKyZifBnxoepRqbNyKUG
OA==
-----END CERTIFICATE-----
&quot;
</code></pre>
<p><strong>（3）利用REST接口注册设备</strong></p>
<p>使用<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices">ProvisionDevices</a>接口。</p>
<p>这属于<strong>用户到云</strong>的接口调用，需要使用<strong>API key</strong>。</p>
<pre><code class="bash"># 向nRF Cloud发送请求，注册设备。
$  curl --request POST --url https://api.nrfcloud.com/v1/devices \
--header &#39;Authorization: Bearer 3c967ecbd9f3cxxxxxxxxxxfa73cf37049983&#39; \
--header &#39;content-type: text/csv&#39; \
--data-binary @./fake-device.csv
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>把API Key改成你自己的API Key</li>
<li>用curl发送csv文件时，必须使用二进制流。否则curl可能会丢掉文件末尾的换行符。也可以不用curl，而是通过Postman软件来进行API的调用测试。</li>
</ul>
</blockquote>
<p>云端返回结果：</p>
<pre><code>&#123;&quot;bulkOpsRequestId&quot;:&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;&#125;
</code></pre>
<p>如果是一次真实的批量注册，这个bulkOpsRequestId需要记录下来，用于调用<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest">FetchBulkOpsRequest</a> API。这个API的作用是用来检查自己批量注册的进度。但是本次是一次模拟，只注册了一个设备，所以不用关心。</p>
<blockquote>
<p>FetchBulkOpsRequest使用方法：</p>
<p>url的最后是上面获取的bulkOpsRequestId</p>
<pre><code class="bash">curl --request GET \
--url https://api.nrfcloud.com/v1/bulk-ops-requests/01GK0NECJPXVNDNKVA4XE98HDE \
-H &quot;Authorization: Bearer 3c967ecbd9fxxxxxxxxxxxxxx3cf37049983&quot;
</code></pre>
<p>返回结果：</p>
<pre><code class="json">&#123;
    &quot;bulkOpsRequestId&quot;:&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;,
    &quot;status&quot;:&quot;SUCCEEDED&quot;,
    &quot;endpoint&quot;:&quot;PROVISION_DEVICES&quot;,
    &quot;requestedAt&quot;:&quot;2022-11-29T03:03:48.054Z&quot;,   // 这个时间应该是GMT+1的时间
    &quot;completedAt&quot;:&quot;2022-11-29T03:03:51.365Z&quot;,
    &quot;uploadedDataUrl&quot;:&quot;https://bulk-ops-requests.nrfcloud.com/a9d25242-adad-479e-b526-xxxxxxxxxxxx/provision_devices/01GK0NECJPXVNDNKVA4XE98HDE.csv&quot;
&#125;
</code></pre>
</blockquote>
<p>利用<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice">FetchDevice</a>接口来获取新注册的这个设备的信息：</p>
<p>其中<code>&#123;device-id&#125;</code>要换成UUID</p>
<pre><code class="bash">$ curl --request GET \
--url https://api.nrfcloud.com/v1/devices/&#123;device-id&#125; \
--header &#39;Authorization: Bearer 3c967ecbxxxxxxxxxxxxe81cfa73cf37049983&#39;
</code></pre>
<p>返回结果：</p>
<pre><code class="json">&#123;
    &quot;id&quot;:&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;,
    &quot;tags&quot;:[
        &quot;jayant-DK&quot;
    ],
    &quot;tenantId&quot;:&quot;a9d25242-adad-479e-b526-xxxxxxxxxxx&quot;,
    &quot;$meta&quot;:&#123;
        &quot;createdAt&quot;:&quot;2022-11-29T03:03:53.127Z&quot;
    &#125;,
    &quot;name&quot;:&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;,
    &quot;type&quot;:&quot;Generic&quot;,
    &quot;subType&quot;:&quot;fake-device&quot;,
    &quot;firmware&quot;:&#123;
        &quot;supports&quot;:[
            &quot;APP&quot;,
            &quot;MODEM&quot;
        ]
    &#125;,
    &quot;state&quot;:&#123;
        &quot;desired&quot;:&#123;
            &quot;nrfcloud_mqtt_topic_prefix&quot;:&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/&quot;,
            &quot;pairing&quot;:&#123;
                &quot;state&quot;:&quot;paired&quot;,
                &quot;topics&quot;:&#123;
                    &quot;d2c&quot;:&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/d2c&quot;,
                    &quot;c2d&quot;:&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/+/r&quot;
                &#125;
            &#125;
        &#125;,
        &quot;version&quot;:3,
        &quot;metadata&quot;:&#123;
            &quot;desired&quot;:&#123;
                &quot;nrfcloud_mqtt_topic_prefix&quot;:&#123;
                    &quot;timestamp&quot;:1669691031
                &#125;,
                &quot;pairing&quot;:&#123;
                    &quot;state&quot;:&#123;
                        &quot;timestamp&quot;:1669691031
                    &#125;,
                    &quot;topics&quot;:&#123;
                        &quot;d2c&quot;:&#123;
                            &quot;timestamp&quot;:1669691031
                        &#125;,
                        &quot;c2d&quot;:&#123;
                            &quot;timestamp&quot;:1669691031
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看到里面包含设备的信息，除了之前自己在CSV表格中填写的信息外，还包括MQTT的topic、时间戳等信息。</p>
<p>设备注册成功后，在网页端也已经可以看到这个虚拟的设备：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124154802151.png" alt="image-20221124154802151"></p>
<p><strong>（4）生成JWT</strong></p>
<p><strong>设备到云</strong>（D2C）的API调用需要JWT认证，我们先生成一个JWT：</p>
<p>打开<a target="_blank" rel="noopener" href="https://jwt.io/"> jwt.io</a>，上方选择ES256签名算法，然后PAYLOAD中填入：</p>
<pre><code class="json">&#123;
    &quot;sub&quot;: &quot;你的UUID&quot;
&#125;
</code></pre>
<p>下方公钥、私钥区域粘贴上一小节中生成的设备证书的公钥（pub.pem）和私钥（\prv.pem）的内容。</p>
<p>（注意，不是CA证书，而是设备证书）</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114051110.png" alt="image-20221129114051110"></p>
<p>左下角显示”Signature Verified”，则说明公钥与私钥是成对的。可以把左侧编码好的JWT复制出来，这就是设备与云端通信所需要的 Token：</p>
<pre><code>eyJhbGciOiJFUzI1Nixxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxx78F5NXw
</code></pre>
<p><strong>（5）测试一个设备API接口</strong></p>
<p>我们利用<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/GetAssistanceData">GetAssistanceData</a>来测试接口，在官方API文档页面，我们可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130102929376.png" alt="image-20221130102929376"></p>
<ul>
<li>展示了URL、参数</li>
<li>有两种请求方式，Basci Request和 Cuscom Request，后者需要携带更多参数</li>
<li>提供了<code>curl</code>命令示例，如何携带参数</li>
<li>展示了认证方式，有 API Key 和 JWT两种，展开有详细说明</li>
</ul>
<p>下方是一个Custom Request的调用示例，与API文档中的例子不同，没有使用<code>-d</code>选项，这里是直接把参数写在了URL中：</p>
<pre><code class="bash">$ curl --request GET \
  --url &#39;https://api.nrfcloud.com/v1/location/agps?requestType=custom&amp;customTypes=1%2C3%2C4%2C6%2C7%2C8%2C9&amp;mcc=310&amp;mnc=410&amp;tac=36874&amp;eci=84485647&#39; \
  --header &#39;Accept: application/octet-stream&#39; \
  --header &#39;Authorization: Bearer eyJhbGciOiJFUzI1Nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxm6Hx78F5NXw&#39; \
  --header &#39;range: bytes=0-500&#39;
</code></pre>
<p>请求已经成功返回，但是返回的数据是二进制内容，curl提示我们它不会展示二进制内容，以免打乱终端文字。</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114408304.png" alt="image-20221129114408304"></p>
<p>也可以用Postman软件进行测试，结果是一样的，返回206，说明数据请求成功：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114544096.png" alt="image-20221129114544096"></p>
<p><strong>（6）总结：</strong></p>
<p>本小节展示了<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices">ProvisionDevices</a>，<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest">FetchBulkOpsRequest</a>，<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice">FetchDevice</a>，<a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/GetAssistanceData">GetAssistanceData</a>这5个REST接口的调用。大多数接口都是云到云的，需要用户的APP key来进行认证。最后一个接口展示了设备到云的REST接口调用，需要使用JWT来进行认证。</p>
<h2 id="6-2-MQTT-API"><a href="#6-2-MQTT-API" class="headerlink" title="6.2. MQTT API"></a>6.2. MQTT API</h2><p>nRF Cloud是部署在亚马逊AWS上的，并且使用<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-gs.html">AWS IoT Core</a>的MQTT broker。</p>
<p>MQTT API的通信，只要订阅topic即可。这里需要有2个topic，<code>d2c</code>和<code>c2d</code>。</p>
<ul>
<li><code>d2c</code>：设备发布，云端订阅</li>
<li><code>c2d</code>：云端发布，设备订阅</li>
</ul>
<p>只要每个设备能获得这两个topic，就能与云端进行通信。这个topic可以通过REST API获得，下一小节会介绍。但是实际开发应用的时候，并不需要关心，因为nRF Cloud Library已经帮我们封装好了，我们只需调用<code>connect()</code>，<code>send()</code>之类的就好了。</p>
<h3 id="MQTT-topic前缀的获取"><a href="#MQTT-topic前缀的获取" class="headerlink" title="MQTT topic前缀的获取"></a>MQTT topic前缀的获取</h3><p>用户可以通过REST API获取topic前缀，接口是 <a target="_blank" rel="noopener" href="https://api.nrfcloud.com/v1/#operation/FetchAccountInfo">FetchAccountInfo</a>。需要使用用户的API Key进行认证。接口会返回很多数据，其中就包含：</p>
<pre><code class="json">&#123;
    &quot;mqttEndpoint&quot;: &quot;mqtt.nrfcloud.com&quot;,
    &quot;mqttTopicPrefix&quot;: &quot;prod/a5592ec1-18ae-4d9d-bc44-xxxxxxxxx/&quot;
&#125;
</code></pre>
<p>不用REST API，也可以在网页端获取。点击右上角下拉菜单-Teams：</p>
<p><img src="https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130132356346.png" alt="image-20221130132356346"></p>
<p>可以看到Team的信息，其中就有team id。<code>mqttTopicPrefix</code>就是<code>prod/&lt;team_id&gt;</code>。</p>
<h3 id="云端的认证"><a href="#云端的认证" class="headerlink" title="云端的认证"></a>云端的认证</h3><p>所有到AWS IoT MQTT broker的连接都必须使用在8883端口上进行的Mutual TLS。所有用MQTT的设备都必须有一个<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/Devices/Security/Security/#authentication">X.509 device certificate</a>，并且已经<strong>注册到云端（Provisioned）</strong>。这正是我们在[3.5](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))和[6.1](#REST API 调用示例 )中已经介绍过的部分。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>nRF Cloud部署在AWS上，除了<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html">AWS保留的topic</a>外，还有一些是nRF Cloud自定义的。官方文档请参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/APIs/MQTT/Topics/">nRF Cloud MQTT topics | nRF Cloud Docs</a></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>有关nRF Cloud Library底层的细节，官方文档为 <a target="_blank" rel="noopener" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>
<p>在[5.3.4](#5.3.4. 数据传输相关代码)中，我们知道9160是通过Cloud Wrapper API包装了nRF Cloud Library相关的接口进行的。其中发送到云端就是<code>cloud_wrap_batch_send()</code>：</p>
<pre><code class="c">int cloud_wrap_batch_send(char *buf, size_t len, bool ack, uint32_t id)
&#123;
    int err;
    struct nrf_cloud_tx_data msg = &#123;
        .data.ptr = buf,
        .data.len = len,
        .id = id,
        .qos = ack ? MQTT_QOS_1_AT_LEAST_ONCE : MQTT_QOS_0_AT_MOST_ONCE,
        .topic_type = NRF_CLOUD_TOPIC_BULK,
    &#125;;

    err = nrf_cloud_send(&amp;msg);
    if (err) &#123;
        LOG_ERR(&quot;nrf_cloud_send, error: %d&quot;, err);
        return err;
    &#125;

    return 0;
&#125;
</code></pre>
<p>这里面，准备好要发送的数据<code>msg</code>即可，数据类型是<code>nrf_cloud_tx_data_msg</code>。Topic是<code>NRF_CLOUD_TOPIC_BULK</code>。</p>
<p>这恰好就是<a target="_blank" rel="noopener" href="https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics">官方MQTT API手册</a>中的topic，作用是发送一组bulk数据。只要仿照wrapper中的格式，就可以写出自己的发送函数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io">Jayant Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/">https://jayant-tang.github.io/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/jayant97.github.io/2022/12/01/hello-world/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/jayant97.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/jayant97.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jayant Tang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/jayant97.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/jayant97.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nRF9160-DK-%E8%BF%9E%E6%8E%A5-nRF-Cloud%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">使用nRF9160-DK 连接 nRF Cloud示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BA%A7%E5%93%81%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">1. 产品简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-nRF-Cloud"><span class="toc-number">2.1.</span> <span class="toc-text">1.1. nRF Cloud</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-nRF9160-SiP"><span class="toc-number">2.2.</span> <span class="toc-text">1.2. nRF9160 SiP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-nRF9160-DK"><span class="toc-number">2.3.</span> <span class="toc-text">1.3. nRF9160 DK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-nRF-Connect-SDK"><span class="toc-number">2.4.</span> <span class="toc-text">1.4. nRF Connect SDK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85NCS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">3.</span> <span class="toc-text">2. 安装NCS开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%80%9A%E8%BF%87%E5%AE%89%E8%A3%85%E5%8C%85%E5%AE%89%E8%A3%85VS-Code%EF%BC%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%92%8C%E6%A1%8C%E9%9D%A2%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.</span> <span class="toc-text">2.1. 通过安装包安装VS Code，命令行工具和桌面工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%89%E8%A3%85%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86%EF%BC%88%E5%B7%A5%E5%85%B7%E9%93%BE%E5%92%8CNCS%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2.2. 安装剩余部分（工具链和NCS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2. 自动安装方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3. 手动安装方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AE%89%E8%A3%85choco"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">（1）安装choco</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8choco%E5%AE%89%E8%A3%85%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">（2）利用choco安装其他工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E8%A3%85GN%E5%B7%A5%E5%85%B7%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">（3）安装GN工具（可选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AE%89%E8%A3%85west"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">（4）安装west</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%AE%89%E8%A3%85NCS"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">（5）安装NCS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%AE%89%E8%A3%85Zephyr-SDK%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="toc-number">3.2.3.6.</span> <span class="toc-text">（6）安装Zephyr SDK工具链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%AE%89%E8%A3%85VS-Code%E6%8F%92%E4%BB%B6"><span class="toc-number">3.2.3.7.</span> <span class="toc-text">（7）安装VS Code插件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E4%BE%8B%E7%A8%8B%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">2.3. 打开一个或多个例程并保存工作区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%90%86%E8%A7%A3VS-Code%E7%9A%84Workspace%EF%BC%88%E5%B7%A5%E4%BD%9C%E5%8C%BA%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">（1）理解VS Code的Workspace（工作区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%90%86%E8%A7%A3nRF-Connect%E7%9A%84workspace"><span class="toc-number">3.3.2.</span> <span class="toc-text">（2）理解nRF Connect的workspace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%B7%A5%E7%A8%8B%E5%B9%B6%E7%94%A8git%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">2.4. 创建一个新工程并用git管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">（1）创建新工程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3Application-Type"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">理解Application Type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84%E6%96%B0%E5%B7%A5%E7%A8%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">（2）使用git管理你的新工程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%BC%96%E8%AF%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">2.5. 编译工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%83%A7%E5%BD%95hex"><span class="toc-number">3.6.</span> <span class="toc-text">2.6. 烧录hex</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5%E5%88%B0nRF-Cloud"><span class="toc-number">4.</span> <span class="toc-text">3. 示例: 使用nRF9160-DK连接到nRF Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87"><span class="toc-number">4.1.</span> <span class="toc-text">3.1. 前期准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%83%A7%E5%BD%95Modem%E5%9B%BA%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">3.2. 烧录Modem固件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E9%85%8D%E7%BD%AE%E3%80%81%E7%BC%96%E8%AF%91%E5%B9%B6%E7%83%A7%E5%BD%95Application%E5%9B%BA%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">3.3. 配置、编译并烧录Application固件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%A5asset-tracker-v2%E4%B8%BA%E6%A8%A1%E6%9D%BF%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">（1）以asset_tracker_v2为模板，创建新工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E6%96%B0%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">（2）为新工程创建编译选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.3.</span> <span class="toc-text">（3）修改配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E7%BC%96%E8%AF%91%EF%BC%8C%E7%83%A7%E5%BD%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">（4）编译，烧录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%81%94%E7%BD%91%E6%B5%8B%E8%AF%95"><span class="toc-number">4.4.</span> <span class="toc-text">3.4. 联网测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%B0%86%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E5%88%B0nRF-Cloud%E4%BA%91%E7%AB%AF-Cloud-Provisioning"><span class="toc-number">4.5.</span> <span class="toc-text">3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JITP%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C"><span class="toc-number">4.5.1.</span> <span class="toc-text">JITP方式注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C"><span class="toc-number">4.5.2.</span> <span class="toc-text">预连接方式注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87"><span class="toc-number">4.5.3.</span> <span class="toc-text">（1）前期准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84nRF-Cloud-Utils%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%B9%B6%E5%AE%89%E8%A3%85%E5%A5%BD%E4%BE%9D%E8%B5%96"><span class="toc-number">4.5.4.</span> <span class="toc-text">（2）获取最新的nRF Cloud Utils工具，并安装好依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6"><span class="toc-number">4.5.5.</span> <span class="toc-text">（3）生成你的自签CA证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6"><span class="toc-number">4.5.6.</span> <span class="toc-text">（4）签发并安装设备证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%8A%8A%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E5%88%B0%E4%BA%91%E7%AB%AF"><span class="toc-number">4.5.7.</span> <span class="toc-text">（5）把设备信息批量注册到云端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%9C%A8%E4%BA%91%E7%AB%AF%E6%9F%A5%E7%9C%8B%E5%88%9A%E5%88%9A%E6%B3%A8%E5%86%8C%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="toc-number">4.5.8.</span> <span class="toc-text">（6）在云端查看刚刚注册的设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BB%8E%E4%BA%91%E7%AB%AF%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87"><span class="toc-number">4.5.9.</span> <span class="toc-text">（7）从云端删除设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-nRF-Cloud-%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">4. nRF Cloud 设备模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">4.1. 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">4.1.1. 设备类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E8%AE%BE%E5%A4%87ID"><span class="toc-number">5.1.2.</span> <span class="toc-text">4.1.2. 设备ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%95%B0%E5%AD%97%E5%AD%AA%E7%94%9F%EF%BC%88Device-Shadow%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">4.1.3. 数字孪生（Device Shadow）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">4.2. 安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.2.1. 身份验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%8E%88%E6%9D%83"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2.2. 授权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%9C%A89160%E4%B8%8A%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.3. 在9160上生成证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-JWT%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.2.4. JWT身份验证示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%88Association%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">4.3. 设备管理（Association）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.3.1. 设备注册方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.3.2.  添加与删除设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E8%AE%BE%E5%A4%87%E7%BB%84"><span class="toc-number">5.3.3.</span> <span class="toc-text">4.3.3. 设备组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%8D%87%E7%BA%A7"><span class="toc-number">5.4.</span> <span class="toc-text">4.4. 设备固件升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%B6%88%E6%81%AF"><span class="toc-number">5.5.</span> <span class="toc-text">4.5. 消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E8%AE%BE%E5%A4%87%E6%B6%88%E6%81%AF"><span class="toc-number">5.5.1.</span> <span class="toc-text">4.5.1. 设备消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%B6%88%E6%81%AF%E6%A1%A5%E6%8E%A5"><span class="toc-number">5.5.2.</span> <span class="toc-text">4.5.2. 消息桥接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Asset-Tracker-v2-%E4%BE%8B%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">5. Asset Tracker v2 例程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%9C%AC%E4%BE%8B%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.1.</span> <span class="toc-text">5.1. 本例程设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Zephyr%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-number">6.2.</span> <span class="toc-text">5.2. Zephyr构建系统简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CMake"><span class="toc-number">6.2.1.</span> <span class="toc-text">CMake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeviceTree"><span class="toc-number">6.2.2.</span> <span class="toc-text">DeviceTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kconfig"><span class="toc-number">6.2.3.</span> <span class="toc-text">Kconfig</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BE%8B%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">5.3. 例程代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1. 工程结构分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-main-c%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2. main.c文件分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E4%BA%91%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E6%A8%A1%E7%BB%84%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.3.3.</span> <span class="toc-text">5.3.3. 云端连接相关模组的代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">6.3.4.</span> <span class="toc-text">5.3.4. 数据传输相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E4%BE%8B%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.5.</span> <span class="toc-text">5.3.5. 例程代码总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-nRF-Cloud-API%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">6. nRF Cloud API介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-REST-API"><span class="toc-number">7.1.</span> <span class="toc-text">6.1. REST API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#REST-API-%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">REST API 认证方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REST-API-%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.1.2.</span> <span class="toc-text">REST API 调用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-MQTT-API"><span class="toc-number">7.2.</span> <span class="toc-text">6.2. MQTT API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MQTT-topic%E5%89%8D%E7%BC%80%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">7.2.1.</span> <span class="toc-text">MQTT topic前缀的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E7%AB%AF%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="toc-number">7.2.2.</span> <span class="toc-text">云端的认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic"><span class="toc-number">7.2.3.</span> <span class="toc-text">Topic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.2.4.</span> <span class="toc-text">代码分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/" title="nRF9160与nRF Cloud应用示例"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/jayant97.github.io/img/404.jpg'" alt="nRF9160与nRF Cloud应用示例"/></a><div class="content"><a class="title" href="/jayant97.github.io/2022/12/01/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF%20Cloud%E7%A4%BA%E4%BE%8B/" title="nRF9160与nRF Cloud应用示例">nRF9160与nRF Cloud应用示例</a><time datetime="2022-12-01T06:49:44.789Z" title="Created 2022-12-01 14:49:44">2022-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/jayant97.github.io/2022/12/01/hello-world/" title="Hello World"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/jayant97.github.io/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/jayant97.github.io/2022/12/01/hello-world/" title="Hello World">Hello World</a><time datetime="2022-12-01T05:09:24.967Z" title="Created 2022-12-01 13:09:24">2022-12-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jayant Tang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/jayant97.github.io/js/utils.js"></script><script src="/jayant97.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>