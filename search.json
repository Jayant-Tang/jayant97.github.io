[{"title":"使用Ubuntu进行WiFi抓包","url":"/jayant97.github.io/2022/12/5dfa479d25f0/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t在之前的文章里，我介绍了如何在Windows中使用NPCAP把无线网卡变为monitor模式，并用Wireshark进行抓包。但是Windows下支持monitor的无线网卡实在是太少了，笔记本自带的PCIE无线网卡更是无法支持。\t</p>\n<p>​\t本文介绍如何在Linux系统下进行WiFi的抓包，并且在本地或者用另一台Windows电脑的Wireshark进行实时分析。</p>\n<p>​\t本文使用的硬件环境：</p>\n<ul>\n<li>Ubuntu笔记本电脑：<ul>\n<li>操作系统：Ubuntu 22.04</li>\n<li>WiFi网卡：Intel(R) Wi-Fi 6E AX211 160MHz （支持WiFi6E）</li>\n<li>有线网口（可选）：WiFi网卡变成monitor模式后，用有线网让Windows电脑远程连接到Ubuntu电脑</li>\n</ul>\n</li>\n<li>路由器：支持wifi6的路由器</li>\n<li>手机：支持wifi6的手机</li>\n<li>Windows笔记本电脑（可选）</li>\n</ul>\n<p>​\t示意图如下，虚线内容是可选的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216162542858.png\" alt=\"image-20221216162542858\"></p>\n<blockquote>\n<p>在linux下查看自己的WiFi网卡是否支持抓包：</p>\n<p><strong>网卡驱动已经安装的情况</strong>：</p>\n<ol>\n<li><p>查看自己电脑上的所有网卡，并查看其驱动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo lshw -C network                                                            </span><br><span class=\"line\">   [sudo] password <span class=\"keyword\">for</span> jayant:</span><br><span class=\"line\">  *-network</span><br><span class=\"line\">       description: Wireless interface</span><br><span class=\"line\">       product: Alder Lake-P PCH CNVi WiFi</span><br><span class=\"line\">       vendor: Intel Corporation</span><br><span class=\"line\">      ...</span><br><span class=\"line\">       logical name: wlp0s20f3mon</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      ...</span><br><span class=\"line\">       configuration: broadcast=<span class=\"built_in\">yes</span> driver=iwlwifi driverversion=5.15.0-56-generic firmware=64.97bbee0a.0 so-a0-gf-a0-64.uc latency=0 <span class=\"built_in\">link</span>=<span class=\"built_in\">yes</span> multicast=<span class=\"built_in\">yes</span> wireless=IEEE 802.11</span><br><span class=\"line\">       resources: iomemory:600-5ff irq:16 memory:601d1cc000-601d1cffff</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>  可以看到 在configuration中，<code>driver=iwlwifi</code>，说明wifi网卡的驱动是<code>iwlwifi</code>。</p>\n<ol start=\"2\">\n<li>在<a href=\"https://wireless.wiki.kernel.org/en/users/drivers\">Linux Wireless</a>网站中搜索这个驱动，可以看到这个驱动是支持monitor模式的，说明可以用来抓包：</li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216232607399.png\" alt=\"image-20221216232607399\"></p>\n<p><strong>网卡驱动未安装的情况</strong></p>\n<ol>\n<li>如果<code>ifconfig</code>和<code>iwconfig</code>看不到无线网卡，则可能是没有驱动</li>\n<li>根据是USB网卡还是PCIE网卡，可以先执行<code>lsusb</code>和<code>lspci</code>来看一下是否能识别到硬件</li>\n<li>如果能识别到硬件，再去google上搜索此款网卡的驱动，并在<a href=\"https://wireless.wiki.kernel.org/en/users/drivers\">Linux Wireless</a>网站上搜索此驱动是否支持Monitor模式。</li>\n</ol>\n</blockquote>\n<h1 id=\"2-在Linux环境下进行抓包\"><a href=\"#2-在Linux环境下进行抓包\" class=\"headerlink\" title=\"2. 在Linux环境下进行抓包\"></a>2. 在Linux环境下进行抓包</h1><p>​\t本节参考的文章：<a href=\"https://www.aneasystone.com/archives/2016/08/wireless-analysis-one-monitoring.html\">实战无线网络分析（篇一）无线监听 - aneasystone’s blog</a></p>\n<h2 id=\"2-1-安装工具\"><a href=\"#2-1-安装工具\" class=\"headerlink\" title=\"2.1. 安装工具\"></a>2.1. 安装工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt install -y wireshark net-tools wireless-tools aircrack-ng</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-无线网卡改为Monitor模式\"><a href=\"#2-2-无线网卡改为Monitor模式\" class=\"headerlink\" title=\"2.2. 无线网卡改为Monitor模式\"></a>2.2. 无线网卡改为Monitor模式</h2><blockquote>\n<p>注意，在Linux系统中，当一个无线网卡被改为Monitor模式后，就无法用来上网了。</p>\n</blockquote>\n<p>​\t查看无线网卡名称：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ iwconfig</span><br><span class=\"line\">lo        no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">wlp0s20f3  IEEE 802.11  ESSID:off/any</span><br><span class=\"line\">          Mode:Managed  Access Point: Not-Associated   Tx-Power=-2147483648 dBm</span><br><span class=\"line\">          Retry short <span class=\"built_in\">limit</span>:7   RTS thr:off   Fragment thr:off</span><br><span class=\"line\">          Power Management:on</span><br><span class=\"line\"></span><br><span class=\"line\">enx000ec6259ae4  no wireless extensions.</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到网卡名称是<code>wlp0s20f3</code></p>\n<p>​\t将网卡改为Monitor模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo airmon-ng start wlp0s20f3        </span><br><span class=\"line\"></span><br><span class=\"line\">PHY    Interface\tDriver\t\tChipset</span><br><span class=\"line\"></span><br><span class=\"line\">phy0    wlp0s20f3\tiwlwifi\t\tIntel Corporation Alder Lake-P PCH CNVi WiFi (rev 01)</span><br><span class=\"line\">        (mac80211 monitor mode vif enabled <span class=\"keyword\">for</span> [phy0]wlp0s20f3 on [phy0]wlp0s20f3mon)</span><br><span class=\"line\">        (mac80211 station mode vif disabled <span class=\"keyword\">for</span> [phy0]wlp0s20f3)</span><br></pre></td></tr></table></figure>\n\n<p>​\t这时使用<code>iwconfig</code>查看，会出现一个新的网卡，<strong>网卡名称也发生了改变</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">~$ iwconfig</span><br><span class=\"line\">lo        no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">enx000ec6259ae4  no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">wlp0s20f3mon  IEEE 802.11  Mode:Monitor  Frequency:2.457 GHz  Tx-Power=-2147483648 dBm</span><br><span class=\"line\">          Retry short <span class=\"built_in\">limit</span>:7   RTS thr:off   Fragment thr:off</span><br></pre></td></tr></table></figure>\n\n<p>可以看到名称变为<code>wlp0s20f3mon</code>，并且Mode变为了Monitor</p>\n<blockquote>\n<p>注意：</p>\n<p>​\t有些教程会让你使用<code>sudo airmon-ng check kill</code>来自动杀死一些会影响Monitor网卡的守护进程，这些进程可能会导致网卡的信道被切换，也可能把网卡切回Managed模式。</p>\n<p>​\t但是这样直接杀死 Network Manager，会导致其他的网卡（比如有线网络）在拔掉后也无法自动连回。目前比较好的解决方法是：使用<code>nmtui</code>命令（NetworkManager的图形菜单），在Edit Connection中，把你要抓包的这张网卡记住的WiFi都改成“不自动连接”，这样你的网卡就不会被Network Manager改回Manged模式了。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223152925995.png\" alt=\"image-20221223152925995\"></p>\n</blockquote>\n<h2 id=\"2-3-在Linux中进行抓包\"><a href=\"#2-3-在Linux中进行抓包\" class=\"headerlink\" title=\"2.3. 在Linux中进行抓包\"></a>2.3. 在Linux中进行抓包</h2><p>首先，以root权限打开Wireshark</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo wireshark</span><br></pre></td></tr></table></figure>\n\n<p>然后，在”Capture –&gt; Options…”窗口中，可以看到<code>wlp0s20f3mon</code>网卡：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216165935706.png\" alt=\"image-20221216165935706\"></p>\n<blockquote>\n<p>注意到Monitor Mode栏并不能打勾，但是没关系，网卡本身已经是Monitor模式了</p>\n</blockquote>\n<p>​\t</p>\n<h2 id=\"2-4-设置要抓包的信道\"><a href=\"#2-4-设置要抓包的信道\" class=\"headerlink\" title=\"2.4. 设置要抓包的信道\"></a>2.4. 设置要抓包的信道</h2><p>​\t本节参考：<a href=\"https://netbeez.net/blog/linux-channel-hopping-wifi-packet-capturing/\">Linux for Network Engineers: How to do channel hopping during WiFi packet capturing | NetBeez</a></p>\n<h3 id=\"2-4-1-信道与带宽介绍\"><a href=\"#2-4-1-信道与带宽介绍\" class=\"headerlink\" title=\"2.4.1. 信道与带宽介绍\"></a>2.4.1. 信道与带宽介绍</h3><p>​\t在Monitor模式下，只能扫描<strong>固定的信道和带宽</strong>。为了能够找到自己想要抓的设备到底在哪个信道进行通信，需要先进行<strong>跳频Channel Hopping）</strong>。跳频时，不可避免的会扫不到一些包，但是等找到自己想要监听的信道之后，再切回固定信道的方式即可。</p>\n<blockquote>\n<p>什么是WiFi的信道和带宽？</p>\n<p>​\t不同版本的WiFi协议，其无线电载波工作在不同的频率上，常见的如2.4 GHz和5 GHz。但这都不是指一个频率的值，而是指一个范围。因为固定频率的波是无法承载信息的，只有能切换频率的波才能承载信息。把这个频率范围分成很多份，就是<strong>信道</strong>，每个信道的频率宽度称为<strong>带宽</strong>。</p>\n<p>例如：2.4 GHz （802.11 b&#x2F;g&#x2F;n）频段分配，共有14个信道</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223160719938.png\" alt=\"image-20221223160719938\"></p>\n<p>​\t如果每个信道的带宽是22MHz，那么2.4G最多只能同时使用三个信道（1，6和11）。14信道是特殊的，大多数国家不允许使用。<br>​\t如果信道带宽是20MHz，那么最多可以同时使用四个信道（1，5，9，13）.</p>\n<p>​\t同理，5GHz频段，信道从5.000GHz（信道0）开始编码，每5MHz一个信道。但FCC开放的频率从5.150GHz开始，故实际使用的信道是从36开始的，频宽20MHz，可用信道每次+4，如36，40，44，48 … 64 。</p>\n<p>​\t每个国家可用的信道，可参考：<a href=\"https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8\">无线局域网信道列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>\n</blockquote>\n<p>​\t</p>\n<p>​\t查看自己无线网卡<strong>支持</strong>的信道：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下命令将输出大量信息</span></span><br><span class=\"line\">$ iw list</span><br><span class=\"line\">Wiphy phy0</span><br><span class=\"line\">        ... </span><br><span class=\"line\">        Available Antennas: TX 0x3 RX 0x3   <span class=\"comment\"># 天线数量</span></span><br><span class=\"line\">        Configured Antennas: TX 0x3 RX 0x3</span><br><span class=\"line\">        Supported interface modes:          <span class=\"comment\"># 网卡支持的模式</span></span><br><span class=\"line\">                 * IBSS</span><br><span class=\"line\">                 * managed</span><br><span class=\"line\">                 * AP</span><br><span class=\"line\">                 * AP/VLAN</span><br><span class=\"line\">                 * monitor   <span class=\"comment\"># 支持 monitor</span></span><br><span class=\"line\">                 * P2P-client</span><br><span class=\"line\">                 * P2P-GO</span><br><span class=\"line\">                 * P2P-device</span><br><span class=\"line\">        Band 1:</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                Frequencies: <span class=\"comment\"># 2.4 GHz 信道，disabled为不可用</span></span><br><span class=\"line\">                        * 2412 MHz [1] (22.0 dBm)</span><br><span class=\"line\">                        * 2417 MHz [2] (22.0 dBm)</span><br><span class=\"line\">                        * 2422 MHz [3] (22.0 dBm)</span><br><span class=\"line\">                        * 2427 MHz [4] (22.0 dBm)</span><br><span class=\"line\">                        * 2432 MHz [5] (22.0 dBm)</span><br><span class=\"line\">                        * 2437 MHz [6] (22.0 dBm)</span><br><span class=\"line\">                        * 2442 MHz [7] (22.0 dBm)</span><br><span class=\"line\">                        * 2447 MHz [8] (22.0 dBm)</span><br><span class=\"line\">                        * 2452 MHz [9] (22.0 dBm)</span><br><span class=\"line\">                        * 2457 MHz [10] (22.0 dBm)</span><br><span class=\"line\">                        * 2462 MHz [11] (22.0 dBm)</span><br><span class=\"line\">                        * 2467 MHz [12] (22.0 dBm)</span><br><span class=\"line\">                        * 2472 MHz [13] (22.0 dBm)</span><br><span class=\"line\">                        * 2484 MHz [14] (disabled)</span><br><span class=\"line\">        Band 2:</span><br><span class=\"line\">               ...</span><br><span class=\"line\">                Frequencies: <span class=\"comment\"># 5 GHz 信道，disabled为不可用</span></span><br><span class=\"line\">                        * 5180 MHz [36] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5200 MHz [40] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5220 MHz [44] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5240 MHz [48] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5260 MHz [52] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5280 MHz [56] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5300 MHz [60] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5320 MHz [64] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5340 MHz [68] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5480 MHz [96] (disabled)</span><br><span class=\"line\">                        * 5500 MHz [100] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5720 MHz [144] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5745 MHz [149] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5765 MHz [153] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5785 MHz [157] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5805 MHz [161] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5825 MHz [165] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5845 MHz [169] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5905 MHz [181] (disabled)</span><br><span class=\"line\">        Band 4:</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                Frequencies:  <span class=\"comment\"># 6 GHz 信道，中国不可用</span></span><br><span class=\"line\">                        * 5955 MHz [1] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 7115 MHz [233] (disabled)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t</p>\n<p>​\t查看无线网卡<strong>当前</strong>的信道和带宽：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ iw wlp0s20f3mon info</span><br><span class=\"line\">Interface wlp0s20f3mon</span><br><span class=\"line\">        ifindex 4</span><br><span class=\"line\">        wdev 0x3</span><br><span class=\"line\">        addr 00:93:37:90:08:3a</span><br><span class=\"line\">        <span class=\"built_in\">type</span> monitor</span><br><span class=\"line\">        wiphy 0</span><br><span class=\"line\">        channel 10 (2457 MHz), width: 20 MHz (no HT), center1: 2457 MHz</span><br><span class=\"line\">        txpower 0.00 dBm</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到，当前使用信道10，带宽20MHz，这与Wireshark中的信息是一致的，说明我们目前只能抓到信道10、带宽20MHz的包：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221217162609725.png\" alt=\"image-20221217162609725\"></p>\n<h3 id=\"2-4-2-修改信道与带宽\"><a href=\"#2-4-2-修改信道与带宽\" class=\"headerlink\" title=\"2.4.2.  修改信道与带宽\"></a>2.4.2.  修改信道与带宽</h3><p>​\t由于Wireshark不提供切换信道的功能。我们只能自己手动切换信道和带宽，以下为设置信道和带宽的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo iw dev wlp0s20f3mon <span class=\"built_in\">set</span> channel 149 80MHz</span><br><span class=\"line\"><span class=\"comment\"># 网卡名：wlp0s20f3mon</span></span><br><span class=\"line\"><span class=\"comment\"># 频道：149</span></span><br><span class=\"line\"><span class=\"comment\"># 带宽：可选的参数有</span></span><br><span class=\"line\"><span class=\"comment\">#     NOHT  : 不使用802.11n，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#     HT20  : 802.11n/ac/ax 20MHz频宽</span></span><br><span class=\"line\"><span class=\"comment\">#     HT40+ : 802.11n/ac/ax 双20MHz，控制信道比扩展信道频率高</span></span><br><span class=\"line\"><span class=\"comment\">#     HT40- : 802.11n/ac/ax 双20MHz，控制信道比扩展信道频率低</span></span><br><span class=\"line\"><span class=\"comment\">#    5MHz  : 5MHz，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#     10MHz : 10MHz，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#    80MHz : 802.11ac/ax</span></span><br><span class=\"line\"><span class=\"comment\">#     160MHz: 802.11ac/ax</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t以上命令，是可以在抓包时<strong>实时</strong>执行的，无需重启Wireshark，可以看到信道立即发生了改变：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221217163934869.png\" alt=\"image-20221217163934869\"></p>\n<h3 id=\"2-4-3-实时跳频\"><a href=\"#2-4-3-实时跳频\" class=\"headerlink\" title=\"2.4.3. 实时跳频\"></a>2.4.3. 实时跳频</h3><p>​\t<strong>信道×带宽</strong>的排列组合选项太多，我们不知道哪些组合是合法的，以及自己的网卡是否支持这些组合。我们需要2个脚本，来自动帮我们完成一些工作：</p>\n<ul>\n<li>配置识别：自动识别出当前网卡哪些<strong>信道</strong>+<strong>带宽</strong>的排列组合是合法的，并记录下来</li>\n<li>自动跳频：在前一个脚本的范围内，无限循环跳频扫描</li>\n</ul>\n<p>第一个脚本，<strong>配置识别</strong>：</p>\n<p><code>test-channels.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Make sure that the wifi adapter below is in Monitor mode.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Wi-Fi Adapter</span></span><br><span class=\"line\">DEFAULT_INTERFACE=<span class=\"string\">&quot;wlp0s20f3mon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_24=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14&quot;</span></span><br><span class=\"line\">channels_50=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">widths=<span class=\"string\">&quot;HT20 HT40+ HT40- 80MHz 160MHz&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">result_2g4=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">result_5g=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">current_user=$(<span class=\"built_in\">whoami</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$current_user</span>&quot;</span> != <span class=\"string\">&quot;root&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;[Error] Please run this script with sudo!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> width <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;widths&#125;</span>;<span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    valid_channels=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels_24&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> iw <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> info | grep <span class=\"string\">&quot;channel <span class=\"variable\">$&#123;channel&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">                valid_channels=<span class=\"string\">&quot;<span class=\"variable\">$&#123;valid_channels&#125;</span>&quot;</span><span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span> &quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">fi</span>    </span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">    result_2g4=<span class=\"string\">&quot;<span class=\"variable\">$&#123;result_2g4&#125;</span>&quot;</span><span class=\"string\">&quot;Width:<span class=\"variable\">$&#123;width&#125;</span>, Valid Channels:<span class=\"variable\">$&#123;valid_channels&#125;</span>\\n&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> width <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;widths&#125;</span>;<span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    valid_channels=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels_50&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> iw <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> info | grep <span class=\"string\">&quot;channel <span class=\"variable\">$&#123;channel&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">                valid_channels=<span class=\"string\">&quot;<span class=\"variable\">$&#123;valid_channels&#125;</span>&quot;</span><span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span> &quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">fi</span>    </span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">    result_5g=<span class=\"string\">&quot;<span class=\"variable\">$&#123;result_5g&#125;</span>&quot;</span><span class=\"string\">&quot;Width:<span class=\"variable\">$&#123;width&#125;</span>, Valid Channels:<span class=\"variable\">$&#123;valid_channels&#125;</span>\\n&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;  &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;===================================================&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2.4G:&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;result_2g4&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5G:&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;result_5g&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>给这个脚本添加执行权限，修改脚本中的网卡名，并用sudo执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> +x ./test-channels.sh</span><br><span class=\"line\">$ sudo ./test-channels.sh</span><br><span class=\"line\">...</span><br><span class=\"line\">===================================================</span><br><span class=\"line\">2.4G:</span><br><span class=\"line\">Width:HT20, Valid Channels:1 2 3 4 5 6 7 8 9 10 11 12 13 </span><br><span class=\"line\">Width:HT40+, Valid Channels:1 2 3 4 5 6 7 8 9 </span><br><span class=\"line\">Width:HT40-, Valid Channels:5 6 7 8 9 10 11 12 13 </span><br><span class=\"line\">Width:80MHz, Valid Channels:</span><br><span class=\"line\">Width:160MHz, Valid Channels:</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">5G:</span><br><span class=\"line\">Width:HT20, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165 </span><br><span class=\"line\">Width:HT40+, Valid Channels:36 44 52 60 100 108 116 124 132 140 149 157 </span><br><span class=\"line\">Width:HT40-, Valid Channels:40 48 56 64 104 112 120 128 136 144 153 161 </span><br><span class=\"line\">Width:80MHz, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 </span><br><span class=\"line\">Width:160MHz, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 </span><br></pre></td></tr></table></figure>\n\n<p>可以看出此脚本列举出了5G、2.4G频段下，各个带宽下支持的扫描信道。</p>\n<p>第二个脚本，<strong>自动跳频</strong>：</p>\n<p>自动跳频的脚本内记录了每种带宽下，网卡可以支持的信道。这些数据来源是前一个脚本的输出结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">DEFAULT_INTERFACE=<span class=\"string\">&quot;wlp0s20f3mon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_2G4_HT20=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9 10 11 12 13&quot;</span></span><br><span class=\"line\">channels_2G4_HT40p=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9&quot;</span></span><br><span class=\"line\">channels_2G4_HT40m=<span class=\"string\">&quot;5 6 7 8 9 10 11 12 13&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_5G_HT20=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165&quot;</span></span><br><span class=\"line\">channels_5G_HT40p=<span class=\"string\">&quot;36 44 52 60 100 108 116 124 132 140 149 157&quot;</span></span><br><span class=\"line\">channels_5G_HT40m=<span class=\"string\">&quot;40 48 56 64 104 112 120 128 136 144 153 161&quot;</span></span><br><span class=\"line\">channels_5G_80MHz=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161&quot;</span></span><br><span class=\"line\">channels_5G_160MHz=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">current_user=$(<span class=\"built_in\">whoami</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$current_user</span>&quot;</span> != <span class=\"string\">&quot;root&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;[Error] Please run this script with sudo!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -n <span class=\"variable\">$1</span> ] </span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"variable\">$1</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"string\">&quot;HT20&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT20</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT20</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;HT40+&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT40p</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT40p</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;HT40-&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT40m</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT40m</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;80MHz&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_5G_80MHz</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;160MHz&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_5G_160MHz</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    *)</span><br><span class=\"line\">        echp <span class=\"string\">&quot;Invalid Bandwidth: <span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;no bandwidth set! i.e. &#x27;sudo channel-hopping.sh HT20&#x27;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">width=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Setting channel <span class=\"variable\">$&#123;channel&#125;</span>, <span class=\"variable\">$&#123;width&#125;</span>&quot;</span></span><br><span class=\"line\">    iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">sleep</span> 0.5</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>给这个脚本添加执行权限，修改脚本中的网卡名，并用sudo执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> +x channel-hopping.sh</span><br><span class=\"line\">$ sudo ./channel-hopping.sh HT20</span><br></pre></td></tr></table></figure>\n\n<p>执行脚本时，指定要使用的带宽，脚本将会每 0.5s 切换一次信道。</p>\n<p>脚本只会循环执行一次，之后你可以手动指定信道和带宽。</p>\n<h3 id=\"2-4-4-过滤器\"><a href=\"#2-4-4-过滤器\" class=\"headerlink\" title=\"2.4.4. 过滤器\"></a>2.4.4. 过滤器</h3><p>跳频时，可以设置过滤器来抓自己设备的包。</p>\n<p><strong>显示过滤器</strong>语法：</p>\n<p><strong>Source Address:</strong> <code>wlan.sa==XX:XX:XX:XX:XX:XX</code><br><strong>Destination Address:</strong> <code>wlan.da==XX:XX:XX:XX:XX:XX</code><br><strong>Receiver Address:</strong>  <code>wlan.ra==XX:XX:XX:XX:XX:XX</code><br><strong>Transmitter Address:</strong>  <code>wlan.ta==XX:XX:XX:XX:XX:XX</code></p>\n<p>例如，可以在手机上查看MAC地址，然后输入到wireshark中</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223155547191.png\" alt=\"image-20221223155547191\"></p>\n<p>可以看到，成功抓到了手机的WiFi6包（802.11ax）</p>\n<h2 id=\"2-5-关闭monitor模式的方法\"><a href=\"#2-5-关闭monitor模式的方法\" class=\"headerlink\" title=\"2.5. 关闭monitor模式的方法\"></a>2.5. 关闭monitor模式的方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo airmon-ng stop wlp0s20f3mon</span><br></pre></td></tr></table></figure>\n\n<p>注意网卡名是变为monitor之后的网卡名。</p>\n<h1 id=\"3-在Windows上远程抓包\"><a href=\"#3-在Windows上远程抓包\" class=\"headerlink\" title=\"3. 在Windows上远程抓包\"></a>3. 在Windows上远程抓包</h1><h2 id=\"3-1-确保Ubuntu上安装了ssh服务\"><a href=\"#3-1-确保Ubuntu上安装了ssh服务\" class=\"headerlink\" title=\"3.1. 确保Ubuntu上安装了ssh服务\"></a>3.1. 确保Ubuntu上安装了ssh服务</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-让用户执行sudo命令不用输入密码\"><a href=\"#3-2-让用户执行sudo命令不用输入密码\" class=\"headerlink\" title=\"3.2. 让用户执行sudo命令不用输入密码\"></a>3.2. 让用户执行sudo命令不用输入密码</h2><p>​\t抓包需要root权限，并且我们用wireshark远程抓包的时候无法输入sudo密码。网上会有两种不太推荐的方法解决问题：</p>\n<ul>\n<li>直接打开root的ssh登陆权限，后续Windows电脑的Wireshark直接通过root登录</li>\n<li>让自己的用户执行sudo时不需要密码</li>\n</ul>\n<p>​\t但是以上两种方法是很不安全的，下面介绍一种通过改sudo配置的方式，让你的linux用户只在执行一些指定的命令的时候不需要输入sudo密码，而其他时候还是要密码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用visudo编辑器，在/etc/sudoers.d/下创建个人的sudo配置</span></span><br><span class=\"line\">sudo visudo </span><br></pre></td></tr></table></figure>\n\n<p>​\t填入以下内容，然后保存：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">jayant ALL=(root)NOPASSWD:/usr/bin/tcpdump</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>释义：</p>\n<pre><code>- jayant：用户名或组名，如果是组名，前面加`%`\n- ALL：主机名，多服务器才有用，这里设置ALL即可\n- (root)：完整写法是(用户名:组名)，这里只写了用户名。这里指jayant可以作为root运行后面的指令。如果只有组名，写`(:组名)`\n- NOPASSWD:/usr/bin/tcpdump ：指定的命令，前面`NOPASSWD:`指不需要密码。这里需要填命令的绝对地址，如果你不知道绝对地址，可以输入`which tcpdump `查看。\n</code></pre>\n<p>其他说明：</p>\n<p>​\t在 <code>/etc/sudoers</code>中，有<code>@include</code>语句包含了<code>/etc/sudoers.d/</code>下的所有文件（文件名不含<code>.</code>和<code>~</code>），所以我们不需要修改<code>/etc/sudoers</code>，而是在<code>/etc/sudoers.d/</code>目录中增加自己的配置文件；</p>\n<p>​\t使用visudo文本编辑器进行编辑，可以在保存时自动提示是否有语法错误。\t</p>\n</blockquote>\n<p>测试一下<code>sudo tcpdump</code>是不是已经不需要输入密码了。</p>\n<h2 id=\"3-3-按照第二节的做法，把网卡设为monitor模式\"><a href=\"#3-3-按照第二节的做法，把网卡设为monitor模式\" class=\"headerlink\" title=\"3.3. 按照第二节的做法，把网卡设为monitor模式\"></a>3.3. 按照第二节的做法，把网卡设为monitor模式</h2><p>​\t请参考第2节的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo airmon-ng check <span class=\"built_in\">kill</span></span><br><span class=\"line\">sudo airmon-ng start &lt;网卡名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-在Windows上安装sshdump\"><a href=\"#3-4-在Windows上安装sshdump\" class=\"headerlink\" title=\"3.4. 在Windows上安装sshdump\"></a>3.4. 在Windows上安装sshdump</h2><p>​\t安装Wireshark时勾选即可</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194013150.png\" alt=\"image-20221216194013150\"></p>\n<h2 id=\"3-5-在Windows上设置Wireshark\"><a href=\"#3-5-在Windows上设置Wireshark\" class=\"headerlink\" title=\"3.5. 在Windows上设置Wireshark\"></a>3.5. 在Windows上设置Wireshark</h2><img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194117135.png\" alt=\"image-20221216194117135\" style=\"zoom: 50%;\" />\n\n<p>设置远程主机地址和ssh端口：</p>\n<img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194137684.png\" alt=\"image-20221216194137684\" style=\"zoom: 50%;\" />\n\n<p>我这里使用密钥登录，也可以使用密码：</p>\n<img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194206105.png\" alt=\"image-20221216194206105\" style=\"zoom:50%;\" />\n\n<p>设置网卡名：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194235505.png\" alt=\"image-20221216194235505\"></p>\n<h2 id=\"3-6-开始抓包\"><a href=\"#3-6-开始抓包\" class=\"headerlink\" title=\"3.6. 开始抓包\"></a>3.6. 开始抓包</h2><p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194816124.png\" alt=\"image-20221216194816124\"></p>\n<p>​\t</p>\n","categories":["网络","WiFi"],"tags":["Linux","Wireshark","WiFi"]},{"title":"nRF9160与nRF Cloud应用示例","url":"/jayant97.github.io/2022/12/175d0fa05ecc/","content":"<h1 id=\"1-产品简介\"><a href=\"#1-产品简介\" class=\"headerlink\" title=\"1. 产品简介\"></a>1. 产品简介</h1><h2 id=\"1-1-nRF-Cloud\"><a href=\"#1-1-nRF-Cloud\" class=\"headerlink\" title=\"1.1. nRF Cloud\"></a>1.1. nRF Cloud</h2><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221204174543482.png\" alt=\"image-20221204174543482\" style=\"zoom: 67%;\" />\n\n<p>​\tnRF Cloud是Nordic Semiconducotr公司在AWS上搭建的IoT平台，提供<strong>设备注册（Cloud Provisioning）</strong>、<strong>OTA升级</strong>、<strong>数据存储</strong>、<strong>位置服务</strong>等业务，所有这些功能都可通过Web界面进行管理。此外还有账号权限控制功能，客户可以为不同的团队配置不同级别的账户管理权限。本文会介绍上述功能的具体使用方法。</p>\n<blockquote>\n<p>​\t除了设备注册、OTA、消息存储等物联网云平台常见的功能外，nRF Cloud的重要卖点是位置服务（Location Service）：</p>\n<ul>\n<li>AGPS&#x2F;PGPS：设备根据附近的基站信息，从Location Service获取当前地区GPS卫星的信息，从而缩小搜星范围，把搜星的几十秒缩短到几秒，极大的节省功耗</li>\n<li>基站定位：根据上传附近的基站id，从云端获取获取当前定位，支持单基站和多基定位</li>\n<li>WiFi定位：根据附近的WiFi SSID获取定位</li>\n</ul>\n</blockquote>\n<p>​\tnRF Cloud为Nordic nRF91系列产品提供了方便快速的上云方式，通过NCS的例程可以很方便的连入nRF Cloud。<strong>当然，非Nordic产品也是可以注册到nRF Cloud的，本文最后就会介绍如何使用随机生成的UUID来注册到nRF Cloud。</strong></p>\n<p>​\tnRF Cloud目前有Devloper，Pro和Enterprise三种收费计划。其中开发者计划（Developer plan）是<strong>完全免费</strong>的，你可以不用任何开发板，只使用PC就能连上云端进行测试。并且开发者计划每月有500条免费的Location Service。</p>\n<p>​\t设备通过nRF Cloud APIs与nRF Cloud进行连接，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221125164136165.png\" alt=\"image-20221125164136165\"></p>\n<p>​\t设备可以直接通过MQTT API或REST API接入到云。nRF Cloud也通过REST API为客户提供了<strong>云-云对接</strong>的接口。</p>\n<p>​\tnRF Cloud的MQTT连接使用X.509证书进行认证和加密。<strong>此证书不必是CA收费签发的证书，可以使用自签证书</strong>。Nordic提供了一套方便的脚本（TypeScript和Python可选）来进行证书的生成、签发、烧录。本文后续会介绍具体步骤。</p>\n<p>​\t要想调用nRF Cloud的REST API，对用户来说，使用常见的API Key进行认证；对IoT设备来说，需要使用JWT进行认证。JWT需要使用前述的X.509证书进行生成，本文后续会介绍IoT设备以及PC端测试JWT生成的方法。</p>\n<blockquote>\n<p>REST API 是通过HTTP请求来调用的</p>\n</blockquote>\n<p>​\t更多有关nRF Cloud的信息，可以参考：</p>\n<ul>\n<li><a href=\"https://docs.nrfcloud.com/\">nRF Cloud | nRF Cloud Docs</a></li>\n</ul>\n<h2 id=\"1-2-nRF9160-SiP\"><a href=\"#1-2-nRF9160-SiP\" class=\"headerlink\" title=\"1.2. nRF9160 SiP\"></a>1.2. nRF9160 SiP</h2><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-SiP-rev2-1016-front-and-back.webp\" alt=\"application\" style=\"zoom: 50%;\" />\n\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122134533863.png\" alt=\"image-20221122134533863\" style=\"zoom: 33%;\" />\n\n<p>​\tnRF9160是一款高集成度的低功耗SiP（System-in-Package），具有完整的LTE-M&#x2F;NB-IoT Modem、射频前端、电源管理系统，还具有一颗Cortex-M33应用处理器，便于开发自定义应用。nRF9160是目前市面上<strong>最紧凑、最完整、功耗最低</strong>的蜂窝物联网解决方案。</p>\n<p>​\tnRF9160内置的调制解调器（Modem）在全球范围内同时支持<strong>LTE-M</strong>和<strong>NB-IoT</strong>，并且支持<strong>eDRX和PSM省电模式</strong>，支持传输层安全（TCP&#x2F;TLS），支持GPS。</p>\n<p>​\tModem固件由Nordic以二进制形式提供，Modem固件可以通过OTA进行升级。</p>\n<blockquote>\n<p>中国大陆地区目前只有NB-IoT覆盖，无LTE-M。</p>\n</blockquote>\n<p>​\tCortex-M33应用处理器具有独享的1 MB Flash，256 KB SRAM和多种外设接口，可以让用户自行开发高效率的应用。</p>\n<p>​\t除了直接在9160上开发以外，也可以把nRF9160当作外挂模组，让外部MCU通过AT指令进行操作，拓展连网能力。在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看并下载AT指令手册。</p>\n<p>​\t在把9160当作外挂模组时，除了3GPP标准AT指令（以<code>AT+</code>开头），以及Nordic自定义的Modem相关指令（以<code>AT%</code>开头）以外。还可以在前述Cortex-M33应用核中烧录<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/applications/serial_lte_modem/README.html\">SLM（Serial LTE modem）</a>例程，这样就可以扩展出大量实用指令（以<code>AT#</code>开头），可以实现Socket、TCP&#x2F;UDP、MQTT、FOTA、DFU、FTP、GNSS、GPIO等实用功能，使得9160作为外挂模组时也能充分发挥其片上资源的作用。</p>\n<p>​\t在安全方面：Arm TrustZone技术可为固件和外设提供安全隔离和保护。使应用可实现Secure Boot、受信任固件升级、受信任的Root等安全需求，且不影响性能。Arm CryptoCell通过加密和安全资源来保护物联网应用程序免受各种攻击威胁。</p>\n<p>​\tnRF9160支持SIM和eSIM。今后随着与虚拟运营商的合作，还将在海内外支持SoftSIM。</p>\n<blockquote>\n<p>SoftSIM无需卡或芯片，SIM的信息直接烧录在9160内部。</p>\n</blockquote>\n<p>​\tnRF91的功耗极低，在PSM休眠时可以做到2.7uA的电流。\t</p>\n<p>​\t更多信息，可参考：</p>\n<ul>\n<li><a href=\"https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/Translated-versions/04_nRF9160-SiP-1.4_SC.pdf?la=en&hash=A1F478B9D8593C70FA143C1CA09C2759C8ED51B6\">nRF9160中文brief - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/nRF9160\">nRF9160 - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_PS_v2.1.pdf\">nRF9160 Product Specifications v2.1.pdf</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/Low-power-cellular-IoT/nRF9160-Certifications\">nRF9160 全球认证信息 - nordicsemi.com</a></li>\n</ul>\n<h2 id=\"1-3-nRF9160-DK-和-PPK-II\"><a href=\"#1-3-nRF9160-DK-和-PPK-II\" class=\"headerlink\" title=\"1.3. nRF9160 DK 和 PPK II\"></a>1.3. nRF9160 DK 和 PPK II</h2><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-DK.webp\" alt=\"nRF9160 DK promo\"></p>\n<p>​\tnRF9160 DK是一款优秀设计的预认证开发套件，带有一颗nRF9160 SiP和一颗nRF52840低功耗蓝牙MCU（用于开发BLE网关产品）。</p>\n<p>​\t板载一个支持多个频段的LTE-M和NB-IoT天线、一个GPS贴片天线和一个2.4G陶瓷天线（用于BLE）。其中LTE和2.4G天线接口提供SWF射频连接端子，便于测量RF信号。所有三款连接器均允许使用外部天线。</p>\n<p>​\t开发板引出了所有GPIO和接口，兼容Arduino Uno Rev3。提供可编程LED(4)、按钮(2)、开关(2)。开发板还具有nano SIM卡插槽（J5）和eSIM贴片焊盘（U20）或eSIM直插接口（P28）。</p>\n<p>板载正版Jlink OB，除可下载、调试板载的nRF9160外，也可对外调试其他产品。</p>\n<blockquote>\n<p>关于nRF 9160DK的更多信息，可参考：</p>\n<ul>\n<li><p><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN#infotabs\">nRF9160 DK - nordicsemi.com</a></p>\n</li>\n<li><p><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_DK_HW_User_Guide_v1.1.0.pdf\">nRF9160 DK HW User Guide v1.1.0.pdf</a></p>\n</li>\n</ul>\n</blockquote>\n<p>​\tNordic所有的开发板都预留了SoC&#x2F;SiP电流测量的接口。9160DK还预留了SIM卡电流测量的接口。电流的测量可以使用PPK II。下图展示了9160 PSM休眠时的电流（灰色窗口内平均电流为2.8uA）：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311124553236.png\" alt=\"image-20230311124553236\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/PPK2_SideView_Transparent.webp\" alt=\"Online Power Profiler\"></p>\n<p>​\tPower Profile Kit II (PPK II) 是一个方便的功耗测量工具，具有<strong>电流表</strong>和**电源(0.8V ~ 5V)**两种模式，且两种模式都可测量电流，范围从低于1uA到1A。PPK II本身通过USB供电（5V 500mA），如果在电源模式需要输出1A，需要插两个USB。</p>\n<p>​\tPPK II还自带8通道逻辑分析仪，便于分析各个阶段的功耗。下图底部为逻辑分析仪通道3的输出，它连接到9160的一个GPIO，用于测量9160连接MQTT服务器进行证书交换的耗时和功耗。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311123832875.png\" alt=\"image-20230311123832875\"></p>\n<blockquote>\n<p>更多有关PPK II的信息，可参考：<a href=\"https://www.nordicsemi.com/Products/Development-hardware/Power-Profiler-Kit-2\">Power Profiler Kit II - nordicsemi.com</a></p>\n</blockquote>\n<h2 id=\"1-4-nRF-Connect-SDK\"><a href=\"#1-4-nRF-Connect-SDK\" class=\"headerlink\" title=\"1.4. nRF Connect SDK\"></a>1.4. nRF Connect SDK</h2><p>​\tnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>\n<p>​\tNordic所有的新产品都将在NCS上进行开发。</p>\n<p>​\tNCS内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统、库和驱动。利用Device Tree和Kconfig进行项目的硬件、软件配置，自动载入驱动程序，自动初始化硬件。使用CMake和Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便。此外，NCS是跨平台的（Windows&#x2F;Linux&#x2F;OSX），支持命令行编译，可以在服务器上实现CI&#x2F;CD。</p>\n<p>​\tNCS提供VS Code插件，实现强大的项目管理、项目构建、调试等功能（支持条件断点、查看寄存器和</p>\n<p>线程堆栈）。</p>\n<p>​\tNCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。</p>\n<p>​\t更多信息可参考：</p>\n<ul>\n<li><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html\">About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n</li>\n</ul>\n<h1 id=\"2-入门-使用nRF9160-DK连接到nRF-Cloud\"><a href=\"#2-入门-使用nRF9160-DK连接到nRF-Cloud\" class=\"headerlink\" title=\"2. 入门: 使用nRF9160-DK连接到nRF Cloud\"></a>2. 入门: 使用nRF9160-DK连接到nRF Cloud</h1><p>​\t本节将会在nRF9160-DK开发板上，烧录<code>nrf/applications/asset_tracker_v2</code>例程。根据国内的网络进行配置，然后把板子连接到nRF Cloud上。</p>\n<h2 id=\"2-1-前期准备\"><a href=\"#2-1-前期准备\" class=\"headerlink\" title=\"2.1. 前期准备\"></a>2.1. 前期准备</h2><h3 id=\"硬件准备\"><a href=\"#硬件准备\" class=\"headerlink\" title=\"硬件准备\"></a>硬件准备</h3><ul>\n<li><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN\">nRF9160 DK开发板（本示例使用的版本：v1.1.0）</a>：其中nRF9160 SiP<strong>不能</strong>是Revision 1版本，必须是Revision 2或更高版本。<br>（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110534824.png\" alt=\"image-20221124110534824\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>micro USB线缆一根</p>\n</li>\n<li><p>中国移动NB-IoT卡(物联网卡)<br>  <img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122191558453.png\" alt=\"image-20221122191558453\"></p>\n<ul>\n<li>将电源开关拨到on，并确保调试开关处于”nRF91”挡位</li>\n<li>插好nano SIM卡，并通过microUSB线连接到电脑</li>\n</ul>\n<blockquote>\n<p>注：DK包装盒内附赠的iBASIS SIM卡为国外运营商产品，国内无法使用。需要另外购买移动NB-IoT物联网卡。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"非硬件准备\"><a href=\"#非硬件准备\" class=\"headerlink\" title=\"非硬件准备\"></a>非硬件准备</h3><ul>\n<li>一台Windows10或以上版本操作系统的电脑，并<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/779143a4bec8/\"><strong>正确安装了NCS开发环境</strong></a>。本次示例使用的NCS版本是v2.2.0。</li>\n<li>免费注册一个 <a href=\"https://nrfcloud.com/#/\">nRF Cloud</a> 账号</li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205005305505.png\" alt=\"image-20221205005305505\" style=\"zoom:50%;\" />\n\n<ul>\n<li>知道如何打开NCS中的例程，并且知道如何编译、烧写。</li>\n</ul>\n<h2 id=\"2-2-烧录Modem固件\"><a href=\"#2-2-烧录Modem固件\" class=\"headerlink\" title=\"2.2. 烧录Modem固件\"></a>2.2. 烧录Modem固件</h2><p>​\tnRF9160的Modem具有独立的固件，这部分固件是Nordic以zip包的形式提供的。</p>\n<ol>\n<li>在官网<a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK/Download#infotabs\">nRF9160 DK - Downloads - nordicsemi.com</a>界面，选中最新的Modem固件版本并下载（必须大于1.3.0）。</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143324324.png\" alt=\"image-20221123143324324\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"2\">\n<li>打开nRF Connect桌面版，找到Programmer工具并打开</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143424410.png\" alt=\"image-20221123143424410\" style=\"zoom: 67%;\" />\n\n\n\n<ol start=\"3\">\n<li>先选择板卡，然后选择固件文件（.zip），最后烧录</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143649354.png\" alt=\"image-20221123143649354\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"4\">\n<li>烧录完毕</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123144339925.png\" alt=\"image-20221123144339925\"></p>\n<h2 id=\"2-3-配置、编译并烧录Application固件\"><a href=\"#2-3-配置、编译并烧录Application固件\" class=\"headerlink\" title=\"2.3. 配置、编译并烧录Application固件\"></a>2.3. 配置、编译并烧录Application固件</h2><h3 id=\"2-3-1-以asset-tracker-v2为模板，创建新工程\"><a href=\"#2-3-1-以asset-tracker-v2为模板，创建新工程\" class=\"headerlink\" title=\"2.3.1. 以asset_tracker_v2为模板，创建新工程\"></a>2.3.1. 以asset_tracker_v2为模板，创建新工程</h3><blockquote>\n<p>asset_tracker_v2是applications目录下的例程。这个目录下的都是商业级例程，基本改一下就能作为产品使用了。</p>\n</blockquote>\n<p>​\t创建新工程相比于打开例程的好处，在我的另一篇文章《安装nRF-Connect-SDK》中已经描述了。</p>\n<p>​\t通过nrf connect插件界面的”Create a new application”来创建新的工程。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145304528.png\" alt=\"image-20221123145304528\"></p>\n<p>从上到下，选项依次为：</p>\n<ul>\n<li>NCS路径</li>\n<li>Zephyer SDK工具链路径</li>\n<li>本项目的存储位置</li>\n<li>选取作为模板的sample例程（NCS中的例程）</li>\n<li>本项目的名称</li>\n</ul>\n<p>​\t关于asset_tracker_v2例程的更多信息，可以参考官方的例程说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<blockquote>\n<p>建议把为这个新创建的初始化为git仓库，便于你记录自己修改了什么。</p>\n<p>记得添加<code>.gitignore</code>文件，并且忽略你的<code>build/</code>文件夹</p>\n</blockquote>\n<h3 id=\"2-3-2-为新工程创建build配置\"><a href=\"#2-3-2-为新工程创建build配置\" class=\"headerlink\" title=\"2.3.2. 为新工程创建build配置\"></a>2.3.2. 为新工程创建build配置</h3><p>板卡选择<code>nrf9160dk_nrf9160_ns</code>，然后Build Configuration即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145942948.png\" alt=\"image-20221123145942948\"></p>\n<h3 id=\"2-3-3-修改配置\"><a href=\"#2-3-3-修改配置\" class=\"headerlink\" title=\"2.3.3. 修改配置\"></a>2.3.3. 修改配置</h3><p>打开工程根目录下的<code>prj.conf</code>文件，进行修改：</p>\n<ol>\n<li>与运营商有关的修改</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 由于使用移动的NB物联网卡，故需要关闭LET-M，使用NB-IoT</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_LTE_M_GPS=n  <span class=\"comment\"># 由y改为n</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y  <span class=\"comment\"># 新增</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NB-IoT对ePCO支持的不好，故使用传统的PCO</span></span><br><span class=\"line\">CONFIG_PDN=y                         <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_PDN_LEGACY_PCO=y              <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>与nRF Cloud连接、注册有关的修改（后面小节会详细说明）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用JWT和UUID的云端注册方式</span></span><br><span class=\"line\">CONFIG_MODEM_JWT=y                              <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y  <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>【备注】<code>prj.conf</code>文件的作用：</p>\n<p>在Zephyer编译系统中，Kconfig管理编译选项、各类功能选项的开关，而devicetree用来管理硬件。编译时，通过CMake和ninja会调用一系列python辅助脚本，把Kconfig和device tree变成c代码和头文件。然后进行编译。更多资料，可参考：<a href=\"https://docs.zephyrproject.org/latest/build/index.html#build-and-configuration-systems\">Build and Configuration Systems — Zephyr Project Documentation</a></p>\n<p>开发时，只需关注Kconfig与device tree如何修改即可。Kconfig中的选项非常多，大多数情况下保持默认即可。Kconfig的默认配置保存在NCS中。</p>\n<p><code>prj.conf</code>的作用，就是为这个工程单独修改部分Kconfig配置。编译时，构建系统会优先使用prj.conf里的配置来覆盖默认的Kconfig配置。这样每个工程都可以单独配置，不会影响到NCS中的默认配置。</p>\n<p><code>prj.conf</code>中的选项都必须是Kconfig中可以找到的。</p>\n<p>在VS Code中通过图形界面修改完Kconfig时，也可以通过”Save to file”按钮，来把修改的部分单独保存到<code>prj.conf</code>中，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123154242926.png\" alt=\"image-20221123154242926\"></p>\n</blockquote>\n<h3 id=\"2-3-4-编译\"><a href=\"#2-3-4-编译\" class=\"headerlink\" title=\"2.3.4. 编译\"></a>2.3.4. 编译</h3><p>使用nRF Connect插件中的Action菜单中的build即可编译</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221205010029256.png\" alt=\"image-20221205010029256\"></p>\n<p>编译成功的结果：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205010439970.png\" alt=\"image-20221205010439970\" style=\"zoom: 50%;\" />\n\n<h3 id=\"2-3-5-烧录\"><a href=\"#2-3-5-烧录\" class=\"headerlink\" title=\"2.3.5. 烧录\"></a>2.3.5. 烧录</h3><p>​\t先把官方的开发板通过USB连接到电脑上，识别到Jlink之后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221123160139273-1670173336700-36.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n<p>​\t也可以通过命令行的形式进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>备注：\t</p>\n<p>​\t这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160245857-1670173336700-37.png\" alt=\"image-20221123160245857\"></p>\n<p>​\t这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。</p>\n<p>​\t全片擦除然后烧录的方式，点击Flash右边的按钮：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160832598-1670173336700-38.png\" alt=\"image-20221123160832598\"></p>\n<p>​\t或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash --force --erase</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"2-4-联网测试\"><a href=\"#2-4-联网测试\" class=\"headerlink\" title=\"2.4. 联网测试\"></a>2.4. 联网测试</h2><p>​\t在nRF Connect桌面版中，打开LTE Link Monitor工具。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123163321689.png\" alt=\"image-20221123163321689\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t然后左上角选择板卡，然后再打开串口。串口共有三个(都是Jlink提供的虚拟串口，在板子上2个连接到9160，1个连接到52840)，其中9160的串口只有一个用于AT Command。</p>\n<p>需要依次尝试，点击“AT”按钮就会从串口发送一行“AT”命令，如果有回复OK，说明这个串口就是AT指令的串口。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173504262.png\" alt=\"image-20221123173504262\"></p>\n<blockquote>\n<p>在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>\n</blockquote>\n<p>​\t左侧的面板显示了联网状态、IP地址、信号强度等信息：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173600818.png\" alt=\"image-20221123173600818\"></p>\n<p>​\t注意，”<strong>Automatic Request</strong>“需要勾选上。勾选以后，在切换串口或者点击“AT+CFUN?”指令时，此软件会自动发送相关AT指令，查询网络状态信息，面板上的信息才会更新。否则面板可能不更新。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173636098.png\" alt=\"image-20221123173636098\"></p>\n<p>​\t即是说，以下状态灯应当全绿，则说明联网成功。但若不是全绿，也不一定是联网失败，可能只是信息没有刷新，参照上一条勾选“<strong>自动请求</strong>”，然后点击“AT+CFUN?”指令再次查询即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173817830.png\" alt=\"image-20221123173817830\"></p>\n<blockquote>\n<p>含义：</p>\n<ul>\n<li>UART：串口状态</li>\n<li>Modem：调制解调器状态</li>\n<li>UICC：SIM卡状态</li>\n<li>LTE：LTE联网状态</li>\n<li>PDN：Packet Data Domain联网状态</li>\n</ul>\n</blockquote>\n<h2 id=\"2-5-将设备注册到nRF-Cloud云端\"><a href=\"#2-5-将设备注册到nRF-Cloud云端\" class=\"headerlink\" title=\"2.5. 将设备注册到nRF Cloud云端\"></a>2.5. 将设备注册到nRF Cloud云端</h2><p>​\tIoT设备是需要注册到云端的，并且通信都需要加密认证，否则任何人开发的设备都能连接到你的云，就不安全了。</p>\n<p>​\t设备注册到云端的过程称为<strong>Cloud Provisioning</strong></p>\n<p>​\t设备注册的流程是：</p>\n<ol>\n<li>首先，要有一个自签CA证书，以及对应的密钥文件；</li>\n<li>需要用自签CA证书+设备的UUID，给每个设备单独签发CA证书，并安装单独的私钥到设备中。</li>\n<li>云端持有证书（公钥），这样设备和云端就可以加密通信了。</li>\n</ol>\n<blockquote>\n<p>什么是非对称加密和CA证书？</p>\n<p>​\tCA证书具有证书文件（内含公钥）和私钥文件两个部分，公钥和私钥是用来做非对称加密的。公钥加密的数据，只能用私钥解密；用私钥加密的数据，只能用公钥解密。</p>\n<p>私钥是自己持有的，而公钥公开给所有想与自己通信的对象。</p>\n<p>假设A要给B发送一段消息M：</p>\n<ol>\n<li>对于这段消息M，发送者A先利用MD5或SHA256等方式生成一个数字摘要D，再用私钥把消息M加密得到密文C。最后把C+D一起发给接收者B。</li>\n<li>B收到消息后，先用公钥解密C得到M’，再对比M’的数据摘要和D是否一致，若一致，则说明数据确实是<strong>公钥的所有者</strong>发出的。于是确信M’就是要接收的消息M。</li>\n</ol>\n<p>但B可能拿到假的公钥，黑客发出假的公钥，就可以冒充A给B发消息。为了避免这种情况发生，公钥需要被<strong>认证</strong>，这就是CA证书。</p>\n<p>​\t一个CA证书文件<code>ca1</code>包含公钥P、签名S、所有者信息（国家、城市、单位名称、邮箱等）。<code>ca1</code>的签名S，是用另一个证书<code>ca2</code>的私钥，对<code>ca1</code>的公钥P进行加密得到的。</p>\n<p>所以利用公开的<code>ca2</code>的公钥对S进行解密，如果和P一致，则说明<code>ca1</code>是合法的。<code>ca1</code>的合法性由<code>ca2</code>证明。</p>\n<p>​\t一个CA证书的安全性由另一个CA证书来证明，这样层层递归下去，形成证书链。而最初的CA证书就是<strong>根证书</strong>。具有颁发<strong>根证书</strong>的资质的机关就是CA（Certificate Authority），也叫“证书授权中心”。CA具有根证书，然后给他信任的其他公司颁发CA证书，这些颁发的CA证书里的签名S就是用根证书的私钥加密的。</p>\n</blockquote>\n<p>​\t目前nRF Cloud有两种注册方式，一种是通过JITP的方式（Just-in-Time Provisioning）,另一种是<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>。</p>\n<h3 id=\"JITP方式注册\"><a href=\"#JITP方式注册\" class=\"headerlink\" title=\"JITP方式注册\"></a>JITP方式注册</h3><p>​\tJITP（Just-in-Time Provisioning）的方式利用开发板背面贴纸上的IMEI和PIN码，在云端控制台<strong>手动</strong>生成一个CA证书，然后下载到电脑，并通过LTE Link Monitor 工具生成<strong>设备证书</strong>，并把设备证书的私钥安装到9160中。这样设备就可以直接连接到云端并注册。这种方式便于快速开发、验证，但不适合量产，本文不详细介绍。图文步骤可参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/ug_nrf9160_gs.html#connecting-to-nrf-cloud\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/ug_nrf9160_gs.html#connecting-to-nrf-cloud</a></p>\n<p>JITP的文档说明为：<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#just-in-time-provisioning\">Updating The nRF Cloud Certificate</a></p>\n<h3 id=\"预连接方式注册\"><a href=\"#预连接方式注册\" class=\"headerlink\" title=\"预连接方式注册\"></a>预连接方式注册</h3><p>​\t<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>，是利用nRF Cloud提供的云端REST接口（接口文档见<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">Provision Devices</a>），进行批量的设备注册。具体步骤为：</p>\n<ol>\n<li>首先电脑上需要一个CA证书（不一定要CA正规机构颁发，可以自己生成）；</li>\n<li>电脑连接到nRF9160 AT串口，通过nRF Cloud Utils脚本（TypeScript 或 python），执行以下步骤：<ul>\n<li>通过串口AT命令，让设备生成UUID，并通过PC上的<strong>自签CA证书</strong>和<strong>UUID</strong>为每一个设备生成X.509<strong>设备证书</strong>和<strong>私钥</strong>。由于X.509私钥是直接在9160内生成的，PC上看不到，从而确保了安全性。</li>\n<li>通过串口烧写AWS根证书到9160 Modem中，这样可以确保nRF9160连接nRF Cloud时可以对服务器进行验证（nRF Cloud 运行在AWS上）。</li>\n<li>把该设备的UUID、X.509证书等信息记录到一个CSV表格文件中。</li>\n</ul>\n</li>\n<li>步骤2可重复最多1000次，信息存入同一个CSV表格。</li>\n<li>通过nRF Cloud的云端REST接口，把CSV表格上传，把这一批设备一次性注册到云端。</li>\n</ol>\n<p>​\t<strong>nRF Cloud提供了一套工具来帮助你快速完成上述三项工作，可以用TypeScript脚本或Python脚本</strong>，这套工具在github上，地址为： <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#create-device-credentials\">utils&#x2F;README.md at master · nRFCloud&#x2F;utils (github.com)</a>。</p>\n<p>​\t下面通过Python脚本进行示例：</p>\n<h3 id=\"（1）前期准备\"><a href=\"#（1）前期准备\" class=\"headerlink\" title=\"（1）前期准备\"></a>（1）前期准备</h3><ul>\n<li><p>确保9160SiP 为Revision 2或更高版本（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110504562.png\" alt=\"image-20221124110504562\" style=\"zoom: 25%;\" />\n</li>\n<li><p>确保已经按照[2.2](#2.2. 烧录Modem固件)的步骤，烧录了1.3.0或更高版本的Modem固件（这些版本才支持新的安全AT指令，如<code>KEYGEN</code>）</p>\n</li>\n<li><p>确保你已经按照[2.3](#2.3. 配置、编译并烧录Application固件)的步骤，修改了Application固件的配置参数，启用了JWT和UUID；</p>\n</li>\n<li><p>已经按照[2.4](#2.4. 联网测试)的步骤，验证了设备可以成功联网；</p>\n</li>\n<li><p>已经 <a href=\"https://nrfcloud.com/#/\">注册了nRF Cloud账号，并登录</a>。</p>\n</li>\n</ul>\n<h3 id=\"（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\"><a href=\"#（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\" class=\"headerlink\" title=\"（2）获取最新的nRF Cloud Utils工具，并安装好依赖\"></a>（2）获取最新的nRF Cloud Utils工具，并安装好依赖</h3><p>​\t在一个无中文、无空格、无特殊字符的路径下，从github拷贝仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/nRFCloud/utils.git</span><br></pre></td></tr></table></figure>\n\n<p>​\t进入modem firmware 1.3+ 子文件夹，然后安装其python依赖包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> utils/python/modem-firmware-1.3+/</span><br><span class=\"line\">$ pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）生成你的自签CA证书\"><a href=\"#（3）生成你的自签CA证书\" class=\"headerlink\" title=\"（3）生成你的自签CA证书\"></a>（3）生成你的自签CA证书</h3><p>​\t复制下方的命令，并把对应参数改成你自己需要的信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python create_ca_cert.py \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn nordic.cn \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-p ./my_ca \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义（部分参数未使用）：</p>\n<ul>\n<li><code>-c</code> ：2字符的国家代码，<code>CN</code>为中国</li>\n<li><code>-st</code>：州或省</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：公司&#x2F;组织</li>\n<li><code>-ou</code>：组织部门</li>\n<li><code>-cn</code>：Common Name</li>\n<li><code>-dv</code>：有效天数</li>\n<li><code>-e</code>：电子邮箱地址</li>\n<li><code>-p</code>：CA证书生成后存储的位置</li>\n<li><code>-f</code>：给生成的三个证书文件的文件名添加前缀（字符串）</li>\n</ul>\n</blockquote>\n<p>​\t生成后，可以看到自己指定的目录下已经有了三个证书文件：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123223024181.png\" alt=\"image-20221123223024181\" style=\"zoom: 67%;\" />\n\n<p>​\t其中，ca是证书，prv是私钥，pub是公钥。</p>\n<blockquote>\n<p>​\tCA证书是我们自己签发的根证书，能让设备和云端的通信被加密即可。这个CA证书本身并不是CA机构签发的正规证书。</p>\n<p>​\t若想查看CA证书的信息，可以随便找一个<a href=\"https://myssl.com/cert_decode.html\">在线CA查看器</a>，把xxx_ca.pem拖进去就可以看到信息了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123224514523.png\" alt=\"image-20221123224514523\" style=\"zoom:80%;\" />\n</blockquote>\n<h3 id=\"（4）签发并安装设备证书\"><a href=\"#（4）签发并安装设备证书\" class=\"headerlink\" title=\"（4）签发并安装设备证书\"></a>（4）签发并安装设备证书</h3><p>​\t需要使用<code>utils/python/modem-firmware-1.3+/</code>目录下的<code>device_credentials_installer.py</code>脚本。</p>\n<p>如果想查看最新的脚本使用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -h</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t此脚本的功能：</p>\n<ol>\n<li>通过电脑串口，给你的设备发送AT指令，生成一个UUID</li>\n<li>这个脚本会调用同一目录下的<code>create_device_credentials.py</code>，让每个设备单独生成X509设备证书和私钥；</li>\n<li>通过电脑串口，读取到UUID和X.509证书，并保存csv表格文件中</li>\n<li>量产时，这个脚本可以重复执行。只需要在每次串口上换一个设备时，就执行一次这个脚本。这个设备就会生成X.509证书，并且设备的信息会记录到2个表格文件中。<strong>最多允许存1000台设备的信息。</strong></li>\n<li>后续可以把这两个表格文件和证书上传到云端，便于批量注册设备。</li>\n</ol>\n<p>​\t在执行这个脚本之前，确保第（2）步中的CA证书都生成好了。</p>\n<p>​\t脚本使用示例如下（windows环境），你需要根据实际情况改变命令的参数配置。</p>\n<p>​\t注意，示例执行脚本时，并未指定串口。因为脚本在windows下会自动检测哪个串口是AT指令串口。注意不要开着LTE Link Monitor等工具占用着串口导致安装失败。如果在linux下操作，请增加<code>--port /dev/ttyS??</code>来指定串口，详情可参考 <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#device-credentials-installer\">Device Credentials Installer</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -d -t <span class=\"string\">&quot;jayant-DK&quot;</span> --ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem --ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem -a --devinfo_append --csv ./jayant_provision.csv --devinfo ./jayant_devinfo.csv --term CRLF</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-d</code>：安装前先从Modem中删除sectag</li>\n<li><code>-t</code>：用于设备分组管理的标签，是一个字符串</li>\n<li><code>-T</code>：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置</li>\n<li><code>--ca</code>：CA证书文件的路径</li>\n<li><code>--ca_key</code>：CA证书私钥的路径(prv)</li>\n<li><code>-a</code>或<code>--append</code>：保存<strong>设备注册信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--devinfo_append </code>：保存<strong>设备信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--csv</code>：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）</li>\n<li><code>--devinfo</code>：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）</li>\n<li><code>--term</code>：AT指令的结束符（<code>NULL</code>,<code>CRLF</code>,<code> CR</code> 或<code>LF</code>）</li>\n<li><code>--port</code>：指定AT指令串口</li>\n</ul>\n</blockquote>\n<p>​\t我只有一块开发板，所以只执行一次。</p>\n<h3 id=\"（5）把设备信息批量注册到云端\"><a href=\"#（5）把设备信息批量注册到云端\" class=\"headerlink\" title=\"（5）把设备信息批量注册到云端\"></a>（5）把设备信息批量注册到云端</h3><p>​\t批量的在nRFCloud上进行设备注册（Cloud Provisioning）。</p>\n<p>​\t首先，在<a href=\"https://nrfcloud.com/#/\">nRF Cloud Portal</a> 登录你的nRF Cloud账号（前面应该已经注册好了）。然后获取nRF Cloud REST API key。</p>\n<p>​\t在右上角点击进入个人账户页面，然后在下面可以看到API key，复制出来即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123234437620.png\" alt=\"image-20221123234437620\"></p>\n<p>​\t接下来继续执行python脚本，进行云端注册（这个脚本底层就是调用了REST API进行注册）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python ./nrf_cloud_provision.py --apikey 3c967ecbd9fxxxxxxxxxxxxxxxxa73cf37049983 --chk --csv ./jayant_provision.csv --devinfo jayant_devinfo.csv --set_mfwv --name_imei --name_pref <span class=\"string\">&quot;my_dk_&quot;</span> --res prov.log</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>--apikey</code>：刚刚复制的API key</li>\n<li><code>--chk</code>：<strong>单个设备的注册才使用</strong>，注册前先检查设备是否存在</li>\n<li><code>--csv</code> ：上一步生成的，存储着<strong>设备注册信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li><code>--devinfo</code> ：上一步生成的，存储着<strong>设备信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li><code>--set_mfwv</code>：把<code>--devinfo</code>中记录的Modem固件版本存储到云端</li>\n<li><code>--name_imei</code>：把<code>--devinfo</code>中记录的IMEI（芯片ID）作为friendly name</li>\n<li><code>--name_pref</code>：给friendly name添加一个前缀字符串</li>\n<li><code>--res</code>：存储注册结果的日志文件</li>\n</ul>\n</blockquote>\n<p>​\t完成后，可以看到成功注册的结果：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235635167.png\" alt=\"image-20221123235635167\"></p>\n<h3 id=\"（6）在云端查看刚刚注册的设备\"><a href=\"#（6）在云端查看刚刚注册的设备\" class=\"headerlink\" title=\"（6）在云端查看刚刚注册的设备\"></a>（6）在云端查看刚刚注册的设备</h3><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235940868.png\" alt=\"image-20221123235940868\"></p>\n<p>​\t可以在Device界面看到设备已经注册成功，设备的名称是“前缀字符串” + “IMEI”的形式。</p>\n<p>​\t但设备还处于Disconnect的状态。这是因为刚才下载私钥时，把设备设为了离线状态，可以通过LTE Link Monitor输入以下AT指令，也可以简单reset一下设备，或者重新通过LTE Link Monitor查看设备的状态。这样设备应该就会变成已连接了:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">AT%XSYSTEMMODE=0,1,0,0 // 选择NB网络</span><br><span class=\"line\">AT+CEREG=5             // 打开调制解调器</span><br><span class=\"line\">AT+CFUN=1              // 开始联网</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000424393.png\" alt=\"image-20221124000424393\"></p>\n<p>​\t点进设备的详情页面，已经可以看到大量的信息（部分资源在墙外，加载不出属于正常现象，需要代理上网）：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000623033.png\" alt=\"image-20221124000623033\"></p>\n<p>​\t可以通过terminal窗口，发送json消息，与设备进行交互。也可以进行OTA升级。</p>\n<p>​\t在本例程中，板子上的LED指示灯也可以展示状态：详见<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#led-indication\">Led indication</a>。这里只列出DK板的行为。</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>nRF9160 DK solid LEDs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LTE connection search</td>\n<td>LED1 blinking</td>\n</tr>\n<tr>\n<td>GNSS fix search</td>\n<td>LED2 blinking</td>\n</tr>\n<tr>\n<td>Cloud association</td>\n<td>LED3 double pulse blinking</td>\n</tr>\n<tr>\n<td>Connecting to cloud</td>\n<td>LED3 triple pulse blinking</td>\n</tr>\n<tr>\n<td>Publishing data</td>\n<td>LED3 blinking</td>\n</tr>\n<tr>\n<td>Active mode</td>\n<td>LED4 blinking</td>\n</tr>\n<tr>\n<td>Passive mode</td>\n<td>LED3 and LED4 blinking</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>All 4 LEDs blinking</td>\n</tr>\n<tr>\n<td>FOTA update</td>\n<td>LED1 and LED2 blinking</td>\n</tr>\n<tr>\n<td>Completion of FOTA update</td>\n<td>LED1 and LED2 static</td>\n</tr>\n</tbody></table>\n<h3 id=\"（7）从云端删除设备\"><a href=\"#（7）从云端删除设备\" class=\"headerlink\" title=\"（7）从云端删除设备\"></a>（7）从云端删除设备</h3><p>​\t如果你想从云端删除设备，可以直接在网页端操作，从右上角齿轮除点击删除即可。也可以用云对云的REST API进行删除，后续章节讲解。</p>\n<h1 id=\"3-Asset-Tracker-v2-例程分析\"><a href=\"#3-Asset-Tracker-v2-例程分析\" class=\"headerlink\" title=\"3. Asset Tracker v2 例程分析\"></a>3. Asset Tracker v2 例程分析</h1><p>​\t例程的官方说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/asset_tracker_v2_description.html\">Application description — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<h2 id=\"3-1-本例程设计原则\"><a href=\"#3-1-本例程设计原则\" class=\"headerlink\" title=\"3.1. 本例程设计原则\"></a>3.1. 本例程设计原则</h2><ul>\n<li>超低功耗</li>\n<li>离线优先：本例程假设大多数情况下是离线的，连接是不可靠的。因此会有数据重发的机制。</li>\n<li>时间戳机制：多时间源的时间戳机制，离线情况也可以计时</li>\n<li>数据打包：多次数据打包，减少数据发送次数；离线时，数据会被存储，等到下次在线时一起发送</li>\n<li>运行时参数修改：支持在运行时修改部分配置参数（例如加速度计灵敏度，或GNSS超时时间）</li>\n</ul>\n<h2 id=\"3-2-例程实现的功能\"><a href=\"#3-2-例程实现的功能\" class=\"headerlink\" title=\"3.2. 例程实现的功能\"></a>3.2. 例程实现的功能</h2><p>​\t本节概览性的介绍此例程的具体功能：</p>\n<h3 id=\"数据搜集\"><a href=\"#数据搜集\" class=\"headerlink\" title=\"数据搜集\"></a>数据搜集</h3><p>​\t本例程会搜集数据，并上传到云端，下表列出会上传的数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n<th>Identifiers</th>\n<th>String identifier for NOD list</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>位置（Location）</td>\n<td>GNSS坐标</td>\n<td>APP_DATA_GNSS</td>\n<td><code>gnss</code></td>\n</tr>\n<tr>\n<td>环境信息（Environmental）</td>\n<td>温度，湿度</td>\n<td>APP_DATA_ENVIRONMENTAL</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>运动信息（Movement）</td>\n<td>加速度</td>\n<td>APP_DATA_MOVEMENT</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>调制解调器（Modem）</td>\n<td>LTE link data, device data</td>\n<td>APP_DATA_MODEM_DYNAMIC, APP_DATA_MODEM_STATIC</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>电池信息（Battery）</td>\n<td>电压</td>\n<td>APP_DATA_BATTERY</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>Neighbor cells</td>\n<td>Neighbor cell measurements</td>\n<td>APP_DATA_NEIGHBOR_CELLS</td>\n<td><code>ncell</code></td>\n</tr>\n</tbody></table>\n<p>​\t此外，还有一些异步数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>按钮（Button）</td>\n<td>按下的按钮的ID</td>\n</tr>\n<tr>\n<td>冲击（Impact）</td>\n<td>冲击的幅度（单位是重力加速度常数G）</td>\n</tr>\n</tbody></table>\n<h3 id=\"实时配置\"><a href=\"#实时配置\" class=\"headerlink\" title=\"实时配置\"></a>实时配置</h3><p>​\t本例程中的一些选项，支持通过云端进行远程实时配置。</p>\n<table>\n<thead>\n<tr>\n<th>实时配置项</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Device Mode</td>\n<td>主动（Active）或被动（Passive）：Active指一直上报，而Passive只在运动时才上报</td>\n<td>Active</td>\n</tr>\n<tr>\n<td>Active: Wait time</td>\n<td>Active模式下，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement resolution</td>\n<td>Passive模式下，设备在移动时，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement timeout</td>\n<td>Passive模式下，不论设备是否移动，每次把数据传送到云端的时间间隔</td>\n<td>3600秒</td>\n</tr>\n<tr>\n<td>GNSS timeout</td>\n<td>数据采样时，获取GNSS定位的超时时间</td>\n<td>30秒</td>\n</tr>\n<tr>\n<td>Accelerometer activity threshold</td>\n<td>设备被判定为移动的加速度阈值</td>\n<td>10  m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity threshold</td>\n<td>设备被判定为精致动的加速度阈值</td>\n<td>5 m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity timeout</td>\n<td>设备被判定为移动的时间阈值，加速度和时间都超过阈值才被判定为移动</td>\n<td>1秒</td>\n</tr>\n<tr>\n<td>No Data List (NOD)</td>\n<td>禁用列表，列表项是Data Type，字符串形式。可以禁用例程上报某一些Data Type的数据</td>\n<td>空</td>\n</tr>\n</tbody></table>\n<p>​\t这些配置可以另外修改，有以下几种方式：</p>\n<ul>\n<li>每次与云端建立连接时，从云端同步</li>\n<li>设备发送更新数据到云端时</li>\n<li>启动后，从flash中另外加载</li>\n</ul>\n<h3 id=\"工作流程图\"><a href=\"#工作流程图\" class=\"headerlink\" title=\"工作流程图\"></a>工作流程图</h3><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206195856563.png\" alt=\"image-20221206195856563\" style=\"zoom: 67%;\" />\n\n<center>\n 主动模式流程图\n</center>\n\n<p>​\t在<strong>主动模式</strong>下，只要超时，例程就会采样新数据，并发送到云端。</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206200043536.png\" alt=\"image-20221206200043536\" style=\"zoom:80%;\" />\n\n<center>\n    被动模式流程图\n</center>\n\n\n\n<p>​\t在<strong>被动模式</strong>下，只有两种情况会触发数据上报：</p>\n<ul>\n<li>检测到运动，并且Resolution定时器超时，默认120s</li>\n<li>未检测到运动，并且 timeout定时器超时，默认3600s</li>\n</ul>\n<h3 id=\"用户接口\"><a href=\"#用户接口\" class=\"headerlink\" title=\"用户接口\"></a>用户接口</h3><table>\n<thead>\n<tr>\n<th>按钮</th>\n<th>Thingy:91 评估板</th>\n<th>nRF9160 DK 开发板</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>给云端发送数据</td>\n<td>给云端发送数据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-</td>\n<td>给云端发送数据；<br />由于nRF9160 DK没有加速度计，故使用此按钮模拟加速度计有运动的情况</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>工作状态</th>\n<th>Thngy:91 LED</th>\n<th>nRF9160 DK LED</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>搜索LTE网络</td>\n<td>黄色闪烁</td>\n<td>LED1 闪烁</td>\n</tr>\n<tr>\n<td>GNSS定位中</td>\n<td>紫色闪烁</td>\n<td>LED2 闪烁</td>\n</tr>\n<tr>\n<td>Cloud association</td>\n<td>白色双闪</td>\n<td>LED3 双闪</td>\n</tr>\n<tr>\n<td>MQTT连接中</td>\n<td>绿灯三闪</td>\n<td>LED3 三闪</td>\n</tr>\n<tr>\n<td>Publish Data</td>\n<td>绿灯闪烁</td>\n<td>LED3 闪烁</td>\n</tr>\n<tr>\n<td>Active Mode</td>\n<td>浅蓝色闪烁</td>\n<td>LED4 闪烁</td>\n</tr>\n<tr>\n<td>Passive Mode</td>\n<td>深蓝色闪烁</td>\n<td>LED3和LED4闪烁</td>\n</tr>\n<tr>\n<td>故障</td>\n<td>红色常亮</td>\n<td>4个灯闪烁</td>\n</tr>\n<tr>\n<td>FOTA升级</td>\n<td>橙色快闪</td>\n<td>LED1 LED2 闪烁</td>\n</tr>\n<tr>\n<td>升级完成</td>\n<td>橙色常亮</td>\n<td>LED1 LED2 常亮</td>\n</tr>\n</tbody></table>\n<h3 id=\"A-GPS与P-GPS\"><a href=\"#A-GPS与P-GPS\" class=\"headerlink\" title=\"A-GPS与P-GPS\"></a>A-GPS与P-GPS</h3><blockquote>\n<p>GNSS简介：</p>\n<ul>\n<li>GNSS：全球卫星导航系统，通过多颗同步卫星对地球进行广播。地面上的设备只要接收到三个卫星的信号，根据<strong>预先获得的卫星轨道数据</strong>和<strong>接收到广播的时间差</strong>就可以计算出在地球上的定位。</li>\n<li>GPS：美国GNSS，每12.5分钟广播一次。</li>\n<li>A-GPS：辅助GPS，适合室外。设备不用等GPS广播，先从附近蜂窝基站获得大概定位。然后从云服务器的AGPS服务下载这个区域的GPS信息。于是可以缩短设备的GNSS模块首次捕获的时间（2~3分钟缩短到几秒）。</li>\n<li>P-GPS：预测GPS。设备可以下载长达2周的预测卫星星历数据，使设备能够准确的知道卫星的轨道位置，而无需每2小时连接到网络。并且还能随时间变化权衡精度的下降。P-GPS也能缩短设备定位所需的时间。</li>\n</ul>\n</blockquote>\n<p>​\tNCS提供nRFCloud <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_agps.html#lib-nrf-cloud-agps\">A-GPS库</a>和<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_pgps.html#lib-nrf-cloud-pgps\">P-GPS库</a>，让设备能直接从nRF Cloud云端获取这些数据。</p>\n<p>​\t如果云端是其他云，如 <a href=\"https://aws.amazon.com/iot-core/\">AWS IoT Core</a>, <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/\">Azure IoT Hub</a>等。则Location Library也支持从外部输入这些数据（在定位需要用到AGPS&#x2F;PGPS时，产生一个回调事件，应用层把自己从其他云获取到的AGPS、PGPS数据传入Location Library即可）。</p>\n<h2 id=\"3-3-例程的工程结构\"><a href=\"#3-3-例程的工程结构\" class=\"headerlink\" title=\"3.3. 例程的工程结构\"></a>3.3. 例程的工程结构</h2><p>​\tZephyer开发最大的特点是<strong>模块化</strong>。在我的另一篇文章<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/2a39e705bff0/\">《理解Zephyr项目的配置与构建系统》</a>中，我介绍了Zephyr和Nordic提供的库都可以看成是一个模块，每个模块有自己的Kconfig配置。</p>\n<p>​\t如果你自己写一个项目，可以把几个<code>.c</code>源文件和<code>.h</code>头文件丢进<code>CMakeList.txt</code>就行，这样比较简单直接。但如果你想开发好几个独立的复杂模块，并让他们搭配起来工作，就一定要学一下Asset Tracker v2这个例程的写法。</p>\n<p>​\t首先看项目根目录下的<code>Kconfig</code>的包含关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Kconfig</span><br><span class=\"line\">|-- Asset Tracker v2</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modules_common</span><br><span class=\"line\">|   |-- src/modules/Kconfig.app_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.cloud_module</span><br><span class=\"line\">|   |-- src/cloud/Kconfig.lwm2m_integration</span><br><span class=\"line\">|   |-- src/modules/Kconfig.data_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.gnss_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modem_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.sensor_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.ui_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.util_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.led_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.debug_module</span><br><span class=\"line\">|   |</span><br><span class=\"line\">|   |-- src/cloud/cloud_codec/Kconfig</span><br><span class=\"line\">|   |-- src/watchdog/Kconfig</span><br><span class=\"line\">|   |-- src/events/Kconfig</span><br><span class=\"line\">|   </span><br><span class=\"line\">|-- Zephyr Kernel  // 操作系统内核的配置</span><br><span class=\"line\">|    |-- Kconfig.zephyr</span><br><span class=\"line\">|</span><br><span class=\"line\">`-- 日志打印等级配置</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到，除了Zephyr操作系统内核外，还包含了src目录下许多的模组，这些模组<strong>不是官方库</strong>。而是Nordic官方为这个例程开发的应用模组。你也可以照葫芦画瓢开发自己的应用模组。</p>\n<p>​\t直接用图形化界面查看，就可以看到Kconfig中的选项了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129154636314.png\" alt=\"image-20221129154636314\" style=\"zoom: 67%;\" />\n\n<blockquote>\n<p>​\t分模块开发，除了更加简洁直观、解耦以外，还有一个巨大的好处，那就是每个模组的Log可以在Kconfig中单独开关。这个例程的项目实在是太复杂了，如果所有模组的log都打开，不论是串口还是RTT都是打不下的。</p>\n</blockquote>\n<p>​\t每个模组都可以有自己的线程、初始化代码、回调函数等。</p>\n<h2 id=\"3-4-模组间的配合方式\"><a href=\"#3-4-模组间的配合方式\" class=\"headerlink\" title=\"3.4. 模组间的配合方式\"></a>3.4. 模组间的配合方式</h2><h3 id=\"程序的调用方式\"><a href=\"#程序的调用方式\" class=\"headerlink\" title=\"程序的调用方式\"></a>程序的调用方式</h3><p>​\t我们知道，不同代码之间互相调用的方式有同步调用和异步调用：</p>\n<ul>\n<li>同步调用就是，直接调用几个函数，等到它们依次返回后，你才做最后的处理，然后返回；</li>\n<li>异步调用就是，先把最后的处理写进回调函数，然后通过函数指针注册给其他模组。调用其他模组的函数时不用阻塞，立刻就能返回。等到其他模组处理完后，执行这个回调函数，就成功把参数传回本模组了。</li>\n</ul>\n<p>​\t以上两种方式，常常发生在我们使用官方库的过程中。我们直接调用官方库中的函数（同步调用），或者把回调函数注册进官方库中（异步调用）。</p>\n<h3 id=\"Application-Event-Manager\"><a href=\"#Application-Event-Manager\" class=\"headerlink\" title=\"Application Event Manager\"></a>Application Event Manager</h3><p>​\t对于我们自己开发的application模组，如果互相之间通信还要调用对方的函数，还要做线程间通信，还要做互斥锁、信号量，那就失去模块化的意义了。</p>\n<p>​\tNordic提供了一个叫做Application Event Manager的库，Nordic许多产品级的复杂例程都用到了它。它提供了一个不同模组之间的通信机制：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205013810750.png\" alt=\"image-20221205013810750\" style=\"zoom: 67%;\" />\n\n<p>​\t每个模组只负责与自己有关的应用和驱动。每个模组可以发布（SUBMIT）事件，也可以订阅（SUBSCRIB）其他模组的事件。想让其他模组做什么事的时候，发布一个事件就好。而只要订阅了其他模组的事件，那么就可以从Application Event Manager中收到这些事件，之后，只要编写好处理这些事件的回调函数即可。</p>\n<p>​\t所有的事件都是从Applicarion Event Manager来的，回调函数是注册给Applicarion Event Manager的，不是注册给其他模组。此外，每个模组只需一个回调函数就可以处理所有其他模组来的时间，不用定义一堆事件入口。</p>\n<p>​\t由此我们可以体会这个设计的方便之处，每个模组都是独立的，只用关心自己的业务即可。</p>\n<h3 id=\"模组的线程\"><a href=\"#模组的线程\" class=\"headerlink\" title=\"模组的线程\"></a>模组的线程</h3><p>​\t一个模组，根据其业务复杂程度的不同（比如有无状态机），可能自带线程，也可能不带线程。Application Event Manager对这两种模组都兼容。</p>\n<ul>\n<li>对于带线程的模组。所有的事件都变成消息，存入消息队列。模组的线程里循环等待消息队列的数据，并根据具体情况处理到来的事件。</li>\n<li>对于不带线程的模组，只需写好事件的回调函数，注册进Application Event Manager即可。</li>\n</ul>\n<blockquote>\n<p>​\t对于不带线程的模组，必须确保回调函数执行较快，否则将会阻塞Application Event Manager。如果没法确保这一点，就必须给模组写一个单独的线程来处理消息。</p>\n</blockquote>\n<p>如下图：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203957763.png\" alt=\"image-20221206203957763\"></p>\n<blockquote>\n<p>​\t\t对于带线程的模组：<br>​\t把Event变成Message，并放入消息队列的工作，都是每个模组自己维护的。Application Event Manager只是提供一个事件回调的接口，各个模组自己通过事件回调函数，把事件放入消息队列。</p>\n</blockquote>\n<h3 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h3><p>​\t模组大多使用静态分配的内存。但是本例程会有一些内容使用动态内存，依赖的是 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/memory_management/heap.html#heap-v2\">Zephyr的堆内存池</a>。以下内容是使用了动态内存的：</p>\n<ul>\n<li>模组之间传输的Event</li>\n<li>即将被发送到云端的数据</li>\n</ul>\n<p>​\t要发送到云的数据是最耗内存的。所以如果要修改data模组的缓冲区大小，别忘了同时也修改堆的大小。</p>\n<blockquote>\n<p>使用<code>CONFIG_HEAP_MEM_POOL_SIZE</code>来配置堆的大小。</p>\n</blockquote>\n<h2 id=\"3-5-例程模组介绍\"><a href=\"#3-5-例程模组介绍\" class=\"headerlink\" title=\"3.5. 例程模组介绍\"></a>3.5. 例程模组介绍</h2><p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203138376.png\" alt=\"image-20221206203138376\"></p>\n<p>​\t如上图，例程中共实现了9个模组。蓝色的是自带线程的，而橙色的是不带线程的。</p>\n<ul>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/app_module.html#asset-tracker-v2-app-module\">Application module</a>：控制何时采集数据、采集什么数据，并且控制整个例程的其他行为</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html#asset-tracker-v2-data-module\">Data module</a>：根据App模块的设定搜集其他模块的数据，存入环形缓冲。并决定何时发送到云端。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/cloud_module.html#asset-tracker-v2-cloud-module\">Cloud module</a>：负责与云端的连接与数据交互</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/sensor_module.html#asset-tracker-v2-sensor-module\">Sensor module</a>：与 <a href=\"thingy:91productpage\">Thingy:91</a>开发板上的传感器交互并获得数据</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/gnss_module.html#asset-tracker-v2-gnss-module\">GNSS module</a>：控制nRF9160的GNSS功能</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#asset-tracker-v2-ui-module\">User Interface module</a>：利用按键和灯提供简易的用户交互接口</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/util_module.html#asset-tracker-v2-util-module\">Utility module</a>：提供对例程进行管理和监控的工具</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/debug_module.html#asset-tracker-v2-debug-module\">Debug module</a>：此模组订阅了所有事件，方便调试，也支持nCS中的Memfault模组。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/modem_module.html#asset-tracker-v2-modem-module\">Modem module</a>：控制LTE连接</li>\n</ul>\n<blockquote>\n<p>要使用debug模组，需要include <code>../overlay-debug.conf</code></p>\n</blockquote>\n<h2 id=\"3-6-例程代码分析\"><a href=\"#3-6-例程代码分析\" class=\"headerlink\" title=\"3.6. 例程代码分析\"></a>3.6. 例程代码分析</h2><p>​\t今后会编写其他文章详解此例程的代码。\t</p>\n<p>​\t要了解更多关于此项目的实现内容，可以参考例程的官方说明，非常详细：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<div style=”page-break-after: always;”></div>\n\n<h1 id=\"4-nRF-Cloud-API介绍\"><a href=\"#4-nRF-Cloud-API介绍\" class=\"headerlink\" title=\"4. nRF Cloud API介绍\"></a>4. nRF Cloud API介绍</h1><p>nRF Cloud 提供 REST 和 MQTT 两种API。</p>\n<ul>\n<li>REST API 用于<strong>用户到云</strong>、<strong>第三方云到云</strong>的连接；其中少部分API也可被设备调用。</li>\n<li>MQTT API用于<strong>设备和云</strong>的连接</li>\n</ul>\n<h2 id=\"4-1-REST-API\"><a href=\"#4-1-REST-API\" class=\"headerlink\" title=\"4.1. REST API\"></a>4.1. REST API</h2><p>nRF Cloud REST API文档，参考：<a href=\"https://api.nrfcloud.com/v1\">nRF Cloud REST API Documentation</a></p>\n<h3 id=\"REST-API-认证方式\"><a href=\"#REST-API-认证方式\" class=\"headerlink\" title=\"REST API 认证方式\"></a>REST API 认证方式</h3><p>​\t在使用REST API时，不管是用户、设备还是第三方云，在调用API时都需要携带一个Token，来证明消息发出源是可信的。不同的API需要使用不同类型的Token。在API文档中会明确说明此API需要哪种方式认证，例如：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311133314758.png\" alt=\"image-20230311133314758\"></p>\n<blockquote>\n<ul>\n<li><strong>Simple Token</strong>：也就是<strong>API KEY</strong>，在2.5小节中已经见过。它的地位与用户的云账号密码是一样的，不能泄露。通常是用来调用一些与<strong>用户</strong>账户、配置、用户业务有关的API，例如列举设备、注册设备、批量拉取Message等</li>\n<li><strong>JSON Web Token（JWT）</strong>：JWT内包含了设备信息（如UUID）和时间戳等。<strong>设备</strong>可以用自己的X.509私钥生成一个JWT。在调用API时，云端会检查这个JWT是否合法（由于设备已经注册到云端，云端保存了此设备的X.509证书，因此云端可以验证JWT是否合法），如果合法，则允许API的调用。</li>\n<li><strong>Service Evaluation Token</strong>：nRF Cloud提供的服务都是需要JWT认证的，而JWT想要认证成功就必须要注册一个设备到云端。如果一个客户只是单纯想快速评估一下服务的效果，不想搞注册设备、生成JWT那一套麻烦事，那么可以申请服务评估令牌（Service Evaluation Token），使用此Token的效果和JWT相同，可在没有注册设备的情况下直接调用相关API。Servic Evaluation Token本身也是通过REST API获取的，使用<a href=\"https://api.nrfcloud.com/v1#tag/Account/operation/GenerateServiceEvaluationToken\">GenerateServiceEvaluationToken</a>和 <a href=\"https://api.nrfcloud.com/v1#tag/Account/operation/GetServiceEvaluationToken\">GetServiceEvaluationToken</a>两个API即可。要注意这个Token只有30天的试用期限，若想要延长，需要联系Nordic销售。</li>\n</ul>\n</blockquote>\n<h3 id=\"REST-API-调用示例\"><a href=\"#REST-API-调用示例\" class=\"headerlink\" title=\"REST API 调用示例\"></a>REST API 调用示例</h3><p>​\t本小节将使用电脑模拟一台<strong>设备</strong>，通过REST接口注册设备，并使用JWT的认证方式，调用一个REST API。</p>\n<p>整个过程分为三个步骤：</p>\n<ul>\n<li>设备注册（Provision）</li>\n<li>检查设备注册的结果</li>\n<li>获取AGPS数据</li>\n</ul>\n<p>官方文档可参考：<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<blockquote>\n<p>​\t整个注册过程和[2.5小节](#2.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))的流程是一模一样的。但是本小节中展示的注册过程没有使用python脚本，而是使用最基本的HTTP请求来展示REST API调用的过程。</p>\n</blockquote>\n<p>​\t在<strong>开始之前</strong>，找一个<a href=\"https://www.uuidgenerator.net/\">在线UUID生成器</a>，生成一个UUID。本例生成的是：<code>64520de4-e0a0-45cf-bf56-1f43f80a4f37</code>，这个UUID就代表一台设备。</p>\n<p>​\t对于实际的产品，UUID可以是任何字符串。但是Nordic推荐使用9160出厂自带的UUID，你可以在前面加上一些前缀。</p>\n<blockquote>\n<p>nRF Cloud 全球所有的客户的所有设备，都通过UUID来进行区分。所以防止UUID重复是非常必要的。</p>\n</blockquote>\n<p><strong>（1）生成CA证书和设备证书</strong></p>\n<p>​\t在 <a href=\"#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6\">2.5-(3)</a> 小节中，我们已经通过 Nordic 提供的 python 脚本生成了一套 CA证书文件和私钥。这套utils工具中也包含一套TypeScript脚本，和pythone脚本的功能是一样的。你也可以两种都不使用，而只使用OpenSSL进行生成，可参考<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<p>​\t后面在<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">2.5-(4)</a>中，我们通过这个<strong>CA证书</strong>给nRF9160签发了<strong>设备证书</strong>，给设备安装了设备独立的私钥。</p>\n<p>​\t现在，我们要用电脑模拟一台设备，所以，就需要通过刚刚生成的UUID和<strong>CA证书</strong>，来生成一个<strong>新的设备证书</strong>。</p>\n<p>​\t进入 [2.5-(2)](#（2）获取最新的nRF Cloud Utils工具，并安装好依赖) 中安装utils的文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在终端中进入utils文件夹后，再进行后续操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入python工具文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> python/modem-firmware-1.3+/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成设备证书</span></span><br><span class=\"line\">$ python create_device_credentials.py \\</span><br><span class=\"line\">-ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem \\</span><br><span class=\"line\">-ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn 64520de4-e0a0-45cf-bf56-1f43f80a4f37 \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-dv 2000 \\</span><br><span class=\"line\">-p ./dev_credentials \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-Device-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-ca</code>：CA证书文件</li>\n<li><code>-ca_key</code>：CA证书密钥文件</li>\n<li><code>-c</code>：2字符国家代码</li>\n<li><code>-st</code>：美国、加拿大的州或省代码</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：组织</li>\n<li><code>-o</code>u：组织部门</li>\n<li><code>-cn</code>：Common Name。使用nRF CLoud Device ID 或者 MQTT Client ID。这里使用UUID。</li>\n<li><code>-e</code>：e-mail</li>\n<li><code>-dv</code>：证书合法天数</li>\n<li><code>-p</code>：用于生成设备证书的目录</li>\n<li><code>-f</code>：生成的证书文件名前缀</li>\n</ul>\n</blockquote>\n<p><strong>（2）生成设备注册信息表格</strong></p>\n<p>​\t本小节参考 <a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">REST 设备注册API （ProvisionDevices）</a>。</p>\n<p>​\t打开Excel，创建一个新的空表格，并另存为csv格式。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150045752.png\" alt=\"image-20221124150045752\" style=\"zoom: 80%;\" />\n\n<p>​\t在表格中从左往右填入以下内容：</p>\n<ul>\n<li><p>第一列：设备ID，这里是UUID</p>\n</li>\n<li><p>第二列：设备子类型，可以写温湿度传感器之类的文字，可以留空；</p>\n</li>\n<li><p>第三列：用于设备分类的标签，这里填<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">3.5-(4)</a>中nRF9160一样的tag名称就行，也可以留空</p>\n</li>\n<li><p>第四列：固件类型，可以和9160例程填一样的，也可以留空</p>\n</li>\n<li><p>第五列：设备证书。从上一小节的设备证书中，把<code>xxxx_crt.pem</code>中的内容拷贝进去即可</p>\n<p>（注意，excel单元格类型要设置成“文本”，否则可能把等号、加号识别为公式）</p>\n</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150540606.png\" alt=\"image-20221124150540606\"></p>\n<p>​\t保存csv表格，此处给出我的csv文件内容，方便对比格式是否正确：</p>\n<p><code>fake-device.csv</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">64520de4-e0a0-45cf-bf56-1f43f80a4f37,fake-device,jayant-DK,APP|MODEM,&quot;-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">MIICPTCCAeICFHx8JF+NRorZfBQF0sr+jzKSmg9gMAoGCCqGSM49BAMCMIGSMQsw</span><br><span class=\"line\">CQYDVQQGEwJDTjERMA8GA1UEBwwIU2hhbmdoYWkxIjAgBgNVBAoMGU5vcmRpYyBT</span><br><span class=\"line\">ZW1pY29uZHVjdG9yIEsuSy4xDjAMBgNVBAsMBVNhbGVzMRIwEAYDVQQDDAlub3Jk</span><br><span class=\"line\">aWMuY24xKDAmBgkqhkiG9w0BCQEWGWpheWFudC50YW5nQG5vcmRpY3NlbWkubm8w</span><br><span class=\"line\">HhcNMjIxMTI0MDY1MjEwWhcNMjgwNTE2MDY1MjEwWjCBrTELMAkGA1UEBhMCQ04x</span><br><span class=\"line\">ETAPBgNVBAcMCFNoYW5naGFpMSIwIAYDVQQKDBlOb3JkaWMgU2VtaWNvbmR1Y3Rv</span><br><span class=\"line\">ciBLLksuMQ4wDAYDVQQLDAVTYWxlczEtMCsGA1UEAwwkNjQ1MjBkZTQtZTBhMC00</span><br><span class=\"line\">NWNmLWJmNTYtMWY0M2Y4MGE0ZjM3MSgwJgYJKoZIhvcNAQkBFhlqYXlhbnQudGFu</span><br><span class=\"line\">Z0Bub3JkaWNzZW1pLm5vMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6OIeO6C0</span><br><span class=\"line\">/kJzfaWUHt/Xg4J6bdAphzmX5sCLGV+oEeSi1sUQKpBLugda2OwG9FxOCikg8ih7</span><br><span class=\"line\">CvMm7C98+fr+nTAKBggqhkjOPQQDAgNJADBGAiEAuCdq6D1K329hwU9e+4S5//2b</span><br><span class=\"line\">upwtaqT+j6Mckpmj6XUCIQCaAqjWRMXMiOd/pXRkcf7SjKyZifBnxoepRqbNyKUG</span><br><span class=\"line\">OA==</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br><span class=\"line\">&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​\t注意，这个表格是作为REST API的参数传入的，而云端会通过正则表达式来检查内容是否合法，有时多一个少一个回车、空格都不行，正则表达式可参考<a href=\"https://api.nrfcloud.com/v1#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>的API说明：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311135339410.png\" alt=\"image-20230311135339410\"></p>\n</blockquote>\n<p><strong>（3）利用REST接口注册设备</strong></p>\n<p>​\t使用<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>接口。这属于<strong>用户到云</strong>的接口调用，需要使用<strong>API key</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向nRF Cloud发送请求，注册设备。</span></span><br><span class=\"line\">$  curl --request POST --url https://api.nrfcloud.com/v1/devices \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbd9f3cxxxxxxxxxxfa73cf37049983&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;content-type: text/csv&#x27;</span> \\</span><br><span class=\"line\">--data-binary @./fake-device.csv</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>把API Key改成你自己的API Key</li>\n<li>用curl发送csv文件时，必须使用二进制流。否则curl可能会丢掉文件末尾的换行符。也可以不用curl，而是通过Postman软件来进行API的调用测试。</li>\n</ul>\n</blockquote>\n<p>​\t云端返回结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;bulkOpsRequestId&quot;:&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t假如这是一次真实的批量注册，这个bulkOpsRequestId需要记录下来，用于调用<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a> API。这个API的作用是用来检查自己批量注册的进度。但是本次是一次模拟，只注册了一个设备，所以很快就能注册完成。</p>\n<blockquote>\n<p>FetchBulkOpsRequest使用方法：</p>\n<p>url的最后是上面获取的bulkOpsRequestId</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/bulk-ops-requests/01GK0NECJPXVNDNKVA4XE98HDE \\</span><br><span class=\"line\">-H <span class=\"string\">&quot;Authorization: Bearer 3c967ecbd9fxxxxxxxxxxxxxx3cf37049983&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bulkOpsRequestId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;status&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;SUCCEEDED&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;PROVISION_DEVICES&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;requestedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:48.054Z&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 这个时间应该是GMT+1的时间</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;completedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:51.365Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;uploadedDataUrl&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;https://bulk-ops-requests.nrfcloud.com/a9d25242-adad-479e-b526-xxxxxxxxxxxx/provision_devices/01GK0NECJPXVNDNKVA4XE98HDE.csv&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\t利用<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>接口来获取新注册的这个设备的信息，其中<code>&#123;device-id&#125;</code>要换成UUID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/devices/&#123;device-id&#125; \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbxxxxxxxxxxxxe81cfa73cf37049983&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tags&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"string\">&quot;jayant-DK&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tenantId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a9d25242-adad-479e-b526-xxxxxxxxxxx&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$meta&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;createdAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:53.127Z&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Generic&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;subType&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;fake-device&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;firmware&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;supports&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;APP&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;MODEM&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;paired&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/d2c&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/+/r&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;metadata&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到里面包含设备的信息，除了之前自己在CSV表格中填写的信息外，还包括MQTT的topic、时间戳等信息。</p>\n<p>​\t设备注册成功后，在网页端也已经可以看到这个模拟的设备：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124154802151.png\" alt=\"image-20221124154802151\"></p>\n<p><strong>（4）生成JWT</strong></p>\n<p><strong>设备到云</strong>（D2C）的API调用需要JWT认证，我们先生成一个JWT：</p>\n<p>打开<a href=\"https://jwt.io/\"> jwt.io</a>，上方选择ES256签名算法，然后PAYLOAD中填入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;sub&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;你的UUID&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下方公钥、私钥区域粘贴上一小节中生成的设备证书的公钥（_pub.pem）和私钥（_prv.pem）的内容。</p>\n<p>（注意，不是CA证书，而是设备证书）</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114051110.png\" alt=\"image-20221129114051110\"></p>\n<p>左下角显示”Signature Verified”，则说明公钥与私钥是成对的。可以把左侧编码好的JWT复制出来，这就是设备与云端通信所需要的 Token：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJFUzI1Nixxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxx78F5NXw</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>（5）测试一个设备API接口</strong></p>\n<p>​\t我们利用<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>来测试接口，在官方API文档页面，我们可以看到：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130102929376.png\" alt=\"image-20221130102929376\"></p>\n<ul>\n<li>展示了URL、参数</li>\n<li>有两种请求方式，Basci Request和 Cuscom Request，后者需要携带更多参数</li>\n<li>提供了<code>curl</code>命令示例，如何携带参数</li>\n<li>展示了认证方式，有 API Key 和 JWT两种，展开有详细说明</li>\n</ul>\n<p>​\t下方是一个Custom Request的调用示例，与API文档中的例子不同，没有使用<code>-d</code>选项，这里是直接把参数写在了URL中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">  --url <span class=\"string\">&#x27;https://api.nrfcloud.com/v1/location/agps?requestType=custom&amp;customTypes=1%2C3%2C4%2C6%2C7%2C8%2C9&amp;mcc=310&amp;mnc=410&amp;tac=36874&amp;eci=84485647&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Accept: application/octet-stream&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Authorization: Bearer eyJhbGciOiJFUzI1Nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxm6Hx78F5NXw&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;range: bytes=0-500&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t请求已经成功返回，但是返回的数据是二进制内容，curl提示我们它不会展示二进制内容，以免打乱终端文字。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114408304.png\" alt=\"image-20221129114408304\"></p>\n<p>​\t也可以用Postman软件进行测试，结果是一样的，返回206，说明数据请求成功：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114544096.png\" alt=\"image-20221129114544096\"></p>\n<p><strong>（6）总结：</strong></p>\n<p>​\t本小节展示了<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a>，<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>这5个REST接口的调用。大多数接口都是云到云的，需要用户的APP key来进行认证。最后一个接口展示了设备到云的REST接口调用，需要使用JWT来进行认证。</p>\n<h2 id=\"4-2-MQTT-API\"><a href=\"#4-2-MQTT-API\" class=\"headerlink\" title=\"4.2. MQTT API\"></a>4.2. MQTT API</h2><p>​\tnRF Cloud是部署在亚马逊AWS上的，并且使用<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/iot-gs.html\">AWS IoT Core</a>的MQTT broker。</p>\n<p>MQTT API的通信，只要订阅topic即可。这里需要有2个topic，<code>d2c</code>和<code>c2d</code>。</p>\n<ul>\n<li><code>d2c</code>：设备发布，云端订阅</li>\n<li><code>c2d</code>：云端发布，设备订阅</li>\n</ul>\n<p>​\t只要每个设备能获得这两个topic，就能与云端进行通信。这个topic可以通过REST API获得，下一小节会介绍。但是实际开发应用的时候，并不需要关心，因为nRF Cloud Library已经帮我们封装好了，我们只需调用<code>connect()</code>，<code>send()</code>之类的就好了。</p>\n<h3 id=\"MQTT-topic前缀的获取\"><a href=\"#MQTT-topic前缀的获取\" class=\"headerlink\" title=\"MQTT topic前缀的获取\"></a>MQTT topic前缀的获取</h3><p>​\t用户可以通过REST API获取topic前缀，接口是 <a href=\"https://api.nrfcloud.com/v1/#operation/FetchAccountInfo\">FetchAccountInfo</a>。需要使用用户的API Key进行认证。接口会返回很多数据，其中就包含：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttEndpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;mqtt.nrfcloud.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttTopicPrefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;prod/a5592ec1-18ae-4d9d-bc44-xxxxxxxxx/&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t不用REST API，也可以在网页端获取。点击右上角下拉菜单-Teams：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130132356346.png\" alt=\"image-20221130132356346\"></p>\n<p>​\t可以看到Team的信息，其中就有team id。<code>mqttTopicPrefix</code>就是<code>prod/&lt;team_id&gt;</code>。</p>\n<h3 id=\"云端的认证\"><a href=\"#云端的认证\" class=\"headerlink\" title=\"云端的认证\"></a>云端的认证</h3><p>​\t所有到AWS IoT MQTT broker的连接都必须使用在8883端口上进行的Mutual TLS。所有用MQTT的设备都必须有一个<a href=\"https://docs.nrfcloud.com/Devices/Security/Security/#authentication\">X.509 device certificate</a>，并且已经<strong>注册到云端（Provisioned）</strong>。这正是我们在[3.5](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))和[6.1](#REST API 调用示例 )中已经介绍过的部分。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>​\tnRF Cloud部署在AWS上，除了<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html\">AWS保留的topic</a>外，还有一些是nRF Cloud自定义的。官方文档请参考：</p>\n<p><a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/\">nRF Cloud MQTT topics | nRF Cloud Docs</a></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>​\t有关nRF Cloud Library底层的细节，官方文档为 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html\">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>\n<p>​\t在[3.5.3](#3.5.3. 数据传输相关代码)中，我们知道9160是通过Cloud Wrapper API包装了nRF Cloud Library相关的接口进行的。其中发送到云端就是<code>cloud_wrap_batch_send()</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">cloud_wrap_batch_send</span><span class=\"params\">(<span class=\"type\">char</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">bool</span> ack, <span class=\"type\">uint32_t</span> id)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> err;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nrf_cloud_tx_data</span> <span class=\"title\">msg</span> =</span> &#123;</span><br><span class=\"line\">        .data.ptr = buf,</span><br><span class=\"line\">        .data.len = len,</span><br><span class=\"line\">        .id = id,</span><br><span class=\"line\">        .qos = ack ? MQTT_QOS_1_AT_LEAST_ONCE : MQTT_QOS_0_AT_MOST_ONCE,</span><br><span class=\"line\">        .topic_type = NRF_CLOUD_TOPIC_BULK,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = nrf_cloud_send(&amp;msg);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;nrf_cloud_send, error: %d&quot;</span>, err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t这里面，准备好要发送的数据<code>msg</code>即可，数据类型是<code>nrf_cloud_tx_data_msg</code>。Topic是<code>NRF_CLOUD_TOPIC_BULK</code>。</p>\n<p>​\t这恰好就是<a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics\">官方MQTT API手册</a>中的topic，作用是发送一组bulk数据。只要仿照wrapper中的格式，就可以写出自己的发送函数。</p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>​\tnRF Cloud是一个物联网云，提供最基本的设备管理和OTA等功能。此外还提供收费的Location Service，含AGPS、PGPS、基站定位、WiFi定位等功能。不局限于Nordic产品，任何产品都可以连。</p>\n<p>​\tnRF9160具有LTE-M和NB-IoT联网能力，支持GPS。支持eDRX和PSM低功耗，休眠时功耗低至2.7uA。除了本身的Cortex M33应用核可开放开发以外，还可作为外挂通讯模组进行开发。SLM扩展的AT指令也支持多种功能。</p>\n<p>​\t</p>\n","categories":["Nordic","LTE"],"tags":["Nordic","nRF91","nRF_Cloud"]},{"title":"利用Wireshark和tcpdump对整个局域网进行实时抓包","url":"/jayant97.github.io/2022/12/dad29a5a49fd/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t有时我们需要对局域网中两个设备之间的通讯进行抓包调试，一种比较方便的方式就是在路由器上通过<code>tcpdump</code>抓包，然后传回电脑上，利用Wireshark查看抓包内容。</p>\n<p>​\t本文将以一个OpenWrt路由器为例，展示抓包过程。</p>\n<p>​\t参考文章：<a href=\"https://thiscute.world/posts/tcpdump-and-wireshark/#%E4%BA%8Ctcpdump--ssh--wireshark-%E8%BF%9C%E7%A8%8B%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85\">使用 tcpdump 和 Wireshark 进行远程实时抓包分析 - This Cute World</a></p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214212711479.png\" alt=\"image-20221214212711479\"></p>\n<h1 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h1><h2 id=\"2-1-PC上安装Wireshark\"><a href=\"#2-1-PC上安装Wireshark\" class=\"headerlink\" title=\"2.1. PC上安装Wireshark\"></a>2.1. PC上安装Wireshark</h2><p>​\t官网下载安装包然后安装即可，安装时，一定要勾选：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/16052569014970022.png\" alt=\"image description\"></p>\n<h2 id=\"2-2-路由器上需要有tcpdump\"><a href=\"#2-2-路由器上需要有tcpdump\" class=\"headerlink\" title=\"2.2. 路由器上需要有tcpdump\"></a>2.2. 路由器上需要有<code>tcpdump</code></h2><p>​\t我是在路由器固件编译时就编译了<code>tcpdump</code>和<code>libcap</code>。选择为<code>&lt;*&gt;</code>号是随固件一起编译，选择为<code>&lt;M&gt;</code>是作为包进行编译。<code>-*-</code>表示强制随固件一起编译，因为有其他包依赖它，所以它必须选中。</p>\n<p>​\tNetwork —&gt; tcpdump</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214214847255.png\" alt=\"image-20221214214847255\"></p>\n<p>​\tLibraries —&gt; libcap：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215049186.png\" alt=\"image-20221214215049186\"></p>\n<p>​\t如果你不是自己编译的固件，也可以网上下载别人编译好的ipk传到OpenWrt上安装即可：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214214611043.png\" alt=\"image-20221214214611043\"></p>\n<p>在路由器上进行测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tcpdump --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215320752.png\" alt=\"image-20221214215320752\"></p>\n<h1 id=\"3-利用Wireshark调用路由器上的tcpdump进行抓包\"><a href=\"#3-利用Wireshark调用路由器上的tcpdump进行抓包\" class=\"headerlink\" title=\"3. 利用Wireshark调用路由器上的tcpdump进行抓包\"></a>3. 利用Wireshark调用路由器上的<code>tcpdump</code>进行抓包</h1><p>（1）打开Wireshark，选择<strong>捕获——选项</strong>：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215528345.png\" alt=\"image-20221214215528345\"></p>\n<p>（2）选择<strong>SSH remote capture</strong>，点击开始</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215620451.png\" alt=\"image-20221214215620451\"></p>\n<p>（3）输入路由器的ip地址和ssh端口号（默认22）</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215737318.png\" alt=\"image-20221214215737318\"></p>\n<p>（4）输入路由器用户名和密码&#x2F;密钥</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215921550.png\" alt=\"image-20221214215921550\"></p>\n<blockquote>\n<p>我这里用的是密钥而非密码，请参考：<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/693c6a957393/\">最简洁清爽的ssh使用方案 | 一苇万顷 (jayant-tang.github.io)</a>。</p>\n<p>你也可以用密码</p>\n</blockquote>\n<p>（5）tcpdump设置</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214220409559.png\" alt=\"image-20221214220409559\"></p>\n<p>参数设置：</p>\n<ul>\n<li><p>Remote Interface：路由器上要抓包的接口，可以在路由器管理网页上查看，也可以用<code>ifconfig</code>查看，这里是<code>br-lan</code></p>\n<img src=\"/jayant97.github.io/imgs/利用Wireshark和tcpdump对整个局域网进行实时抓包.assets/image-20221214220526046.png\" alt=\"image-20221214220526046\" style=\"zoom:50%;\" />\n</li>\n<li><p>Remote capture command selection：路由器上选择的抓包工具，这里是<code>tcpdump</code></p>\n</li>\n<li><p>Remote capture filter：远程抓包的规则，可以把本机的IP地址填进去过滤，防止Wireshark抓自己和路由器之间的ssh包。比如<code>not (host 192.168.2.2 and port 22)</code>。这里可以用<code>not</code>，<code>or</code>和<code>and</code>逻辑，可以过滤IPv4&#x2F;IPv6地址和端口号。</p>\n<blockquote>\n<p>这个地方是远程过滤器，是抓包时就过滤，后面Wireshark里面还可以再次设置本地过滤器。</p>\n</blockquote>\n</li>\n</ul>\n<p>（6）开始抓包</p>\n<p>最后点击开始，即可在Wireshark中看到路由器br-lan的包了。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214221347037.png\" alt=\"image-20221214221347037\"></p>\n<p>​\t与此同时，我们可以去路由器上看看Wireshark是怎么用<code>tcpdump</code>抓的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ root@OpenWrt:~<span class=\"comment\"># ps | grep tcpdump</span></span><br><span class=\"line\"> 2131 root      5676 S    tcpdump -U -i br-lan -w - not (host 192.168.2.2 and port 22)</span><br><span class=\"line\"> 8318 root      1248 S    grep tcpdump</span><br></pre></td></tr></table></figure>\n\n<p>​\t如上，可以看到Wireshark调用的<code>tcpdump</code>命令以及参数。</p>\n","categories":["网络"],"tags":["Wireshark","OpenWrt"]},{"title":"在Windows上使用Wireshark和Npcap进行WiFi嗅探","url":"/jayant97.github.io/2022/12/66c35f484401/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t我们知道，无线网卡有四种工作模式：</p>\n<ul>\n<li>Managed：电脑网卡最常用的模式，用于连接到无线AP进行上网，被AP管理通信过程。</li>\n<li>Master：AP模式，提供无线接入和路由的功能。Master能管理与Managed模式的网卡的通信过程。</li>\n<li>Ad-hoc：点对点通讯模式，通信双方地位对等，共同承担AP的任务</li>\n<li>Monitor：监听模式</li>\n</ul>\n<p>​\t本文讲解如何在<strong>Windows</strong>电脑上，把无线网卡变为<strong>Monitor</strong>模式，对空中的wifi进行抓包，并用<strong>Wireshark</strong>进行包的分析。</p>\n<p>​\t本文参考了：<a href=\"https://zhiliao.h3c.com/theme/details/183006\">在Windows电脑上通过wireshark直接无线抓包的方式 - 知了社区 (h3c.com)</a></p>\n<h1 id=\"2-安装Npcap\"><a href=\"#2-安装Npcap\" class=\"headerlink\" title=\"2. 安装Npcap\"></a>2. 安装Npcap</h1><p>在Windows上安装Wireshark时，会问你是否要同时安装Npcap，这里要勾选：</p>\n<p>​\t<img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225008728.png\" alt=\"image-20221214225008728\"></p>\n<p>安装Npacp时，<strong>不勾选</strong>管理员模式，<strong>勾选</strong>802.11流量抓包支持：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225059444.png\" alt=\"image-20221214225059444\"></p>\n<blockquote>\n<p>注！</p>\n<p>​\t经过亲自测试，发现Npcap 1.71&#x2F;1.70版本在Windows 11 上均存在bug，明明勾选了<code>Support raw 802.11 traffic</code>，但是实际使用时却提示没有勾选。</p>\n<p>​\t后来安装Npcap 1.60版本才成功，老版本下载地址：<a href=\"https://npcap.com/dist/\">Npcap release archive</a></p>\n</blockquote>\n<p>安装完毕，重启电脑后，任意打开一个终端，输入<code>WlanHelper --help</code>，应该有输出：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225257642.png\" alt=\"image-20221214225257642\"></p>\n<blockquote>\n<p>WlanHelper.exe的位置在<code>C:\\Windows\\System32\\Npcap</code></p>\n</blockquote>\n<h1 id=\"3-WlanHelper的使用\"><a href=\"#3-WlanHelper的使用\" class=\"headerlink\" title=\"3. WlanHelper的使用\"></a>3. WlanHelper的使用</h1><h2 id=\"3-1-查看无线网卡的名称\"><a href=\"#3-1-查看无线网卡的名称\" class=\"headerlink\" title=\"3.1. 查看无线网卡的名称\"></a>3.1. 查看无线网卡的名称</h2><p>查看自己电脑上无线网卡的名称：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipconfig</span><br></pre></td></tr></table></figure>\n\n<p>如下图，名称是WLAN：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225720426.png\" alt=\"image-20221214225720426\"></p>\n<p>​\t也可以在新版Windows设置中查看：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225852951.png\" alt=\"image-20221214225852951\"></p>\n<p>​\t也可以在旧版Windows网络适配器中查看：</p>\n<img src=\"/jayant97.github.io/imgs/在Windows上使用Wireshark和Npcap进行WiFi嗅探.assets/image-20221214225813048.png\" alt=\"image-20221214225813048\" style=\"zoom:50%;\" />\n\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225931713.png\" alt=\"image-20221214225931713\"></p>\n<p>​\t 可以看到，我这张网卡的名称是WLAN，有的网卡名称可能叫Wi-Fi，这与电脑品牌有关。</p>\n<h2 id=\"3-2-把网卡切换为monitor模式\"><a href=\"#3-2-把网卡切换为monitor模式\" class=\"headerlink\" title=\"3.2. 把网卡切换为monitor模式\"></a>3.2. 把网卡切换为monitor模式</h2><p>​\t使用一个支持抓包的USB网卡，插到电脑上：</p>\n<img src=\"/jayant97.github.io/imgs/在Windows上使用Wireshark和Npcap进行WiFi嗅探.assets/image-20221215075234594.png\" alt=\"image-20221215075234594\" style=\"zoom:50%;\" />\n\n<p>​\t可以看到有两张无线网卡：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075413896.png\" alt=\"image-20221215075413896\"></p>\n<p>​\t查看网卡当前工作模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper <span class=\"string\">&quot;Wi-Fi 2&quot;</span> mode</span><br><span class=\"line\">managed</span><br></pre></td></tr></table></figure>\n\n<p>​\t查看网卡支持的所有模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper.exe <span class=\"string\">&quot;Wi-Fi 2&quot;</span> modes</span><br><span class=\"line\">master, managed, monitor</span><br></pre></td></tr></table></figure>\n\n<p>​\t修改网卡的模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper.exe <span class=\"string\">&quot;Wi-Fi 2&quot;</span> mode monitor</span><br><span class=\"line\">Success</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>也可以直接<code>WlanHelper -i</code>，进入交互模式，然后根据其提示输入数字，来进行配置</p>\n</blockquote>\n<h1 id=\"4-使用Wireshark进行抓包\"><a href=\"#4-使用Wireshark进行抓包\" class=\"headerlink\" title=\"4. 使用Wireshark进行抓包\"></a>4. 使用Wireshark进行抓包</h1><p>​\t选择“捕获”——“选项”：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075810915.png\" alt=\"image-20221215075810915\"></p>\n<p>​\t发现监控模式已经可以打勾，可以进行抓包：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075830448.png\" alt=\"image-20221215075830448\"></p>\n","categories":["网络","WiFi"],"tags":["Wireshark","WiFi"]},{"title":"在nRF7002开发板上运行MQTT例程","url":"/jayant97.github.io/2023/08/045cdc9c9b10/","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>本文面向零基础读者，将一步一步介绍如何通过nRF7002DK开发板来运行MQTT例程，并分析此例程的框架、代码，以及用到的库。</p>\n<p>本文包含以下内容：</p>\n<ul>\n<li>MQTT协议简介</li>\n<li>手把手教你运行MQTT over WiFi例程</li>\n<li>MQTT例程解析<ul>\n<li>线程间通信框架：ZBus</li>\n<li>Zephyr状态机框架：SMF (State Machine Framework)</li>\n<li>NCS中的Wi-Fi连接方法</li>\n<li>NCS中的MQTT连接方法</li>\n<li>MQTT加密连接配置（TLS配置）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-1-nRF7002DK\"><a href=\"#1-1-nRF7002DK\" class=\"headerlink\" title=\"1.1. nRF7002DK\"></a>1.1. nRF7002DK</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/nRF7002-DK-1.0.0_perspective_prod_page.webp\" alt=\"nRF7002-DK-1.0.0_perspective\"></p>\n<p>nRF7002DK是Nordic的WiFi6开发板，上面有nRF7002和nRF5340两颗芯片。其中nRF7002是Wi-Fi6双频IC，nRF5340是双核蓝牙主控MCU，二者通过QSPI连接。此开发板提供了5GHz和2.4GHz双频WiFi和蓝牙共存的功能。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908164659947.png\" alt=\"image-20230908164659947\"></p>\n<p>此外如果你在今年的Nordic Tech Tour上获得了免费的Clever Connect Kit（CCK），也可以使用。它和7002DK的主要电路都相同（7002, 5340，Jlink和外挂Flash），只是缺少一些外围保护电路和IO口切换用的电子开关。你可以在<a href=\"https://devzone.nordicsemi.com/cfs-file/__key/communityserver-discussions-components-files/4/INTERNAL-CCK-Quick-Guide-v1.pdf\">这里</a>下载到它的说明文档。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115736114.png\" alt=\"image-20230823115736114\"></p>\n<h2 id=\"1-2-MQTT协议简介\"><a href=\"#1-2-MQTT协议简介\" class=\"headerlink\" title=\"1.2. MQTT协议简介\"></a>1.2. MQTT协议简介</h2><h3 id=\"什么是MQTT协议？\"><a href=\"#什么是MQTT协议？\" class=\"headerlink\" title=\"什么是MQTT协议？\"></a>什么是MQTT协议？</h3><p>MQTT是物联网领域常用的通讯协议，它轻量、高效，适合需要联网的嵌入式应用。要快速了解MQTT协议，可以从以下几个角度看。</p>\n<h3 id=\"设备之间如何建立连接？\"><a href=\"#设备之间如何建立连接？\" class=\"headerlink\" title=\"设备之间如何建立连接？\"></a>设备之间如何建立连接？</h3><p>许多设备通过TCP连接到一个服务器上，这个服务器是MQTT Broker，它代理了设备之间的通信。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115755610.png\" alt=\"image-20230823115755610\"></p>\n<p>这种方式优势很多。由于<strong>设备之间</strong>不需要建立<strong>直接</strong>连接，因此当一个设备要与另一个设备通信时，既不需要知道对方的地址，也不需要等待对方的唤醒，甚至不需要知道对方的存在。设备只需要把消息交给服务器，并且从服务器取回自己所需的数据即可，然后就能继续休眠。</p>\n<h3 id=\"MQTT消息如何传输？\"><a href=\"#MQTT消息如何传输？\" class=\"headerlink\" title=\"MQTT消息如何传输？\"></a>MQTT消息如何传输？</h3><p>消息被发布到主题上，然后就能被订阅此主题的设备接收到。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908165648117.png\" alt=\"image-20230908165648117\"></p>\n<p>MQTT是基于发布&#x2F;订阅模型的消息传输协议。任何一个设备都可以向某个主题（Topic）发布（Publish）消息，也可以订阅（Subscribe）某个主题从而接收消息。当某个客户端向一个主题发布数据时，所有订阅了这个主题的客户端都可以收到这个消息。</p>\n<blockquote>\n<p>消息：可以是任何数据。如json字符串或纯二进制数据；</p>\n<p>客户端：既可以是IoT设备，也可以是PC、手机或服务器；</p>\n<p>主题：一串符合格式要求的字符串。其格式不是本文的重点，此处不详细叙述。</p>\n</blockquote>\n<h3 id=\"MQTT协议安全吗？\"><a href=\"#MQTT协议安全吗？\" class=\"headerlink\" title=\"MQTT协议安全吗？\"></a>MQTT协议安全吗？</h3><p>从最简单的角度考虑，安全分为两个方面，一个是设备身份的认证，一个是传输本身的加密。</p>\n<p>每一个MQTT客户端都有一个Client ID，用于标识设备的身份。在一些仅供测试学习的MQTT broker上，只需要自己随便填写一个个Client ID就可以登录了。而商用的MQTT broker可能还需要密码、密钥、证书等凭据才可以允许设备登录。</p>\n<p>此外，MQTT是基于TCP&#x2F;IP的协议，这意味着MQTT也可以通过TLS加密通讯。在这种情况下：</p>\n<ul>\n<li>如果客户端需要验证服务端的身份，则客户端内需要安装CA证书，用于验证TLS握手时服务器出示的证书是否合法；</li>\n<li>如果服务端要验证客户端的身份，那么除了前面讲的通过<strong>密码</strong>进行登陆的方式外，还可以通过<strong>设备证书</strong>的方式进行验证。这种情况下，客户端需要持有<strong>设备证书</strong>（包含公钥）及其<strong>私钥</strong>。并且设备的证书和Client  ID要提前被注册到云端。</li>\n</ul>\n<h1 id=\"2-环境准备\"><a href=\"#2-环境准备\" class=\"headerlink\" title=\"2. 环境准备\"></a>2. 环境准备</h1><ol>\n<li>nRF7002DK或CCK</li>\n<li>一台安装了nRF Connect SDK v2.4.0的开发环境的PC (Windows&#x2F;Linux&#x2F;MacOS)</li>\n<li>PC上安装一个MQTT客户端，例如：<a href=\"https://mqttx.app/zh\">MQTTX</a></li>\n<li>联网的WiFi环境（目前仅支持PSK，也就是输入密码的类型；不支持企业级Wi-Fi）</li>\n</ol>\n<h1 id=\"3-运行例程\"><a href=\"#3-运行例程\" class=\"headerlink\" title=\"3. 运行例程\"></a>3. 运行例程</h1><h2 id=\"3-1-通过例程模板创建新工程\"><a href=\"#3-1-通过例程模板创建新工程\" class=\"headerlink\" title=\"3.1. 通过例程模板创建新工程\"></a>3.1. 通过例程模板创建新工程</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002150634368.png\" alt=\"image-20231002150634368\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002150727465.png\" alt=\"image-20231002150727465\"></p>\n<ol>\n<li>打开一个VS Code新窗口，进入nRF Connect插件界面，选择Create a new application，创建一个新工程</li>\n<li>选择copy a sample，复制一个例程</li>\n<li>在搜索框输入mqtt，选择<code>nrf/samples/net/mqtt</code></li>\n<li>输入工程存放的路径，回车</li>\n<li>输入新工程的名称，回车创建</li>\n</ol>\n<blockquote>\n<p>通过这种方式创建的新工程会自动创建单独的git仓库，方便我们后续追踪文件的变动。</p>\n</blockquote>\n<h2 id=\"3-2-修改工程配置文件\"><a href=\"#3-2-修改工程配置文件\" class=\"headerlink\" title=\"3.2. 修改工程配置文件\"></a>3.2. 修改工程配置文件</h2><p>在<code>boards/nrf7002dk_nrf5340_cpuapp.conf</code>中，添加WiFi SSID和密码的配置，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># WIFI SSID与密码</span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_SSID=<span class=\"string\">&quot;Nordicsh-5G&quot;</span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_PASSWORD=<span class=\"string\">&quot;xxxxxxxx&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加密方式，根据AP的情况四选一</span></span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_OPEN=y </span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_PSK=y</span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_PSK_SHA256=y</span></span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_SAE=y</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提示：</p>\n<ol>\n<li><p>本例程的<code>src/modules/network_wifi.c</code>中要求必须静态配置WiFi SSID和密码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">BUILD_ASSERT(IS_ENABLED(CONFIG_WIFI_CREDENTIALS_STATIC), <span class=\"string\">&quot;Static Wi-Fi config must be used&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因此，若不在编译前就设置好WiFi SSID与密码，则Assert无法通过。<br>不过在实际的产品开发中，肯定是希望在程序运行后再动态配置，具体方法请参考后续章节。</p>\n</li>\n<li><p>由于<code>mqtt</code>例程除了可以用7002wifi开发板运行外，也可用9160蜂窝网开发板运行，因此Wi-Fi的相关配置最好放在<code>boards</code>目录下与WiFi板子相关的配置文件中，而不是放在<code>prj.conf</code>这个通用的配置文件中。这是一种更合理的做法。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"3-3-创建编译目标\"><a href=\"#3-3-创建编译目标\" class=\"headerlink\" title=\"3.3. 创建编译目标\"></a>3.3. 创建编译目标</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115834345.png\" alt=\"image-20230823115834345\"></p>\n<ol>\n<li>选择nRF Connect 插件</li>\n<li>在mqtt工程下新建一个编译目标</li>\n<li>选择板子<code>nrf7002dk_nrf5340_cpuapp</code> （含义：7002DK开发板——5340MCU——应用核）</li>\n<li>追加的配置文件选择<code>overlay-tls-nrf7002.conf</code>。（也可以把这个追加配置文件的内容复制到prj.conf中）</li>\n<li>编译</li>\n</ol>\n<blockquote>\n<p>提示：</p>\n<ol>\n<li><p>通过按<code>CTRL + ` </code> 可以呼出命令行界面，查看编译进度</p>\n</li>\n<li><p>编译时，命令行中会显示运行的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/sh -c west build --build-dir /home/jayant/project/ncs-project/wifi/mqtt/build /home/jayant/project/ncs-project/wifi/mqtt --pristine --board nrf7002dk_nrf5340_cpuapp --no-sysbuild -- -DNCS_TOOLCHAIN_VERSION:STRING=<span class=\"string\">&quot;NONE&quot;</span> -DBOARD_ROOT:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt&quot;</span> -DCONF_FILE:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt/prj.conf;/home/jayant/project/ncs-project/wifi/mqtt/boards/nrf7002dk_nrf5340_cpuapp.conf&quot;</span> -DOVERLAY_CONFIG:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt/overlay-tls-nrf7002.conf&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过阅读这个命令携带的冗长的参数，我们可以知道，编译系统采用了以下三个配置文件：</p>\n<ul>\n<li><code>prj.conf</code></li>\n<li><code>boards/nrf7002dk_nrf5340_cpuapp.conf</code></li>\n<li><code>overlay-tls-nrf7002.conf</code></li>\n</ul>\n<p>第一个是zephyr系统默认的配置文件，第二个是系统根据所选的板子自动选择的配置文件，第三个是我们创建编译目标时手动选择的附加的配置文件。三者的内容最终是合并在一起，然后才采用的。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"3-4-程序下载与运行\"><a href=\"#3-4-程序下载与运行\" class=\"headerlink\" title=\"3.4. 程序下载与运行\"></a>3.4. 程序下载与运行</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115845564.png\" alt=\"image-20230823115845564\"></p>\n<ol>\n<li>连接好开发板，确认VS Code中可以识别到已连接的Jlink</li>\n<li>点击“Flash”按钮，下载编译好的程序（如果是点击图中红色框内按钮，则是擦除并下载）</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823121558235.png\" alt=\"image-20230823121558235\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824102839317.png\" alt=\"image-20230824102839317\"></p>\n<ol start=\"3\">\n<li>打开编号较大的串口（这是应用核的串口，另一个串口是5340网络核的默认串口），并点击开发板上的reset 按钮让程序重新运行<br><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823122202243.png\" alt=\"image-20230823122202243\"></li>\n<li>等待一段时间，就能看到板子已经依次成功连上WiFi、互联网、MQTT broker、并订阅了topic。由于我们之前设置编译目标时选择了TLS的overlay配置文件，所以可以看到这里连接的是MQTTS默认的8883端口，并且启用了TLS协议。<br><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824103416044.png\" alt=\"image-20230824103416044\"></li>\n</ol>\n<h2 id=\"3-5-MQTT通信测试\"><a href=\"#3-5-MQTT通信测试\" class=\"headerlink\" title=\"3.5. MQTT通信测试\"></a>3.5. MQTT通信测试</h2><p>例程默认连接的是<code>test.mosquitto.org</code>这个免费的公共MQTT broker，它仅供测试使用。</p>\n<p>我们在PC上使用一个MQTT客户端，也连上这个broker，与板子进行通讯测试。这里以MQTTX为例：</p>\n<h3 id=\"连接到MQTT-broker\"><a href=\"#连接到MQTT-broker\" class=\"headerlink\" title=\"连接到MQTT broker\"></a>连接到MQTT broker</h3><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824104643996.png\" alt=\"image-20230824104643996\"></p>\n<p>首先打开MQTTX，在连接的右侧点击“+”，选择新建连接。在右侧填入基本信息：</p>\n<ul>\n<li>名称：此链接在客户端软件里显示的名称，与MQTT协议本身无关；</li>\n<li>Client ID：此客户端在MQTT broker上被识别的身份。由于这是个免费公共broker，因此可以随意填写，不要填写容易与其他人重复的ID即可；</li>\n<li>服务器地址：协议选择MQTT，地址填写<code>test.mosquitto.org</code>。</li>\n<li>SSL&#x2F;TLS：无需启用。此Broker既支持TLS连接也支持非加密连接。虽然开发板是通过TLS方式连接的，但PC客户端即使通过不同方式连接，最终只要连接到同一个broker上，也是可以通讯的。</li>\n</ul>\n<p>其余参数保持默认即可，然后点击右上角的“连接”。</p>\n<h3 id=\"订阅主题并接收数据\"><a href=\"#订阅主题并接收数据\" class=\"headerlink\" title=\"订阅主题并接收数据\"></a>订阅主题并接收数据</h3><p>通过串口日志我们可以看出:</p>\n<ul>\n<li>开发板订阅的topic为：<code>F4CE36000384/my/subscribe/topic</code></li>\n<li>开发板发布数据的topic为：<code>F4CE36000384/my/publish/topic</code></li>\n</ul>\n<blockquote>\n<p>这里的Client ID是硬件ID生成的，你需要查看你的板子的ID是多少。</p>\n</blockquote>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105539237.png\" alt=\"image-20230824105539237\"></p>\n<p>因此在MQTTX中，我们要订阅<code>F4CE36000384/my/publish/topic</code>，从而接收开发板上发送的数据：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105703966.png\" alt=\"image-20230824105703966\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105745173.png\" alt=\"image-20230824105745173\"></p>\n<ul>\n<li>点击“添加订阅”</li>\n<li>填写Topic，并将服务质量（QoS）设置为1（确保对方收到至少一次，也就是有重传确认机制）。</li>\n</ul>\n<p>此例程是定时发送数据的，但也可以通过按下开发板上的Button1或Button2来立即发送数据。</p>\n<h3 id=\"发送数据到开发板\"><a href=\"#发送数据到开发板\" class=\"headerlink\" title=\"发送数据到开发板\"></a>发送数据到开发板</h3><p>同理，我们可以发送数据到<code>F4CE36000384/my/subscribe/topic</code>，从而让开发板可以接收到：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824110521147.png\" alt=\"image-20230824110521147\"></p>\n<ul>\n<li>Paylod：选择字符串（Plaintext）。由于MQTT传输的底层就是二进制传输。因此，我们在Playload选项中，选择的其实是客户端如何编码，如何进行格式检查。MQTT协议本身并不会有什么字段来描述自己携带的数据类型。</li>\n<li>QoS：选择1，确保Broker会收到至少一次。</li>\n<li>Topic：填入开发板订阅的Topic，这里是<code>F4CE36000384/my/subscribe/topic</code></li>\n<li>下方填入要发送的内容，并发送数据</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824111005271.png\" alt=\"image-20230824111005271\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824111020710-1692846622507-1.png\" alt=\"image-20230824111020710\"></p>\n<p>可以看到开发板成功收到数据。</p>\n<h1 id=\"4-代码解析\"><a href=\"#4-代码解析\" class=\"headerlink\" title=\"4. 代码解析\"></a>4. 代码解析</h1><h2 id=\"4-1-编译与配置系统\"><a href=\"#4-1-编译与配置系统\" class=\"headerlink\" title=\"4.1. 编译与配置系统\"></a>4.1. 编译与配置系统</h2><h3 id=\"源码的组织\"><a href=\"#源码的组织\" class=\"headerlink\" title=\"源码的组织\"></a>源码的组织</h3><p>源码都位于<code>src</code>目录下，分成了<code>common</code>和几个模块：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824113012286.png\" alt=\"image-20230824113012286\"></p>\n<p>我们可以注意到，代码是没有<code>main()</code>函数的。因为Zephyr支持静态定义线程，系统上电reset后，各个模块的线程就直接运行起来了，无需<code>main()</code>函数。</p>\n<p>源码使用CMake进行管理，我们可以看到项目顶层<code>CMakeLists.txt</code>使用<code>add_subdirectory()</code>引用了各个模块的<code>CMakeLists.txt</code>，从而把所有源码组织在一起。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824114611064.png\" alt=\"image-20230824114611064\"></p>\n<h3 id=\"Kconfig配置系统\"><a href=\"#Kconfig配置系统\" class=\"headerlink\" title=\"Kconfig配置系统\"></a>Kconfig配置系统</h3><p>各个模块以及Zephyr系统有大量的配置项可以修改，这些配置项是以预编译宏的形式存在的。由于配置项很多，Zephyr采用了Kconfig进行配置项的管理。</p>\n<p>例程目录下的顶层Kconfig文件定义了本工程的一个配置项菜单，它包含本工程所需的全部配置：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115854511.png\" alt=\"image-20230823115854511\"></p>\n<p>和CMake的逻辑类似。顶层Kconfig也是可以通过引用各个模块的菜单，从而形成一个整个项目的大型菜单。菜单的前一部分是引用了<code>src/modules/</code>目录下各个子模块的Kconfig菜单，后一部分是引用了Zephyr的Kconfig菜单。我们可以通过点击Kconfig按钮来查看这个完整的菜单：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824115336388.png\" alt=\"image-20230824115336388\"></p>\n<p>在完整的菜单中，我们可以看到，顶层的两级目录就分别是例程本身的各个模块的菜单，以及Zephyr系统的配置菜单。</p>\n<h3 id=\"设置配置项的值\"><a href=\"#设置配置项的值\" class=\"headerlink\" title=\"设置配置项的值\"></a>设置配置项的值</h3><p>Kconfig是一个<strong>菜单</strong>，真正发挥作用的是菜单中各个<strong>配置项的值</strong>。其中的配置项的值会有很多个来源：</p>\n<ul>\n<li>在Kconfig文件定义菜单时，某些配置项会有默认值</li>\n<li>在创建编译目标，选择板子时，这个板子自带的一些配置项。见<code>$&#123;NCS&#125;/nrf/boards/arm/</code>或<code>$&#123;NCS&#125;/zephyr/boards/arm/</code>下各个板子的目录中的<code>.conf</code>文件</li>\n<li>工程目录下，<code>boards/</code>目录下与板子对应的<code>.conf</code>配置文件</li>\n<li>工程目录下默认的<code>prj.conf</code>配置文件，这也是最常用的</li>\n<li>创建编译目标时，选择附加的Kconfig片段，例如<code>overlay-tls-7002.conf</code></li>\n</ul>\n<blockquote>\n<p>配置项的来源还有很多，例如使用CMake编译时指定<code>CONFIG_</code>开头的变量，还有一些隐含的配置项，无法直接修改，只会被其他配置项联动修改等等。要了解更多关于配置项的问题，可参考：<a href=\"https://docs.zephyrproject.org/latest/build/kconfig/setting.html#the-initial-configuration\">https://docs.zephyrproject.org/latest/build/kconfig/setting.html#the-initial-configuration</a></p>\n</blockquote>\n<p>所有的配置项最终在编译时都会合并到<code>build/zephyr/.config</code>临时文件中，要想知道自己的配置有没有成功适用，查看这个文件即可。</p>\n<p>在Kconfig菜单界面修改后，如果只点击”Apply”，那么此修改只会保存到<code>.config</code>临时文件中。下次Build时可以生效。但是如果修改了其他config文件、CMake文件，或者执行了重新编译的情况下，这些修改就会随着<code>.config</code>文件一起消失。如果想让自己的修改永久保存，需要点击Save to file，然后选择一个合适的文件保存。通常，与特定板子有关的，可以保存到<code>boards</code>目录下的配置文件中；如果是这个项目通用的配置，可以保存到<code>prj.conf</code>中。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824122017814.png\" alt=\"image-20230824122017814\"></p>\n<p>举例来说：</p>\n<ol>\n<li>MQTT服务器地址是在哪里配置的？<br>在<code>src/modules/transport/Kconfig.transport</code>中，定义菜单时，<code>MQTT_SAMPLE_TRANSPORT_BROKER_HOSTNAME</code>的默认值是<code>test.mosquitto.org</code></li>\n<li>Wi-Fi密码在哪里配置的？<br>可以像第3节中一样，在板子的<code>conf</code>文件中配置，也可以直接写在项目的<code>prj.conf</code>中。</li>\n</ol>\n<h2 id=\"4-2-代码框架\"><a href=\"#4-2-代码框架\" class=\"headerlink\" title=\"4.2. 代码框架\"></a>4.2. 代码框架</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824141934689.png\" alt=\"image-20230824141934689\"></p>\n<p>此例程有6个模块，分别是：</p>\n<ul>\n<li>Trigger：定时触发，让其他模块向MQTT broker发布消息，同时在检测到按钮按下时也触发；</li>\n<li>Sampler：当其他模块发出请求时，采样数据，并发送给其他模块。此例程中，采样的数据用一串字符串代替；</li>\n<li>Transport：负责处理MQTT连接；</li>\n<li>Network：负责网络连接；</li>\n<li>LED：负责根据其他模块发出的消息，控制不同的LED状态；</li>\n<li>Error：监控其他模块发出的报错信息，若出现报错，则执行重启。</li>\n</ul>\n<h3 id=\"Zbus与模块化编程\"><a href=\"#Zbus与模块化编程\" class=\"headerlink\" title=\"Zbus与模块化编程\"></a>Zbus与模块化编程</h3><p>在模块化的编程中，除了模块本身的实现以外，模块间的通信也是非常重要的一环，往往牵扯到大量的队列、信号量和锁的交互。</p>\n<p>为了减轻这部分的工作量，Zephyr提供了Zbus通信框架，相当于对上述操作进行了一个封装。Zbus有点像“本地的MQTT”，每个模块可以在不同的通道（Channel）上发布&#x2F;订阅消息。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824143949656.png\" alt=\"image-20230824143949656\"></p>\n<p>Zbus可以使模块间实现解耦，因为每个模块实际上只和Zbus交互，并不知道其他模块的存在。</p>\n<p>我们在<code>src/common/message_channel.h</code>中可以看到总共<strong>声明</strong>了4个Zbus通道：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZBUS_CHAN_DECLARE(TRIGGER_CHAN, PAYLOAD_CHAN, NETWORK_CHAN, FATAL_ERROR_CHAN);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>src/common/message_channel.c</code>中可以看到每个通道的<strong>定义</strong>，这里以<code>NETWORK_CHAN</code>通道为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZBUS_CHAN_DEFINE(NETWORK_CHAN,</span><br><span class=\"line\">         <span class=\"keyword\">enum</span> network_status,</span><br><span class=\"line\">         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">         ZBUS_OBSERVERS(transport IF_ENABLED(CONFIG_MQTT_SAMPLE_LED, (, led)), sampler),</span><br><span class=\"line\">         ZBUS_MSG_INIT(<span class=\"number\">0</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到定义了通道的名称，payload的数据类型以及通道数据的接收者（Observers）。这里的Observers就是能从这个Channel接收消息的模块，可以填写多个。这里可以看到一个条件预编译：如果定义了<code>CONFIG_MQTT_SAMPLE_LED=y</code>，则此处就会插入一个“<code>, led</code>”字符串。</p>\n<p>Zbus支持多对多通信，支持同步、异步通信。</p>\n<h3 id=\"Zbus同步接收\"><a href=\"#Zbus同步接收\" class=\"headerlink\" title=\"Zbus同步接收\"></a>Zbus同步接收</h3><p>同步通信的例子是<code>led</code>模块，我们可以看到<code>src/modules/led/led.c</code>中并没有定义线程，而是只定义了一个Zbus Listener和LED的回调函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处仅定义了listener，没有定义其要监听哪个channel，因为在前面Zbus定义channel时就已经确定好observer的名称了</span></span><br><span class=\"line\">ZBUS_LISTENER_DEFINE(led, led_callback);</span><br></pre></td></tr></table></figure>\n\n<p>这就是同步通信的例子，每当Channel上有消息产生时，这个回调函数都会<strong>在发送端的发送函数内被执行一次</strong>。所以，同步接收的回调函数应该尽量快速执行，以免阻塞发送端的线程。</p>\n<h3 id=\"Zbus异步接收\"><a href=\"#Zbus异步接收\" class=\"headerlink\" title=\"Zbus异步接收\"></a>Zbus异步接收</h3><p>异步通信的例子是<code>sampler</code>模块，我们可以看到<code>src/modules/sample/sampler.c</code>中分别定义了Zbus Subscriber和一个线程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于在src/common/message_channel.c中，定义Zbus channel时就已经确定好observer的名称了</span></span><br><span class=\"line\"><span class=\"comment\">// 因此此处只需定义自身的observer的名称即可</span></span><br><span class=\"line\">ZBUS_SUBSCRIBER_DEFINE(sampler, CONFIG_MQTT_SAMPLE_SAMPLER_MESSAGE_QUEUE_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">sampler_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zbus_channel</span> *<span class=\"title\">chan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!zbus_sub_wait(&amp;sampler, &amp;chan, K_FOREVER)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (&amp;TRIGGER_CHAN == chan) &#123;</span><br><span class=\"line\">            sample();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">K_THREAD_DEFINE(sampler_task_id,</span><br><span class=\"line\">        CONFIG_MQTT_SAMPLE_SAMPLER_THREAD_STACK_SIZE,</span><br><span class=\"line\">        sampler_task, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在线程中，通过<code>zbus_sub_wait()</code>函数来监听通道上是否有消息。由于此消息只是用来触发采样的，消息内的payload并无任何作用，因此此处没有使用<code>zbus_chan_read()</code>函数。</p>\n<blockquote>\n<p>Zbus接收的本质：</p>\n<ol>\n<li>每定义一个subscriber，就会同时为它定义一个<code>k_msgq</code>队列；</li>\n<li>每次数据发送到某个channel时，实际上是给这个channel下的每个obsever的队列都填充了相同的消息；</li>\n<li><code>zbus_sub_wait()</code>的作用是阻塞等待，并从队列中取出消息；</li>\n<li><code>zbus_chane_read()</code>的作用是从已经出队的消息中提取真正的数据；</li>\n</ol>\n</blockquote>\n<h3 id=\"Zbus数据发送\"><a href=\"#Zbus数据发送\" class=\"headerlink\" title=\"Zbus数据发送\"></a>Zbus数据发送</h3><p>在<code>src/modules/trigger/trigger.c</code>中可以看到，发送的行为不需要定义类似publisher的东西。直接向channel发布数据即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">err = zbus_chan_pub(&amp;TRIGGER_CHAN, &amp;not_used, K_SECONDS(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于Zbus的总结：</p>\n<ul>\n<li>每次数据发送到某个channel时，实际上是给这个channel下的每个observer的消息队列都push了相同的消息；并且如果有注册的同步接收的回调函数的话，还要执行这个回调函数</li>\n<li>由于发布、接收都是对锁操作的封装，因此它们都不能在中断服务函数中使用；并且都可以设置超时时间以避免一直阻塞</li>\n<li>不必担心线程阻塞造成功耗问题，因为在Zephyr中，进入IDLE线程时会自动进入低功耗模式</li>\n<li>发送数据是拷贝的，因此，消息数据用局部变量即可。此外，有多少个observer就会把数据拷贝多少份，如果需要做大量数据的传输，注意CPU的开销。</li>\n<li>更多资料，参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/zbus/index.html#zbus\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/zbus/index.html#zbus</a></li>\n</ul>\n</blockquote>\n<h2 id=\"4-3-Wi-Fi连接过程\"><a href=\"#4-3-Wi-Fi连接过程\" class=\"headerlink\" title=\"4.3. Wi-Fi连接过程\"></a>4.3. Wi-Fi连接过程</h2><p>网络连接由network模块控制，在<code>src/modules/network/CMLakeists.txt</code>中，我们可以看到，根据不同的板子选择，实际参与编译的是不同的源代码。由于我们选择的是7002开发板，因此这里只会编译<code>network_wifi.c</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">connect</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_if</span> *<span class=\"title\">iface</span> =</span> net_if_get_default();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iface == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Returned network interface is NULL&quot;</span>);</span><br><span class=\"line\">        SEND_FATAL_ERROR();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> err = net_mgmt(NET_REQUEST_WIFI_CONNECT_STORED, iface, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Connecting to Wi-Fi failed. error: %d&quot;</span>, err);</span><br><span class=\"line\">        SEND_FATAL_ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">network_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    net_mgmt_init_event_callback(&amp;net_mgmt_callback, wifi_mgmt_event_handler, MGMT_EVENTS);</span><br><span class=\"line\">    net_mgmt_add_event_callback(&amp;net_mgmt_callback);</span><br><span class=\"line\">    net_mgmt_init_event_callback(&amp;net_mgmt_ipv4_callback, ipv4_mgmt_event_handler,</span><br><span class=\"line\">                     NET_EVENT_IPV4_ADDR_ADD | NET_EVENT_IPV4_ADDR_DEL);</span><br><span class=\"line\">    net_mgmt_add_event_callback(&amp;net_mgmt_ipv4_callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Add temporary fix to prevent using Wi-Fi before WPA supplicant is ready. */</span></span><br><span class=\"line\">    k_sleep(K_SECONDS(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    connect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码非常直观，先是分别给WiFi和IPv4注册了不同的回调函数，然后再执行连接。这里的网络回调函数和连接分别用到了两个模块，<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/net_if.html#net-if-interface\">Network Interface</a>和<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/net_mgmt.html#net-mgmt-interface\">Network Management</a>。</p>\n<h3 id=\"Network-Interface\"><a href=\"#Network-Interface\" class=\"headerlink\" title=\"Network Interface\"></a>Network Interface</h3><p>所有与网络相关的处理都与网络接口有关。网络接口是在编译时就确定的。我们可以看到<code>connect()</code>函数中获得了默认的网络接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_if</span> *<span class=\"title\">iface</span> =</span> net_if_get_default();</span><br></pre></td></tr></table></figure>\n\n<p>由于Zephyr将nRF7002抽象成了网卡，并且在NCS中已经有了7002的驱动代码，所以我们不必太关心底层细节，就能实现网络通信。</p>\n<p>有关7002驱动的架构，可以查看：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/wifi/nrf700x/nrf700x.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/wifi/nrf700x/nrf700x.html</a></p>\n<h3 id=\"Network-Management库\"><a href=\"#Network-Management库\" class=\"headerlink\" title=\"Network Management库\"></a>Network Management库</h3><p>Network Management可以让应用层与网络层之间、或者网络层的内部进行方便的函数调用。我们通过查看<code>net_mgmt</code>的定义可以知道，实际上<code>net_mgmt()</code>并不是一个单独的函数，而是把第一个参数放入函数名的多个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> net_mgmt(_mgmt_request, _iface, _data, _len)            \\</span></span><br><span class=\"line\"><span class=\"meta\">    net_mgmt_##_mgmt_request(_mgmt_request, _iface, _data, _len)</span></span><br></pre></td></tr></table></figure>\n\n<p>这也意味着每个调用<code>net_mgmt(ABC)</code>的地方，都会在SDK的某个地方对应一个函数的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NET_MGMT_DEFINE_REQUEST_HANDLER(_mgmt_request)            \\</span></span><br><span class=\"line\"><span class=\"meta\">    extern int net_mgmt_##_mgmt_request(uint32_t mgmt_request,\t\\</span></span><br><span class=\"line\"><span class=\"meta\">                        struct net_if *iface,\t\\</span></span><br><span class=\"line\"><span class=\"meta\">                        void *data, size_t len)</span></span><br></pre></td></tr></table></figure>\n\n<p>这种实现方式可以让整个网络API有更强的扩展性，同时，让用不到的函数在编译时就被消除，从而减少代码的大小。</p>\n<p>因此，当我们想查看某个<code>net_mgmt(request,...)</code>函数做了什么的时候，可以去整个SDK中搜索这个函数的参数，从而找到这个函数注册的地方，从而查看它的具体的实现。</p>\n<blockquote>\n<p>此Network Management的实现方式是实验性的，今后可能会更新。</p>\n</blockquote>\n<h3 id=\"Wi-Fi的自动连接\"><a href=\"#Wi-Fi的自动连接\" class=\"headerlink\" title=\"Wi-Fi的自动连接\"></a>Wi-Fi的自动连接</h3><p>我们在整个SDK中全局搜索<code>NET_REQUEST_WIFI_CONNECT_STORED</code>就可以查到前述网络API被注册的地方，其实际的代码位于<code>$&#123;NCS&#125;/nrf/subsys/net/lib/wifi_mgmt_ext/wifi_mgmt_ext.c</code>。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908172441366.png\" alt=\"image-20230908172441366\"></p>\n<p>由此我们可以看出Network Management API的扩展性很强。Nordic直接在Zephyr的Network Management API里，注册了一个新的API，扩展出了通过config文件配置Wi-Fi凭据的功能，方便了例程的配置。这就是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_mgmt_ext.html\">Wi-Fi management extension</a>库，它能让例程上电自动连接预设Wi-Fi。</p>\n<p>从代码中可以看出，它的具体步骤是：先把config中静态配置的Wi-Fi凭据保存到Flash中，然后自动执行Wi-Fi连接。大家可以打开这个代码文件，去查看具体的代码。</p>\n<h3 id=\"Wi-Fi凭据的管理\"><a href=\"#Wi-Fi凭据的管理\" class=\"headerlink\" title=\"Wi-Fi凭据的管理\"></a>Wi-Fi凭据的管理</h3><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#wi-fi-credentials\">Wi-Fi credentials</a>这个库用于管理Wi-Fi凭据。它可以让Wi-Fi凭据存储在MCU内部。</p>\n<p>Wi-Fi凭据，对于Personal模式（PSK, Pre-Shared Key）来说，就是密码。对于Enterprise模式来说，就是各类证书和密钥。我们可以从<code>$&#123;NCS&#125;/nrf/include/net/wifi_credentials.h</code>中看出，这两种凭据是通过不同的两种结构体来存储的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">wifi_security_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ssid[WIFI_SSID_MAX_LEN];</span><br><span class=\"line\">    <span class=\"type\">size_t</span> ssid_len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> bssid[WIFI_MAC_ADDR_LEN];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> flags;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Personal凭据只存储header和密码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_personal</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> password[WIFI_CREDENTIALS_MAX_PASSWORD_LEN];</span><br><span class=\"line\">    <span class=\"type\">size_t</span> password_len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Enterprise凭据会存储Header和各类身份信息，可能包含密码、密钥、证书等</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Enterprise凭据目前只有定义，其功能并未实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_enterprise</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> identity_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> anonymous_identity_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> password_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> ca_cert_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> client_cert_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> private_key_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> private_key_pw_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Wi-Fi凭据的写和读都很简单，分别提供了两种API。一种是直接传递参数，另一种是通过结构体来传递参数。由于篇幅原因，这里只列出较短的，也就是通过结构体传参数的形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_get_by_ssid_personal_struct</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"keyword\">struct</span> wifi_credentials_personal *buf)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_get_by_ssid_personal_struct</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"keyword\">struct</span> wifi_credentials_personal *buf)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_delete_by_ssid</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">wifi_credentials_for_each_ssid</span><span class=\"params\">(wifi_credentials_ssid_cb cb, <span class=\"type\">void</span> *cb_arg)</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：</p>\n<ul>\n<li>Enterprise模式的相关API目前并未实现，因此无法连接。</li>\n<li>用于凭据永久存储的后端（Backend）有两种。一种是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/settings/index.html\">Zephyr Settings存储服务</a>，另一种是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/samples/tfm_integration/psa_protected_storage/README.html\">PSA安全存储</a>。前者只是对Flash读写进行封装的库，使得整个Zephyr系统中的各个模组都可以方便地存储自己的非易失数据；而后者是ARM PSA (Platform Security Archtecture)中提出的一种安全存储服务，这种方式可以让自己的应用程序运行在“非安全（Non-Secure）”空间的同时，把凭据存储在“安全（Secure）空间”中，它需要TF-M才能工作。具体内容不在本文中阐述。修改后端的配置可以参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#configuration\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#configuration</a></li>\n</ul>\n</blockquote>\n<h3 id=\"Wi-Fi连接的管理\"><a href=\"#Wi-Fi连接的管理\" class=\"headerlink\" title=\"Wi-Fi连接的管理\"></a>Wi-Fi连接的管理</h3><p>前面提到，在<code>$&#123;NCS&#125;/nrf/subsys/net/lib/wifi_mgmt_ext/wifi_mgmt_ext.c</code>中，对存储中的每一个SSID遍历执行了<code>add_stored_network</code>函数。如果我们追踪下去，就会发现最终执行的连接函数，内部都是<code>wpa_cli</code>的命令，也就是我们在Linux上常见的一个Wi-Fi管理工具。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002155758866.png\" alt=\"image-20231002155758866\"></p>\n<p>不过，当我们开发实际的产品时，肯定还是要通过蓝牙、USB、串口等其他方式把Wi-Fi凭据传入的。而且，实际上非专业的客户也不可能真的去写这些<code>wpa_cli</code>命令。</p>\n<p>Nordic当然也提供了通过BLE配置Wi-Fi凭据的方案，例程是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples/wifi/provisioning/README.html#wi-fi-provisioning-service\">Wi-Fi: Provisioning Service</a>，位于<code>$&#123;NCS&#125;/nrf/samples/wifi/provisioning</code>。这是一个完整的BLE服务，可以通过手机APP（<a href=\"https://play.google.com/store/apps/details?id=no.nordicsemi.android.wifi.provisioning\">安卓版本</a>和<a href=\"https://apps.apple.com/cn/app/nrf-wi-fi-provisioner/id1638948698\">iOS版本</a>都有）对nRF7002DK进行配网。手机App和BLE Service之间数据的格式使用<a href=\"https://protobuf.dev/\">Protocol Buffers</a>来管理。当然手机App的源码也是开放的，客户可以把它们集成到自己的手机App中：</p>\n<ul>\n<li><a href=\"https://github.com/NordicSemiconductor/Android-nRF-Wi-Fi-Provisioner\">https://github.com/NordicSemiconductor/Android-nRF-Wi-Fi-Provisioner</a></li>\n<li><a href=\"https://github.com/NordicSemiconductor/IOS-nRF-Wi-Fi-Provisioner\">https://github.com/NordicSemiconductor/IOS-nRF-Wi-Fi-Provisioner</a></li>\n</ul>\n<p>如果你愿意阅读这个BLE Service的源码，会发现这个Service中，它通过BLE获得Wi-Fi密码后，也是用前面说的 Wi-Fi credentials 库对凭据进行存储。此外，它连接Wi-Fi所使用的方法是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">rc = net_mgmt(NET_REQUEST_WIFI_CONNECT, iface,</span><br><span class=\"line\">             &amp;cnx_params, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> wifi_connect_req_params));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这段代码位于<code>$&#123;NCS&#125;/nrf/subsys/bluetooth/services/wifi_prov/wifi_prov_handler.c</code></p>\n</blockquote>\n<p>这又是一个Network Management API。其注册的位置在<code>$&#123;NCS&#125;/zephyr/subsys/net/l2/wifi/wifi_mgmt.c</code>。它需要的参数除了基本的wifi连接所需的信息以外，还需要的就是一个Interface。而这个Interface已经由nRF7002的驱动提供好了，就像前文所述，直接用<code>net_if_get_default()</code>就能获得这个Interface。</p>\n<p>如果你想用其他方式配置Wi-Fi凭据，也推荐参考这个BLE Service中连接Wi-Fi的方式。</p>\n<h2 id=\"4-4-MQTT连接过程\"><a href=\"#4-4-MQTT连接过程\" class=\"headerlink\" title=\"4.4. MQTT连接过程\"></a>4.4. MQTT连接过程</h2><h3 id=\"MQTT-Helper-库\"><a href=\"#MQTT-Helper-库\" class=\"headerlink\" title=\"MQTT Helper 库\"></a>MQTT Helper 库</h3><p>Zephyr有一个很基础的<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/mqtt.html#mqtt\">MQTT库</a>，支持MQTT 3.1.0和3.1.1。它是基于Socket编写的，简单直接，但是不太好用。由于它只提供API，也就是连接、发布、订阅这些，还要开发者自己处理一些文件描述符（fd）。在之前版本的NCS中有个例程叫<code>mqtt_simple</code>，MQTT的心跳包甚至要在main.c里单独用一个定时任务来发送，目前这个例程已经被删除了。</p>\n<p>Nordic提供了<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/mqtt_helper.html#api-documentation\">MQTT Helper库</a>，对Zephyr的MQTT接口进行了封装，使其更加易用。一方面，它单独建立了一个线程，用来发送MQTT心跳包；另一方面，它把大部分重要的MQTT参数都变成了Kconfig菜单中的参数，便于你做配置。</p>\n<p>通过阅读例程<code>src/modules/transport/transport.c</code>，可知MQTT Helper的用法：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231005225532340.png\" alt=\"image-20231005225532340\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231005230011226.png\" alt=\"image-20231005230011226\"></p>\n<p>基本上，就是配好回调函数和各种参数，初始化一下再连接服务器即可。当然，实际的例程代码写的不是这么直接。</p>\n<h3 id=\"Zephyr状态机框架-SMF-State-Machine-Framework\"><a href=\"#Zephyr状态机框架-SMF-State-Machine-Framework\" class=\"headerlink\" title=\"Zephyr状态机框架 (SMF, State Machine Framework)\"></a>Zephyr状态机框架 (SMF, State Machine Framework)</h3><p>由于<code>transport.c</code>代码中的MQTT连接并不是像前文说的直来直去进行的，而是分散在各处。因此，在继续分析MQTT代码之前，有必要先分析一下SMF的代码，以方便不熟悉的读者。</p>\n<p>我们知道状态机是开发中常用的一种框架，只要<strong>明确</strong>规定好一个模块被允许存在的所有状态、规定好每个状态下被允许的行为，以及各个状态之间切换的条件，就能写出较为完善、逻辑清晰、健壮性强、易于调试的代码。</p>\n<p>最常见的状态机代码是用<code>switch...case</code>语句编写的，通过一个<code>state</code>变量来判断当前处于哪个<code>case</code>，执行完不同的处理代码后，根据其他变量、事件等等不同的因素，来决定是否要切换到其他<code>state</code>值。常见的例子是写一个自定义二进制协议的解包代码，“状态”就是当前正在处理的是包头、数据、包尾还是转义字符，而“切换条件”就是输入的二进制流。</p>\n<p>Zephyr SMF和<code>switch...case</code>也没什么区别，只不过它把各个步骤进行了拆分，让你把“状态机的结构”和“各个状态的处理代码”分开，然后通过回调函数注册。比如，它把每个状态内的处理函数分为了<code>entry</code>、<code>run</code>、<code>exit</code>三部分，分别对应“进入此状态时要执行的一次性代码”、“在此状态循环处理时运行的代码”、“退出此状态时要执行的一次性代码”，让你不用写一堆标志位来判断状态的切换、也不用在<code>switch...case</code>语句中嵌套一堆<code>if...else</code>语句。另一方面，SMF也做好了状态机的嵌套处理，每个状态的内部还可以有一堆子状态，每个子状态也可以有<code>entry</code>、<code>run</code>、<code>exit</code>三个处理函数。通过把这些内容拆开，让我们可以先定义好一个状态机的结构，再给每个状态和子状态注册回调函数，从而使得代码更加清晰。</p>\n<p>要使用SMF，首先需要定义上下文(context)结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">s_object</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* This must be first */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">smf_ctx</span> <span class=\"title\">ctx</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Last channel type that a message was received on */</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zbus_channel</span> *<span class=\"title\">chan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Network status */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">network_status</span> <span class=\"title\">status</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Payload */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">payload</span> <span class=\"title\">payload</span>;</span></span><br><span class=\"line\">&#125; s_obj;</span><br></pre></td></tr></table></figure>\n\n<p>所谓的上下文，就是你在处理这个状态机时所需要的全部信息，例如标志位等，把他们全填入这个自定义结构体。</p>\n<p>然后，定义好所有的状态枚举，注册好每个状态的<code>entry</code>、<code>run</code>和<code>exit</code>函数即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Internal states */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">module_state</span> &#123;</span> MQTT_CONNECTED, MQTT_DISCONNECTED &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Construct state table */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">smf_state</span> <span class=\"title\">state</span>[] =</span> &#123;</span><br><span class=\"line\">    [MQTT_DISCONNECTED] = SMF_CREATE_STATE(disconnected_entry, disconnected_run, <span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    [MQTT_CONNECTED] = SMF_CREATE_STATE(connected_entry, connected_run, connected_exit),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>关于状态切换，可以用<code>smf_set_state</code>函数，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">smf_set_state(SMF_CTX(&amp;s_obj), &amp;state[MQTT_CONNECTED]);</span><br></pre></td></tr></table></figure>\n\n<p>状态切换时，就会执行前一个状态的<code>exit</code>函数，以及后一个状态的<code>entry</code>函数。</p>\n<p>在本模块的线程函数中，每次通过ZBus接收到新的消息后，都会通过<code>smf_run_state(SMF_CTX(&amp;s_obj))</code>来处理这个消息携带的数据。这个函数底层执行的就是当前状态的<code>run</code>函数。</p>\n<p>由此可见SMF也是比较简单易用的，步骤就是先定义状态，然后注册回调函数，最后执行。</p>\n<p>MQTT的连接就发生在状态机执行初始状态的这一步：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Set initial state */</span></span><br><span class=\"line\">    smf_set_initial(SMF_CTX(&amp;s_obj), &amp;state[MQTT_DISCONNECTED]);</span><br></pre></td></tr></table></figure>\n\n<p>这时就会执行初始状态的<code>entry</code>函数，进行MQTT的连接。</p>\n<blockquote>\n<p>其他补充：</p>\n<ol>\n<li>本例程没有展示出状态机嵌套的功能，要想了解这部分，可以参考<a href=\"https://docs.zephyrproject.org/latest/services/smf/index.html\">SMF文档</a>。</li>\n<li>SMF的<code>run</code>函数和<code>set_state</code>函数何时执行，完全由开发者决定，如果你想要事件驱动型的状态机框架（阻塞等待某个事件，然后再执行run函数），可以参考SMF文档中的写法。。</li>\n<li>在<code>exit</code>函数内部进行<code>set_state</code>这种行为是有歧义的，因为<code>set_state</code>本身就是要进入一个新的状态，而<code>set_state</code>内部同时也会调用前一个状态的<code>exit</code>函数，因此SMF底层会拒绝这种操作，会报错。</li>\n<li>SMF框架没有限制<code>set_state</code>函数必须和状态机本身的<code>run</code>函数处于同一个线程（本例程中，<code>set_state</code>就在MQTT的回调函数中，与状态机不在一个线程）。因此完全有可能出现<code>run</code>函数还没执行完，<code>exit</code>函数就在另一个线程被执行了的情况。开发者自己要控制好这一情况。</li>\n<li>为了防止<strong>4</strong>的情况出现，我们的回调函数，不论是MQTT回调函数，还是状态机的回调函数，都要<strong>快进快出</strong>，而且要保证在状态机层面上是<strong>原子操作</strong>。因此，我们可以发现代码中，这些回调函数实际都没做什么工作，而是把具体的代码提交到<a href=\"https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html\">work queue</a>去执行，然后就马上返回了。work queue是个单独的线程，从work queue的层面上讲，每个work都是“原子”的，就不用担心<strong>4</strong>中的情况了。</li>\n</ol>\n</blockquote>\n<h3 id=\"TLS-Credentials-库与证书管理\"><a href=\"#TLS-Credentials-库与证书管理\" class=\"headerlink\" title=\"TLS Credentials 库与证书管理\"></a>TLS Credentials 库与证书管理</h3><p>我们知道，SSL加密通信，其核心不仅仅在于加密，还在于身份的认证，需要确保对方真的是你想要连接的那个对象，这里就分为三种情况：</p>\n<ul>\n<li><p>如果只是设备验证服务器，单向验证，则设备中需要存储服务器对应的<strong>CA证书</strong>，用CA证书校验服务器出示的证书是否合法。这也是我们电脑访问各大网站的常见方式。</p>\n</li>\n<li><p>如果只是服务器验证设备，单向验证，则设备中需要存储<strong>客户端证书</strong>，用于出示给服务器。服务器中预先注册了设备的证书信息，因此可以检查设备是否是冒充的。当然，设备也需要存储此证书对应的<strong>私钥</strong>；</p>\n</li>\n<li><p>若双向都要验证，则三样都需要。这也是目前物联网行业常见的方式。</p>\n</li>\n</ul>\n<p>在MQTTX客户端软件中，我们就可以看到这三个文件的配置项：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006004212156.png\" alt=\"image-20231006004212156\"></p>\n<p>如果我们的开发板要想通过MQTTS连接到MQTT Broker，当然也需要存储这些凭据信息。</p>\n<p>我们使用的电脑已经预安装了世界上各大CA机构的证书，因此我们访问世界上绝大多数服务器，都可以用已经安装的CA证书去检查该服务器是否是冒充的。但是嵌入式设备不可能存这么多证书，最好是按需存储，要通过TLS连哪个服务器，就只存哪个服务器对应的CA证书。</p>\n<p>Zephyr提供了<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/sockets.html#tls-credentials-subsystem\">TLS Credentials</a>库来管理各类证书、私钥。简而言之，它管理了一个TLS连接所需的<strong>CA证书</strong>、<strong>设备证书</strong>、<strong>设备私钥</strong>，并且通过一个编号来索引。每次要进行TLS连接时，只需要指定一个编号即可，这个编号叫做<code>SEC_TAG</code>。</p>\n<p>直观地说，就是要先存储证书和私钥：</p>\n<img src=\"/jayant97.github.io/imgs/在nRF7002开发板上运行MQTT例程.assets/image-20231006010250433.png\" alt=\"image-20231006010250433\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>同一个TLS连接所需的CA证书、设备证书、设备私钥都存储在同一个<code>SEC_TAG</code>下。</p>\n</blockquote>\n<p>然后，在底层建立Socket连接时，通过传参传入<code>SEC_TAG</code>，就可以使用这些证书了：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006010436194.png\" alt=\"image-20231006010436194\"></p>\n<p>这个库的设计逻辑在于<strong>“存储”与“使用”分离</strong>。存储后端可以自由切换，它既可以是单纯的Flash存储，也可以是ARM平台安全架构（PSA）提供的安全存储服务（Protected Storage Service）。</p>\n<p>一个实例就是nRF9160，我们知道9160的证书是通过python脚本或者nRF Connect for Desktop软件烧录到Modem中的（底层都是AT指令），烧录时其实就指定了Security Tag号（例如，nRF Cloud默认用的就是<code>16842753</code>）。在应用层建立TLS连接时（例如连接到nRF Cloud时），都是通过<code>SEC_TAG</code>号来访问私钥的。这样既能完成握手，又能让应用层无法读取到证书、私钥的内容，从而确保了信息安全。</p>\n<blockquote>\n<p>实际上，9160的证书和私钥可以不烧进去，而是直接在Modem内部生成。然后生产线上只取出证书，上传到服务器即可，从而确保私钥绝对不会泄漏。</p>\n</blockquote>\n<h3 id=\"MQTT证书文件配置流程\"><a href=\"#MQTT证书文件配置流程\" class=\"headerlink\" title=\"MQTT证书文件配置流程\"></a>MQTT证书文件配置流程</h3><p>回到例程中来，我们的证书究竟是如何配置进去的？</p>\n<p>首先，例程默认连接的服务器是<code>mqtt://test.mosquitto.org:1883</code>。我们可以用HTTP协议，也就是直接用浏览器访问<a href=\"https://test.mosquitto.org/%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%8B%E7%BB%8D%EF%BC%9A\">https://test.mosquitto.org/，查看介绍：</a></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006012304338.png\" alt=\"image-20231006012304338\"></p>\n<p>我们可以得知，这个服务器有许多端口，每个不同的端口上运行的是不同的协议。其中8883端口运行的是MQTT over TLS，并且只需单向验证服务器，服务器不需要验证客户端。 </p>\n<p>我们先看看之前添加的<code>overlay-tls-nrf7002.conf</code>里有哪些与SSL有关的config：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006004756724.png\" alt=\"image-20231006004756724\"></p>\n<p>首先要使能TLS，然后是目标服务器的端口号要改为8883。然后选择载入默认的SSL证书，启用加密库，最后Socket也要启用TLS的支持。</p>\n<p>MQTT Helper有默认的证书文件名，我们可以看到在<code>$&#123;NCS&#125;/nrf/subsys/net/lib/mqtt_helper/cert/mqtt-certs.h</code>中，默认包含的CA证书文件名为<code>ca-cert.pem</code>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006013111085.png\" alt=\"image-20231006013111085\"></p>\n<p>而<code>CONFIG_MQTT_HELPER_PROVISION_CERTIFICATES</code>配置决定了MQTT Helper会不会在编译时自动包含这个证书，并且在MQTT连接前自动载入这个证书。具体代码位于<code>$&#123;NCS&#125;/nrf/subsys/net/lib/mqtt_helper/mqtt_helper.c</code></p>\n<blockquote>\n<p>读者可以尝试把服务器改成<code>broker.emqx.io</code>，这是另一个免费的测试用MQTT broker，文档地址是<a href=\"https://www.emqx.com/zh/mqtt/public-mqtt5-broker\">https://www.emqx.com/zh/mqtt/public-mqtt5-broker</a></p>\n<p>在网页上下载到CA证书后，把代码中的<code>ca-cert.pem</code>改成下载好的证书即可。注意不能直接改文件名，因为这个文件是在C语言中被当成字符串包含的，所以下载好的证书要编辑一下，把里面的内容都用引号括起来，并添加好<code>\\n</code>。</p>\n</blockquote>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><ol>\n<li>MQTT是轻量高效的网络协议，适合物联网，实现了设备间解耦通信。</li>\n<li>由于是例程，Wi-Fi的凭据和TLS的凭据都是静态配置，被编译进固件的。编译前注意检查配置。</li>\n<li>例程是无main架构，各个模块通过ZBUS进行线程间通信。</li>\n<li>程序先连上MQTT broker，然后订阅主题，再然后定时发布消息。</li>\n<li>Zephyr提供了状态机框架SMF</li>\n<li>Wi-Fi 连接的底层是 WPA Supplicant 软件，也有Network Management API可用。Wi-Fi凭据的存储用的是 Wi-Fi Credential 库。 Wi-Fi Credential 使用 SSID 来索引。</li>\n<li>MQTTS连接使用MQTT Helper库。MQTTS的连接需要SSL，SSL证书的存储用的是 TLS Credential库。它使用SEC_TAG来索引。</li>\n</ol>\n","categories":["Nordic","Wi-Fi"],"tags":["Nordic","nRF_Cloud","nRF70"]},{"title":"安装nRF-Connect-SDK","url":"/jayant97.github.io/2022/12/779143a4bec8/","content":"<p>​\tnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台支持Nordic所有产品线的所有技术，包括BLE，AoA，NFC，蜂窝网与GPS，Wi-Fi，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>\n<p>​\tNCS是跨平台的（Windows&#x2F;Linux&#x2F;OSX），其基础是Zephyr系统。Zephyr系统是Linux基金会维护的一个项目，除了一个基本的Zephyr RTOS之外，还有很多方便的第三方软件库，像是MCUBoot、TCP&#x2F;UDP&#x2F;MQTT&#x2F;TLS等网络库等等。</p>\n<p>​\t更多信息可参考：</p>\n<ul>\n<li><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/installation.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/installation.html</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n</li>\n</ul>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>​\t本节将会详细介绍如何在一台<strong>Windows</strong> 11的电脑上安装NCS开发环境（Windows 10也适用），包含NCS、编译器以及其他工具。<em>如果你已经安装好NCS开发环境，可以跳过本节</em>。</p>\n<p>​\t需要安装的内容列表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">软件</th>\n<th>分类</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></td>\n<td>编辑器</td>\n<td>代码文本编辑器，并且通过安装插件的方式为其他开发调试工具提供可视化界面</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-command-line-tools\">nRF Command Line Tools</a></td>\n<td>工具链</td>\n<td>Jlink驱动、nrfjprog等命令行烧录工具</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop\">nRF Connect for Desktop</a></td>\n<td>桌面工具</td>\n<td>桌面工具集合，含SDK安装器、功耗评估、射频抓包等工具</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><a href=\"https://git-scm.com/\">Git</a></td>\n<td>工具链</td>\n<td>版本管理工具</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><a href=\"https://www.python.org/downloads/release/python-3913/\">Python 3.9</a></td>\n<td>工具链</td>\n<td>为编译套件的python脚本提供运行环境</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\"><a href=\"https://ninja-build.org/\">Ninja</a></td>\n<td>工具链</td>\n<td>快速构建工具（类似make）</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\"><a href=\"https://cmake.org/\">CMake</a></td>\n<td>工具链</td>\n<td>工程管理器，根据配置生成.ninja或Makefile文件的工具</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\"><a href=\"https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html\">Zephyr SDK</a></td>\n<td>工具链</td>\n<td>交叉编译工具链（编译器、链接器等）</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\"><a href=\"https://github.com/nrfconnect/sdk-nrf\">NCS</a></td>\n<td>SDK源码包</td>\n<td>含nRF产品驱动包、内核、第三方库等代码和编译配置文件等</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\">VS Code: nRF Connect插件包</td>\n<td>编辑器</td>\n<td>在VS Code中为NCS功能提供可视化</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-下载安装包并进行安装\"><a href=\"#2-下载安装包并进行安装\" class=\"headerlink\" title=\"2. 下载安装包并进行安装\"></a>2. 下载安装包并进行安装</h1><p>​\t上述列表中1~3号软件都是使用<strong>安装包</strong>的形式进行安装，点击表格中的链接进入官网，下载安装后可以直接双击安装。安装路径需要无中文、空格或“-”，“_”以外的特殊字符。</p>\n<p>​\tVS Code的安装，这里不做介绍，一步一步安装即可。剩余的两个Nordic的工具，安装方式是类似的。下图仅示例nRF Connect for Desktop的下载方式：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122214235111.png\" alt=\"image-20221122214235111\"></p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122213145436.png\" alt=\"image-20221122213145436\" style=\"zoom: 67%;\" />\n\n<center>“开始”菜单中安装好的工具（未完全展示）</center>\n\n<h1 id=\"3-安装SDK和工具链\"><a href=\"#3-安装SDK和工具链\" class=\"headerlink\" title=\"3. 安装SDK和工具链\"></a>3. 安装SDK和工具链</h1><h2 id=\"3-1-自动安装与手动安装的区别\"><a href=\"#3-1-自动安装与手动安装的区别\" class=\"headerlink\" title=\"3.1. 自动安装与手动安装的区别\"></a>3.1. 自动安装与手动安装的区别</h2><p>​\t列表中4~10号软件有2种安装方式，<strong>自动安装</strong>和<strong>手动安装</strong>。</p>\n<ul>\n<li><strong>自动安装（推荐）</strong>：自动下载SDK和工具链，所有工具链都放在一个文件夹内，编译时，只使用此文件夹内的工具链。工具链与电脑上本身安装的软件不冲突；</li>\n<li><strong>手动安装</strong>：只拉取SDK，工具链单独安装到电脑里，并添加到PATH环境变量，编译时直接用PATH环境变量。</li>\n</ul>\n<h2 id=\"3-1-自动安装\"><a href=\"#3-1-自动安装\" class=\"headerlink\" title=\"3.1. 自动安装\"></a>3.1. 自动安装</h2><p>打开刚刚安装的nRF Connect for Desktop软件，找到<strong>Toolchain Manager</strong>，Install然后Open。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122214549553.png\" alt=\"image-20221122214549553\" style=\"zoom: 50%;\" />\n\n\n\n<p>打开后，先在SETTINGS中选择自己想要存放NCS和toolchains的位置：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122215033170.png\" alt=\"image-20221122215033170\" style=\"zoom: 50%;\" />\n\n\n\n<p>然后，在SDK ENVIRONMENTS中选择想安装的SDK版本进行安装（如①）。<strong>由于是从Github拉取，可能会要很久</strong>。安装完毕后，可打开VS Code（如②）。也可以在对应目录下打开终端（如③④）。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122215310523.png\" alt=\"image-20221122215310523\" style=\"zoom: 50%;\" />\n\n<p>点击“打开VS Code”，它会弹窗提示，帮你自动安装VS Code的nRF Connect插件包，如下图：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221123161445490.png\" alt=\"image-20221123161445490\" style=\"zoom: 50%;\" />\n\n<h3 id=\"【重要】检查安装是否完整\"><a href=\"#【重要】检查安装是否完整\" class=\"headerlink\" title=\"【重要】检查安装是否完整\"></a>【重要】检查安装是否完整</h3><p>由于墙的存在，即使没有任何报错，SDK很有可能安装是不完整的。不过不必担心toolchain不完整，因为toolchain不完整的时候会报错。</p>\n<p>这时，需要在SDK的目录下打开命令行。但不是直接打开，因为直接打开命令行，环境变量都是PATH。而是要从上图的“Open command prompt”来打开命令行，这时，打开的命令行中的环境变量是指向Toolchain文件夹的。</p>\n<p>打开后，输入<code>west update</code>。NCS是由多个Github上的仓库组成的，此命令会依次pull这些仓库，如果有文件缺失，就能从命令行的输出看出来。</p>\n<p>如果某些仓库pull失败，就继续不断重复执行<code>west update</code>，因为它是可以断点继续下载的。直到命令不报错为止，则说明仓库全部拉取完毕。</p>\n<p>最后执行<code>west zephyr-export</code>，此命令会让工具链中的CMake记住SDK的位置。</p>\n<h2 id=\"3-2-手动安装方式\"><a href=\"#3-2-手动安装方式\" class=\"headerlink\" title=\"3.2. 手动安装方式\"></a>3.2. 手动安装方式</h2><p>安装过程需要网络代理（注意，命令行终端也需要被代理）</p>\n<h3 id=\"（1）【Windows专用】安装choco\"><a href=\"#（1）【Windows专用】安装choco\" class=\"headerlink\" title=\"（1）【Windows专用】安装choco\"></a>（1）【Windows专用】安装choco</h3><p>​\t<code>choco</code>是一个包管理工具，类似于Ubuntu中的<code>apt-get</code>，可以通过命令行安装软件工具，<strong>并自动添加到全局PATH环境变量中</strong>。</p>\n<p>​\t首先右键单击开始菜单，然后打开管理员终端，输入以下命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置脚本执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">Set-ExecutionPolicy</span> AllSigned</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从网络端执行安装脚本</span></span><br><span class=\"line\"><span class=\"built_in\">Set-ExecutionPolicy</span> Bypass <span class=\"literal\">-Scope</span> <span class=\"keyword\">Process</span> <span class=\"literal\">-Force</span>; [<span class=\"type\">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class=\"type\">System.Net.ServicePointManager</span>]::SecurityProtocol <span class=\"operator\">-bor</span> <span class=\"number\">3072</span>; <span class=\"built_in\">iex</span> ((<span class=\"built_in\">New-Object</span> System.Net.WebClient).DownloadString(<span class=\"string\">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>测试是否安装成功：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">choco</span><br><span class=\"line\"><span class=\"comment\"># 有版本号输出即为成功</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）利用choco安装其他工具\"><a href=\"#（2）利用choco安装其他工具\" class=\"headerlink\" title=\"（2）利用choco安装其他工具\"></a>（2）利用choco安装其他工具</h3><p>部分工具也可自己去官网下载，并用安装包安装，<strong>注意安装时要勾选“添加到PATH环境变量”</strong>。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置choco</span></span><br><span class=\"line\">choco feature enable <span class=\"literal\">-n</span> allowGlobalConfirmation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装cmake (也可以把这步替换成从官网下载cmake安装包，注意安装时要勾选添加进PATH环境变量)</span></span><br><span class=\"line\">choco install cmake <span class=\"literal\">--installargs</span> <span class=\"string\">&#x27;ADD_CMAKE_TO_PATH=System&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装git (也可以把这步替换成从官网下载git安装包，注意安装时要勾选添加到环境变量)</span></span><br><span class=\"line\">choco install git </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装python (建议把这步换成从官网下载python3.9安装包，并勾选添加到环境变量,通过choco安装容易出错)</span></span><br><span class=\"line\">choco install python <span class=\"literal\">--version</span>=<span class=\"number\">3.9</span>.<span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装其他工具</span></span><br><span class=\"line\">choco install ninja gperf dtc<span class=\"literal\">-msys2</span> <span class=\"built_in\">wget</span> unzip</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Git也建议从官网安装，同时勾选安装Git bash。可以让你在windows上使用bash终端，而不是powershell。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221204224509512.png\" alt=\"image-20221204224509512\" style=\"zoom: 50%;\" />\n</blockquote>\n<h3 id=\"（3）安装GN工具（可选）\"><a href=\"#（3）安装GN工具（可选）\" class=\"headerlink\" title=\"（3）安装GN工具（可选）\"></a>（3）安装GN工具（可选）</h3><p>GN工具是开发<a href=\"https://www.nordicsemi.com/Products/Matter\">Matter</a>所需的工具。</p>\n<p>从<a href=\"https://gn.googlesource.com/gn/#getting-a-binary\">GN网站</a>下载编译好的Windows压缩包（Getting a binary），推荐在用户目录（<code>C:\\Users\\&lt;用户名&gt;</code>）下解压。并且添加到PATH环境变量即可。</p>\n<blockquote>\n<p>如果你的Windows用户名是中文，那还是换个无中文的目录。</p>\n</blockquote>\n<h3 id=\"（4）安装west\"><a href=\"#（4）安装west\" class=\"headerlink\" title=\"（4）安装west\"></a>（4）安装west</h3><p>west是一个多仓库管理工具（类似Android的repo），支持添加自定义插件。在NCS中，除了可以管理NCS仓库外，也通过插件实现了板卡选择、触发编译动作、触发flash烧写的功能。</p>\n<p>利用Python的pip进行安装</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install west</span><br><span class=\"line\"><span class=\"comment\"># 若python版本不对，这一步可能会报错</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（5）安装NCS\"><a href=\"#（5）安装NCS\" class=\"headerlink\" title=\"（5）安装NCS\"></a>（5）安装NCS</h3><p>nRF Connect SDK前面已经介绍过，含驱动、内核以及第三方库的源码。</p>\n<ol>\n<li>在一个无中文、无空格的合适路径下打开终端（powershell或bash）：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">#创建并进入文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ncs</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ncs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化仓库（从github拉取）</span></span><br><span class=\"line\">west init -m https://github.com/nrfconnect/sdk-nrf --mr v2.4.2</span><br><span class=\"line\"><span class=\"comment\"># 也可选择其他分支或tag，如：</span></span><br><span class=\"line\"><span class=\"comment\"># west init -m https://github.com/nrfconnect/sdk-nrf --mr main</span></span><br><span class=\"line\"><span class=\"comment\"># 但通常不建议用户使用main分支</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>这一步如果下载失败想重新下载，<strong>需要把创建的ncs文件夹下的所有内容删除干净</strong>，尤其是<code>.west</code>隐藏文件夹。然后再次执行<code>west init</code>即可；</li>\n<li>如果网络实在差，可以从百度网盘下载，见<a href=\"https://www.cnblogs.com/iini/p/14174427.html\">《开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序》 - iini - 博客园 (cnblogs.com)</a></li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>更新仓库</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#更新仓库</span></span><br><span class=\"line\">west update</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于国内网络原因，这一步也<strong>经常</strong>失败，但是没关系，每次<code>west update</code>都能下载一点点，如果失败了，就重复<code>west update</code>就行了。不需要像<code>west init</code>失败一样删除干净重新下载。</p>\n</blockquote>\n<ol start=\"3\">\n<li>导出Zephyr CMake package，便于CMake自动识别SDK的路径，后续生成工程</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">west zephyr<span class=\"literal\">-export</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"4\">\n<li>安装额外的python依赖</li>\n</ol>\n<blockquote>\n<p>​\t安装python依赖之前，还需要安装”Microsoft Visual C++ Build Tools 14.0”或更高版本：<a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\">Microsoft C++ Build Tools - Visual Studio</a>，用来编译这些python工具。在上述微软链接下载，会获得一个VS安装工具。只在Workloads栏里选择 **”Desktop Development with C++”**，然后安装即可。</p>\n</blockquote>\n<p>​\t安装python依赖包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install -r zephyr/scripts/requirements.txt</span><br><span class=\"line\">pip3 install -r nrf/scripts/requirements.txt</span><br><span class=\"line\">pip3 install -r bootloader/mcuboot/scripts/requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（6）安装Zephyr-SDK工具链\"><a href=\"#（6）安装Zephyr-SDK工具链\" class=\"headerlink\" title=\"（6）安装Zephyr SDK工具链\"></a>（6）安装Zephyr SDK工具链</h3><p>​\tZephyr SDK是编译器、链接器等工具。建议放在用户目录下（同样的，如果你的用户名是中文，还是换个目录吧）。</p>\n<p>​\t下方展示了通过Poweshell命令下载Zephyr SDK的方式。其中Zephyr工具链的版本是我安装时使用的版本。你需要获取最新的版本，最新版本的下载地址可从 <a href=\"https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html#install-zephyr-sdk-on-windows\">Zephyr SDK — Zephyr Project Documentation</a> 获取。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入到用户目录（c:\\Users\\[用户名]）</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HOME</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是你的终端是bash而非powershell，则命令为</span></span><br><span class=\"line\"><span class=\"comment\"># cd ~</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载（最新版本的下载地址可从上述链接获取）</span></span><br><span class=\"line\"><span class=\"built_in\">wget</span> https://github.com/zephyrproject<span class=\"literal\">-rtos</span>/sdk<span class=\"literal\">-ng</span>/releases/download/v0.<span class=\"number\">15.1</span>/zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span>_windows<span class=\"literal\">-x86_64</span>.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">unzip zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span>_windows<span class=\"literal\">-x86_64</span>.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span></span><br><span class=\"line\">setup.cmd</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li><code>setup.cmd</code>只需执行一次。如果改变了安装位置，需要再次执行。</li>\n<li>Zephyr SDK安装完成后，会发现：如果在前面安装了ncs的目录下执行<code>west --help</code>会比其他目录下执行<code>west --help</code>多出一些扩展指令，如<code>build</code>,<code>board</code>等等。这是因为NCS中的<code>.west</code>文件夹的配置了Zephyer的base路径，提供了这个仓库独有的插件。这些扩展的指令就是调用了插件进行编译、调试、烧写等工作。<br>为了让其他目录下也能使用Zephyr工具，需要设置全局环境变量：<br><strong>在Windows环境变量中新建<code>ZEPHYR_BASE</code>环境变量，并把其值设置为<code>ncs</code>安装目录下的<code>zephyr</code>目录的路径即可。</strong></li>\n</ul>\n<p>（这个效果和执行一次<code>ncs</code>目录下的<code>zephyr/zephyr-env.cmd</code>脚本是一样的，但这个脚本设置环境变量只是临时生效，关闭终端再另开一个终端就不起作用了。而设置全局环境变量是永久生效。）</p>\n</blockquote>\n<h3 id=\"（7）安装VS-Code插件\"><a href=\"#（7）安装VS-Code插件\" class=\"headerlink\" title=\"（7）安装VS Code插件\"></a>（7）安装VS Code插件</h3><p>​\t打开VS Code，在插件中心搜索nRF Connect for VS Code Extension Pack，这个插件包会自动安装其他nRF Connect 所需的VS Code插件。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122220619736.png\" alt=\"image-20221122220619736\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t可以在VS Code的设置中，对插件进行单独的设置，例如可以设置使用工具链的路径。可以对<strong>全局</strong>进行设置（USER），也可以单独对某个<strong>工作区</strong>进行设置（WORKSPACE）。</p>\n<p><img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122220941604.png\" alt=\"image-20221122220941604\" style=\"zoom: 80%;\" />\t由于我们是手动安装的，已经设置了<code>PATH</code>环境变量。所以把插件设置的工具链路径设为<code>PATH</code>即可。</p>\n<h2 id=\"3-3-SDK更新\"><a href=\"#3-3-SDK更新\" class=\"headerlink\" title=\"3.3. SDK更新\"></a>3.3. SDK更新</h2><p>手动安装和自动安装的SDK是一样的。如果有新版本SDK出来，想切换到新版本，都可以按照以下步骤操作：</p>\n<h3 id=\"确保SDK中的git仓库状态均为Clean\"><a href=\"#确保SDK中的git仓库状态均为Clean\" class=\"headerlink\" title=\"确保SDK中的git仓库状态均为Clean\"></a>确保SDK中的git仓库状态均为Clean</h3><p>这意味着，<strong>客户平时不要随便去改SDK中的任何代码</strong>。也不要往里添加任何内容。但是编译例程是没问题的，因为例程编译目录<code>build*</code>是被<code>.gitignore</code>忽略掉的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此命令可查看当前git仓库的状态</span></span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>但是NCS中的仓库很多。也可以用VS Code打开整个NCS，用git界面图形化查看是否每个仓库均为clean。</p>\n<h3 id=\"检查manifest有无新版本\"><a href=\"#检查manifest有无新版本\" class=\"headerlink\" title=\"检查manifest有无新版本\"></a>检查manifest有无新版本</h3><p>NCS中，nrf为主仓库，nrf的版本即为整个SDK的版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看nfr仓库下有多少版本</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nrf</span><br><span class=\"line\">git pull</span><br><span class=\"line\">git tag  <span class=\"comment\"># 按键盘上下键翻阅，按q退出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"切换到自己想要的版本\"><a href=\"#切换到自己想要的版本\" class=\"headerlink\" title=\"切换到自己想要的版本\"></a>切换到自己想要的版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检出想要的版本</span></span><br><span class=\"line\">git checkout v2.4.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新整个仓库</span></span><br><span class=\"line\">west update</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-打开一个例程\"><a href=\"#4-打开一个例程\" class=\"headerlink\" title=\"4. 打开一个例程\"></a>4. 打开一个例程</h1><p>从VS Code 的一个全新窗口，选择<strong>打开文件夹</strong>：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209103137554.png\" alt=\"image-20221209103137554\"></p>\n<center>或者：</center>\n\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209103240455.png\" alt=\"image-20221209103240455\"></p>\n<blockquote>\n<p>含有例程的目录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NCS </span><br><span class=\"line\">|-- nrf                      </span><br><span class=\"line\">|   |-- applications/      # Nordic商业级例程</span><br><span class=\"line\">|   |-- samples/           # Nordic外设、蓝牙、LTE等例程</span><br><span class=\"line\">|   |-- tests/             # 模块测试例程</span><br><span class=\"line\">`-- zephyr</span><br><span class=\"line\">    |-- samples            # Zephyr Kernel、各类板子、各类传感器芯片例程</span><br><span class=\"line\">    `-- tests              # 模块测试例程</span><br></pre></td></tr></table></figure>\n\n<p><code>zephyr/samples/</code>中有RTOS的组件例程、Zephyr支持的各类厂商的板卡例程、各类传感器的例程等，其中也有蓝牙例程。</p>\n<p><code>zephyr/tests/</code>中有<strong>全部的</strong>API测试例程。</p>\n<p><code>nrf</code>仓库的目录结构仿造<code>zephyr</code>仓库，也有<code>samples/</code>和<code>tests/</code>目录。<code>samples/</code>中有Nordic提供的软件库例程、Zephyr未收录的例程（如 nRF9160的LTE）等。</p>\n</blockquote>\n<p>我们选择一个蓝牙例程，<code>nrf/samples/bluetooth/peripheral_uart</code>，并打开文件夹。这只是在VS Code 中打开，打开后，nRF Connect 插件会检测到这是一个Application文件夹，询问你是否要把它加入到nRF Connect插件的Application中，点击Yes即可：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209110542991.png\" alt=\"image-20221209110542991\"></p>\n<p>打开后，在VS Code资源管理器中可以看到文件夹视图：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209113911545.png\" alt=\"image-20221209113911545\"></p>\n<p>​\t另外，也可以在Application中看到这个例程：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209112255254.png\" alt=\"image-20221209112255254\"></p>\n<h1 id=\"5-以例程为模板创建新工程\"><a href=\"#5-以例程为模板创建新工程\" class=\"headerlink\" title=\"5. 以例程为模板创建新工程\"></a>5. 以例程为模板创建新工程</h1><p>上一节讲解了如何<strong>打开</strong>一个例程。</p>\n<p>如果我们只是打开例程，例程的文件夹还是在ncs仓库内部，受到ncs的git仓库的管理。如果想自己开发项目，并用git管理版本，就需要<strong>创建</strong>新工程。</p>\n<p>NCS支持把例程当作模板，复制到NCS外部，并创建新工程。</p>\n<h2 id=\"5-1-创建新工程\"><a href=\"#5-1-创建新工程\" class=\"headerlink\" title=\"5.1. 创建新工程\"></a>5.1. 创建新工程</h2><p>NCS支持以例程作为模板，复制并创建新的工程。这也是Nordic非常推荐的方式。</p>\n<p>首先在VS Code中打开一个新窗口</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027154653607.png\" alt=\"image-20231027154653607\"></p>\n<p>在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，先检查toolchain和SDK是否已经检测到。</p>\n<p>然后点击<code>Create a new application</code>创建新工程。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027154922771.png\" alt=\"image-20231027154922771\"></p>\n<p>选择“Copy a sample”</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155052262.png\" alt=\"image-20231027155052262\"></p>\n<p>选择自己想要拷贝的例程，支持文字搜索：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155146846.png\" alt=\"image-20231027155146846\"></p>\n<blockquote>\n<p>这里的例程列表，和第4节中提到的目录结构是一致的。同时也和SDK官网的例程说明是保持一致的，每个例程都有其对应的说明文档：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155316876.png\" alt=\"image-20231027155316876\"></p>\n<p>Nordic商业级应用：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/applications.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/applications.html</a></p>\n<p>Nordic例程：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples.html</a></p>\n<p>Zephyr例程：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/samples/index.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/samples/index.html</a></p>\n</blockquote>\n<p>选择自己新建例程的父目录（我这里是Linux电脑的路径）：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155535431.png\" alt=\"image-20231027155535431\"></p>\n<p>选择自己新建例程的文件夹名称：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155623993.png\" alt=\"image-20231027155623993\"></p>\n<p>然后就可以打开新的工程。</p>\n<h2 id=\"5-2-使用git跟踪你的代码修改\"><a href=\"#5-2-使用git跟踪你的代码修改\" class=\"headerlink\" title=\"5.2. 使用git跟踪你的代码修改\"></a>5.2. 使用git跟踪你的代码修改</h2><blockquote>\n<p>如果你从没用过git，需要先配置用户名和邮箱。这个用户名和邮箱不是登陆什么网站用的，而是一个签名，在提交代码时用于标记这段代码是谁提交的。这个配置存在你电脑的本地，并且是<strong>全局</strong>的，对所有git仓库都有效。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;Jayant.Tang&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;jayant.tang@nordicsemi.no&quot;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>新建的工程都会自动初始化git仓库，我们可以看到.gitignore文件：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027155922698.png\" alt=\"image-20231027155922698\"></p>\n<p>你可以把<code>.vscode/</code>添加到其中</p>\n<p>如果你不熟悉Git以及Git在VS Code中的使用，强烈建议去学习一下，它极大的方便了代码的管理。</p>\n<p>例如：如果安装了git history插件，就可以查看提交历史：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122235338251.png\" alt=\"image-20221122235338251\"></p>\n<p>Git History提供了很方便的视图，可以看到每次commit都改动了哪些代码和配置（左侧是旧的，右侧是新的）：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122235416865.png\" alt=\"image-20221122235416865\"></p>\n<p>​\t更多Git的使用，可以去网上了解其他教程。本文不再赘述。</p>\n<h1 id=\"6-编译工程\"><a href=\"#6-编译工程\" class=\"headerlink\" title=\"6. 编译工程\"></a>6. 编译工程</h1><h2 id=\"6-1-创建一个编译目标（Build-Target）\"><a href=\"#6-1-创建一个编译目标（Build-Target）\" class=\"headerlink\" title=\"6.1. 创建一个编译目标（Build Target）\"></a>6.1. 创建一个编译目标（Build Target）</h2><p>所谓编译目标就是在同一套代码下，可能有不同的配置项（Debug&#x2F;Release，不同的优化级别等等），编译出不同的可执行文件。一个项目下可以创建多个编译目标。</p>\n<h3 id=\"Board\"><a href=\"#Board\" class=\"headerlink\" title=\"Board\"></a>Board</h3><p>创建Build，需要选择自己使用的板子，Zephyr自带各个厂商的开发板配置。</p>\n<p>下图中，Board下拉框是用来选板子的，下方还有三个<strong>过滤器</strong>，来过滤可选的板子：</p>\n<ul>\n<li><p>Compatible boards：本例程适配的板子，如果选择这些板子，<strong>不需要任何修改就可以烧录进去使用</strong></p>\n</li>\n<li><p>Nordic boards：Nordic 出品的官方开发板，以及一些Nordic的demo板</p>\n</li>\n<li><p>All boards：Zephyr 支持的所有开发板</p>\n</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028172343694.png\" alt=\"image-20231028172343694\"></p>\n<blockquote>\n<p>Nordic开发板board配置的命名规则：</p>\n<p>例如：<code>nrf52840dk_nrf52840</code>，是说这个板子的配置是为 nrf52840dk 这块开发板上的 nrf52840 这颗 MCU 创建的，会记录这个MCU的外设地址，以及此MCU连接的外部硬件的信息（如SPI Flash）。</p>\n<p>例如：<code>nrf9160dk_nrf9160</code>和<code>nrf9160dk_nrf52840</code>，都是nrf9160dk这块开发板的配置。但是这块开发板上有两颗MCU&#x2F;SoC，一颗是9160 SiP，另一颗是52840。所以有两个配置可选，分别为这两颗MCU&#x2F;SoC编译固件。</p>\n<p>例如：<code>nrf5340dk_nrf5340_cpuapp</code>和<code>nrf5340dk_nrf5340_cpunet</code>，都是nrf5340dk这块板子的配置，并且这块板子上只有nRF5340这一颗主控。但是nRF5340是一颗双核MCU，所以，可以有两种配置来区分两个核。这两个核的固件是分开运行的，因此编译时也是分别编译的。</p>\n<p>例如：<code>nrf5340dk_nrf5340_cpuapp</code>和<code>nrf5340dk_nrf5340_cpuapp_ns</code>，都是nrf5340dk开发板上，nrf5340芯片的应用核的配置。但是，这颗应用核使用的CPU是Cortex-M33，基于Arm V8架构，提供了TrustZone的安全保护技术，同样的一个外设寄存器，可以有安全（Secure）和非安全（Non-Secure）两个地址，这样可以把安全应用和非安全应用隔离开来。因此，这两个board配置的不同之处，就是从安全地址还是非安全地址去访问芯片上的外设资源。</p>\n<p>例如：<code>nrf52833dk_nrf52820</code>。这块开发板上只有nrf52833这一块主控。但是由于nRF52833和nRF52820同属nRF52系列，52820上的资源是52833的子集，并且Nordic并未单独为52820制作开发板，因此可以用52833来模拟52820。此配置文件限制了52833上的硬件资源，使其表现和52820相同。</p>\n<p>更详细的信息牵扯到DeviceTree，可参考：<a href=\"https://www.bilibili.com/video/BV1L94y1F7qS/?share_source=copy_web&vd_source=5b30c59b8b35af4478df0c81135c53e6\">【详解Zephyr设备数与设备驱动模型】</a></p>\n</blockquote>\n<h3 id=\"Configuation\"><a href=\"#Configuation\" class=\"headerlink\" title=\"Configuation\"></a>Configuation</h3><p>选用的Kconfig配置。Zephyr的Kconfig菜单中，很多配置项都是有默认值的。项目内的<code>prj.conf</code>配置文件的作用是，对原始的默认配置进行覆盖。通常只选<code>prj.conf</code>即可，如果有不一样的，可以参考例程的说明文档。</p>\n<h3 id=\"Kconfig-fragments\"><a href=\"#Kconfig-fragments\" class=\"headerlink\" title=\"Kconfig fragments\"></a>Kconfig fragments</h3><p>其实和<code>prj.conf</code>差不多，相当于对<code>prj.conf</code>的一个补充。通常，同一个例程支持很多不同的板子的情况下，<code>prj.conf</code>中记录的是例程通用的配置。</p>\n<p>而<code>boards/xxx.conf</code>中记录的是某种开发板单独需要的配置。<code>boards/</code>下的通常不用选，编译时会自动根据板子选择。</p>\n<p>此外还可能有其他的配置文件可以选，说明这个例程支持不同的功能，具体需要看那个例程的文档。</p>\n<h3 id=\"Devicetree-overlays\"><a href=\"#Devicetree-overlays\" class=\"headerlink\" title=\"Devicetree overlays\"></a>Devicetree overlays</h3><p>系统选择板子时，板子都会有一个device tree。这里的overlay就是当前例程对板子device tree的增、删、改。所以叫做覆盖（overlay）。默认名称是<code>app.overlay</code>。<code>boards/</code>目录下也可能有不同开发板对应的overlay文件。通常也不用选择，编译时会自动使用app.overlay，或者自动根据板子选择。</p>\n<h3 id=\"Extra-CMake-arguments\"><a href=\"#Extra-CMake-arguments\" class=\"headerlink\" title=\"Extra CMake arguments\"></a>Extra CMake arguments</h3><p>跟直接在CMakeLists.txt里面写<code>set(xxx yyy)</code>定义一个宏的值，效果是一样的。格式是<code>-Dxxx=yyy</code>，也就是在命令行中运行CMake时通过<code>-D</code>进行传参。</p>\n<h2 id=\"6-2-进行编译\"><a href=\"#6-2-进行编译\" class=\"headerlink\" title=\"6.2. 进行编译\"></a>6.2. 进行编译</h2><p>新建完build target后，点击Build Configuration进行编译。</p>\n<p>如果后续要再次编译这个target，可以在APPLICATIONS栏选中自己要构建的工程和target。然后在ACTIONS栏通过build<strong>按钮</strong>进行项目的构建。</p>\n<blockquote>\n<p>按Build旁的圆圈箭头按钮，可以全部重新编译。</p>\n</blockquote>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123140646521.png\" alt=\"image-20221123140646521\"></p>\n<blockquote>\n<p>补充：命令行编译</p>\n<p>按 “ CTRL + &#96; “，可以呼出终端。点击“+”号右边的下拉箭头，选择nRF Connect：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027161338719.png\" alt=\"image-20231027161338719\"></p>\n<p>这样打开的终端，其环境变量指向前面安装的toolchain</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 利用当前已经创建的build target进行编译</span></span><br><span class=\"line\">west build</span><br></pre></td></tr></table></figure>\n\n<p>更多用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -h</span><br></pre></td></tr></table></figure>\n\n<p>编译时可以指定项目根目录、build目录、板子名称、配置文件、overlay文件等。你可以先用上面的图形化的方式在VS Code中进行编译，然后在VS Code终端中查看这次编译的命令是什么。</p>\n</blockquote>\n<h1 id=\"7-连接设备\"><a href=\"#7-连接设备\" class=\"headerlink\" title=\"7. 连接设备\"></a>7. 连接设备</h1><p>nrf-connect插件，底层调用的是<code>nrfjprog</code>或<code>nrfutil</code>命令来连接开发板上的JLink。因此，需要通过USB线连接到JLink口。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209144123203.png\" alt=\"image-20221209144123203\"></p>\n<p>以nRF52840DK为例，中间最大的带有贴纸的芯片为JLink主控（官方称其为Interface MCU），左侧为JLink USB口，此接口可以用来给整块板供电。</p>\n<p>需确保左下角电源开关打开。左侧中间位置的开关置于VDD挡位，右上角开关置于DEFAULT挡位（如上图）。</p>\n<p>对于一些有多颗MCU的开发板，注意要使用拨码开关选择自己要调试的MCU，例如nRF9160DK可选择9160和52840：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209153801993.png\" alt=\"image-20221209153801993\"></p>\n<p>​\t然后就可以在VS Code中识别到设备了：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209144833292.png\" alt=\"image-20221209144833292\"></p>\n<blockquote>\n<p>如果不能自动识别到，或者很不稳定。可能是最新的底层Python工具<code>nrfutil</code>在Windows上不太稳定。可以把它改回之前的<code>nrfjprog</code>：</p>\n<p>打开VS Code Settings:</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027162356248.png\" alt=\"image-20231027162356248\"></p>\n<p>搜索“Device Provider”，并改为<code>nrfjprog</code>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027162506329.png\" alt=\"image-20231027162506329\"></p>\n</blockquote>\n<h1 id=\"8-烧录固件\"><a href=\"#8-烧录固件\" class=\"headerlink\" title=\"8. 烧录固件\"></a>8. 烧录固件</h1><p>连接并成功识别到Jlink后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221123160139273.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n<p>​\t也可以通过命令行进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west flash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：\t</p>\n<p>这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123160245857.png\" alt=\"image-20221123160245857\"></p>\n<p>这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。相关资料，可以参考Nordic芯片数据手册的UICR章节。</p>\n<p>这种情况下只能全片擦除然后再烧录，点击Flash右边的按钮：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123160832598.png\" alt=\"image-20221123160832598\"></p>\n<p>或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west flash --force --erase</span><br></pre></td></tr></table></figure>\n\n<p>此外，还有一种可能是，调试接口启用了保护，需要recover这颗芯片来解除保护。</p>\n<p>通常，右下角会有弹窗来问你是否要recover，就选择Yes就好。</p>\n<p>如果没有效果，也可以用命令行来recover</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrfjprog --recover</span><br></pre></td></tr></table></figure>\n\n<p>如果是nRF5340这种双核芯片，那么网络核也要recover</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrfjprog --recover --coprocessor CP_NETWORK</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"9-运行并测试\"><a href=\"#9-运行并测试\" class=\"headerlink\" title=\"9. 运行并测试\"></a>9. 运行并测试</h1><p>连接的设备，可以看到Jlink上的主控芯片、串口以及RTT。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028103135931.png\" alt=\"image-20231028103135931\"></p>\n<p>这里的串口是MCU上真实的物理串口，在开发板上通过PCB走线连接到Jlink，然后Jlink把这个串口转化为USB虚拟串口。</p>\n<blockquote>\n<p>新款开发板，板载的Jlink是拿5340做的，这种新款开发板有两个USB虚拟串口：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027164658632.png\" alt=\"image-20231027164658632\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027163914699.png\" alt=\"image-20231027163914699\"></p>\n<p>但是对于52840DK来说，开发板上只连了一个串口，另一个是空的。具体是哪个？要试一下，因为可能USB枚举的顺序不一样。</p>\n<p>对于5340DK, 7002DK来说，两个串口分别对应Application Core和Network Core的日志输出。</p>\n</blockquote>\n<h2 id=\"9-2-连接串口\"><a href=\"#9-2-连接串口\" class=\"headerlink\" title=\"9.2. 连接串口\"></a>9.2. 连接串口</h2><p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209154745021.png\" alt=\"image-20221209154745021\"></p>\n<p>​\t点击串口，选择波特率，即可打开串口。串口<strong>接收</strong>的信息在Terminal展示：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231027162835862.png\" alt=\"image-20231027162835862\"></p>\n<blockquote>\n<p>这个串口工具类似于Putty，按下键盘的按键就立即发送出去一个字符，不会显示自己发出了什么。便于在这个串口上运行命令行终端之类的，这也是Zephyr所支持的。</p>\n</blockquote>\n<h2 id=\"9-3-连接RTT\"><a href=\"#9-3-连接RTT\" class=\"headerlink\" title=\"9.3. 连接RTT\"></a>9.3. 连接RTT</h2><p>RTT是Segger提供的日志调试手段，全称Real Time Transmit。MCU将日志打印到内部缓存中，然后利用Jlink的高速通道，把日志打印到电脑上。这个方法不需要占用串口外设，而且速度极快，对CPU运行影响小。</p>\n<blockquote>\n<p>大多数例程的默认日志输出口是串口。但本例程是蓝牙串口透传，串口需要传输用户数据，因此日志的默认输出就是RTT。</p>\n<p>查看RTT日志输出的相关配置：</p>\n<p>打开工程根目录下的<code>.prj</code>文件：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209161912543.png\" alt=\"image-20221209161912543\"></p>\n<p>可以看到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_LOG=y                 <span class=\"comment\"># 启用日志系统</span></span><br><span class=\"line\">CONFIG_USE_SEGGER_RTT=y      <span class=\"comment\"># 启用RTT</span></span><br><span class=\"line\">CONFIG_LOG_BACKEND_RTT=y     <span class=\"comment\"># 日志后端选用RTT</span></span><br><span class=\"line\">CONFIG_LOG_BACKEND_UART=n    <span class=\"comment\"># 日志后端不选用串口</span></span><br><span class=\"line\">CONFIG_LOG_PRINTK=n          <span class=\"comment\"># 不启用PRINTK日志</span></span><br></pre></td></tr></table></figure>\n\n</blockquote>\n<p>如下图连接RTT：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221209170245563.png\" alt=\"image-20221209170245563\"></p>\n<h2 id=\"9-4-测试peripheral-uart例程\"><a href=\"#9-4-测试peripheral-uart例程\" class=\"headerlink\" title=\"9.4. 测试peripheral_uart例程\"></a>9.4. 测试peripheral_uart例程</h2><p>一般来说，需要两块开发板，一块烧<code>peripheral_uart</code>，一块烧<code>central_uart</code>。两块开发板上电后会自动连接。从一个开发板串口输入的数据，会从另一个开发板输出。</p>\n<p>但是这里我们只有一块开发板，那么BLE central我们就用手机。iOS应用商店可以下载<code>nRF Connect</code>，安卓可以在谷歌商店下载，或者直接去Github下载<a href=\"https://github.com/NordicSemiconductor/Android-nRF-Connect/releases\">APK</a>。</p>\n<h3 id=\"通过BLE连接设备\"><a href=\"#通过BLE连接设备\" class=\"headerlink\" title=\"通过BLE连接设备\"></a>通过BLE连接设备</h3><p>在nRF Connect APP中，先扫描，扫到设备后，再连接：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028104626601.png\" alt=\"image-20231028104626601\"></p>\n<h3 id=\"开发板接收数据\"><a href=\"#开发板接收数据\" class=\"headerlink\" title=\"开发板接收数据\"></a>开发板接收数据</h3><p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028104717740.png\" alt=\"image-20231028104717740\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028104734696.png\" alt=\"image-20231028104734696\"></p>\n<p>可以在串口看到数据：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028104845188.png\" alt=\"image-20231028104845188\"></p>\n<h3 id=\"开发板发送数据\"><a href=\"#开发板发送数据\" class=\"headerlink\" title=\"开发板发送数据\"></a>开发板发送数据</h3><p>BLE协议是Client-Server架构。BLE协议规定，从机作为Server，只能被Client读、写上面的属性。默认情况下不能主动发消息到Client。除非Client使能了Notify的功能，Server才能Nortify到Client。更多信息，大家可以搜索CCCD(Client Characteristic Configuration Descriptor)。这里，就需要点亮TX属性的CCCD：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028105348055.png\" alt=\"image-20231028105348055\"></p>\n<p>然后在串口中通过键盘输入内容：hello+回车。屏幕上不会显示东西，但是按键确实会发送出去。</p>\n<blockquote>\n<p>这个串口工具类似于Putty，按下键盘的按键就立即发送出去一个字符，不会在屏幕上显示自己发出了什么。</p>\n<p>这里之所以要加回车，是因为例程代码就是这么写的。在串口回调函数内，检测到回车，才会把串口数据打包从蓝牙发出。</p>\n</blockquote>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028105643833.png\" alt=\"image-20231028105643833\"></p>\n<p>至此，我们完成了在nRF52840DK上的<code>peripheral_uart</code>例程的编译、烧录与运行测试。</p>\n<h1 id=\"10-官方资料\"><a href=\"#10-官方资料\" class=\"headerlink\" title=\"10. 官方资料\"></a>10. 官方资料</h1><h2 id=\"NCS官网\"><a href=\"#NCS官网\" class=\"headerlink\" title=\"NCS官网\"></a>NCS官网</h2><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html</a></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20231028162512499.png\" alt=\"image-20231028162512499\"></p>\n<p>进入官网，首先看到右上角可以选择文档的版本，需要与SDK的版本对应。</p>\n<p>然后可以看到中间的一排标签页：</p>\n<ul>\n<li><p><strong>Zephyr Project</strong>：是<a href=\"https://docs.zephyrproject.org/latest/index.html\">Zephyr官方文档</a>的一个镜像，包含Zephyr RTOS内核服务、操作系统API、各种驱动、协议支持以及它们的例程文档。一些比较通用的功能的如日志、Flash存储、线程间通信等功能的文档都在这里面。它对应的是NCS中的<code>zephyr</code>文件夹。</p>\n</li>\n<li><p><strong>nRF Connect SDK:</strong> 是Nordic在Zephyr系统上扩展的各种Nordic独有的库、驱动和例程的文档。里面大多数是一些Nordic独有的技术，对应的是NCS中的<code>nrf</code>文件夹。</p>\n</li>\n<li><p><strong>nrfx与nrfxlib</strong>：Nordic的外设驱动库，是最接近寄存器操作的一层，和目前已经停止维护的的nRF5 SDK中的nrfx几乎是一样的。在Zephyr中，通常应用层只需调用Zephyr的标准API，Nordic提供的底层驱动会把nrfxlib和一些寄存器操作封装成Zephyr的标准API。通常，只有客户在对MCU外设功能进行较为深入的开发时，会参考到这一块的文档。</p>\n</li>\n<li><p><strong>MCUboot</strong>：MCUboot是一个开源的第三方安全bootloader，支持很多系统和平台，Zephyr只是其中之一。很多支持OTA的例程基本都是使用MCUboot</p>\n</li>\n<li><p><strong>Trust Firmware-M</strong>：ARM提出了<strong>平台安全架构（Platform Security Architecture, PSA）</strong>，意思就是说，客户自己开发软件容易有安全漏洞，因此运行环境应分为<strong>安全环境（SPE）</strong>和<strong>非安全环境（NSPE）</strong>。客户开发的程序，属于非安全环境。安全环境的程序，由厂商提供，主要提供一些安全存储、安全启动之类的API给客户的非安全环境来调用。Trust Firmware-M(TFM)是安全环境的一个样板固件。 如果你使用了nRF5340或者nRF9160这种带有ARM v8架构的主控平台，则在编译选板子时，都可以看到<code>_s</code>或<code>_ns</code>后缀。<code>_s</code>的意思是说，客户直接在安全环境开发程序，安全性全由客户自己掌控。<code>_ns</code>的意思是说，客户在非安全环境开发程序，编译时，Zephyr会自动把TFM一起编译进去，和客户的应用程序一起工作。对于9160来说，由于要和蜂窝modem进行交互，因此，牵扯到蜂窝网络操作的例程，都必须选择<code>nrf9160dk_nrf9160_ns</code>。</p>\n</li>\n<li><p><strong>Matter</strong>：Matter是智能家居的新标准，目的是打破厂商之间的壁垒，实现生态融合。从连接方式上讲，Matter是基于局域网IPv6的，因此，Wi-Fi和Thread都是可以作为Matter的底层的。从配网方式上讲，Matter通过BLE来传输认证信息，此外可以通过NFC或者二维码的方式，让手机快速的找到要配网的这个设备的BLE广播。此页面主要是Matter SDK的文档，并不局限于在Nordic MCU上进行开发。如果要找Matter在Nordic产品上运行的例程，还是要去nRF Connect SDK页面的Samples目录下去寻找。</p>\n</li>\n<li><p><strong>Kconfig</strong>：Zephyr系统中有大量的Kconfig配置，Nordic扩展的库、驱动中也有大量Kconfig配置。如果你不知道一个Kconfig配置是干什么的，可以在这个页面进行搜索。</p>\n</li>\n</ul>\n<p>总之，NCS官网里面有大量的技术细节，在运行一个例程之前，一定要参照网站中该例程的说明进行操作。</p>\n<h2 id=\"Nordic资料中心\"><a href=\"#Nordic资料中心\" class=\"headerlink\" title=\"Nordic资料中心\"></a>Nordic资料中心</h2><p><a href=\"https://docs.nordicsemi.com/\">https://docs.nordicsemi.com/</a></p>\n<p>目前最新的资料中心，可以通过技术或产品系列进行分类，查找想要的资料。芯片数据手册（Specification）、开发板说明都可以在这里查看。也会导向到NCS官网。</p>\n<h2 id=\"Nordic旧版资料中心\"><a href=\"#Nordic旧版资料中心\" class=\"headerlink\" title=\"Nordic旧版资料中心\"></a>Nordic旧版资料中心</h2><p><a href=\"https://infocenter.nordicsemi.com/index.jsp\">https://infocenter.nordicsemi.com/index.jsp</a></p>\n<p>也可以下载到芯片数据手册（Specification）、开发板说明、技术白皮书等。这里也有目前已停止维护的nRF5 SDK的文档。</p>\n<h2 id=\"Nordic官网\"><a href=\"#Nordic官网\" class=\"headerlink\" title=\"Nordic官网\"></a>Nordic官网</h2><p><a href=\"https://www.nordicsemi.com/\">https://www.nordicsemi.com/</a></p>\n<p>一些商业新闻和产品介绍。但是最重要的是一些<strong>工具软件</strong>、<strong>开发板原理图&#x2F;PCB&#x2F;BOM</strong>之类，需要在这里下载。</p>\n<p>例如：</p>\n<p><strong>nRF52840DK开发板默认例程、Jlink固件、原理图等</strong>：<a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF52840-DK/Download?lang=en#infotabs\">https://www.nordicsemi.com/Products/Development-hardware/nRF52840-DK/Download?lang=en#infotabs</a></p>\n<h2 id=\"DevZone开发者论坛\"><a href=\"#DevZone开发者论坛\" class=\"headerlink\" title=\"DevZone开发者论坛\"></a>DevZone开发者论坛</h2><p><a href=\"https://devzone.nordicsemi.com/\">https://devzone.nordicsemi.com/</a></p>\n<p>有问题可以在上面搜索，也可以用英文提问。每天都有原厂support team查看问题并回复。Nordic注册客户，还可以提交private ticket，解决一些与代码、板子有关的问题，也可以简单审核PCB。</p>\n<h1 id=\"11-其他推荐阅读\"><a href=\"#11-其他推荐阅读\" class=\"headerlink\" title=\"11. 其他推荐阅读\"></a>11. 其他推荐阅读</h1><ul>\n<li><a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/2a39e705bff0/\">理解Zephyr编译与配置系统</a></li>\n<li>（开坑）Zephyr日志系统介绍</li>\n<li><a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">详解Zephyr设备树（DeviceTree）与驱动模型</a></li>\n<li>（开坑）Zephyr设备树与驱动应用实战——串口</li>\n<li>（开坑）不想用Zephyr DeviceTree？试试nrfx api</li>\n</ul>\n","categories":["Nordic","NCS"],"tags":["Nordic","NCS"]},{"title":"搭建自己的静态博客并自动部署","url":"/jayant97.github.io/2022/12/b42baba50896/","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>本文讲解本博客的搭建方式</p>\n<table>\n<thead>\n<tr>\n<th>部件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://hexo.io/zh-cn/\">Hexo</a></td>\n<td>把.md文章转换为页面，并且快速部署到平台</td>\n</tr>\n<tr>\n<td>GitHub Pages</td>\n<td>提供从GitHub仓库创建网站的服务</td>\n</tr>\n<tr>\n<td>GitHub Actions</td>\n<td>GitHub提供的免费持续集成服务</td>\n</tr>\n</tbody></table>\n<h2 id=\"Hexo-Github-Pages\"><a href=\"#Hexo-Github-Pages\" class=\"headerlink\" title=\"Hexo + Github Pages\"></a>Hexo + Github Pages</h2><p>先从简单的讲起，看图：</p>\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202224730111.png\" alt=\"image-20221202224730111\" style=\"zoom: 50%;\" />\n\n<p>简而言之：</p>\n<ul>\n<li>Hexo是一个博客框架，存放在你的电脑上，能把你的markdown文章转换成网站源码，并存入一个git仓库</li>\n<li>Github Pages是GitHub提供的免费静态网站服务，能让你展示文档。你只需要把网站源码存入一个repository，并且启用这个服务，GitHub就会帮你建一个静态网站，分配一个网址。别人从这个网址就能看到你的博客了。</li>\n<li>Hexo能一键把本地的网站源码推送到GitHub，让GitHub自动将其部署为Pages</li>\n</ul>\n<h2 id=\"GitHub-Actions\"><a href=\"#GitHub-Actions\" class=\"headerlink\" title=\"GitHub Actions\"></a>GitHub Actions</h2><p>​    前面的方法，网站所有的资源都存在本地，除了markdown文章和图片这种<strong>资源文件</strong>以外，网站的<strong>美化主题</strong>、<strong>配置</strong>等也存在本地。</p>\n<p>​    这会产生几个问题：</p>\n<ul>\n<li><p>数据容易丢失，一旦硬盘损坏，你的博客就灰飞烟灭了</p>\n</li>\n<li><p>只能在一台电脑上写文章，多台电脑之间hexo文件夹不好同步</p>\n</li>\n<li><p>网站的配置文件修改，没有历史记录追踪</p>\n</li>\n<li><p>由于网站的美化主题本身就是Github上的项目，每次要手动更新，很麻烦</p>\n</li>\n<li><p>每次写完文章，都要用hexo命令生成网站，还要用hexo命令部署网站，重复操作</p>\n</li>\n</ul>\n<p>​    所以，<strong>最好把hexo文件夹本身也当作Git项目，并放在GitHub托管</strong>。并且，还要把hexo部署的操作给自动化，让我们每次写完markdown文章，一 Push 就能自动部署页面。</p>\n<p>​    这就要用到GitHub Actions，它是GitHub提供的<strong>持续集成</strong>（Continuous integration， CI）服务。这里不详述CI&#x2F;CD的概念，你只需要知道，GitHub提供的这个服务，可以让你的仓库在特定条件下（例如push时），触发对应的<strong>动作（Actions）</strong>。</p>\n<p>​    所谓的Actions，可以认为就是一条一条的Linux命令（也可以是Windows CMD命令）或者脚本，并且GitHub给你一个虚拟服务器去自动执行这一条一条的命令，这个虚拟服务器具有2核CPU，7GB内存，14GB硬盘。</p>\n<p>​    你可以写自己的Actions，也可以用别人的Actions。Github提供了一个Action商店。</p>\n<p>​    最终的效果应该如下图：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221203224217145.png\" alt=\"image-20221203224217145.png\" style=\"zoom: 50%;\" />\n\n<p>配置完成后的效果：</p>\n<ul>\n<li>写完文章后，直接本地hexo仓库<code>commit</code>，然后<code>push</code></li>\n<li>GitHub上的hexo仓库由<code>push</code>触发Actions，自动在虚拟服务器中生成网站源码，然后部署到网站仓库中</li>\n<li>网站仓库（xxxx.github.io）更新时，自动更新Github Pages</li>\n<li>hexo的美化主题，作为hexo的git submodule，每次push时自动checkout最新分支</li>\n</ul>\n<h1 id=\"2-搭建步骤\"><a href=\"#2-搭建步骤\" class=\"headerlink\" title=\"2. 搭建步骤\"></a>2. 搭建步骤</h1><p>一些简单的步骤就只简略提一下。</p>\n<h2 id=\"2-1-在GitHub创建仓库并启用Pages\"><a href=\"#2-1-在GitHub创建仓库并启用Pages\" class=\"headerlink\" title=\"2.1. 在GitHub创建仓库并启用Pages\"></a>2.1. 在GitHub创建仓库并启用Pages</h2><ol>\n<li>注册一个GitHub账号</li>\n<li>在GitHub创建两个仓库<code>&lt;site_name&gt;.github.io</code>和<code>my-hexo</code><br> 前者是GitHub Pages仓库，命名必须以<code>github.io</code>结尾，后者是hexo仓库，可随意取名。<br> 两个仓库都留空，不创建任何文件。</li>\n<li>然后设置Pages，在<code>&lt;site_name&gt;.github.io</code>仓库中：</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202233043747.png\" alt=\"image-20221202233043747\"></p>\n<p>在仓库的Settings中，选择Pages，下方选择哪个分支的哪个目录被识别为网站的根目录。</p>\n<blockquote>\n<p>GitHub现在的主分支是<code>main</code>而不是<code>master</code>了，我是自己创建了一个<code>master</code>分支，因为我本地的git默认主分支还是master。</p>\n</blockquote>\n<h2 id=\"2-2-本地部署hexo\"><a href=\"#2-2-本地部署hexo\" class=\"headerlink\" title=\"2.2. 本地部署hexo\"></a>2.2. 本地部署hexo</h2><h3 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h3><p>首先安装依赖，需要安装的软件：</p>\n<ul>\n<li><a href=\"https://git-scm.com/\">Git (git-scm.com)</a>：版本管理</li>\n<li><a href=\"https://nodejs.org/en/download/\">Node.js</a>：hexo所需的平台</li>\n</ul>\n<blockquote>\n<p>Windows用户安装时，一定要勾选<code>Add to PATH </code>选项</p>\n</blockquote>\n<p>然后安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm  install -g hexo-cli <span class=\"comment\"># 全局安装</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于Node.js和hexo的版本依赖关系，请参考：<a href=\"https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6\">文档 | Hexo</a></p>\n</blockquote>\n<h3 id=\"初始化hexo\"><a href=\"#初始化hexo\" class=\"headerlink\" title=\"初始化hexo\"></a>初始化hexo</h3><p>找个喜欢的地方创建一个文件夹用于存放hexo项目，例如<code>my-hexo</code>。</p>\n<p>进入这个仓库，然后进行hexo初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> my-hexo &amp;&amp; <span class=\"built_in\">cd</span> my-hexo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化hexo，执行这步之前，需确保文件夹是空的</span></span><br><span class=\"line\">$ hexo init ./</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖的node.js插件</span></span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>hexo初始化要求文件夹为空，因此必须先初始化hexo，再初始化git。否则<code>.git/</code>的存在将导致hexo无法初始化</li>\n<li><code>hexo init</code>时，产生了文件<code>package.json</code>，里面记录了hexo所依赖的npm包的具体来源和版本号</li>\n<li><code>npm install</code>时，就根据<code>package.json</code>记录的内容进行了包的安装。包的具体安装情况记录在<code>package-lock.json</code>中</li>\n</ul>\n</blockquote>\n<p>安装完毕后，目录结构应该如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- _config.landscape.yml  # landscape主题配置文件</span><br><span class=\"line\">|-- _config.yml            # 网站配置文件</span><br><span class=\"line\">|-- node_modules           # node.js插件包</span><br><span class=\"line\">|-- package-lock.json      # node.js插件包记录</span><br><span class=\"line\">|-- package.json           # node.js插件包记录</span><br><span class=\"line\">|-- scaffolds/             # 文章、页面模板文件夹</span><br><span class=\"line\">|-- source/                # 网站静态资源（文章、图片等）</span><br><span class=\"line\">`-- themes/                # 网站美化主题文件夹</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"初始化git并传到远程仓库\"><a href=\"#初始化git并传到远程仓库\" class=\"headerlink\" title=\"初始化git并传到远程仓库\"></a>初始化git并传到远程仓库</h3><blockquote>\n<p>如果你从没用过git，需要配置本地的git用户和邮箱：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;$ git config --global user.name &lt;用户名&gt;</span><br><span class=\"line\">&gt;$ git config --global user.email &lt;邮箱&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个用户名和邮箱只是本地提交代码时记录修改人是谁，并非是要登录什么网站</p>\n</blockquote>\n<p>​    还是在这个目录，进行Git仓库初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本文不解释git及其相关概念，后续使用git命令时，即使是复制，也务必明白你在做什么</p>\n<p>另外，记得确认仓库中的<code>.gitignore</code>文件，它是<code>hexo init &lt;文件夹&gt;</code>时生成的，其内容包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/         # 安装的npm包</span><br><span class=\"line\">public/               # 生成的静态网站源码目录</span><br><span class=\"line\">.deploy*/             # xxxx.github.io仓库</span><br><span class=\"line\">_multiconfig.yml</span><br></pre></td></tr></table></figure>\n\n<p>​    这是让git不要去追踪一些自动生成的内容，这些内容与文章、站点配置无关。</p>\n</blockquote>\n<p>​    然后再<code>commit</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;init&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​    还记得前面在GitHub创建的<code>my-hexo</code>仓库还是空的吗，现在需要把本地<code>my-hexo</code>仓库绑定到GitHub仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin https://github.com/&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br><span class=\"line\">$ git branch -M master  <span class=\"comment\"># 默认主分支我改名为master</span></span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地预览hexo网站页面\"><a href=\"#本地预览hexo网站页面\" class=\"headerlink\" title=\"本地预览hexo网站页面\"></a>本地预览hexo网站页面</h3><p>依次输入以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean      <span class=\"comment\"># 清理hexo缓存</span></span><br><span class=\"line\">$ hexo g          <span class=\"comment\"># 生成hexo网站源码</span></span><br><span class=\"line\">$ hexo s --debug  <span class=\"comment\"># 在本地开启网站的访问端口</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">16:49:54.435 DEBUG Generator: tag</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: category</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: index</span><br><span class=\"line\">16:49:54.445 INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>终端中会打印本地网站的地址，Ctrl+鼠标左键点击访问即可：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203005355143.png\" alt=\"image-20221203005355143\"></p>\n<p>可以看到默认页面即为成功，首页的唯一一篇文章是hexo自带的<code>source/_post/hello-world.md</code>.</p>\n<blockquote>\n<p>终端按Ctrl + C停止本地服务器</p>\n</blockquote>\n<h2 id=\"2-3-配置hexo\"><a href=\"#2-3-配置hexo\" class=\"headerlink\" title=\"2.3.  配置hexo\"></a>2.3.  配置hexo</h2><h3 id=\"安装主题\"><a href=\"#安装主题\" class=\"headerlink\" title=\"安装主题\"></a>安装主题</h3><p>​    hexo有很多美化主题，可以在<a href=\"https://hexo.io/themes/\">Themes | Hexo</a>找到喜欢的主题，也可以在GitHub上搜索其他主题。我选择的主题是<a href=\"https://butterfly.js.org/\">Butterfly - A Simple and Card UI Design theme for Hexo</a>。主题除了美化外，往往还提供许多其他功能的配置。</p>\n<p>​    主题放在themes文件夹下。<strong>不论安装什么主题，一定要注意</strong>：</p>\n<ul>\n<li>虽然主题的官方教程一般都是让用<code>git clone</code>到themes文件夹下，但是我们的hexo文件夹已经是一个git仓库了，所以要以<code>git submodule</code>的形式安装；</li>\n<li><code>themes</code>下的主题文件夹必须以<code>&lt;主题名&gt;</code>来命名，而不是GitHub仓库的名称，如<code>hexo-theme-&lt;主题名&gt;</code>。</li>\n<li>很多主题的官方说明会要求安装其他的npm包。使用<code>npm</code>安装这些包时，一定要带<code>--save</code>选项。这样这些包才会被记录到<code>package.json</code>中，这样我们以后push时，GitHub Actions上面的虚拟服务器才会帮我们完整的安装这些依赖。</li>\n<li>主题本身的配置文件在<code>themes/&lt;主题名&gt;/_config.yml</code>中，但这个文件是被主题仓库管理的，不会被hexo仓库管理，无法推送到GitHub。而且主题仓库更新后我们修改的配置也会丢失。所以我们应当在hexo根目录下创建<code>_config.&lt;主题名&gt;.yml</code>文件，并把主题中的配置文件拷贝进去。这样配置文件就会被hexo仓库管理。（但是原来主题文件夹里的_config.yml也不要删除）</li>\n</ul>\n<p>下面是我安装butterfly的步骤:</p>\n<ol>\n<li>把butterfly作为git submodule安装到hexo中</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git submodule add -b master https://github.com/jerryc127/hexo-theme-butterfly.git ./themes/butterfly</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：<code>git submodule add</code>时，一定要指定主题的文件夹名称，将其命名为主题的名称，此处为<code>themes/butterfly</code>。若不这样做，将会变成其GitHub仓库的名称，如<code>hexo-theme-butterfly</code>，这样是不行的。</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装渲染器</li>\n</ol>\n<p>根据butterfly的官方文档，需要安装渲染器。其他主题可能需要其他渲染器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一定要带<code>--save</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>拷贝<strong>主题配置</strong>文件</li>\n</ol>\n<p>把<code>themes/&lt;主题名&gt;/_config.yml</code>配置拷到hexo根目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>应用主题</li>\n</ol>\n<p>修改<strong>hexo配置文件</strong>，<code>my-hexo</code>根目录下的<code>_config.yml</code>，找到<code>theme</code>项并修改：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">butterfly</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>yml格式的<code>:</code>后面一定要有一个空格</p>\n</blockquote>\n<ol start=\"5\">\n<li>查看效果</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203191314829.png\" alt=\"image-20221203191314829\"></p>\n<ol start=\"6\">\n<li>其他修改</li>\n</ol>\n<p>根据主题的官方说明，进行其他的自定义配置。所有的修改都在my-hexo根目录下<code>_config.&lt;主题名&gt;.yml</code>中修改。 </p>\n<blockquote>\n<p><code>themes/&lt;主题名&gt;/_config.yml</code>虽然不生效，但是也不能删除。</p>\n</blockquote>\n<h3 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h3><p>​    hexo本身的配置，需要修改<code>my-hexo</code>根目录下的<code>_config.yml</code>文件。可以修改站点名称、作者等，具体可以参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a>。</p>\n<p>​    这里提一些与Github Pages还有markdown文章插入相关的配置。</p>\n<h4 id=\"网站url与root\"><a href=\"#网站url与root\" class=\"headerlink\" title=\"网站url与root\"></a>网站url与root</h4><p>目前，GitHub Pages提供的网站url为：</p>\n<p><code>https://&lt;用户名&gt;.github.io/&lt;仓库名&gt;/</code></p>\n<p>例如：</p>\n<p><code>https://jayant-tang.github.io/jayant97.github.io/</code></p>\n<p>所以，要配置hexo的目录：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://jayant-tang.github.io/jayant97.github.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/jayant97.github.io/</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​    不同环境，访问资源的根目录是不同的。hexo的所有资源文件都应该放在<code>&lt;hexo文件夹&gt;/source</code>下，生成网页时，会自动拷贝到网页的根目录下。</p>\n<p>​    例如，有一张图片资源的路径是：<code>&lt;hexo文件夹&gt;/source/foo/bar/image.png</code>：</p>\n<ul>\n<li>对于你的markdown文章，可以设置根目录为<code>&lt;hexo文件夹&gt;/source</code></li>\n<li>对于网站，刚才已经配置了根目录为<code>/jayant97.github.io/</code></li>\n</ul>\n<p>只要设置好根目录，markdown和网页就可以使用<strong>相同的路径</strong>来访问到<strong>相同的资源</strong>了，如<code>/foo/bar/image.png</code>。</p>\n</blockquote>\n<h4 id=\"hexo的部署方式介绍\"><a href=\"#hexo的部署方式介绍\" class=\"headerlink\" title=\"hexo的部署方式介绍\"></a>hexo的部署方式介绍</h4><p>通常情况下，hexo的部署流程是这样的：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203195710806.png\" alt=\"image-20221203195710806\"></p>\n<ol>\n<li><code>hexo g</code>，生成网页源码，并存储在<code>/public</code>文件夹中</li>\n<li><code>hexo d</code>，把public同步到本地git仓库，然后推送到github仓库。</li>\n</ol>\n<p>先安装git部署的插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后需要给hexo配置github仓库的路径和权限，打开<strong>hexo配置文件</strong>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">    <span class=\"comment\">#repo: https://github.com/Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td>部署类型，可以设置多个要部署的目标</td>\n</tr>\n<tr>\n<td>branch</td>\n<td>分支名称</td>\n</tr>\n<tr>\n<td>repo</td>\n<td>仓库名称，这里有ssh和https两种方式。使用ssh方式。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>GitHub认证方式：</p>\n<ul>\n<li>https方式，任何人可以随便clone，但是push时需要在弹窗中输入账号密码，认证身份；</li>\n<li>ssh方式，需要ssh key，公钥放在GitGub，私钥自己持有。只要持有私钥就可以用ssh访问GitHub仓库，纯命令行操作，不会弹窗。</li>\n</ul>\n<p>因为后面要用GitHub Actions在虚拟服务器里自动部署，所以需要用ssh的方式。</p>\n</blockquote>\n<h4 id=\"ssh密钥对的生成\"><a href=\"#ssh密钥对的生成\" class=\"headerlink\" title=\"ssh密钥对的生成\"></a>ssh密钥对的生成</h4><p>​     然后需要生成两对ssh  key，第一对用于<strong>电脑</strong>和<strong>GitHub</strong>之间的认证，第二对用于<strong>GitHub my-hexo仓库</strong> 和<strong>GitHub xxxx.github.io仓库</strong>之间的认证。</p>\n<p>​    生成key：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/github_ed25519</span><br><span class=\"line\"><span class=\"comment\"># 输入后一直回车</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>-t</code>：选择加密算法，ed25519比较安全</p>\n<p><code>-C</code>:  密钥的备注说明文字。Github要求这里要填上git config时配置的邮箱，同时也必须是GitHub中已经配置的认证邮箱。</p>\n<p><code>-f</code>：生成的私钥文件名</p>\n</blockquote>\n<p>执行完毕后，<code>~/.ssh</code>下应该有4个新文件，其中带有<code>.pub</code>后缀的是公钥，不带的是私钥:</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"code\"><pre><span class=\"line\">~/.ssh</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519.pub</span><br><span class=\"line\">|-hexo<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">`-hexo<span class=\"built_in\">_</span>ed25519.pub</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"GitHub-ssh-key设置\"><a href=\"#GitHub-ssh-key设置\" class=\"headerlink\" title=\"GitHub ssh key设置\"></a>GitHub ssh key设置</h4><p>配置你的电脑ssh访问GitHub的权限。GitHub点击右上角头像-Settings，然后点击New SSH key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203202950352.png\" alt=\"image-20221203202950352\"></p>\n<p>然后，把<code>github_ed25519.pub</code>的内容粘贴进去，其他都不用填，确认即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203203135033.png\" alt=\"image-20221203203135033\" style=\"zoom: 50%;\" />\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\"><span class=\"comment\"># Attempts to ssh to GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; The authenticity of host <span class=\"string\">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class=\"string\">&#x27;t be established.</span></span><br><span class=\"line\"><span class=\"string\">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class=\"line\"><span class=\"string\">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br><span class=\"line\"><span class=\"string\"># 这里输入yes然后回车</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; Hi USERNAME! You&#x27;</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>有以上输出说明权限配置成功。</p>\n<h3 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h3><p>根据你所使用的主题的官方文档来配置。建议把后面的其他部署都完成后，再研究主题的配置。</p>\n<h2 id=\"2-4-从电脑部署hexo\"><a href=\"#2-4-从电脑部署hexo\" class=\"headerlink\" title=\"2.4. 从电脑部署hexo\"></a>2.4. 从电脑部署hexo</h2><p>前面的步骤都完成后，可以执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>这时，hexo应该已经可以把网站配置到<code>xxxx.github.io</code>上了，过一会从网页端就可以看到网站页面了。</p>\n<p><strong>网页端的入口：</strong></p>\n<p>​\tPages仓库右边：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104114033850.png\" alt=\"image-20230104114033850\"></p>\n<p>然后点击View deployment</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104114222770.png\" alt=\"image-20230104114222770\"></p>\n<h2 id=\"2-5-GitHub-Actions自动部署\"><a href=\"#2-5-GitHub-Actions自动部署\" class=\"headerlink\" title=\"2.5. GitHub Actions自动部署\"></a>2.5. GitHub Actions自动部署</h2><h4 id=\"pages仓库添加公钥\"><a href=\"#pages仓库添加公钥\" class=\"headerlink\" title=\"pages仓库添加公钥\"></a>pages仓库添加公钥</h4><p>​     我们需要设置<code>my-hexo</code>仓库访问<code>xxxx.github.io</code>仓库的权限，前者持有私钥，后者持有公钥。然后才能在push完<code>my-hexo</code>仓库之后，让<code>my-hexo</code>仓库的Actions自动部署博客到Pages仓库。</p>\n<p>​    首先进入<code>xxxx.github.io</code>仓库页面，找到Settings - Deploy Keys，然后点击Add deploy key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204246535.png\" alt=\"image-20221203204246535\"></p>\n<p>把<code>hexo_ed25519.pub</code>的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204425639.png\" alt=\"image-20221203204425639.png\" style=\"zoom:50%;\" />\n\n<p>Title填写<code>HEXO_DEPLOY_PUB</code></p>\n<h4 id=\"hexo仓库添加私钥\"><a href=\"#hexo仓库添加私钥\" class=\"headerlink\" title=\"hexo仓库添加私钥\"></a>hexo仓库添加私钥</h4><p>​    然后进入<code>my-hexo</code>仓库，找到Settings - Secrets - Actions，然后点击New repository secret.</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204626463.png\" alt=\"image-20221203204626463\"></p>\n<p>把私钥<code>hexo_ed25519</code>中的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204859957.png\" alt=\"image-20221203204859957.png\"></p>\n<p><strong>注意，Name要记住，后面需要用到</strong>。我这里配置的是<code>HEXO_DEPLOY_PRI</code>.</p>\n<h4 id=\"编写Actions\"><a href=\"#编写Actions\" class=\"headerlink\" title=\"编写Actions\"></a>编写Actions</h4><p>在本地my-hexo文件夹中，创建一个文件<code>.github/workflows/deploy.yml</code>，填入以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在master分支上收到push时，开始执行流程</span></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">      - master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">env</span>:</span><br><span class=\"line\">  GIT_USER: Jayant.Tang</span><br><span class=\"line\">  GIT_EMAIL: jayant.tang@nordicsemi.no</span><br><span class=\"line\">  DEPLOY_REPO: Jayant-Tang/jayant97.github.io</span><br><span class=\"line\">  DEPLOY_BRANCH: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 具体步骤</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span>:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    name: Build on node <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125; and <span class=\"variable\">$&#123;&#123; matrix.os &#125;</span>&#125;</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    strategy:</span><br><span class=\"line\">      matrix:</span><br><span class=\"line\">        os: [ubuntu-latest]</span><br><span class=\"line\">        node_version: [18.12.1] <span class=\"comment\"># 修改好node js版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Checkout</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          submodules: recursive</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Checkout deploy repo</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          repository: <span class=\"variable\">$&#123;&#123; env.DEPLOY_REPO &#125;</span>&#125;</span><br><span class=\"line\">          ref: <span class=\"variable\">$&#123;&#123; env.DEPLOY_BRANCH &#125;</span>&#125;</span><br><span class=\"line\">          path: .deploy_git</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Use Node.js <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\">        uses: actions/setup-node@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          node-version: <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Configuration environment</span><br><span class=\"line\">        <span class=\"built_in\">env</span>:</span><br><span class=\"line\">          HEXO_DEPLOY_PRI: <span class=\"variable\">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          sudo timedatectl set-timezone <span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br><span class=\"line\">          <span class=\"built_in\">mkdir</span> -p ~/.ssh/</span><br><span class=\"line\">          <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_ed25519</span><br><span class=\"line\">          <span class=\"built_in\">chmod</span> 600 ~/.ssh/id_ed25519</span><br><span class=\"line\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">          git config --global user.name <span class=\"variable\">$GIT_USER</span></span><br><span class=\"line\">          git config --global user.email <span class=\"variable\">$GIT_EMAIL</span></span><br><span class=\"line\">          <span class=\"comment\">#cp _config.theme.yml themes/concise/_config.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Install dependencies</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm install</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Deploy hexo</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm run deploy</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>内容修改：</p>\n<ol>\n<li><p>修改环境变量，改成你自己的用户名(GIT_USER)、邮箱(GIT_EMAIL)、pages仓库、pages分支</p>\n</li>\n<li><p>修改node_version: [xxxx]，填上你电脑本地安装的Nodejs的版本</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看本地Node.js版本</span></span><br><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改时区，如果在中国就不用改了</p>\n</li>\n</ol>\n<p>内容解释：</p>\n<ol>\n<li>在hexo仓库的master分支收到push时，触发job</li>\n<li>在Ubuntu环境中，checkout本仓库的最新内容，并且同时自动获取各个submodle的仓库。这里的<code>actions/checkout@v3</code>是Actions商店提供的，我们只需要用<code>with</code>传参数进去就行了。商店页面<a href=\"https://github.com/marketplace/actions/checkout\">Checkout · Actions · GitHub Marketplace</a>。</li>\n<li>checkout pages仓库，并把它放到.deploy_git路径中</li>\n<li>安装指定版本的Node.js</li>\n<li>配置环境变量：添加私钥、配置git用户和邮箱。注意，这里的私钥的名称就是<code>$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</code>，与前面配置的<code>HEXO_DEPLOY_PRI</code>一致。</li>\n<li>根据package.json的内容安装npm包</li>\n<li>部署hexo博客</li>\n</ol>\n<p>其他说明：</p>\n<ul>\n<li>我没有使用商店中别人写的自动部署hexo的Actions，因为他们很久没更新了，使用的Node.js版本比较低，也没法通过传参的方式修改其内部使用的Node.js版本。</li>\n</ul>\n</blockquote>\n<h4 id=\"提交修改\"><a href=\"#提交修改\" class=\"headerlink\" title=\"提交修改\"></a>提交修改</h4><p>从一开始到现在，已经修改了不少内容了，将其commit然后push</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;add config&quot;</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>add之前一定要注意检查.gitignore，是否已经让git忽略了<code>db.json</code>，<code>node_modules/</code>，<code>public/</code>。</p>\n</blockquote>\n<p>push之后，在Github Actions页面应该已经可以看到流程了：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212530721.png\" alt=\"image-20221203212530721\"></p>\n<p>你的每次push，都会触发actions。绿色勾说明整个流程没有出现错误（指Ubuntu linux命令没有出现执行错误的）。如果执行失败，会出现红色叉，你可以点进去看详细的执行记录。</p>\n<p>Actions执行完毕后，应该已经部署到Pages仓库了，这里也可以看到网站部署的记录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212852929.png\" alt=\"image-20221203212852929\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203213623303.png\" alt=\"image-20221203213623303\"></p>\n<p>绿色说明部署成功，网站已经可以访问了。</p>\n<h1 id=\"3-编写并发布文章\"><a href=\"#3-编写并发布文章\" class=\"headerlink\" title=\"3. 编写并发布文章\"></a>3. 编写并发布文章</h1><h2 id=\"3-1-文章的存储与格式\"><a href=\"#3-1-文章的存储与格式\" class=\"headerlink\" title=\"3.1. 文章的存储与格式\"></a>3.1. 文章的存储与格式</h2><p>​    所有要显示的markdown文章都存放在<code>source/_posts/</code>目录下，不展示的文章（草稿）都放在<code>source/_drafts</code>目录下。</p>\n<p>​    新建文章：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>layout: markdown的布局（或者说模板），布局存放在<code>scaffolds/</code>目录下，默认有三种布局：</p>\n<ul>\n<li>post.md: 文章模板</li>\n<li>draft.md：草稿模板</li>\n<li>page.md：页面模板</li>\n</ul>\n<p>title：文章的标题，直接写标题即可，不需要写.md。<em><strong>但是最好不要有空格等特殊字符！！！</strong></em></p>\n</blockquote>\n<p>​\t以上命令，会在<code>source/_posts/</code>目录下自动创建一个新的<code>&lt;title&gt;.md</code>文件，并且把模板内容拷贝过去。由于模板中有<code>date</code>参数，这时会自动记录当前的电脑本地时间作为这篇文章的创建时间，记录在Front-Matter中。</p>\n<h2 id=\"3-2-Front-Matter\"><a href=\"#3-2-Front-Matter\" class=\"headerlink\" title=\"3.2. Front-Matter\"></a>3.2. Front-Matter</h2><p>Front-Matter是markdown文件最上方以两行<code>---</code>分隔的区域，里面需要填写yml格式的文章配置，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Hello World</span><br><span class=\"line\">date: 2013/7/13 20:46:25</span><br><span class=\"line\">tags: </span><br><span class=\"line\"><span class=\"bullet\"> -</span> 嵌入式</span><br><span class=\"line\"><span class=\"section\"> - MCU</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>在Typora编辑器中，直接在文章开头输入<code>---</code>并回车，就可以创建这个区域：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203224247035.png\" alt=\"image-20221203224247035\"></p>\n<p>​\t对于某些主题来说，有些选项是必选的，具体要看对应主题的说明文档。比如，我使用的butterfly主题，就可以配置：</p>\n<ul>\n<li><p>title：文章标题</p>\n</li>\n<li><p>date：文章创建日期</p>\n</li>\n<li><p>cover：文章封面图</p>\n</li>\n<li><p>tags：文章标签</p>\n</li>\n<li><p>categories：文章目录</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<blockquote>\n<p>tags和categories的区别：</p>\n<p>​    tags是无顺序的，categories是一个递归层级。设计好的tags和categories能让读者很方便的从主页索引到对应的文章。</p>\n</blockquote>\n<p>​    这里，我们也可以体会到前面模板的意义：可以在模板里填好Front Matter，这样每次hexo就会自动帮我们生成了。</p>\n<h2 id=\"3-3-Typora在文章中插图的问题\"><a href=\"#3-3-Typora在文章中插图的问题\" class=\"headerlink\" title=\"3.3. Typora在文章中插图的问题\"></a>3.3. Typora在文章中插图的问题</h2><h3 id=\"方案一：云端图床\"><a href=\"#方案一：云端图床\" class=\"headerlink\" title=\"方案一：云端图床\"></a>方案一：云端图床</h3><p>图片全部放在云端图床，markdown和Pages都通过URL查看图片。具体的方式，本文不介绍，可以去网上查阅。</p>\n<h3 id=\"方案二：图片放在本地\"><a href=\"#方案二：图片放在本地\" class=\"headerlink\" title=\"方案二：图片放在本地\"></a>方案二：图片放在本地</h3><p>假设我们在markdown中展示一张图片，其路径为<code>source/imgs/foo/bar/image.png</code>。</p>\n<p>hexo生成网站后，网页会根据 <code>$&#123;root&#125;/imgs/foo/bar/image.png</code>来找这张图片，即是说，source文件夹放的内容，在网页端就是根目录下的内容。</p>\n<blockquote>\n<p>在<a href=\"#%E9%85%8D%E7%BD%AEhexo\">2.3 配置hexo</a>中，我们已经配置了root为<code>&lt;仓库名&gt;</code>了。</p>\n</blockquote>\n<p>​    下面要解决的是，如何在markdown文章和网页中，能用<strong>同样的路径</strong>来访问图片资源。这样本地写文章时和网页端就都可以预览了，而且从markdown转换成html时，路径也是可用的。</p>\n<p>​     解决方式就是根目录，由于hexo的根目录前面已经设置过了，我们只需要设置markdown编辑器的根目录就好。设置完毕后，而这就都可以通过<code>/imgs/foo/bar/image.png</code>来访问同一张图片了。</p>\n<p><strong>（1）设置markdown文章访问图片时的根目录</strong></p>\n<p>​    我使用的Markdown编辑器是Typora，Typora支持<strong>针对每一篇文章单独设置</strong>根目录。</p>\n<p>直接在Front-Matter中填入以下内容即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-root-url:</span> <span class=\"string\">./..</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于文章的路径是<code>source/_post</code>，所以<code>./..</code>就是<code>source</code>了。</p>\n</blockquote>\n<p>你可以把这一行配置直接写进<code>scaffolds/post.md</code>中，这样下次模板就自动帮你填了。</p>\n<p>以上设置，直接从菜单栏设置是一样的，Typora会自动帮你写这一行：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221125176.png\" alt=\"image-20221203221125176\"></p>\n<p><strong>（2）设置Typora粘贴图片时的行为</strong></p>\n<p>直接在Front-Matter中写入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-copy-images-to:</span> <span class=\"string\">../../source/imgs/$&#123;filename&#125;.assets/</span></span><br></pre></td></tr></table></figure>\n\n<p>这个效果和下图中的偏好设置是一样的，<strong>但是不要去偏好设置里去配置，因为那是全局的配置</strong>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222104681.png\" alt=\"image-20221203222104681\"></p>\n<blockquote>\n<p>只需要在  Front-Matter 中写就行，不要去偏好设置里设置成上图的样子！！！</p>\n</blockquote>\n<p><strong>（3）检查效果</strong></p>\n<p>​    在Front-Matter中填入以上配置之后，每次粘贴图片到typora时，就会自动帮你把图片拷贝到<code>source/imgs/&lt;文章名&gt;.assets/</code>文件夹中。</p>\n<p>​    我们可以粘贴一张图片到typora中，检查图片位置：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221924602.png\" alt=\"image-20221203221924602\"></p>\n<p>然后，检查markdown访问图片的路径，查看markdown源码：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222001274.png\" alt=\"image-20221203222001274\"></p>\n<p>可以看到，路径名直接是从<code>/imgs</code>开始的，这说明根目录已经是<code>source</code>了。</p>\n<blockquote>\n<p>以上配置全部写在Front-Matter中，把这两行配置写入<code>scaffolds/post.md</code>的Front-Matter中，这样模板就创建好了。这些配置就只对hexo中的markdown有影响，对你平时用typora写其他文章没有任何影响。</p>\n<p>参考资料：<a href=\"https://support.typoraio.cn/YAML/\">YAML Front Matter - Typora Support (typoraio.cn)</a></p>\n</blockquote>\n<h2 id=\"3-4-Typora中的html标签插图\"><a href=\"#3-4-Typora中的html标签插图\" class=\"headerlink\" title=\"3.4. Typora中的html标签插图\"></a>3.4. Typora中的html标签插图</h2><p>​    如果你在Typora中右键点击一张图片，然后进行缩放，它就会从Markdown语法的图片:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片名称</span>](<span class=\"link\">图片路径</span>)</span><br></pre></td></tr></table></figure>\n\n<p>​    变成html格式的img标签，比如缩小到50%：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;图片路径&quot;</span> alt=<span class=\"string\">&quot;图片名称&quot;</span> style=<span class=\"string\">&quot;zoom: 50%;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​\thexo在把<code>.md</code>文章转换成html的时候，会自动根据我们设置的根目录来替换markdown格式图片的路径。</p>\n<p>​\t以本博客为例，<code>![测试图片](/imgs/image.png)</code>会被转换成<code>/jayant97.github.io/imgs/image.png</code>。</p>\n<p>​\t但是，如果<code>.md</code>文章里的图片本来就是html格式的标签，<strong>hexo不会对其进行任何转换</strong>。这就导致，在网站上，图片的路径还是<code>/imgs/image.png</code>，所以网站上就找不到图片了。</p>\n<p>​\t为了解决这个问题，网上解法很多。但我想了想，还是用Linux的sed命令来对文本进行替换，毕竟我并不懂JavaScripts。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br></pre></td></tr></table></figure>\n\n<p>​\t以上三个命令会把<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code> 和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>都替换成 <code>&lt;img src=&quot;/&lt;仓库名&gt;/imgs/</code>。</p>\n<blockquote>\n<p>默认情况下,html标签中的写法：</p>\n<ul>\n<li><p><code>./imgs</code>和<code>imgs</code>是一样的，在网页端会被当作<code>/&lt;文章名&gt;/imgs</code>。</p>\n</li>\n<li><p><code>/imgs</code>不会被转换，在网页端还是<code>/imgs</code></p>\n</li>\n</ul>\n<p>在网页上，以上两种方式都访问不到图片，只有<code>/jayant97.github.io/imgs</code>才能访问到图片。因为所有静态资源都在<code>source</code>文件夹下，而<code>source</code>中的内容会被拷贝到<code>&lt;site_name&gt;/xxxx.github.io/</code>中。</p>\n</blockquote>\n<p>​    把这些命令加到GitHub Actions中，这样我们本地用typora的时候还是能看到图片，push到远程的时候网页也能看到图片。</p>\n<p>​    首先在GitHub Actions的.yml文件中增加一个环境变量，方便后面更改：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221204210311635.png\" alt=\"image-20221204210311635\" style=\"zoom: 67%;\" />\n\n<p>​\t然后，在hexo部署的步骤之前，加入sed命令：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Sed</span> <span class=\"string\">img</span> <span class=\"string\">label</span></span><br><span class=\"line\">  <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样云端部署的时候就会自动帮你替换路径了。</p>\n<blockquote>\n<p>​\t但是，本地<code>hexo s --debug</code>去查看网页的时候，由于没有Actions帮你转换，图片还是看不了的。这个问题倒没什么影响。</p>\n</blockquote>\n<h2 id=\"3-5-Typora云端和本地图片互转\"><a href=\"#3-5-Typora云端和本地图片互转\" class=\"headerlink\" title=\"3.5. Typora云端和本地图片互转\"></a>3.5. Typora云端和本地图片互转</h2><p>如果你有一篇文章，以前所有的图片是放在云端的，现在想放在本地。可以批量操作：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222340559.png\" alt=\"image-20221203222340559.png\"></p>\n<p>​\t只要文章已经写好了Front-Matter，那么整个复制过程会从你设置的图片根目录，来自动设置图片的路径。</p>\n<p>​\t同理，也可以批量把本地图片上传到云端（需要提前设置好上传方式），<strong>文章内所有的图片路径都会自动更新</strong>。</p>\n<h2 id=\"3-6-文章的发布\"><a href=\"#3-6-文章的发布\" class=\"headerlink\" title=\"3.6. 文章的发布\"></a>3.6. 文章的发布</h2><p>​\t文章写好以后，可以<code>hexo s --debug</code>在本地查看一下。也可以<code>hexo d</code>直接从本地发布。但是既然我们已经搭建好CI系统，可以直接add，commit然后push，后面的事情就交给GitHub Actions完成了。</p>\n<p>​\tGithub Actions会在虚拟服务器上，根据我们写好的yml，自动执行<code>hexo g</code>然后<code>hexo d</code>，这样网站就重新部署好了。</p>\n<p>​\t但是这又会产生新问题：<strong>我们每次发布新文章，所有旧的文章都会被重新部署一遍</strong>，导致整个网站所有文章的更新日期都变成一样的了：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104121209837.png\" alt=\"image-20230104121209837\"></p>\n<p>​\t</p>\n<h1 id=\"4-网站的其他设置\"><a href=\"#4-网站的其他设置\" class=\"headerlink\" title=\"4. 网站的其他设置\"></a>4. 网站的其他设置</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>​    博客除了<strong>文章</strong>外，还有<strong>页面</strong>。页面的模板就是<code>scaffolds/post.md</code>。可以有时间线、标签、目录等页面，页面也存放在<code>source</code>目录下。</p>\n<p>​    在<code>_config.yml</code>中，配置了这些页面的目录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203225905257.png\" alt=\"image-20221203225905257\"></p>\n<p>​    基本上所有的配置你都可以在<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a> 和你所用的主题的官方文档中找到。</p>\n<h2 id=\"文章的永久链接（Permalinks）\"><a href=\"#文章的永久链接（Permalinks）\" class=\"headerlink\" title=\"文章的永久链接（Permalinks）\"></a>文章的永久链接（Permalinks）</h2><p>​\thexo默认的文章URL格式是<code>/年/月/日/文章标题</code>，如果你的文章标题有中文，这个URL就会巨长无比：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204210811289.png\" alt=\"image-20221204210811289\"></p>\n<p>​\t我的方案是改成用文章标题+日期的hash值去命名url，这样更简洁。</p>\n<p>​\t打开<strong>站点配置</strong><code>_config.yml</code>，修改：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:hash/</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样，文章的URL就会变成：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204211202297.png\" alt=\"image-20221204211202297\"></p>\n<p>​\t这样URL就比较短了。</p>\n<h2 id=\"文章的更新日期\"><a href=\"#文章的更新日期\" class=\"headerlink\" title=\"文章的更新日期\"></a>文章的更新日期</h2><p>​\t文章具有<strong>创建日期（date）</strong>和<strong>更新日期（updated）</strong>。默认情况下，更新日期使用的是操作系统中记录的文件最后修改日期。</p>\n<p>​\t但是我们利用Github Actions部署时，</p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><ul>\n<li>所有文章标题、文件名、目录名都不要有空格等特殊字符！！！（可以有减号<code>-</code>）</li>\n<li>本博客使用了Gitalk作为评论系统，把页面仓库的Github Issue变成一个评论区。会有一些API key之类的东西，明文配置在hexo仓库中，所以我把hexo仓库的权限设为私有了</li>\n<li>Front-Matter是yml格式，冒号<code>:</code>后面一定要加一个空格，不然识别不了。</li>\n</ul>\n","categories":["其他"],"tags":["hexo","GitHub Pages","GitHub Actions","Typora","博客搭建"]},{"title":"最简洁清爽的ssh使用方案","url":"/jayant97.github.io/2022/12/693c6a957393/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t已经2022年了，看到很多朋友还在使用Putty、MobaXTerm之类的软件，ssh连接到自己的各种linux开发板、服务器等。每次都要回忆IP地址、用户名、密码。如果要传输文件，scp又要又要输一遍IP地址、用户名、密码。整个搞下来，精神聚焦不了，烦躁程度直线上升。</p>\n<p>​\t今天把最方便的ssh使用方式分享给大家。先放一个<strong>演示效果</strong>如下：</p>\n<p>（1）在Linux shell终端，或者Windows Git Bash中，直接输入<code>ssh &lt;主机名&gt;</code>，就可<code>ssh</code>连接到指定主机，无需输入密码.</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193456382.png\" alt=\"image-20221214193456382\"></p>\n<center>上图为Windows11 Terminal中打开的Git Bash</center>\n\n\n<p>（2）<code>scp</code>远程拷贝，也只需主机名，无需用户名、密码：</p>\n<p>​\t<img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193918641.png\" alt=\"image-20221214193918641\"></p>\n<blockquote>\n<p>注：我的远程主机是OpenWrt，没安装sftp，所以这里<code>scp</code>要加<code>-O</code>参数。一般支持sftp的可以不加<code>-O</code>参数。</p>\n</blockquote>\n<p>（3）VS Code Remote，直接选择远程主机，无需密码</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194243898.png\" alt=\"image-20221214194243898\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194211714.png\" alt=\"image-20221214194211714\"></p>\n<blockquote>\n<p>注：VS Code Remote要求对方主机要有<code>glibc</code>和<code>libstdc++</code>，实际上OpenWrt的C运行库是musl，是不能用VS Code Remote连的，我这里只是展示一下。</p>\n<p>​\t大部分开发板的Linux系统都是可以使用VS Code Remote的</p>\n</blockquote>\n<h1 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h1><h2 id=\"2-1-创建密钥对\"><a href=\"#2-1-创建密钥对\" class=\"headerlink\" title=\"2.1. 创建密钥对\"></a>2.1. 创建密钥对</h2><p>​\t使用密钥对而非账户密码来进行<code>ssh</code>连接。这里先生成密钥对</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C <span class=\"string\">&quot;xxxx@xxx.com&quot;</span> -f ~/.ssh/my_ed25519</span><br><span class=\"line\"><span class=\"comment\"># 一路回车即可，不要输入任何内容</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t参数说明：</p>\n<ul>\n<li><code>-t</code>：加密算法，目前推荐ed25519，rsa已经不够安全</li>\n<li><code>-C</code>：备注信息，写一些明文备注，可以写任何东西，让你记得这是个啥。如果是GitHub的密钥，则需要输入本地git邮箱。</li>\n<li><code>-f</code>：存放私钥的文件，会新建一个文件，建议放在<code>~/.ssh/</code>下</li>\n</ul>\n<p>​\t创建完毕后，会发现<code>.ssh</code>目录下有公钥和私钥文件，其中带<code>.pub</code>后缀的是公钥：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214195611976.png\" alt=\"image-20221214195611976\"></p>\n<h2 id=\"2-2-安装公钥到远程主机\"><a href=\"#2-2-安装公钥到远程主机\" class=\"headerlink\" title=\"2.2. 安装公钥到远程主机\"></a>2.2. 安装公钥到远程主机</h2><p>​\t把公钥安装到远程主机，输入以下命令，最后填入你自己的填入远程主机用户名和IP地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/my_ed25519.pub root@192.168.2.1</span><br></pre></td></tr></table></figure>\n\n<p>参数说明:</p>\n<ul>\n<li><code>-i</code>：公钥文件</li>\n</ul>\n<p>第一次安装会要求你输入密码，输入密码后即为安装成功</p>\n<h2 id=\"2-3-配置ssh\"><a href=\"#2-3-配置ssh\" class=\"headerlink\" title=\"2.3. 配置ssh\"></a>2.3. 配置ssh</h2><p>​\t修改<code>~/.ssh/config</code>，如果没有就创建一个新的，内容示例如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host aliyun</span><br><span class=\"line\">    HostName xxx.xxx.xxx.xxx</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_ed25519_aliyun</span><br><span class=\"line\">Host google</span><br><span class=\"line\">    HostName xxx.xxx.xxx.xxx</span><br><span class=\"line\">    User ubuntu</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/ds.txt</span><br><span class=\"line\">Host r5s</span><br><span class=\"line\">    HostName 192.168.2.1</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Host</code>：命名，可以随便取名英文字母+数字+下划线</li>\n<li><code>HostName</code>：主机名，可填IP地址或域名</li>\n<li><code>User</code>：用户名</li>\n<li><code>Port</code>：端口号，如果不配置，默认是22</li>\n<li><code>IndentityFile</code>：私钥文件，必须是与前一步安装的公钥成对的私钥文件</li>\n</ul>\n<h2 id=\"2-4-测试\"><a href=\"#2-4-测试\" class=\"headerlink\" title=\"2.4. 测试\"></a>2.4. 测试</h2><p>直接使用<code>config</code>中命名的别名就可以进行ssh连接，无需输入密码，例如：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193456382.png\" alt=\"image-20221214193456382\"></p>\n<h1 id=\"3-其他相关话题\"><a href=\"#3-其他相关话题\" class=\"headerlink\" title=\"3. 其他相关话题\"></a>3. 其他相关话题</h1><h2 id=\"3-1-VS-Code-Remote\"><a href=\"#3-1-VS-Code-Remote\" class=\"headerlink\" title=\"3.1. VS Code Remote\"></a>3.1. VS Code Remote</h2><p>​\t直接在插件商店搜索remote，安装remote开发合集即可，会自动安装remote ssh等：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214200636992.png\" alt=\"image-20221214200636992\"></p>\n<p>​\t然后点击左下角即可开始选择远程主机：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214200752517.png\" alt=\"image-20221214200752517\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194211714.png\" alt=\"image-20221214194211714\"></p>\n<p>​\t第一次连接，需要选择是Linux&#x2F;Windows&#x2F;Mac OS，然后VS Code会自动在对方主机上编译安装服务端，需要对方主机上有C++环境。需要等待一段时间：<br><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214201022079.png\" alt=\"image-20221214201022079\"></p>\n<p>​\t安装完毕后，在VS Code中打开文件夹，就像在本地一样操作，左侧文件栏是可以拖放文件的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214210243472.png\" alt=\"image-20221214210243472\"></p>\n<h2 id=\"3-2-固定IP地址\"><a href=\"#3-2-固定IP地址\" class=\"headerlink\" title=\"3.2. 固定IP地址\"></a>3.2. 固定IP地址</h2><p>​\t现在家用网络很少用静态IP了，而是路由器通过DHCP服务自动给设备分配IP地址。但是我们希望：</p>\n<ul>\n<li>自己在家调试时，开发板不要每次上电IP地址就变化</li>\n<li>不要在开发板上配置静态IP，不然把板子带到其他地方去联网就又要重新配置动态获取IP了</li>\n</ul>\n<p>​\t解决方法是，DHCP客户端（板子）仍然申请IP，但是DHCP服务器（路由器）只会分配固定的IP地址给它。</p>\n<blockquote>\n<p>DHCP静态分配与“静态IP”不是一个概念，但可以达到我们希望IP地址不变的效果</p>\n</blockquote>\n<p>​\t路由器管理页面种类很多，但是原理都是相通的，这里以OpenWrt为例：</p>\n<p>（1）选择 “网络”——“DHCP&#x2F;DNS”</p>\n<img src=\"/jayant97.github.io/imgs/最简洁清爽的ssh使用方案.assets/image-20221214202240725.png\" alt=\"image-20221214202240725\" style=\"zoom:50%;\" />\n\n<p>（2）可以看到已分配的IP地址，找到你的开发板，记住MAC地址：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202411249.png\" alt=\"image-20221214202411249\"></p>\n<p>（3）在下方，“静态地址分配”中，选择“添加”，然后给MAC地址绑定一个固定的IP地址即可，主机名可以随便取个名，也可以不填：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202548591.png\" alt=\"image-20221214202548591\"></p>\n<p>（4）页面中选择“保存&amp;应用”即可：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202711815.png\" alt=\"image-20221214202711815\"></p>\n<blockquote>\n<p>注意：</p>\n<p>​\tDHCP静态绑定，并不是说这个IP地址就不会被其它设备动态获取到了。只要这个IP在动态IP池子里，就有可能在被绑定的设备不在线时，动态分配给其他设备。</p>\n<p>​\t为了避免这种情况，我们做DHCP静态分配时，最好把静态分配的地址放在动态分配地址池之外。</p>\n<p>​\t以我的OpenWrt为例：</p>\n<p>​\t在“网络”——“接口”——“LAN接口配置修改”中，可以看到DHCP服务器的设置：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214205402842.png\" alt=\"image-20221214205402842\"></p>\n<p>​\t可以看到基址是100，范围是150.由于我的LAN网段是 192.168.2.0&#x2F;24，所以动态地址池的分配范围就是192.168.2.100 ~ 192.168.2.250. </p>\n<p>​\t所以前面做DHCP静态绑定时，IP地址设在这个范围之外即可。</p>\n</blockquote>\n","categories":["Linux","ssh"],"tags":["Linux","ssh"]},{"title":"理解Zephyr项目的配置与构建系统","url":"/jayant97.github.io/2022/12/2a39e705bff0/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>Zephyr Project是Linux基金会推出的一个Apache2.0开源项目，版权非常友好，适合用于商业项目开发。包含RTOS、编译系统、各类第三方库。NCS中的例程基本都跑在[Zephyr RTOS](<a href=\"https://docs.zephyrproject.org/latest/kernel/index.html\">Kernel — Zephyr Project Documentation</a>)上。</p>\n<p>对于之前只接触过<strong>IDE+外设驱动库</strong>这种开发方式的开发者来说，Zephyr的配置和编译系统可能比较令人费解，但是一旦你能掌握，就会发现它的方便之处。</p>\n<p>本文会以最容易理解的方式讲解 Zephyr 的构建系统（Build System）。并列出一些例子。</p>\n<h1 id=\"2-通过CMake管理源码\"><a href=\"#2-通过CMake管理源码\" class=\"headerlink\" title=\"2. 通过CMake管理源码\"></a>2. 通过CMake管理源码</h1><p>本节讲解源码如何管理，不讲CMake的细节。</p>\n<h2 id=\"CMake基本写法\"><a href=\"#CMake基本写法\" class=\"headerlink\" title=\"CMake基本写法\"></a>CMake基本写法</h2><p>通过<code>zephyr/samples/hello_world</code>例程的<code>CMakeLists.txt</code>，我们可以看到：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定CMake版本</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.20</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从环境变量$&#123;ZEPHYR_BASE&#125;找到NCS中的Zephyr安装目录</span></span><br><span class=\"line\"><span class=\"comment\"># 并把整个Zephyr系统当作包来导入</span></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Zephyr REQUIRED HINTS $ENV&#123;ZEPHYR_BASE&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设定项目名称</span></span><br><span class=\"line\"><span class=\"keyword\">project</span>(hello_world)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把main.c添加为app目标的源码</span></span><br><span class=\"line\"><span class=\"keyword\">target_sources</span>(app PRIVATE src/main.c)</span><br></pre></td></tr></table></figure>\n\n<p>这里的编译目标是<code>app</code>，最终会编译为<code>libapp.a</code>，也就是把用户自己的应用层代码编译成库的形式。最后再链接进Zephyr系统。</p>\n<p>这里的<code>PRIVATE</code>控制的是编译的行为：</p>\n<ul>\n<li><code>PRIVATE</code>：main.c修改后，只会重新编译app目标</li>\n<li><code>PUBLIC</code>：main.c修改后，app目标要重新编译，且所有与APP目标链接的其他目标也要重新编译</li>\n</ul>\n<h2 id=\"条件添加源码\"><a href=\"#条件添加源码\" class=\"headerlink\" title=\"条件添加源码\"></a>条件添加源码</h2><p>条件添加也很好理解，就是某个CMake变量值为true时，才把源码添加到目标中去。例如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Include UART ASYNC API adapter</span></span><br><span class=\"line\">target_sources_ifdef(CONFIG_BT_NUS_UART_ASYNC_ADAPTER app PRIVATE</span><br><span class=\"line\">  src/uart_async_adapter.c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>这里就是<code>CONFIG_BT_NUS_UART_ASYNC_ADAPTER</code>为<code>y</code>时，才添加<code>src/uart_async_adapter.c</code>到源码中。</p>\n<h2 id=\"目录添加\"><a href=\"#目录添加\" class=\"headerlink\" title=\"目录添加\"></a>目录添加</h2><p>有时目录层级很多，我们没必要在一个CMakeLists.txt里把所有源码都添加完。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-CMakeLists.txt</span><br><span class=\"line\">|-aaa</span><br><span class=\"line\">|  |-CMakeLists.txt</span><br><span class=\"line\">|  `-main.c</span><br><span class=\"line\">`-bbb</span><br><span class=\"line\">   |-CMakeLists.txt</span><br><span class=\"line\">   `-hello.c</span><br></pre></td></tr></table></figure>\n\n<p>这时，就可以在项目根目录的CMakeLists.txt中写：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(aaa)</span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(bbb)</span><br></pre></td></tr></table></figure>\n\n<p>然后在两个子目录的CMakeLists.txt中添加对应的源码。</p>\n<p>当然，目录也是可以条件添加的，最典型的就是在<code>$&#123;NCS&#125;/zephyr/driver/CMakeLists.txt</code>中：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_subdirectory_ifdef(CONFIG_ADC adc)</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，只有启用了<code>CONFIG_ADC=y</code>，Zephyr才会去编译<code>$&#123;NCS&#125;/zephyr/driver/adc/</code>目录下的驱动。</p>\n<p>此外，如果再去看<code>$&#123;NCS&#125;/zephyr/driver/adc/CMakeLists.txt</code>：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_MCUX_LPADC    adc_mcux_lpadc.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_SAM_AFEC    adc_sam_afec.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_NRFX_ADC    adc_nrfx_adc.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_NRFX_SAADC    adc_nrfx_saadc.c)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>就可以看到，这里又根据不同的MCU平台，来添加对应的adc驱动代码。</p>\n<h2 id=\"添加include目录\"><a href=\"#添加include目录\" class=\"headerlink\" title=\"添加include目录\"></a>添加include目录</h2><p>也就是存放头文件的目录，如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加CMakeLists.txt所在目录下的inc/目录到app目标</span></span><br><span class=\"line\"><span class=\"keyword\">target_include_directories</span>(app PRIVATE inc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也是可以条件添加的</span></span><br><span class=\"line\">zephyr_include_directories_ifdef(CONFIG_MEMFAULT configuration/memfault)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置变量\"><a href=\"#设置变量\" class=\"headerlink\" title=\"设置变量\"></a>设置变量</h2><p>和宏定义类似，把A定义成B。这里，主要是用来定义一些编译系统会用到的东西：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定自己项目的device tree overlay文件（和VS Code中添加build target时，手动选择overlay是一样的）</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>(DTC_OVERLAY_FILE app.oerlay)</span><br></pre></td></tr></table></figure>\n\n<p>这和命令行编译时，通过<code>-D</code>选项传入的参数是一样的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build --build-dir /home/jayant/project/ncs-project/peripheral_uart/build \\</span><br><span class=\"line\">  /home/jayant/project/ncs-project/peripheral_uart \\</span><br><span class=\"line\">  --pristine \\</span><br><span class=\"line\">  --board nrf52840dk_nrf52840 \\</span><br><span class=\"line\">  --no-sysbuild \\</span><br><span class=\"line\">  -- \\</span><br><span class=\"line\">      -DNCS_TOOLCHAIN_VERSION:STRING=<span class=\"string\">&quot;NONE&quot;</span> \\</span><br><span class=\"line\">      -DBOARD_ROOT:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/peripheral_uart&quot;</span> \\</span><br><span class=\"line\">      -DCONF_FILE:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/peripheral_uart/prj.conf&quot;</span> \\</span><br><span class=\"line\">      -DDTC_OVERLAY_FILE:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/peripheral_uart/app.overlay&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>项目通过CMake管理源码和include目录。项目本身会把应用代码编译成<code>build/app/libapp.a</code>，最后和Zephyr系统一起链接成可执行文件。</p>\n<p>Zephyr系统本身的内核、库、驱动等源码也都是用CMake来管理的。</p>\n<h1 id=\"3-通过Kconfig管理配置\"><a href=\"#3-通过Kconfig管理配置\" class=\"headerlink\" title=\"3. 通过Kconfig管理配置\"></a>3. 通过Kconfig管理配置</h1><p>一个编译系统中，肯定有很多配置项的需求，如：</p>\n<ul>\n<li>前面所述的CMake条件添加源码的功能，实现内核的功能的裁减，按需添加源码</li>\n<li>代码中的宏，通过宏来实现一些参数值的配置，或者进行条件编译</li>\n</ul>\n<p>在Zephyr系统中，每个模块都会有自己的配置项；并且，开发者自己的项目也会有很多配置项；此外，有些配置项之间还有依赖关系。如此复杂的关系，该如何管理？</p>\n<p>Kconfig就是把一个模块的所有配置项组成一个菜单。所有模块的菜单，通过层级关系拼接在一起，形成一个大菜单。</p>\n<h2 id=\"了解Kconfig菜单基本写法\"><a href=\"#了解Kconfig菜单基本写法\" class=\"headerlink\" title=\"了解Kconfig菜单基本写法\"></a>了解Kconfig菜单基本写法</h2><p>可以先从一个简单的例子<code>$&#123;NCS&#125;/nrf/samples/bluetooth/peripheral_uart</code>来参考：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 引用Zephyr的Kconfig菜单</span><br><span class=\"line\">source &quot;Kconfig.zephyr&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义本项目的菜单</span><br><span class=\"line\">menu &quot;Nordic UART BLE GATT service sample&quot;</span><br><span class=\"line\">   ... 此处省略...</span><br><span class=\"line\">endmenu</span><br></pre></td></tr></table></figure>\n\n<p>菜单中的选项，可以配置它的类型、说明，和<strong>默认值</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 此选项用来设置Nordic UART Service线程的栈大小</span><br><span class=\"line\"># 并且具有默认值</span><br><span class=\"line\">config BT_NUS_THREAD_STACK_SIZE</span><br><span class=\"line\">    int &quot;Thread stack size&quot;</span><br><span class=\"line\">    default 1024</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Stack size used in each of the two threads</span><br></pre></td></tr></table></figure>\n\n<p>菜单中的选项可以<strong>连锁使能</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 当本选项被设置成y时，通过select，同时把CONFIG_BT_SMP的值设置成y</span><br><span class=\"line\">config BT_NUS_SECURITY_ENABLED</span><br><span class=\"line\">    bool &quot;Enable security&quot;</span><br><span class=\"line\">    default y</span><br><span class=\"line\">    select BT_SMP</span><br><span class=\"line\">    help</span><br><span class=\"line\">      &quot;Enable BLE security for the UART service&quot;</span><br></pre></td></tr></table></figure>\n\n<p>此外，一个选项也可以指定一个<strong>依赖项</strong>。如果本选项被启用，但依赖项未被启用，则编译前的配置过程就会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 配置是否在系统启动时，自动初始化USB ACM设备 （用于输出日志）</span><br><span class=\"line\"># 此配置依赖于CONFIG_USB_CDC_ACM=y，也就是说，起码要把USB_CDC_ACM的代码编译进来</span><br><span class=\"line\">config USB_DEVICE_INITIALIZE_AT_BOOT</span><br><span class=\"line\">    bool &quot;Initialize USB device support at boot&quot;</span><br><span class=\"line\">    depends on USB_CDC_ACM</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Use CDC ACM UART as backend for console, shell, or logging.</span><br></pre></td></tr></table></figure>\n\n<p>当然，Kconfig也不是说要写的非常大，把整个项目的配置都写进去。你也可以每个子文件夹下单独写Kconfig，然后在项目的Kconfig中进行包含：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 通过绝对路径进行包含</span><br><span class=\"line\">source &quot;xxx.Kconfig&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 通过相对路径进行包含</span><br><span class=\"line\">rsource &quot;src/xxx.Kconfig&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>某些简单例程，例如<code>zephyr/samples/hello_world</code>，没有什么配置项，所以是可以没有自己的Kconfig的。这种情况下，相当于直接用了Zephyr的Kconfig菜单，也就是相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"Kconfig交互式菜单\"><a href=\"#Kconfig交互式菜单\" class=\"headerlink\" title=\"Kconfig交互式菜单\"></a>Kconfig交互式菜单</h2><p>我们知道，Kconfig实际上是定义了一个菜单，在哪里能看到这个菜单呢？</p>\n<p>我们可以在VS Code中点击nRF Kconfig GUI:</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028192036882.png\" alt=\"image-20231028192036882\"></p>\n<p>也可以把鼠标悬浮在这个按钮上，点右边的三个点，然后用Guiconfig（弹窗）或Menuconfig（命令行）的方式进行配置。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028192059493.png\" alt=\"image-20231028192059493\"></p>\n<p>这里就只介绍nRF Kconfig GUI：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028192424706.png\" alt=\"image-20231028192424706\"></p>\n<p>可以看到，菜单的顺序，与我们在Kconfig中编写的顺序是一致的。前面是<code>source &quot;Kconfig.zephyr&quot;</code>添加的Zephyr菜单；后面是<code>menu &quot;Nordic UART BLE GATT service sample&quot;</code>定义的本例程的菜单。</p>\n<h2 id=\"保存Kconfig交互式菜单的修改\"><a href=\"#保存Kconfig交互式菜单的修改\" class=\"headerlink\" title=\"保存Kconfig交互式菜单的修改\"></a>保存Kconfig交互式菜单的修改</h2><p>如果我们只是单纯点击界面右上角的”Apply”，那么这些配置是保存在<code>build/zephyr/.config</code>中的。这是编译过程中生成的一个临时文件，是把各种配置项来源整合到一起，得到的最终配置文件。</p>\n<p>如果我们进行pristine build，那么<code>.config</code>文件就会重新生成，我们之前的修改就消失了。</p>\n<p>要想永久保存，应该点击“save to file”。然后保存到<code>prj.conf</code>中。</p>\n<h2 id=\"Kconfig配置项的来源\"><a href=\"#Kconfig配置项的来源\" class=\"headerlink\" title=\"Kconfig配置项的来源\"></a>Kconfig配置项的来源</h2><p>前面提到，<code>.config</code>是把各种来源的配置项整合到一起。那么，配置项总共有哪些来源呢？</p>\n<ol>\n<li>Kconfig菜单中的默认值</li>\n<li>选择板子后，板子自带的一些config。可以在<code>zephyr/boards</code>或者<code>nrf/boards</code>中查看。</li>\n<li>CMake变量<code>CONF_FILE</code>指定的配置文件，<strong>这也是最常用的</strong>。默认情况下是以下两个文件：<ul>\n<li>项目的<code>prj.conf</code>，它可以覆盖默认值；</li>\n<li>项目的<code>boards/&lt;board_name&gt;.conf</code>，当编译目标中选择的板子和这里的board_name一致时，可以覆盖默认值。此配置和前一项会合并。</li>\n</ul>\n</li>\n<li>CMake变量<code>OVERLAY_CONFIG</code>指定的额外配置文件，也就是在VS Code中创建新的build target时，可以选择的”Kconfig fragments”</li>\n</ol>\n<h2 id=\"显性与隐性配置项\"><a href=\"#显性与隐性配置项\" class=\"headerlink\" title=\"显性与隐性配置项\"></a>显性与隐性配置项</h2><p>在Kconfig中定义菜单选项时，我们会发现，大多数选项，在变量类型后面会有一个**说明字符串(prompt)**：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config FPU</span><br><span class=\"line\">   bool &quot;Support floating point operations&quot;</span><br><span class=\"line\">   depends on HAS_FPU</span><br></pre></td></tr></table></figure>\n\n<p>这意味着，这个配置项会出现在Kconfig交互式菜单中，我们可以在交互式菜单中修改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ ] Support floating point operations</span><br></pre></td></tr></table></figure>\n\n<p>也可以用<code>prj.conf</code>之类的配置文件来直接改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_FPU=y</span><br></pre></td></tr></table></figure>\n\n<p>但是，也有一些<strong>隐性配置项</strong>，它们的变量类型后面不带说明字符串，我们无法直接修改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config CPU_HAS_FPU</span><br><span class=\"line\">   bool</span><br><span class=\"line\">   help</span><br><span class=\"line\">     This symbol is y if the CPU has a hardware floating point unit.</span><br></pre></td></tr></table></figure>\n\n<p>一个CPU到底带不带FUP，肯定不由开发者的配置决定，因此不能直接修改是很合理的。</p>\n<p>这种配置，通常是通过<strong>连锁使能select</strong>的方式，被其他配置项使能的，例如<code>zephyr/soc/arm/nordic_nrf/nrf52/Kconfig.soc</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 隐性配置项</span><br><span class=\"line\">config SOC_NRF52840</span><br><span class=\"line\">    bool</span><br><span class=\"line\">    select CPU_CORTEX_M_HAS_DWT</span><br><span class=\"line\">    select CPU_HAS_FPU</span><br><span class=\"line\">    </span><br><span class=\"line\"> ... </span><br><span class=\"line\"> </span><br><span class=\"line\"> # 显性配置项</span><br><span class=\"line\"> config SOC_NRF52840_QIAA</span><br><span class=\"line\">    bool &quot;NRF52840_QIAA&quot;</span><br><span class=\"line\">    select SOC_NRF52840</span><br></pre></td></tr></table></figure>\n\n<p>而这个<code>SOC_NRF52840_QIAA</code>，是我们选择板子时，52840DK的板子自带的默认配置，来自于<code>zephyr/samples/application_development/out_of_tree_board/boards/arm/nrf52840dk_nrf52840/nrf52840dk_nrf52840_defconfig</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_SOC_NRF52840_QIAA=y</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Zephyr的配置系统是Kconfig定义的菜单。可以用<code>prj.conf</code>之类的文件来修改配置项的值。</p>\n<p>Kconfig中的配置项，可以影响CMake中的条件，选择是否添加哪些源码，从而剪裁内核。</p>\n<p>Kconfig中的配置项，最终会生成到<code>build/zephyr/include/generated/autoconf.h</code>中，成为源代码中也可以用到的宏。</p>\n<p>不要去尝试修改隐性的Kconfig配置项。</p>\n<h1 id=\"4-DeviceTree和Zephyr驱动模型\"><a href=\"#4-DeviceTree和Zephyr驱动模型\" class=\"headerlink\" title=\"4. DeviceTree和Zephyr驱动模型\"></a>4. DeviceTree和Zephyr驱动模型</h1><p>device tree比较复杂，具体的语法、使用方法可以参考我的另一篇文章：<a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">《详解Zephyr设备树（DeviceTree）与驱动模型》</a>。</p>\n<p>本文中尽量简洁地说明device tree的用途。</p>\n<h2 id=\"DTS文件\"><a href=\"#DTS文件\" class=\"headerlink\" title=\"DTS文件\"></a>DTS文件</h2><p>device tree的文件是Device Tree Source (DTS)。这里用最简洁的语言描述一下dts文件的产生：</p>\n<ol>\n<li>芯片级的dts文件，定义了芯片上的各种外设资源及其地址；</li>\n<li>板级的dts文件，可以包含芯片级的dts文件。板级的dts文件中，也会包含板子上的资源，如按键、LED、i2c外设等等；</li>\n<li>在工程中选板子时，实际上就是选择了板级的dts文件。在工程中，如果想修改默认的dts，是通过<code>*.overlay</code>文件进行覆盖；</li>\n<li>编译时，所有这些dts会合并成<code>build/zephyr.dts</code>。这就是最终的dts。</li>\n</ol>\n<blockquote>\n<p>overlay文件的逻辑和Kconfig的逻辑类似：</p>\n<ul>\n<li><code>app.overlay</code>是整个项目的overlay</li>\n<li><code>boards/&lt;board_name&gt;.overlay</code>是板子对应的overlay</li>\n</ul>\n</blockquote>\n<h2 id=\"Zephyr驱动程序\"><a href=\"#Zephyr驱动程序\" class=\"headerlink\" title=\"Zephyr驱动程序\"></a>Zephyr驱动程序</h2><p>Zephyr到底是怎么实现，不同的MCU平台共用同一套外设API的？</p>\n<p>其实，Zephyr的外设API，如果我们去查看其定义，其实都没做什么有意义的操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title function_\">z_impl_uart_tx</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device *dev, <span class=\"type\">const</span> <span class=\"type\">uint8_t</span> *buf,</span></span><br><span class=\"line\"><span class=\"params\">                 <span class=\"type\">size_t</span> len, <span class=\"type\">int32_t</span> timeout)</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_driver_api</span> *<span class=\"title\">api</span> =</span></span><br><span class=\"line\">            (<span class=\"type\">const</span> <span class=\"keyword\">struct</span> uart_driver_api *)dev-&gt;api;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 其本质上是调用了device结构体中,api这个成员的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> api-&gt;tx(dev, buf, len, timeout);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>device结构体的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;           <span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *config;         <span class=\"comment\">// 设备的初始配置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *api;            <span class=\"comment\">// 设备的api函数集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_state</span> *<span class=\"title\">state</span>;</span> <span class=\"comment\">// 设备的工作状态</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *data;                 <span class=\"comment\">// 设备的运行数据</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span>                   <span class=\"comment\">// 其他参数，例如电源管理</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>实际上，在<code>main()</code>函数运行起来之前，设备驱动的初始化程序就已经先行运行了，有以下5个阶段可以用来初始化外设驱动：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20230312215847338.png\" alt=\"image-20230312215847338\"></p>\n<p>Zephyr外设驱动的整个流程：</p>\n<ol>\n<li><p>开发者在Kconfig中，使能了某个外设驱动，如<code>CONFIG_ADC=y</code></p>\n</li>\n<li><p><code>zephyr/driver/</code>下的CMakeLists.txt，根据<code>CONFIG_ADC=y</code>，把<code>zephyr/driver/adc/</code>添加到工程中</p>\n</li>\n<li><p><code>zephyr/driver/adc/</code>下有各个半导体厂商向Zephyr提交的ADC驱动代码。此目录下的CMakeLists.txt根据Nordic平台，选择添加Nordic的nrfx adc驱动代码到Zephyr系统中进行编译</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_NRFX_ADC    adc_nrfx_adc.c)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译时，nrfx adc驱动代码中，会通过宏来搜索<code>zephyr.dts</code>中的所有ADC节点，看哪些节点的<code>status=&quot;okay&quot;</code>，就<strong>初始化那个外设</strong>，并且为这个外设定义一个<code>device</code>结构体实例，并且初始化这个实例。<code>api</code>就是这个时候赋值的。</p>\n</li>\n<li><p>在开发者的应用层代码中，先获得这个device结构体的指针。后续调用Zephyr标准外设API时，需要把这个指针作为参数传入。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Zephyr有一套宏，可以从device tree中的节点，获得对应的device结构体指针</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">uart1_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(uart1));</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Zephyr-DeviceTree和驱动模型的优劣\"><a href=\"#Zephyr-DeviceTree和驱动模型的优劣\" class=\"headerlink\" title=\"Zephyr DeviceTree和驱动模型的优劣\"></a>Zephyr DeviceTree和驱动模型的优劣</h2><p>优点：</p>\n<ul>\n<li>代码里调用的都是Zephyr标准API，与硬件细节无关。如果后需要更换MCU平台，几乎没有什么移植成本，只需要更换所选的board即可。</li>\n<li>通用性强，无论是普通的串口，还是USB串口，抑或是<a href=\"\">LPUART</a>，它们的应用层代码均是Zephyr标准API，只需要更换底层驱动即可。</li>\n<li>开发者无需花精力在标准、通用的基本功能上，如串口、SPI、网络、按钮等。因为这些驱动都是厂商提供的，在性能、健壮性、功能性上往往都强于开发者自己用寄存器或外设驱动库开发的代码。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><p>上手难度稍高，需要花精力去学习语法，并且要简单了解驱动代码</p>\n</li>\n<li><p>功能不完全。Zephyr只提供最标准的用法，当用到串口、spi、i2c等协议时，就是最标准的协议。一旦有不符合标准的，或者Zephyr标准库未提供的功能，就无法在Zephyr驱动模型的框架下实现了。</p>\n<blockquote>\n<p>例如，nordic的芯片有PPI的功能，可以让一个外设的event触发另一个外设的task。这个功能Zephyr是没有标准驱动的。</p>\n<p>Nordic可以在提交给Zephyr的驱动代码中用PPI。例如，在串口驱动中，通过uart外设和timer外设，加上PPI，实现异步流控串口（Timer的作用是记录发送&#x2F;接收了多少字节，然后用PPI控制GPIO CTS&#x2F;RTS），<strong>Nordic提供的驱动代码，把他们整体封装成串口</strong>，也就是说，Zephyr标准驱动操作的串口，实际并不是单独对应uart这一个外设，而是UART+GPIOTE+TIMER+PPI的复合外设。</p>\n<p>如果用户想自己用PPI实现一些自定义功能，只能直接调用nrfx api。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>dts怎么写，本质上取决于驱动代码里怎么读取dts。dts的本质就是保存硬件细节相关的信息，使自己的应用代码与硬件细节解耦。</p>\n<p>要更详细地了解Device Tree，请参考<a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">《详解Zephyr设备树（DeviceTree）与驱动模型》</a>。</p>\n<h1 id=\"5-配置与编译过程\"><a href=\"#5-配置与编译过程\" class=\"headerlink\" title=\"5. 配置与编译过程\"></a>5. 配置与编译过程</h1><p>本节简要介绍整个编译过程，详细的过程可以参考：<a href=\"https://docs.zephyrproject.org/latest/build/cmake/index.html\">Zephyr官方文档</a></p>\n<ol>\n<li>合并所有来源的device tree，生成<code>build/zephyr.dts</code>；</li>\n<li>合并所有来源的Kconfig配置项，其中Kconfig是可以读取device tree的，也就是说device tree中的选项会影响到Kconfig中的某些配置，通常是隐性配置；</li>\n<li>device tree的配置最终会生成：<code>build/zephyr/include/generated/devicetree_generated.h</code><br>Kconfig的配置最终会生成：<code>build/zephyr/include/generated/autoconf.h</code></li>\n<li>CMake配置会生成ninja配置（这是一个类似于makefile的工具），然后根据ninja文件调用工具链中的gcc，把每个源文件编译并链接到一起。</li>\n</ol>\n<p>如果是简单的，单分区的工程，最终会编译成<code>build/zephyr/zephyr.hex</code>。</p>\n<p>如果是多分区的工程，例如带bootloader的工程，最终会编译成<code>build/zephyr/merged.hex</code>。</p>\n<h1 id=\"6-其他配置\"><a href=\"#6-其他配置\" class=\"headerlink\" title=\"6. 其他配置\"></a>6. 其他配置</h1><h2 id=\"子镜像的配置\"><a href=\"#子镜像的配置\" class=\"headerlink\" title=\"子镜像的配置\"></a>子镜像的配置</h2><p>子镜像有两种情况：</p>\n<ol>\n<li>一个flash上有多个分区。例如应用程序和bootloader，则bootloader是子镜像</li>\n<li>双核固件。nRF5340是双核MCU，两个核运行的是不同的固件。运行蓝牙例程时，Application core运行用户的应用程序，Network Core运行的是<code>$&#123;NCS&#125;/zephyr/samples/bluetooth/hci_rpmsg</code>。此时，<code>hci_rpmsg</code>是子镜像。</li>\n</ol>\n<p>一个工程只包含主镜像的源码，编译时会自动在<code>build/&lt;child_image_name&gt;/</code>目录下同时编译子镜像，最终合并成<code>build/zephyr/merged.hex</code>。</p>\n<p>如何在工程中<strong>修改子镜像的Kconfig或者overlay</strong>？可以新建一个<code>child_image/</code>目录，放入配置。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028220754152.png\" alt=\"image-20231028220754152\"></p>\n<p>有两种方法：</p>\n<ul>\n<li><code>child_image/&lt;name&gt;.conf</code>和<code>child_image/&lt;name&gt;.overlay</code>，分别可以覆盖子镜像的<code>prj.conf</code>和<code>app.overlay</code></li>\n<li>也可以建立<code>child_image/&lt;name&gt;/</code>文件夹，在文件夹中就像在子镜像的根目录中一样，写<code>prj.conf</code>和<code>boards/</code>文件夹</li>\n</ul>\n<p>子镜像是怎么添加到工程中的？如何把默认的子镜像改成自己修改过的子镜像？请参考NCS原始文档 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/config_and_build/multi_image.html#multi-image-builds\">Multi-image builds</a></p>\n<h2 id=\"Shield配置\"><a href=\"#Shield配置\" class=\"headerlink\" title=\"Shield配置\"></a>Shield配置</h2><p>很多开发板都是支持Arduino接口的，因此很多器件厂商&#x2F;分销商会制作Ardiono接口的扩展板：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028214708544.png\" alt=\"image-20231028214708544\"></p>\n<p>Zephyr中，也会有这些扩展板的配置（包含device tree和Kconfig）。如果要在工程中启用扩展板，则需要设置CMake变量：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(SHIELD nrf21540_ek)</span><br></pre></td></tr></table></figure>\n\n<p>或者在编译目标的配置中添加CMake参数：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20231028215131762.png\" alt=\"image-20231028215131762\"></p>\n<p>编译时，会自动合并原始板子和扩展板的Kconfig和Devicetree。</p>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr"]},{"title":"详解Zephyr设备树（DeviceTree）与驱动模型","url":"/jayant97.github.io/2023/03/4b274a50e575/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\tNordic最新的开发包NCS（nRF Connect SDK）相对于原来的nRF5 SDK来说，最大的更新莫过于采用了Zephyr系统。而Zephyr不单单是一个用来做多线程的RTOS，它更大的价值在于其自带的各种开源的协议栈、框架、软件包、驱动代码等。如果不是为了使用这些现成的协议栈和软件包，只是单纯使用RTOS，实际上并不会产生什么价值。可以说，Zephyr是为物联网而生的。</p>\n<p>​\tZephyr采用Kconfig对这些软件包进行管理，可以方便地使能或剪裁。而为了使Zephyr自带的硬件驱动代码能够通用，Zephyr采用了DeviceTree来描述硬件。各个半导体厂商把自己的硬件描述成标准DeviceTree，并且按照Zephyr的接口提供驱动代码，然后一起提交给Zephyr。在方便地使用Zephyr中协议栈的同时，用户还能简单方便地使用到各个半导体厂家的硬件功能，这多是一件美事。</p>\n<p>​\t但由于目前中文互联网上没有一个很详细的从零开始的教程，导致很多人遇到Zephyr的DeviceTree感到很厌烦：「我之前配一下寄存器、调一下库函数就能操作硬件，怎么现在搞这么复杂？」</p>\n<p>​\t但是相信你读完本文后，能够感受到DeviceTree的便利之处。而所谓的<strong>复杂</strong>与<strong>简单</strong>，往往是相对的。人的大脑容量有限，所以我们要不断地对做事的方法进行压缩、抽象，充分利用别人已经完成的工作成果。这也是最早从机器码发展到汇编，再到现在各种高级语言的底层逻辑。</p>\n<p>​\t下面正式开始。</p>\n<h1 id=\"2-从一些习惯开始\"><a href=\"#2-从一些习惯开始\" class=\"headerlink\" title=\"2. 从一些习惯开始\"></a>2. 从一些习惯开始</h1><h2 id=\"硬件的抽象\"><a href=\"#硬件的抽象\" class=\"headerlink\" title=\"硬件的抽象\"></a>硬件的抽象</h2><p>​\t在做传统的嵌入式C语言开发时，我们常会使用宏定义的方式来实现<strong>硬件的抽象</strong>，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;gpio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PORT_LED_1 GPIO_PORT_0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIN_LED_1 GPIO_PIN_12</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t在实际的应用代码中，如果多次使用到这个GPIO，在想要修改IO的时候，只需要修改宏定义即可，而不需要把每一个用到这个IO的地方都改一遍。这种方法的优点很明显：简单直观。</p>\n<blockquote>\n<p>​\t其实我们写代码，最终都是在CPU上运行，操作的都是外设寄存器，而不是板子上的LED。当我们在代码里写什么LED驱动、屏幕驱动、电机驱动的时候，只是在用<strong>面向对象</strong>的思维方便开发者（也就是我们自己）而已。CPU是不会理解什么是LED、什么是屏幕、什么是电机的，它只是勤勤恳恳按照指令执行代码，从某些地址读写数据而已。</p>\n<p>​\t也就是说，地址、指令和数据才是核心。牢记这一点，才不会被DeviceTree中乱七八糟的硬件节点绕晕。</p>\n</blockquote>\n<p>​\t理解这种简单的操作，其实就已经为理解DeviceTree做好了铺垫。</p>\n<h2 id=\"代码的解耦\"><a href=\"#代码的解耦\" class=\"headerlink\" title=\"代码的解耦\"></a>代码的解耦</h2><p>​\t大家初学代码时，一定有过想要“解耦”开发的想法：把不同的功能写进不同的文件里，封装成模块，然后在主函数里分别调用这些库即可，不同的模块之间完全解耦。</p>\n<p>​\t这种想法在做纯软件时是很容易的。但是，遇到硬件时，往往会遇到一些麻烦。这里举一个例子：假设我们有一个按钮和一个sensor，都需要用到GPIO以及中断，并且我们想实现代码的解耦，如下图。初始化、应用代码、中断服务函数均解耦。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312145925945.png\" alt=\"image-20230312145925945\"></p>\n<p>​\t看似这种解耦很美好，但是实际上是实现不了的。因为，认为按钮和sensor之间有区别，这完全是我们人类的观点。对于MCU来说，它都是在操作外设寄存器，按钮和sensor没什么区别。因此gpio外设只需初始化一次，并且中断服务函数也不能定义在两处。</p>\n<p>​\t实际上，现在很多成熟的SDK，简单来说是用下图这种方式进行实现的解耦：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312150536356.png\" alt=\"image-20230312150536356\" style=\"zoom:80%;\" />\n\n<p>​\t有一个专门的<code>board.c</code>，或者说BSP（Board Support Package，板级支持包），来处理MCU本身的硬件初始化和中断服务函数。然后，剩余的<strong>应用代码</strong>再做解耦，也可以把回调函数注册进中断服务函数中去。<code>board.c</code>可以说是返璞归真，真正的是在面向MCU编程，而不是面向抽象的对象编程。</p>\n<h2 id=\"DeviceTree与Zephyr驱动的引入\"><a href=\"#DeviceTree与Zephyr驱动的引入\" class=\"headerlink\" title=\"DeviceTree与Zephyr驱动的引入\"></a>DeviceTree与Zephyr驱动的引入</h2><p>​\t先说硬件的抽象，前面说的这种宏定义的方式虽然方便，但往往只是方便个人开发者，或者是一个项目内几个同事之间口口相传，没有什么规范可言。不同开发者之间定义宏的方式可能差别很大。</p>\n<p>​\tZephyr不会自己再定义一套新的宏用来描述硬件，那样和各个厂商自己的SDK里的宏也没什么区别，徒增麻烦而已。Zephyr的设计思路就是：能用现成的轮子就不自己造。</p>\n<p>​\t因此，Zephyr引入了DeviceTree这一成熟的方案，像Linux一样，各个半导体厂商自己出DeviceTree来描述自己的产品，并且自己提供各个外设的驱动代码。用户只需调用Zephyr标准驱动，底层就会根据DeviceTree自动找到对应厂商的驱动代码，然后编译进固件中。</p>\n<p>​\t并且，Zephyr支持在系统初始化时就自动初始化好所有驱动。这样系统进入到Application（主线程）时，所有驱动就已经初始化好了，可以直接进行操作。用类比的说法，就是Zephr内置了所有厂商的所有外设的<code>board.c</code>，你只需动动手指改一下DeviceTree，就可以直接做应用开发，不需要自己写这个<code>board.c</code>了。</p>\n<p>​\t\t总的来说，DeviceTree是一个标准的描述硬件的方法，厂商提供了标准的DeviceTree和驱动代码。用户只需配置好DeviceTree，硬件就会自动初始化好。并且只需调用Zephyr通用驱动API，跨平台。</p>\n<h1 id=\"3-DeviceTree的结构和语法\"><a href=\"#3-DeviceTree的结构和语法\" class=\"headerlink\" title=\"3. DeviceTree的结构和语法\"></a>3. DeviceTree的结构和语法</h1><p>本节参考：<a href=\"https://docs.zephyrproject.org/latest/build/dts/intro.html\">Introduction to devicetree — Zephyr Project Documentation</a></p>\n<h2 id=\"3-1-DeviceTree的层次结构\"><a href=\"#3-1-DeviceTree的层次结构\" class=\"headerlink\" title=\"3.1. DeviceTree的层次结构\"></a>3.1. DeviceTree的层次结构</h2><p>​\t先抛开语法本身，我们先用框图的形式理解DeviceTree表达的是什么。如下图是一个示例，描述了一块板子，上面有一颗Soc、一组LED、一组按钮，还有一个I2C接口的RTC时钟ds3231。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312162505279.png\" alt=\"image-20230312162505279\"></p>\n<p>​\t首先，DeviceTree是一个树状结构。那么，树状结构的层次结构是由什么决定的？是什么决定了节点之间的父子关系？</p>\n<p>​\t答案是：<strong>首先看总线的主从关系、其次看硬件的包含关系</strong>。</p>\n<p>​\t具体来说，就是：</p>\n<ol>\n<li>SoC的所有外设都在ARM地址空间内可被<strong>寻址</strong>（AHB总线和APB总线），因此<code>gpio0</code>、<code>i2c0</code>、<code>adc0</code>等外设节点都是<code>SoC</code>的子节点；</li>\n<li><code>ds3231</code> RTC是i2c从机，具有i2c地址，故是<code>i2c</code>外设的子节点；</li>\n<li>Button和LED虽然使用GPIO，但GPIO不是<strong>总线</strong>。并且根据前一章节所述，Button和LED对SoC来说并没有什么意义，它只是便于人类面向对象编程的。因此，这里的<code>Buttons</code>和<code>Leds</code>就根据<strong>硬件的包含关系</strong>，直接挂在板子（也就是根节点<code>/</code>）下面即可；</li>\n<li>同理，如果有某种电压表设备用到了ADC的通道，这里，ADC的通道也不是总线，因此这个电压表设备也应该直接挂在根节点下面。</li>\n</ol>\n<h2 id=\"3-2-DeviceTree的适用范围\"><a href=\"#3-2-DeviceTree的适用范围\" class=\"headerlink\" title=\"3.2. DeviceTree的适用范围\"></a>3.2. DeviceTree的适用范围</h2><p>​\tDeviceTree是为<strong>编译固件</strong>服务的，描述的是这个固件所运行的CPU，所在的板子的硬件信息。因此DeviceTree描述的是<strong>板级</strong>信息。再结合「DeviceTree的层次结构是基于<strong>总线地址</strong>的」，可以得出以下的结论：</p>\n<ol>\n<li><strong>如果一块板子上有两颗MCU，则这两颗MCU固件编译时所采用的DeviceTree不相同。</strong><br>例如nRF9160 DK上有一颗9160，还有一颗52840。在NCS中选择Board时，就有以下两个选项</li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312163613633.png\" alt=\"image-20230312163613633\"></p>\n<ol start=\"2\">\n<li><strong>如果一颗MCU具有两个独立运行固件的CPU，则这两颗CPU不能共用DeviceTree</strong><br>例如nRF5340，具有应用核和网络核，这两颗CPU固件独立。因此选择board时有两个选项。</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312163934665.png\" alt=\"image-20230312163934665\" style=\"zoom:80%;\" />\n\n<ol start=\"3\">\n<li><strong>如果一颗CPU具有两种不同的地址空间（例如Cortex M33的安全地址空间和非安全地址空间），则这两种情况也不能共用DeviceTree</strong></li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312164104566.png\" alt=\"image-20230312164104566\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312164125085.png\" alt=\"image-20230312164125085\"></p>\n<center>nRF5340的地址空间，分为应用核和网络核</center>\n<center>且每个核的外设还分安全（secure）和非安全（non-secure）</center>\n\n<h2 id=\"3-3-DeviceTree的语法\"><a href=\"#3-3-DeviceTree的语法\" class=\"headerlink\" title=\"3.3. DeviceTree的语法\"></a>3.3. DeviceTree的语法</h2><p>​\tDeviceTree既然是一个标准，那么一定有它的标准文档，如果大家有兴趣可以去官网下载：<a href=\"https://www.devicetree.org/specifications/\">Specifications - DeviceTree</a></p>\n<p>​\t本文就只捡重点讲：</p>\n<h3 id=\"3-1-DeviceTree基本结构示例\"><a href=\"#3-1-DeviceTree基本结构示例\" class=\"headerlink\" title=\"3.1. DeviceTree基本结构示例\"></a>3.1. DeviceTree基本结构示例</h3><p>​\tDeviceTree的源码称为DTS（DeviceTree Source），后缀为<code>.dts</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/dts-v1/</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">    a-node&#123;</span><br><span class=\"line\">        a_node_label: a-sub-node &#123;</span><br><span class=\"line\">            foo = &lt;3&gt;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        another-sub-node &#123;</span><br><span class=\"line\">            foo = &lt;3&gt;;</span><br><span class=\"line\">            bar = &lt;&amp;a_node_label&gt;;</span><br><span class=\"line\">        &#125;;\t</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>/dts-v1/</code>，指明了DeviceTree的版本；</li>\n<li>设备树具有唯一的根节点<code>/</code>；</li>\n<li>节点的<strong>名称</strong>写在大括号之前。如<code>a-node</code>、<code>a-sub-node</code>和<code>another-sub-node</code>；</li>\n<li>节点的<strong>属性</strong>写在大括号内，是键值对（Key-Value Pair）的形式。如<code>foo = &lt;3&gt;;</code>；</li>\n<li>子节点直接写在父节点的大括号内，从而可以表达树状的层次关系；</li>\n<li>可以给节点写一个标签，例如<code>a_node_label</code>，标签与节点之间用冒号<code>:</code>连接。</li>\n</ol>\n<blockquote>\n<p>标签（Label）的意义：</p>\n<ol>\n<li>要指明一个节点，标准的做法必须指明绝对路径，例如：<code>/a-node/a-sub-node</code>。<br>有了标签，就可以省略路径，直接用标签表示一个节点，如<code>a_node_label</code>。</li>\n<li>标签可以被作为<strong>属性</strong>引用，让一个节点成为另一个节点的某个属性的<strong>值</strong>。注意，这里说的是成为「属性的值」，而不是成为「子节点」。</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-DeviceTree节点的名称\"><a href=\"#3-2-DeviceTree节点的名称\" class=\"headerlink\" title=\"3.2. DeviceTree节点的名称\"></a>3.2. DeviceTree节点的名称</h3><p>DeviceTree中的节点名称遵循以下命名规则：<code>name@address</code></p>\n<ol>\n<li><code>name</code>：必须以字母开头。长度在1~31子节。允许大小写字母、数字、<strong>英文逗号、小数点、加号、减号、下划线</strong>；</li>\n<li><code>@address</code>：称为<strong>「Unit Address」</strong>，如果节点有<code>reg</code>属性，则address的值必须与<code>reg</code>描述的<strong>第一个寄存器地址</strong>相等，可以理解为某个外设在它的总线上的首地址。如果某个节点没有reg属性，则<code>@address</code><strong>必须省略</strong>。<br>值得一提的是，address和reg都是16进制。但address不需要写<code>0x</code>前缀，而reg的16进制值需要写<code>0x</code>前缀。</li>\n</ol>\n<blockquote>\n<p>​\t实际上，Zephyr对address有一些特殊的规则，见：<a href=\"https://docs.zephyrproject.org/latest/build/dts/intro-syntax-structure.html#id7\">Unit address</a></p>\n<p>​\t这里也说一下：</p>\n<ul>\n<li><p>挂在SPI总线上的设备：address表示片选线（CS）的编号，如果没有片选线，则为<code>0</code>；</p>\n</li>\n<li><p>RAM：address直接为RAM的物理起始地址，如<code>memory@20000000</code>，表示<code>0x20000000</code>；</p>\n</li>\n<li><p>Flash：address直接为Flash的物理起始地址，如<code>flash@800000</code>，表示<code>0x08000000</code>。</p>\n</li>\n<li><p>Flash分区：可以在DeviceTree里存一个Flash分区表，分区的address是相对于Flash物理首地址的偏移量，如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flash@8000000 &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    partitions &#123;</span><br><span class=\"line\">        partition@0 &#123; /* ... */ &#125;;</span><br><span class=\"line\">        partition@20000 &#123;  /* ... */ &#125;;</span><br><span class=\"line\">        /* ... */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<p>几个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// address必须和reg首地址相等，无论是ARM地址还是i2c地址</span><br><span class=\"line\">i2c@40003000 &#123;</span><br><span class=\"line\">    reg = &lt;0x40003000 0x1000&gt;;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    ds3231@68 &#123;</span><br><span class=\"line\">        reg = &lt;0x68&gt;;</span><br><span class=\"line\">        /* ... */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 不带地址的节点，不含@address字段</span><br><span class=\"line\">buttons&#123;</span><br><span class=\"line\">   /* ... */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 英文逗号也是name的一部分</span><br><span class=\"line\">zephyr,user &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-DeviceTree的属性\"><a href=\"#3-3-DeviceTree的属性\" class=\"headerlink\" title=\"3.3. DeviceTree的属性\"></a>3.3. DeviceTree的属性</h3><p>​\tDeviceTree中每个节点可以有几个属性来描述这个节点。</p>\n<p>​\t属性是键值对。属性的名称可以含<strong>大小写字母、数字、逗号、小数点、下划线，加号、减号、问号、”#”号</strong>。</p>\n<p>​\t属性是有<strong>类型</strong>的，并且，Zephyr中的属性类型和标准的DeviceTree还有一定的区别，总之是更详细了，见下表：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>属性示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td><code>a-string=&quot;hello world!&quot;;</code></td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>string-array</td>\n<td><code>a-string-array=&quot;string one&quot;,&quot;string two&quot;.&quot;string three&quot;;</code></td>\n<td>字符串数组</td>\n</tr>\n<tr>\n<td>int</td>\n<td>10进制：<code>an-int = &lt;1&gt;;</code> <br />16进制：<code>an-int = &lt;0xab&gt;;</code></td>\n<td>32bit整数</td>\n</tr>\n<tr>\n<td>array</td>\n<td><code>foo = &lt;0xdeadbeef 1234 0&gt;;</code></td>\n<td>整数数组</td>\n</tr>\n<tr>\n<td>uint8-array</td>\n<td><code>a-byte-array = [00 01 ab];</code></td>\n<td>字节数组，16进制，可省略0x</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>my-true-boolean;</code></td>\n<td>无值属性。值存在则表示<code>true</code>，不存在则表示<code>false</code></td>\n</tr>\n<tr>\n<td>phandle</td>\n<td><code>a-phandle = &lt;&amp;mynode&gt;;</code></td>\n<td>节点句柄，指向其他的节点。可以认为是一个指针（p）或句柄（handle）</td>\n</tr>\n<tr>\n<td>phandles</td>\n<td><code>some-phandles = &lt;&amp;mynode0 &amp;mynode1 &amp;mynode2&gt;;</code></td>\n<td>节点句柄数组</td>\n</tr>\n<tr>\n<td>phandle-array</td>\n<td><code>a-phandle-array = &lt;&amp;mynode0 1 2&gt;,&lt; &lt;&amp;mynode1 3 4&gt;;</code></td>\n<td>见下方详细说明</td>\n</tr>\n</tbody></table>\n<p>​\t其实最基本的属性就是整数、布尔、字符串。以及由它们构成的数组。</p>\n<p>​\t<code>phandle</code>本质也是整数，当给一个节点赋予标签时，其实是给这个节点添加了一个隐藏属性<code>phandle = &lt;n&gt;;</code>。构建系统会确保整个DeviceTree中的<code>n</code>不会重复。所以这里<code>a-phandle = &lt;&amp;mynode&gt;;</code>，<code>&amp;mynode</code>的值就是这个标签指向的节点的隐藏phandle属性的值。</p>\n<p>​\t这里其他的都好理解，值得详细说的是<code>phandle-array</code>类型。其实，将其取名为「结构体数组」更加合适。这个数组的每一个元素都是一个特殊的结构体，结构体的第一个值必定是一个<code>phandle</code>，后续的值可以是任意值，数量也可以任意。Zephyr将这种类型用来做硬件通道的配置，例如<code>&lt;&amp;gpio0 1 GPIO_INPUT&gt;</code>表示gpio0，1号引脚，模式为输入。后续的硬件支持章节会更详细地讲解实例。</p>\n<h3 id=\"3-4-DeviceTree的文件引用\"><a href=\"#3-4-DeviceTree的文件引用\" class=\"headerlink\" title=\"3.4. DeviceTree的文件引用\"></a>3.4. DeviceTree的文件引用</h3><p>​\t<code>.dts</code>可以引用其他的<code>.dts</code>或<code>.dtsi</code>。这样<strong>板卡级dts</strong>就可以引用厂商写好的<strong>芯片级dtsi</strong>，从而减少编写dts的工作量。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312180147944.png\" alt=\"image-20230312180147944\" style=\"zoom:80%;\" />\n\n<p>​\t\t<code>.dts</code>也可以引用C语言头文件，从而使用里面的宏定义和枚举值：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312180310480.png\" alt=\"image-20230312180310480\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312180319140.png\" alt=\"image-20230312180319140\"></p>\n<h1 id=\"4-Zephyr中的DeviceTree文件\"><a href=\"#4-Zephyr中的DeviceTree文件\" class=\"headerlink\" title=\"4. Zephyr中的DeviceTree文件\"></a>4. Zephyr中的DeviceTree文件</h1><p>​\t在Zephyr中，在许多地方都保存的有dts文件。</p>\n<p>​\t首先，在NCS中创建build时，需要选择board，而板子的一系列文件中就包含了<code>.dts</code>文件。</p>\n<h2 id=\"4-1-dts文件\"><a href=\"#4-1-dts文件\" class=\"headerlink\" title=\"4.1. dts文件\"></a>4.1. dts文件</h2><h3 id=\"4-1-1-芯片级dtsi文件\"><a href=\"#4-1-1-芯片级dtsi文件\" class=\"headerlink\" title=\"4.1.1. 芯片级dtsi文件\"></a>4.1.1. 芯片级dtsi文件</h3><p>各个厂商提供的芯片级dtsi文件，对于nordic的产品，其dtsi文件位于<code>$&#123;NCS&#125;/zephyr/dts/arm/nordic/</code>中。</p>\n<h3 id=\"4-1-2-板卡级dts文件\"><a href=\"#4-1-2-板卡级dts文件\" class=\"headerlink\" title=\"4.1.2. 板卡级dts文件\"></a>4.1.2. 板卡级dts文件</h3><p>​\t各个厂商可能会推出一些开发板、评估板。这些板子的dts文件位于<code>$&#123;NCS&#125;/zephyr/board/arm/$&#123;board-name&#125;/</code>中</p>\n<h2 id=\"4-2-overlay文件\"><a href=\"#4-2-overlay文件\" class=\"headerlink\" title=\"4.2. overlay文件\"></a>4.2. overlay文件</h2><h3 id=\"4-2-1-overlay文件的位置\"><a href=\"#4-2-1-overlay文件的位置\" class=\"headerlink\" title=\"4.2.1. overlay文件的位置\"></a>4.2.1. overlay文件的位置</h3><p>​\t在我们开发应用时，往往需要基于厂商的开发板Dts，新增一些功能，或者禁用一些功能。Zephyr提供了overlay的方式让我们可以<strong>覆写</strong>原始的板卡级dts。</p>\n<p>​\t在一些例程中，可以看到<code>boards/&lt;board&gt;.overlay</code>文件：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312182939910.png\" alt=\"image-20230312182939910\"></p>\n<p>​\t如果没有看到，说明这个例程无需修改开发板的原始dts就能实现功能。如果用户想修改，也可以自己在应用根目录创建一个<code>app.overlay</code>：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312183130067.png\" alt=\"image-20230312183130067\"></p>\n<p>​\t其实添加overlay的方式有很多，并且zephyr会按照一定的顺序找这些overlay，如果在多个地方都定义了overlay，可能zephyr只会使用其中的一部分。具体规则请看：<a href=\"https://docs.zephyrproject.org/latest/build/dts/howtos.html#set-devicetree-overlays\">set-devicetree-overlays</a>。</p>\n<h3 id=\"4-2-2-overlay的使用\"><a href=\"#4-2-2-overlay的使用\" class=\"headerlink\" title=\"4.2.2. overlay的使用\"></a>4.2.2. overlay的使用</h3><p><strong>（1）直接在原有节点覆盖&#x2F;新增属性，可以从根节点开始写：</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312192849065.png\" alt=\"image-20230312192849065\"></p>\n<p>​\t也可以直接用label写：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312191745811.png\" alt=\"image-20230312191745811\"></p>\n<p><strong>（2）删除原有的属性</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312192939102.png\" alt=\"image-20230312192939102\"></p>\n<p><strong>（3）删除原有的节点</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312193017699.png\" alt=\"image-20230312193017699\"></p>\n<h2 id=\"4-3-完整的dts文件\"><a href=\"#4-3-完整的dts文件\" class=\"headerlink\" title=\"4.3. 完整的dts文件\"></a>4.3. 完整的dts文件</h2><p>每个项目构建时，编译之前，会在构建目录下生成最终的完整dts。位置为<code>$&#123;project_folder&#125;/build/zephyr/zephyr.dts</code></p>\n<h2 id=\"4-4-最终输出\"><a href=\"#4-4-最终输出\" class=\"headerlink\" title=\"4.4. 最终输出\"></a>4.4. 最终输出</h2><p>​\tLinux的DTS会被编译为DTB，然后在启动时由Bootloader传递给kernel。但Zephyr运行在性能较差的嵌入式平台上，故不可能专门运行一个解析器去读DTB。</p>\n<p>​\t因此，DTS实际上实在编译时被Zephyr的构建系统（一套python脚本）变成了头文件，这个头文件的位置是：</p>\n<p><code>$&#123;project_folder&#125;/build/zephyr/include/generated/devicetree_generated.h</code></p>\n<p>​\t了解即可，实际开发不需要查看这个头文件。</p>\n<h1 id=\"5-用DeviceTree配置硬件信息\"><a href=\"#5-用DeviceTree配置硬件信息\" class=\"headerlink\" title=\"5. 用DeviceTree配置硬件信息\"></a>5. 用DeviceTree配置硬件信息</h1><p>​    从上一节我们可以知道，DeviceTree本身的结构和语法其实非常简单，只是规定了一个形式而已，跟硬件的配置没有任何关系。</p>\n<p>​    要想了解DeviceTree是如何对硬件配置产生影响的，需要了解一些常见的属性和概念。</p>\n<h2 id=\"5-1-标准属性\"><a href=\"#5-1-标准属性\" class=\"headerlink\" title=\"5.1. 标准属性\"></a>5.1. 标准属性</h2><p>​\tDeviceTree中有一些标准的属性，这些属性和Linux是一样的，在DeviceTree Specification中是有定义的。此处简要介绍一下：</p>\n<h3 id=\"reg-address-cells-与-size-cells\"><a href=\"#reg-address-cells-与-size-cells\" class=\"headerlink\" title=\"reg, #address-cells 与 #size-cells\"></a>reg, #address-cells 与 #size-cells</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312200747143.png\" alt=\"image-20230312200747143\"></p>\n<p>  <strong>reg</strong>属性代表此节点在总线上占用的地址和范围。是由<strong>多对</strong> <strong>(address, length)<strong>组合而成的。而</strong>#address-cells</strong> 和**#sieze-cells**则表示了这个总线上的节点的reg属性里，每个address和size要占用多少个uint32单元。</p>\n<p>  如上图，先看父节点<code>soc</code>，可以得知这条总线上，所有寄存器的address和size各占一个uint32单元。则serial有两个寄存器，第一个寄存器首地址是0x0，长度是0x100；第二个寄存器首地址是0x200，长度是0x300。</p>\n<blockquote>\n<p>​\t如果地址长度为64位或更多（即要占用多个Uint32单元），则reg中的写法为大端模式（Big-Endian ），即高地址在前，低地址在后。</p>\n</blockquote>\n<h3 id=\"ranges\"><a href=\"#ranges\" class=\"headerlink\" title=\"ranges\"></a>ranges</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201206619.png\" alt=\"image-20230312201206619\"></p>\n<p>当一个节点定义了ranges属性，那么它的子节点就可以使用<strong>相对地址</strong>，而非<strong>绝对地址</strong>。</p>\n<p>如上图。peripheral基地址为0x40000000。而ADC的地址从0xe000开始，这是一个相对地址。则ADC在ARM地址空间的绝对地址为0x4e000000。</p>\n<blockquote>\n<p>ranges属性的格式为：</p>\n<p><code>ranges = &lt;子空间首地址  父空间首地址 长度&gt;</code></p>\n<p>子空间首地址为0时，子节点的地址就是相对地址。</p>\n<p>至于这三个元素分别要占用几个uint32单元，看图中同色的部分即可。</p>\n</blockquote>\n<p>  一般用户也用不到，了解即可。厂商才会去改芯片内部的dts。</p>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201508849.png\" alt=\"image-20230312201508849\"></p>\n<p>  <strong>status</strong>用来指定是否启用一个设备（节点），根据DeviceTree Spec有以下几个选项：</p>\n<ul>\n<li>“okay” ： 设备是可操作的</li>\n<li>“disabled” ： 设备目前是不可操作的（但未来可能可以操作，比如设备插入、安装后）</li>\n<li>“fail” ： 设备不可操作。设备中检测到错误。</li>\n<li>“fail-sss”：设备不可操作。其中sss的部分会根据不同的设备而变换，用于指定特定的错误码</li>\n<li>“reserved” ： 设备可操作，但不应该使用。通常用于设备被其他软件控制的情况。</li>\n</ul>\n<p>但是实际上Zephyr中基本只会用「okay」和「disabled」 ，用来启用或禁用节点。</p>\n<h3 id=\"compatible\"><a href=\"#compatible\" class=\"headerlink\" title=\"compatible\"></a>compatible</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201647347.png\" alt=\"image-20230312201647347\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201652944.png\" alt=\"image-20230312201652944\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201657935.png\" alt=\"image-20230312201657935\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201702581.png\" alt=\"image-20230312201702581\"></p>\n<p>  <strong>compatible</strong>用来说明一个节点设备的兼容性。它的值是一个字符串或一个字符串数组。</p>\n<p>  Zephyr构建系统就是用它来为每个节点找到合适的驱动程序。其具体的应用后面会讲解。</p>\n<p>  compatible的每个值的通常命名方式是”vendor,device”，即某个供应商的某个产品。这不是强制的要求，也可以没有vendor。</p>\n<p>  如果compatible有多个值，zephyr会按顺序寻找驱动。会使用找到的第一个驱动。</p>\n<h2 id=\"5-2-重要概念——域（Domain）\"><a href=\"#5-2-重要概念——域（Domain）\" class=\"headerlink\" title=\"5.2. 重要概念——域（Domain）\"></a>5.2. 重要概念——域（Domain）</h2><p>  我们知道，DeviceTree是基于<strong>总线地址的层次结构</strong>。然而，实际的硬件之间的关系错综复杂，实为网状结构，如何才能简洁地描述好真实的硬件之间的关系呢？</p>\n<p>  其实，除了DeviceTree本身基于地址的树之外，在逻辑上，还存在一些其他的树，例如GPIO树、中断树、ADC树等等。</p>\n<p>  我们将这种附加在DeviceTree上的，逻辑上的树称为<strong>域（Domain）</strong>。如下图，蓝色为一个按照总线地址的层次结构写好的DeviceTree，但是，在这个树上其实附加了其他的包含关系：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201750000.png\" alt=\"image-20230312201750000\"></p>\n<p>  很容易发现，每个域都有一个自己的“<strong>根节点</strong>”，称为<strong>控制器（Controller）</strong>。不难发现，其实控制器才是真正的我们编程操作的对象，而域中的子节点，都是我们为了方便理解，而抽象出来的概念，这与本文第2章节的观点是一致的。</p>\n<h3 id=\"域的控制器与子节点\"><a href=\"#域的控制器与子节点\" class=\"headerlink\" title=\"域的控制器与子节点\"></a>域的控制器与子节点</h3><p>​\t控制器节点通常会有一个布尔类型属性 <code>*-controller</code>，来表示自己是某个域的控制器，如下图：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202317603.png\" alt=\"image-20230312202317603\" style=\"zoom:67%;\" />\n\n<p>​\t而域中的子节点，就可以使用<code>phandle-array</code>类型的属性来说明自己属于哪个域。此属性的第一个值是指向<strong>控制器的</strong>句柄。后续的值是此节点在这个域中的<strong>配置</strong>。这一条配置被称为<strong>specifier</strong>。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202350076.png\" alt=\"image-20230312202350076\" style=\"zoom:80%;\" />\n\n<p>控制器节点中会有一个<code>#*-cells</code>属性来指明specifier的大小，需要占用多少个<code>uint32</code>单元。</p>\n<h3 id=\"中断域\"><a href=\"#中断域\" class=\"headerlink\" title=\"中断域\"></a>中断域</h3><p>中断域和GPIO域有点类似，但有点区别：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202551215.png\" alt=\"image-20230312202551215\" style=\"zoom:67%;\" />\n\n<p>  首先，我们发现adc的<code>interrupts</code>属性只写了specifier，并没有写controller指向哪里。</p>\n<p>   这是因为，根据DeviceTree标准，构建系统默认把devicetree父节点当作中断域的controller。如果父节点不是controller，则继续向上寻找。直到遇到controller，或者遇到<code>interrupt-parent</code>属性时，才会指定父节点。</p>\n<p>​\t如图可以看出，<code>adc</code>节点向上寻找，遇到<code>soc</code>节点，在<code>soc</code>节点内，指明了其中断域控制器是<code>nvic</code>。于是<code>adc</code>节点中断域的控制器就是nvic。</p>\n<h3 id=\"其他类似的域\"><a href=\"#其他类似的域\" class=\"headerlink\" title=\"其他类似的域\"></a>其他类似的域</h3><p>类似的还有adc域、pwm域、pin-ctrl域等等。这些域的子节点也都采用了<strong>specifier</strong>的方式，来记录配置信息：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202839931.png\" alt=\"image-20230312202839931\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202850193.png\" alt=\"image-20230312202850193\"></p>\n<center>pwm控制器与子节点</center>\n\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202924182.png\" alt=\"image-20230312202924182\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202928953.png\" alt=\"image-20230312202928953\"></p>\n<center>adc控制器与子节点</center>\n\n<p>​\t不过，这里没有*-controller属性来指明controller节点。</p>\n<blockquote>\n<p>​\t这些域的控制器的写法，可能有细小的差别，但是背后的道理是相通的。用户也不用关心控制器具体的写法，按照手册写好子节点即可。</p>\n</blockquote>\n<h3 id=\"域的总结\"><a href=\"#域的总结\" class=\"headerlink\" title=\"域的总结\"></a>域的总结</h3><p>​\t总之，对于初学者，这里只需记住「specifier是用来写配置的」即可，后面会讲到具体的用法。</p>\n<h2 id=\"5-3-DeviceBinding\"><a href=\"#5-3-DeviceBinding\" class=\"headerlink\" title=\"5.3.  DeviceBinding\"></a>5.3.  DeviceBinding</h2><p>​\t前面讲到<strong>域</strong>的概念，我们会发现不同的域的配置方法有一些共性，但也有一些差异，这让我们感觉devicetree的规则很混乱：</p>\n<p>​    “<em>除了<strong>dts</strong>本身的语法之外，竟然还有其他的<strong>规则</strong>，一个不小心就会写错！”</em></p>\n<p>​\t我想说，规则是双刃剑。既可以说规则带来了麻烦（提高了门槛），又可以说规则创造了便利（在配置时就提前检查dts是否正确，防止编译的时候出错，那时候更难排查）。</p>\n<p>​\t这里的便利性还体现在VS Code编辑器的<strong>代码提示</strong>与<strong>自动补全</strong>，这是Nordic提供的nRF Connect for VS Code插件实现的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/%E6%8F%90%E7%A4%BA.gif\" alt=\"提示\"></p>\n<center>自动补全（枚举类型可以给出预选项）</center>\n\n<p>![GIF 2023-2-22 23-54-54](&#x2F;imgs&#x2F;详解Zephyr设备树（DeviceTree）与驱动模型.assets&#x2F;GIF 2023-2-22 23-54-54.gif)</p>\n<center>错误提示（specifier多写了一个单元）</center>\n\n<h3 id=\"DeviceBinding文件\"><a href=\"#DeviceBinding文件\" class=\"headerlink\" title=\"DeviceBinding文件\"></a>DeviceBinding文件</h3><p>​\t所谓的<strong>规则</strong>，被称为Device Binding文件。binding文件是yaml格式文件，yaml是标记语言，由多组键值对组成。每个值可以是：</p>\n<ul>\n<li>纯量（单个不可分割的值，如整数、字符串）</li>\n<li>对象（把键值对当成值）</li>\n<li>数组（一组同类型的<strong>值</strong>）</li>\n</ul>\n<p>示例：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204227457.png\" alt=\"image-20230312204227457\"></p>\n<p>简易语法：</p>\n<ul>\n<li>键、值之间用<strong>冒号+空格</strong>分隔</li>\n<li>yaml的层级关系只看缩进（类似python），相同层级的缩进必须相同</li>\n<li>数组元素可以是纯量、对象。对象的成员也可以有数组</li>\n</ul>\n<blockquote>\n<p>​\t可能新手会感觉很麻烦，又冒出来一种语法。但是其实用户无需有畏难情绪，因为这些内容都是使开发更简单，而不是更麻烦的。bingding文件本身的可读性很强，用户只需要能大概看懂即可，编写yaml文件是厂商的工作。</p>\n</blockquote>\n<p>​\tbinding和DeviceTree中的节点，是通过<code>compatible</code>属性实现联动的。**在VS Code中直接Ctrl+鼠标左键点击<code>compatible</code>**，就可以跳转到对应的binding文件中：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/jump.gif\" alt=\"jump\"></p>\n<p>​\tDeviceTree中节点的属性，必须严格按照binding文件中的要求。如下图，我自定义了一个电压传感器设备，需要用到ADC。那么我在binding文件中，要求符合<code>compatible = &quot;jayant,voltage-sensor&quot;</code>的所有节点，都必须具有<code>io-channels</code>属性，且类型必须是<code>phandle-array</code>。从而使得这个节点可以通过写specifier的方式，把自己加入到ADC域中：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204702592.png\" alt=\"image-20230312204702592\"></p>\n<p>​\tdevice binding的约束能力很强大，不仅可以约束节点的属性（指定数据的类型、枚举、甚至强行赋值），还可以约束此compatible节点的子节点的属性。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312204824297.png\" alt=\"image-20230312204824297\" style=\"zoom:80%;\" />\n\n<center>约束一个节点的子节点的属性</center>\n\n<pre><code>  此外，还能给specifier中记录的数值赋予含义。\n</code></pre>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204820151.png\" alt=\"image-20230312204820151\"></p>\n<center>给gpio specifier中的2个单元赋予含义</center>\n\n<p>  由于内容较多，本文不多赘述，可参考<a href=\"https://docs.zephyrproject.org/latest/build/dts/bindings.html\">Devicetree</a><a href=\"https://docs.zephyrproject.org/latest/build/dts/bindings.html\"> bindings — Zephyr Project Documentation</a>了解更多信息。大家在实际开发过程中，直接通过Ctrl + 鼠标左键跳进binding文件，然后望文生义即可。</p>\n<h3 id=\"DeviceBinding文件的位置\"><a href=\"#DeviceBinding文件的位置\" class=\"headerlink\" title=\"DeviceBinding文件的位置\"></a>DeviceBinding文件的位置</h3><p>zephyr build system会从以下位置寻找binding文件：</p>\n<ul>\n<li><code>$&#123;NCS&#125;/zephyr/dts/bindings/</code></li>\n<li><code>$&#123;board_dir&#125;/dts/bindings/</code></li>\n<li><code>$&#123;project_dir&#125;/dts/bindings/</code></li>\n</ul>\n<p>也可以在CMakeLists.txt中，用 <code>list(APPEND DTS_ROOT /path/to/your/dts) </code>命令增加binding文件的目录</p>\n<p>也可以在编译时，增加选项 <code>west build -b &lt;board_name&gt; -- -DTS_ROOT=&lt;path/to/your/dts&gt;</code></p>\n<p>如果想要自定义设备类型，可以把yaml文件添加到以上位置。文件名推荐和compatible一致，但不是必须的。</p>\n<p>如下图为我自己写的两个bingding文件的位置示例：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205310166.png\" alt=\"image-20230312205310166\"></p>\n<h2 id=\"5-4-特殊节点\"><a href=\"#5-4-特殊节点\" class=\"headerlink\" title=\"5.4. 特殊节点\"></a>5.4. 特殊节点</h2><p>在5.1种描述了一些常见的属性。本节会描述一些常见的特殊节点。这些节点都是虚拟的，不是实际存在的硬件：</p>\n<ul>\n<li><p><code>/chosen</code>：为<strong>Zephyr Kernel</strong>选择特定设备（如日志串口）；<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205611402.png\" alt=\"image-20230312205611402\"></p>\n</li>\n<li><p><code>/aliases</code>：给节点起一个别名，类似label。不过label仍是节点，而aliases中的别名是属性名。<code>/aliases</code>通常是厂商在<strong>开发板级</strong>的驱动代码中操作硬件所需要的。<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205618639.png\" alt=\"image-20230312205618639\"></p>\n</li>\n<li><p><code>/pinctrl</code>：直属于根节点，不属于soc的一个虚拟节点，用于管理<strong>数字IO</strong>的复用（目前不管模拟IO，因为ADC的模拟通道和MCU的硬件引脚往往是绑定死的，不能配置）；</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312210048297.png\" alt=\"image-20230312210048297\"><br>具体的介绍，我后续会写一篇文章专门讲解。大家可以直接Ctrl + 鼠标左键点击dts文件中的<code>pin-ctrl</code>，跳转过去，也能自己看懂。</p>\n</li>\n<li><p><code>/zephyr,user</code>：方便用户开发的节点，此节点无需<code>compatible</code>属性。用户可以直接在里面随便写各种specifier、自定义属性等。于是就可以直接在代码里操作GPIO通道、ADC通道、pwm通道等，或者把自己随便写的配置项读出。这免去了如果自定义一个device，还要自己写binding的麻烦。<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205944691.png\" alt=\"image-20230312205944691\"></p>\n</li>\n</ul>\n<h1 id=\"6-在C代码中访问DeviceTree内容\"><a href=\"#6-在C代码中访问DeviceTree内容\" class=\"headerlink\" title=\"6. 在C代码中访问DeviceTree内容\"></a>6. 在C代码中访问DeviceTree内容</h1><p>​\t在4.4小节中，已经介绍过，DeviceTree最终会用来生成<code>devicetree_generated.h</code>头文件，包含了DeviceTree中的所有信息。自然而然的，我们会想到要在C&#x2F;C++代码中访问这些信息。</p>\n<blockquote>\n<p>​\t注意，由于DeviceTree中节点名称、属性名称允许使用的字符集是比C语言变量命名所允许的字符集更广泛的，因此，Zephyr规定，在C语言中访问DeviceTree的内容时，名称内的字母全部都变成<strong>小写字母</strong>、且特殊符号都变成<strong>下划线</strong>。</p>\n<p>​\t例如<code>zephyr,user</code>变为<code>zephyr_user</code>；<code>my-gpio</code>变为<code>my_gpio</code>。</p>\n</blockquote>\n<p>​\t我们无需关心<code>devicetree_generated.h</code>文件本身的内容，因为它不是给人看的，需要使用一套宏函数来将其读出。在需要操作DeviceTree的文件中包含以下头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这里给出一个示例：</p>\n<ol>\n<li>在overlay文件中新增一个属性，表示自己需要一个GPIO进行测试，属性名称为<code>test-gpios</code>。这是一个gpio specifier。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    zephyr,user &#123;</span><br><span class=\"line\">        test-gpios = &lt;&amp;gpio0 17 0&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>main.c</code>中，获取这个specifier，并操作GPIO</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自己想要操作的节点的id，这里想要操作的节点是zephyr,user</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NODE_ID DT_PATH(zephyr_user)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取到zephyr,user节点的test-gpios属性，并把它作为gpio specifier，读入GPIO驱动。</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">test_io</span> =</span> GPIO_DT_SPEC_GET(NODE_ID, test_gpios);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际代码</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断设备（这里是gpio控制器）是否已初始化完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// 一般情况下，在application运行前，zephyr驱动就已经把控制器初始化好了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!device_is_ready(test_io.port)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新配置IO</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果DeviceTree里写好了，这里也可以不配</span></span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;test_io, GPIO_OUTPUT_INACTIVE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 操作IO</span></span><br><span class=\"line\">    gpio_pin_set_dt(&amp;test_io,<span class=\"number\">1</span>);</span><br><span class=\"line\">    gpio_pin_set_dt(&amp;test_io,<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-1-获取节点ID\"><a href=\"#6-1-获取节点ID\" class=\"headerlink\" title=\"6.1. 获取节点ID\"></a>6.1. 获取节点ID</h2><p>​\tDeviceTree的一切信息都包含在属性之中。要想获得属性，首先要获得节点ID（node identifier）来作为句柄。获得节点id的方式有很多：</p>\n<table>\n<thead>\n<tr>\n<th><strong>获取方式</strong></th>\n<th><strong>示例</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根节点</td>\n<td><code>DT_ROOT</code></td>\n<td>根节点id</td>\n</tr>\n<tr>\n<td>绝对路径</td>\n<td><code>DT_PATH(soc, serial_40001000)</code></td>\n<td><code>/soc/serial@40001000  </code></td>\n</tr>\n<tr>\n<td>Label</td>\n<td><code>DT_NODELABEL(serial1)</code></td>\n<td>根据dts中定义的label来找到节点</td>\n</tr>\n<tr>\n<td>chosen节点</td>\n<td><code>DT_CHOSEN(zephyr_console)</code></td>\n<td>根据dts中chosen节点的配置：     zephyr,console&#x3D;&amp;uart0</td>\n</tr>\n</tbody></table>\n<p>​\t获得节点id的方式还有很多：通过父节点找子节点、通过子节点找父节点等等。详细不多赘述，可参考：<br> <a href=\"https://docs.zephyrproject.org/latest/build/dts/api-usage.html\">https://docs.zephyrproject.org/latest/build/dts/api-usage.html#node-identifiers</a></p>\n<p>​\t但是有一种方式需要注意，它与最后一节讲的Zephyr驱动自动初始化息息相关。那就是通过<strong>实例ID</strong>的方式获取节点ID。所谓实例，就是指，同一个<code>compatible</code>，可能在一个dts中有多个实体。比如<code>nordic,nrf-timer</code>，可能一颗MCU上有很多timer。把它们按照在dts中出现的顺序进行编号，就是实例ID。实例ID从0开始。</p>\n<p>​\t比如：<code>DT_INST(0, nordic_nrf_timer)</code>，对应的就是<code>nordic,nrf-timer</code>的第0个实例节点。</p>\n<p>​\t通过实例ID获取节点ID的好处在于，可以通过遍历的方式来一次性获取到同一个compatible下所有的节点。这正是Zephyr能够在Application运行前就能找到所有dts中配置好的硬件的基础。</p>\n<blockquote>\n<p>注意，所有Device Tree API都是宏，是预编译的结果。因此：</p>\n<ul>\n<li>API参数必须是常量。不能在<code>for(int i=0;i&lt;n;++i)</code>的<strong>运行时</strong>循环中用变量<code>i</code>去调用INST的API；</li>\n<li>调用API的过程也必须在编译时就完成。也就是说API宏的返回值只能赋值给const变量，不能在<strong>运行时</strong>调用，赋值给非const的任何变量。</li>\n</ul>\n</blockquote>\n<h2 id=\"6-2-获取属性\"><a href=\"#6-2-获取属性\" class=\"headerlink\" title=\"6.2. 获取属性\"></a>6.2. 获取属性</h2><p>利用DeviceTree API，输入节点id和属性名称，就可以获得属性。</p>\n<h3 id=\"检查属性是否存在\"><a href=\"#检查属性是否存在\" class=\"headerlink\" title=\"检查属性是否存在\"></a>检查属性是否存在</h3><p>​\t使用node id和小写、下划线命名的属性名称</p>\n<p>示例：查找<code>i2c1</code>节点的<code>clock-frequency</code>属性。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_NODE_HAS_PROP(DT_NODELABEL(i2c1), clock_frequency)  <span class=\"comment\">/* 宏展开为 1 */</span></span><br><span class=\"line\">DT_NODE_HAS_PROP(DT_NODELABEL(i2c1), not_a_property)   <span class=\"comment\">/* 宏展开为 0 */</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>DTS里允许的所有特殊符号<code>「-」 「,」 「#」 「@」</code>在C源码里都要变成<code>「_」</code>，且字母都要变成小写。</p>\n</blockquote>\n<blockquote>\n<p>如果是布尔类型，直接使用下面介绍的<code>DT_PROP()</code>即可。不要再使用<code>DT_HAS_PROP()</code>判断其是否存在。</p>\n</blockquote>\n<h3 id=\"获取普通属性\"><a href=\"#获取普通属性\" class=\"headerlink\" title=\"获取普通属性\"></a>获取普通属性</h3><p>​\t整数、布尔、字符串、数组、字符串数组都是普通属性，用<code>DT_PROP(node_id)</code>读取。</p>\n<p>整数与字符串示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_PROP(DT_PATH(soc, i2c_40002000), clock_frequency)  <span class=\"comment\">/* 宏展开为 100000, */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C1 DT_NODELABEL(i2c1)</span></span><br><span class=\"line\">DT_PROP(I2C1, status)  <span class=\"comment\">/* 宏展开为 &quot;okay&quot; */</span></span><br></pre></td></tr></table></figure>\n\n<p>数组示例：</p>\n<p>​\t假设dts为</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">foo:</span> <span class=\"title class_\">foo@1234</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        a = <span class=\"params\">&lt;<span class=\"number\">1000</span> <span class=\"number\">2000</span> <span class=\"number\">3000</span>&gt;</span><span class=\"punctuation\">;</span> <span class=\"comment\">/* array */</span></span><br><span class=\"line\">        b = [aa bb cc dd]<span class=\"punctuation\">;</span>    <span class=\"comment\">/* uint8-array */</span></span><br><span class=\"line\">        c = <span class=\"string\">&quot;bar&quot;</span>, <span class=\"string\">&quot;baz&quot;</span><span class=\"punctuation\">;</span>     <span class=\"comment\">/* string-array */</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>则C代码中可以写作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FOO DT_NODELABEL(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = DT_PROP(FOO, a);           <span class=\"comment\">/* &#123;1000, 2000, 3000&#125; */</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> b[] = DT_PROP(FOO, b); <span class=\"comment\">/* &#123;0xaa, 0xbb, 0xcc, 0xdd&#125; */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* c[] = DT_PROP(FOO, c);         <span class=\"comment\">/* &#123;&quot;foo&quot;, &quot;bar&quot;&#125; */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取数组的长度</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> a_len = DT_PROP_LEN(FOO, a); <span class=\"comment\">/* 3 */</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> b_len = DT_PROP_LEN(FOO, b); <span class=\"comment\">/* 4 */</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> c_len = DT_PROP_LEN(FOO, c); <span class=\"comment\">/* 2 */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读取reg属性\"><a href=\"#读取reg属性\" class=\"headerlink\" title=\"读取reg属性\"></a>读取reg属性</h3><ul>\n<li><p>获取reg blocks数量：<code>DT_NUM_REGS(node_id)</code></p>\n</li>\n<li><p>若只有1个block，则直接读取其地址和长度：</p>\n<ul>\n<li><p><code>DT_REG_ADDR(node_id)</code></p>\n</li>\n<li><p><code>DT_REG_SIZE(node_id)</code></p>\n</li>\n</ul>\n</li>\n<li><p>若有多个block，则需要通过下标来索引</p>\n<ul>\n<li><code>DT_REG_ADDR_BY_IDX(node_id, idx)</code></li>\n<li><code>DT_REG_SIZE_BY_IDX(node_id, idx)</code></li>\n</ul>\n<blockquote>\n<p>注意，node_id和idx都必须是常量。因为宏的值在编译时就已经展开，因此不能放在循环里运行。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"读取interrupts属性\"><a href=\"#读取interrupts属性\" class=\"headerlink\" title=\"读取interrupts属性\"></a>读取interrupts属性</h3><ul>\n<li><p>获取interrupt specifier数量：<code>DT_NUM_IRQS(node_id)</code></p>\n</li>\n<li><p>获取interrupt specifier：通过node id，下标和val来访问中断配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_IRQ_BY_IDX(node_id, idx, val)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>val的含义：</p>\n<p>​\t是中断控制器devicebind文件中规定的结构体成员名。</p>\n<p>​\t以设备树中的<code>/soc/peripheral/adc@e000</code>节点为例，节点中未指明interrupt parent，故从设备树向上推断，推到<code>/soc</code>节点，此节点指明中断控制器是<code>&amp;nivc</code>，即<code>/soc/interrupt-cntroller@e000e100</code>，其device-binding是<code>&quot;arm,v8m-nvic&quot;</code>。</p>\n<p>​\t在<code>ncs/zephyr/dts/bindings/interrupt-controller/&quot;arm,v8m-nvic.yaml&quot;</code>文件中，指明了interrupt specifier的解析方式：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">interrupt-cells:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">irq</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">priority</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>adc</code>节点中的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interrupts = &lt; 0xe 0x1 &gt;;</span><br></pre></td></tr></table></figure>\n\n<p>可被解析为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADC_NODE DT_NODELABEL(adc)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> irq = DT_IRQ_BY_IDX(ADC_NODE, <span class=\"number\">0</span>, irq) <span class=\"comment\">// 中断号是0xe</span></span><br><span class=\"line\"><span class=\"type\">int</span> priority =  DT_IRQ_BY_IDX(ADC_NODE, <span class=\"number\">0</span>, priority) <span class=\"comment\">// 优先级是priority</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"读取phandle属性\"><a href=\"#读取phandle属性\" class=\"headerlink\" title=\"读取phandle属性\"></a>读取phandle属性</h3><p>例如，dts中有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">n1: node-1 &#123;</span><br><span class=\"line\">    foo = &lt;&amp;n2 &amp;n3&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">n2: node-2 &#123; ... &#125;;</span><br><span class=\"line\">n3: node-3 &#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>则可在C代码中，通过<code>n1</code>节点找到另外两个节点的node id：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N1 DT_NODELABEL(n1)\\</span></span><br><span class=\"line\"><span class=\"meta\">DT_PHANDLE_BY_IDX(N1, foo, 0) <span class=\"comment\">// node identifier for node-2</span></span></span><br><span class=\"line\">DT_PHANDLE_BY_IDX(N1, foo, <span class=\"number\">1</span>) <span class=\"comment\">// node identifier for node-3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3-遍历宏\"><a href=\"#6-3-遍历宏\" class=\"headerlink\" title=\"6.3. 遍历宏\"></a>6.3. 遍历宏</h2><p>​\t前面提到，DeviceTree API都是宏，不能在代码运行时用循环语句（for和while）来调用。但是DeviceTree API提供了遍历展开宏。如：</p>\n<ul>\n<li>对设备树中的每一个节点都调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213721605.png\" alt=\"image-20230312213721605\"></li>\n<li>对设备树中的每一个status为okay的节点调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213728227.png\" alt=\"image-20230312213728227\"></li>\n<li>对一个节点的所有子节点遍历调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213734780.png\" alt=\"image-20230312213734780\"></li>\n</ul>\n<blockquote>\n<p>更多遍历API，请参考： <a href=\"https://docs.zephyrproject.org/latest/build/dts/api/api.html\">https://docs.zephyrproject.org/latest/build/dts/api/api.html#for-each-macros</a></p>\n</blockquote>\n<p>​\t这些API看似是循环，实际上是在预编译时，把所有遍历的可能性全部展开。</p>\n<p>​\t实际上Nordic提供的很多Zephyr驱动，都是用遍历宏来创建外设相关的变量（例如config结构体），从而能调用nrfx api来完成实际的初始化。</p>\n<p>​\t举一个实际的例子，在<code>$&#123;NCS&#125;/zephyr/drivers/led/led_gpio.c</code>中，定义了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_DRV_COMPAT gpio_leds</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t有了这个定义，就可以使用Inst API来访问<code>compatible = &quot;gpio-leds&quot;</code>的所有led，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leds0 &#123;</span><br><span class=\"line\">    compatible = &quot;gpio-leds&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    label = &quot;LED1&quot;;</span><br><span class=\"line\">    led0: led_0 &#123;</span><br><span class=\"line\">        gpios = &lt;&amp;gpio0 4 0&gt;;</span><br><span class=\"line\">        label = &quot;Green LED 1&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">leds1 &#123;</span><br><span class=\"line\">    compatible = &quot;gpio-leds&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    label = &quot;LED2&quot;;</span><br><span class=\"line\">    led1: led_1 &#123;</span><br><span class=\"line\">        gpios = &lt;&amp;gpio0 5 0&gt;;</span><br><span class=\"line\">        label = &quot;Green LED 2&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>DT_DRV_INST(0)</code>表示led0的Node ID，等价于<code>DT_INST(0, gpio_leds)</code></p>\n<p><code>DT_DRV_INST(1)</code>表示led1的Node ID，等价于<code>DT_INST(1, gpio_leds)</code></p>\n<blockquote>\n<p>因为<code>devicetree.h</code>中，有</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_DRV_INST(inst) DT_INST(inst, DT_DRV_COMPAT)</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\tInst API提供了基于<strong>下标</strong>的访问DeviceTree节点的方式。</p>\n<p>​\t接下来，下图用宏函数的方式定义了一个代码模板，内部定义了led 驱动程序所需的变量、device结构体等。所有内部调用的宏函数都是基于实例ID的INST API。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312214413238.png\" alt=\"image-20230312214413238\"></p>\n<p>​\t最后，用<strong>遍历宏</strong>调用了前面的代码模板。这个遍历宏的效果是：对所有<code>status=&quot;okay&quot;</code>，且<code>compatible=&quot;gpio-leds&quot;</code>的节点，执行一次上面的宏函数。</p>\n<p>​\tzephyr就是用这种方式，在驱动代码中自动遍历所有<code>status=&quot;okay&quot;</code>的节点，提取其信息，然后用遍历宏来定义驱动结构体，在kernel启动之前就把硬件的初始化给完成。</p>\n<h2 id=\"6-4-specifier硬件支持\"><a href=\"#6-4-specifier硬件支持\" class=\"headerlink\" title=\"6.4. specifier硬件支持\"></a>6.4. specifier硬件支持</h2><p>Device Tree API 中还有很多硬件支持的宏，方便你直接读取specifier等。具体可参考：</p>\n<p><a href=\"https://docs.zephyrproject.org/latest/build/dts/api/api.html\">https://docs.zephyrproject.org/latest/build/dts/api/api.html#hardware-specific-apis</a></p>\n<p><a href=\"https://docs.zephyrproject.org/latest/hardware/index.html\">https://docs.zephyrproject.org/latest/hardware/index.html</a></p>\n<p>这里以ADC的硬件支持宏为例。例如，一个节点为：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312214651795.png\" alt=\"image-20230312214651795\"></p>\n<p>使用<code>ADC_DT_SPEC_GET_BY_IDX(node_id, idx)</code>,就会展开为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   .dev = xxxx,</span><br><span class=\"line\">   .channel_id = xxxx,</span><br><span class=\"line\">   .channel_cfg = xxx,</span><br><span class=\"line\">   .vref_mv = xxxxx,</span><br><span class=\"line\">   <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刚好和zephyr的adc驱动中定义的adc channel结构体的成员一致</p>\n<p>这就是为什么我们可以直接写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_0</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_1</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_2</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果用上前面说的遍历宏，还能更加简单，直接生成数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给一个specifier对应的大括号末尾加上逗号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_SPEC_AND_COMMA(node_id, prop, idx) \\</span></span><br><span class=\"line\"><span class=\"meta\">    ADC_DT_SPEC_GET_BY_IDX(node_id, idx), <span class=\"comment\">// &lt;--逗号加在这里</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 使用遍历宏直接把所有specifier读进数组</span></span><br><span class=\"line\"><span class=\"comment\">// 这些宏展开后相当于三个结构体初始化大括号，中间用逗号分隔</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">adc_channels</span>[] =</span> &#123;</span><br><span class=\"line\">    DT_FOREACH_PROP_ELEM(DT_PATH(zephyr_user), </span><br><span class=\"line\">                         io_channels,</span><br><span class=\"line\">                 \t\tDT_SPEC_AND_COMMA)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-Zephyr-Driver的实现方式\"><a href=\"#7-Zephyr-Driver的实现方式\" class=\"headerlink\" title=\"7. Zephyr Driver的实现方式\"></a>7. Zephyr Driver的实现方式</h1><h2 id=\"什么是驱动程序？\"><a href=\"#什么是驱动程序？\" class=\"headerlink\" title=\"什么是驱动程序？\"></a><strong>什么是驱动程序？</strong></h2><p>​\t驱动程序是面向对象的。首先要有一个被操作的对象，然后才有驱动程序。这个被操作的对象就是 <strong>device结构体</strong>。 device结构体本身是抽象的，没有具体的含义:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;           <span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *config;         <span class=\"comment\">// 设备的初始配置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *api;            <span class=\"comment\">// 设备的api函数集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_state</span> *<span class=\"title\">state</span>;</span> <span class=\"comment\">// 设备的工作状态</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *data;                 <span class=\"comment\">// 设备的运行数据</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span>                   <span class=\"comment\">// 其他参数，例如电源管理，后续有专门文章讲解</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​\t驱动程序在Appilication程序运行之前，就把硬件初始化做好，然后定义好device结构体的内容。下图中的五个红色的主要级别都是可以定义驱动程序初始化的时间，每个级别内还可以再细分优先级。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312215847338.png\" alt=\"image-20230312215847338\" style=\"zoom:67%;\" />\n\n<h2 id=\"在Application中如何拿到Device结构体？\"><a href=\"#在Application中如何拿到Device结构体？\" class=\"headerlink\" title=\"在Application中如何拿到Device结构体？\"></a>在Application中如何拿到Device结构体？</h2><p>​\t如果说，zephyr在系统初始化阶段就能把所有device结构体定义好。那么Application运行后，要如何拿到这些device呢？</p>\n<h3 id=\"（1）通过Name的方式\"><a href=\"#（1）通过Name的方式\" class=\"headerlink\" title=\"（1）通过Name的方式\"></a>（1）通过Name的方式</h3><p>​\t这种方式，可以与DeviceTree完全无关。可以自己定义一个与DeviceTree无关的纯软件设备，也可以编写驱动程序。</p>\n<p>  例程：<code>$&#123;NCS&#125;/zephyr/samples/application_development/out_of_tree_driver</code> 中，介绍了out of tree driver的写法。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220123168.png\" alt=\"image-20230312220123168\"></p>\n<center>驱动程序中，定义了device的name</center>\n\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220147908.png\" alt=\"image-20230312220147908\"></p>\n<center>应用程序中，通过`device_get_binding()`函数获取device指针 </center>\n\n<h3 id=\"（2）通过DeviceTree的方式\"><a href=\"#（2）通过DeviceTree的方式\" class=\"headerlink\" title=\"（2）通过DeviceTree的方式\"></a>（2）通过DeviceTree的方式</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220418544.png\" alt=\"image-20230312220418544\"></p>\n<p>​\t在驱动程序中，通过<code>DEVICE_DT_DEFINE()</code>，定义了device结构体，并与DeviceTree中的节点绑定：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220359492.png\" alt=\"image-20230312220359492\"></p>\n<p>在Application中，通过<code>DEVICE_DT_GET(node_id) </code>宏来获得这个device结构体</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220423449.png\" alt=\"image-20230312220423449\"></p>\n<h2 id=\"Kconfig与DeviceTree\"><a href=\"#Kconfig与DeviceTree\" class=\"headerlink\" title=\"Kconfig与DeviceTree\"></a>Kconfig与DeviceTree</h2><p>我们修改<code>prj.config</code>中的<code>CONFIG_XXXX</code>选项、修改dts中的<code>status</code>属性，其本质是在做什么？</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220546761.png\" alt=\"image-20230312220546761\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220553466.png\" alt=\"image-20230312220553466\"></p>\n<p>综合前面介绍的device tree、遍历宏的内容，我们可以知道：</p>\n<ol>\n<li>修改driver相关的config选项，其本质是让CMake把驱动程序包含进来。<strong>只要启用了相关config，驱动程序就会载入，固件就会变大。</strong></li>\n<li>修改status为”okay”，其本质是，让驱动程序在使用遍历宏创建device结构体时，能够为这个okay的节点创建device对象。</li>\n</ol>\n<p><strong>只有两者都启用，硬件节点才真正的被驱动了，application中才能真正的操作这个节点。</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220655857.png\" alt=\"image-20230312220655857\"></p>\n<h2 id=\"Zephyr标准驱动\"><a href=\"#Zephyr标准驱动\" class=\"headerlink\" title=\"Zephyr标准驱动\"></a>Zephyr标准驱动</h2><p>Zephyr是一个跨平台的操作系统，自然少不了对各类标准硬件的跨平台支持。</p>\n<p>详见：<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/index.html\">https://docs.zephyrproject.org/latest/hardware/peripherals/index.html</a></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220754929.png\" alt=\"image-20230312220754929\"></p>\n<p>这里以Counter为例：</p>\n<blockquote>\n<p>在Zephyr中，Timer指的是内核软定时器，而Counter指硬件定时器</p>\n</blockquote>\n<p>在<code>zephyr/include/zephyr/drivers/counter.h</code>中，规定了zephyr标准的counter应该具有哪些api。</p>\n<p>在<code>zephyr/drivers/counter/</code>目录下，有各个厂商对自家MCU产品写好的timer驱动，全部都符合zephyr标准的API。</p>\n<p>在Kconfig中启用counter驱动时，zephyr build system就会自动把板子对应厂商的counter驱动编译进来。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220830650.png\" alt=\"image-20230312220830650\"></p>\n<h2 id=\"Zephyr标准驱动支持硬件的全功能吗？\"><a href=\"#Zephyr标准驱动支持硬件的全功能吗？\" class=\"headerlink\" title=\"Zephyr标准驱动支持硬件的全功能吗？\"></a>Zephyr标准驱动支持硬件的全功能吗？</h2><p>​\t很遗憾，答案是<strong>不能</strong>。Zephyr只支持<strong>最基础</strong>、<strong>最标准</strong>的硬件驱动，不支持各个厂商的硬件特性。</p>\n<p>​\t例如nrf系列的PPI，非常方便，zephyr没有为PPI提供标准驱动，因为其他厂商平台并没有这个功能，所以是不可能有「device tree里写一下配置，PPI就自动连好了」这种操作的。Nordic外设的<code>SHORT</code>寄存器也是同理。</p>\n<p>​\t下面是一段混合代码：</p>\n<ul>\n<li>前半部分，zephyr标准已经自动初始化好timer0，所以可以用counter api，配置计时；</li>\n<li>后半部分，利用nrfx api，来连接short寄存器，让timer0计时结束后，自动触发clear。</li>\n</ul>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312221017468.png\" alt=\"image-20230312221017468\"></p>\n<blockquote>\n<p>这里还有个注意事项：<br>    nrf timer本身没有overflow事件，所以把channel 0拿去设置top value了；此外，还把channel 1拿去做输入捕获了。</p>\n<p>​\t因此，nrf timer暴露给zephyr标准驱动的通道就少了两个，实际上zephyr counter的通道0，是硬件定时器的通道2。</p>\n</blockquote>\n<h1 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h1><ol>\n<li>DeviceTree描述的是<strong>板卡级</strong>的硬件信息。DeviceTree是树型逻辑结构，层次关系是由<strong>总线的主从关系，</strong>以及<strong>硬件的包含关系</strong>决定的 。</li>\n<li>DeviceTree的基本单元是节点（Node），节点具有一个<strong>名称</strong>和多条<strong>属性</strong>。可以给节点增加标签（label），来便于引用这个节点。</li>\n<li>板卡级的dts文件可以引用芯片级的dtsi文件，也可以引用.h头文件，从而使用其定义的枚举值和宏。</li>\n<li>用户可以在自己的工程里通过写overlay的方式，来覆写原始board dts里的配置</li>\n<li>Zephyr Build System在构建时会合并所有的dts以及overlay，生成最终的zephyr.dts，并导出为devicetree_generated.h头文件</li>\n<li>DeviceTree本身的语法只提供了一个基于总线主从关系的树形层次结构，此外每个节点可以用属性来存储信息。语法本身并没有规定硬件要如何描述。DeviceTree中的一些常见属性，补充了这方面的空缺。<ul>\n<li>reg、ranges、#address-cells、#size-cells这四个属性描述了总线上的地址分布</li>\n<li>status属性描述了设备是否使能</li>\n<li>compatible属性描述了设备的兼容性</li>\n</ul>\n</li>\n<li>在DeviceTree中，除了本身的树形结构以外，还具有一些逻辑上的树形结构，称为域。域具有<strong>控制器</strong>和设备节点，控制器是真正实现域的功能的硬件外设，而设备节点只是为了开发方便解耦而进行的一种抽象。</li>\n<li>真正限制device tree中属性该如何写的，是device binding文件。binding文件是芯片厂商提供的。有了binding文件，就可以在VS Code中实现自动的检查与补全。Zephyr实际构建项目时，也是参考binding文件来检查dts的正确性。只有dts按照正确的规则写了，zephyr的驱动代码才能识别到硬件配置，进行自动初始化。</li>\n<li>zephyr中会有一些特殊的虚拟节点来为开发提供便利。</li>\n<li>要从C语言中访问DeviceTree中的信息，需要先获得node id。用绝对路径、label、chosen、alias等许多方法都可以获取一个节点的node id。其中要注意的是通过实例id的方法（INST）</li>\n<li>有了node id，就可以获取node的属性。普通的属性与reg、phandle、interrupt属性的获取API不相同。</li>\n<li>zephyr还提供了遍历宏，从而可以针对特定条件的节点&#x2F;属性遍历执行宏函数。</li>\n<li>Zephyr用前面提到的通用API，封装出了各种硬件支持API，方便直接读取各种硬件指定的specifier。</li>\n<li>Zephyr驱动程序，在Application运行之前就会执行初始化，并且定义device结构体。</li>\n<li>Application可以通过Name或者Node id的方式，获得device结构体</li>\n<li>我们在Kconfig中使能driver，本质上是载入了驱动程序，固件会变大。在dts中把节点的status设为okay，本质上是让驱动程序在初始化时，能够自动搜到这个节点，并为这个节点创建device实例。</li>\n<li>Zephyr的标准驱动，让各个厂商都实现了相同功能的驱动API代码，从而实现了跨平台的统一驱动。<br> 但是如果想要使用硬件特性的功能，就还是必须使用厂商自己的driver library或者直接写寄存器。</li>\n</ol>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr","DeviceTree"]}]