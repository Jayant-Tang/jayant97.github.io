[{"title":"Hello World","url":"/2022/12/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"nRF9160与nRF Cloud应用示例","url":"/2022/12/01/使用nRF9160-DK连接nRF Cloud示例/","content":"\n# 使用nRF9160-DK 连接 nRF Cloud示例\n\n# 1. 产品简介\n\n## 1.1. nRF Cloud\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122150443236.png\" style=\"zoom: 40%;\" />\n\nnRF Cloud是Nordic Semiconducotr公司为Nordic无线产品专门优化的物联网云平台，它可以为任何使用Nordic芯片的客户的原型产品、商业产品提供便捷的云连接、云服务。\n\nnRF Cloud提供**设备注册（Cloud Provisioning）**、**OTA升级**、**数据存储**、**位置定位**等服务。所有这些功能都可通过Web界面进行管理。客户可以为不同的团队配置不同级别的管理权限。\n\nnRF Cloud目前有Devloper，Pro和Enterprise三种收费计划。其中开发者计划（Developer plan）是**完全免费**的，只要你有Nordic的开发板就可以最快最方便的方式接入并测试例程。\n\n设备通过nRF Cloud APIs与nRF Cloud进行连接，如下图：\n\n![image-20221125164136165](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221125164136165.png)\n\n设备可以直接通过MQTT API或REST API接入到云。nRF Cloud也通过REST API为客户提供了**云-云对接**的接口。\n\n更多有关nRF Cloud的信息，可以参考：\n\n- [nRF Cloud | nRF Cloud Docs](https://docs.nrfcloud.com/)\n\n## 1.2. nRF9160 SiP\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/nRF9160-SiP-rev2-1016-front-and-back.webp\" alt=\"application\" style=\"zoom: 50%;\" />\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122134533863.png\" alt=\"image-20221122134533863\" style=\"zoom: 33%;\" />\n\nnRF9160是一款高集成度的低功耗SiP（System-in-Package），具有完整的LTE-M/NB-IoT Modem、射频前端、电源管理系统，还具有一颗Cortex-M33应用处理器，便于开发自定义应用。nRF9160是目前市面上**最紧凑、最完整、功耗最低**的蜂窝物联网解决方案。\n\nnRF9160内置的Modem在全球范围内同时支持**LTE-M**和**NB-IoT**，并且在IPv4/IPv6下均支持**eDRX和PSM省电模式**，支持到传输安全层（TCP/TLS）。支持GNSS（含美国GPS和日本QZSS）。Modem固件可以通过加密OTA进行升级。\n\nCortex-M33应用处理器具有独享的1 MB Flash，256 KB SRAM和多种外设接口，便于在单颗设备中实现高级应用。\n\n也可以把nRF9160当作外挂模组，让外部MCU通过AT指令进行操作，拓展连网能力。在 [Nordic Info Center](https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html)可以查看AT指令手册，并可以在右上角下载PDF。\n\n在安全方面：Arm TrustZone技术可为固件和外设提供安全隔离和保护。使应用可实现Secure Boot、受信任固件升级、受信任的Root等安全需求，且不影响性能。Arm CryptoCell通过加密和安全资源来保护物联网应用程序免受各种攻击威胁。\n\nnRF9160支持SIM和eSIM。\n\n更多信息，可参考：\n\n- [nRF9160中文brief - Nordic Semiconductor - nordicsemi.com](https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/Translated-versions/04_nRF9160-SiP-1.4_SC.pdf?la=en&hash=A1F478B9D8593C70FA143C1CA09C2759C8ED51B6)\n- [nRF9160 - Nordic Semiconductor - nordicsemi.com](https://www.nordicsemi.com/Products/nRF9160)\n- [nRF9160 Product Specifications v2.1.pdf](https://infocenter.nordicsemi.com/pdf/nRF9160_PS_v2.1.pdf)\n- [nRF9160 全球认证信息 - nordicsemi.com](https://www.nordicsemi.com/Products/Low-power-cellular-IoT/nRF9160-Certifications)\n\n## 1.3. nRF9160 DK\n\n![nRF9160 DK promo](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/nRF9160-DK.webp)\n\nnRF9160 DK是一款优秀设计的预认证开发套件，带有一颗nRF9160 SiP和一颗nRF52840低功耗蓝牙MCU（用于开发BLE网关产品）。\n\n板载一个支持多个频段的LTE-M和NB-IoT天线、一个GPS贴片天线和一个2.4G陶瓷天线（用于BLE）。其中LTE和2.4G天线接口提供SWF射频连接端子，便于测量RF信号。所有三款连接器均允许使用外部天线。\n\n开发板引出了所有GPIO和接口，兼容Arduino Uno Rev3。提供可编程LED(4)、按钮(2)、开关(2)。开发板还具有nano SIM卡插槽（J5）和eSIM贴片焊盘（U20）或eSIM直插接口（P28）。\n\n板载正版Jlink OB，除可下载、调试板载的nRF9160外，也可对外调试其他产品。\n\n更多信息，可参考：\n\n- [nRF9160 DK - nordicsemi.com](https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN#infotabs)\n\n- [nRF9160 DK HW User Guide v1.1.0.pdf](https://infocenter.nordicsemi.com/pdf/nRF9160_DK_HW_User_Guide_v1.1.0.pdf)\n\n## 1.4. nRF Connect SDK\n\nnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台将支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。\n\nNCS内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统。利用Device Tree和Kconfig进行项目的硬件、软件配置。使用CMake和大量Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便，并且是跨平台的（Windows/Linux/OSX）。\n\nNCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。\n\n更多信息可参考：\n\n- [About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html)\n\n- [开发你的第一个nRF Connect SDK(NCS)/Zephyr应用程序 - iini - 博客园 (cnblogs.com)](https://www.cnblogs.com/iini/p/14174427.html)\n\n<div style=”page-break-after: always;”></div>\n\n# 2. 安装NCS开发环境\n\n本节将会详细介绍如何在一台Windows 11的电脑上安装NCS开发环境（Windows 10也适用），包含NCS、编译器以及其他工具。*如果你已经安装好NCS开发环境，可以跳过本节*。\n\n完整的中文教程，也可参考这篇文章：[开发你的第一个nRF Connect SDK(NCS)/Zephyr应用程序 - iini - 博客园 (cnblogs.com)](https://www.cnblogs.com/iini/p/14174427.html)\n\n也可参考官方安装教程：[Getting started — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html)\n\n安装内容列表：\n\n| 序号 |                             软件                             | 用途                                                         |\n| :--: | :----------------------------------------------------------: | ------------------------------------------------------------ |\n|  1   |     [Visual Studio Code](https://code.visualstudio.com/)     | 代码文本编辑器，并且通过安装插件的方式为其他开发调试工具提供可视化界面 |\n|  2   | [nRF Command Line Tools](https://www.nordicsemi.com/Products/Development-tools/nrf-command-line-tools) | Jlink驱动、nrfjprog等命令行工具和DLL                         |\n|  3   | [nRF Connect for Desktop](https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop) | 桌面工具集合，含SDK安装器、功耗评估、射频抓包等工具          |\n|  4   |                 [Git](https://git-scm.com/)                  | 版本管理工具                                                 |\n|  5   | [Python 3.9](https://www.python.org/downloads/release/python-3913/) | 为编译套件的python脚本提供运行环境                           |\n|  6   |              [Ninja](https://ninja-build.org/)               | 快速构建工具（类似make）                                     |\n|  7   |                 [CMake](https://cmake.org/)                  | 根据配置生成.ninja或Makefile文件的工具                       |\n|  8   | [Zephyr SDK](https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html) | 交叉编译工具链（编译器、链接器等）                           |\n|  9   | [NCS 2.1.2](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html) | 含nRF产品驱动包、内核、第三方库等代码和编译配置文件等        |\n|  10  |                  VS Code: nRF Connect插件包                  | 在VS Code中为NCS功能提供可视化                               |\n\n## 2.1. 通过安装包安装VS Code，命令行工具和桌面工具\n\n上述安装列表中1~3号软件都是installer安装包的形式，点击表格中的链接进入官网，下载安装后可以直接双击安装。安装路径需要无中文、空格或“-”，“_”以外的特殊字符。下图仅示例官网nRF Connect for Desktop的下载方式。\n\n![image-20221122214235111](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214235111.png)\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122213145436.png\" alt=\"image-20221122213145436\" style=\"zoom: 67%;\" />\n\n<center>“开始”菜单中安装好的工具（未完全展示）</center>\n\n## 2.2. 安装剩余部分（工具链和NCS）\n\n### 2.2.1. 概述\n\n列表中4~10号软件有2种安装方式，**自动安装**和**手动安装**。自动安装是通过3号软件nRF Connect for Desktop中的工具安装的，这种安装方式会从github拉取NCS仓库的一个特定版本（如v2.1.2）。并把列表中剩余的软件工具（4~8号）放在toolchains文件夹下，与NCS的目录为并列关系。\n\n自动安装可以同时安装多个版本的NCS，并在同一个toolchains文件夹下安装对应版本适合的工具，如下图：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214853721.png\" alt=\"image-20221122214853721\" style=\"zoom:67%;\" />\n\n<center>toolchains下仍有两个NCS单独的工具链</center>\n\nNCS大约有2.7GB，而toolchains大约有1.1GB。由于是从github拉取，在国内如果没有网络代理基本很难下载成功，或者下载很慢。\n\n**自动安装与手动安装还有一个重要的区别**：自动安装的工具不会添加到Windows全局的`PATH`环境变量中，因此打开VS Code后需要在nRF Connect插件的设置中选择工具链的路径。并且，随便打开一个终端（Cmd/Powershell/Git bash）是无法使用toolchains中的工具的。\n\n>注：全部安装完毕后，可以重启电脑，以应用新的环境变量\n\n### 2.2.2. 自动安装方式\n\n打开nRF Connect for Desktop软件，找到**Toolchain Manager**（Toolchain Manager适合Windows和OSX，而Linux适合使用Getting Started Assistant），Install然后Open。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122214549553.png\" alt=\"image-20221122214549553\" style=\"zoom: 50%;\" />\n\n\n\n打开后，先在SETTINGS中选择自己想要存放NCS和toolchains的位置：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122215033170.png\" alt=\"image-20221122215033170\" style=\"zoom: 50%;\" />\n\n\n\n然后，在SDK ENVIRONMENTS中选择想安装的SDK版本进行安装（如①）。安装过程根据网络状况不同，可能很久，也可能会失败。安装完毕后，可打开VS Code（如②）。也可以在对应目录下打开终端（如③④）。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122215310523.png\" alt=\"image-20221122215310523\" style=\"zoom: 50%;\" />\n\n点击“打开VS Code”，会弹窗帮你自动安装VS Code的nRF Connect插件包，如下图：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123161445490.png\" alt=\"image-20221123161445490\" style=\"zoom: 50%;\" />\n\n\n\n若没有自动安装插件包，可以自行在插件中心搜索nRF Connect for VS Code Extension Pack，这个插件包会自动安装其他nRF Connect所需的VS Code插件。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122220619736.png\" alt=\"image-20221122220619736\" style=\"zoom:67%;\" />\n\n\n\n可以在VS Code的设置中对插件进行单独的设置，例如可以设置使用工具链的路径。可以对全局进行设置（USER），也可以单独对某个工作区进行设置（WORKSPACE）。***关于工作区的概念，请见本节的后续第2.3小节**。*\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122220941604.png\" alt=\"image-20221122220941604\" style=\"zoom: 80%;\" />\n\n\n\n### 2.2.3. 手动安装方式\n\n安装过程需要网络代理（注意，命令行终端也需要被代理）\n\n#### （1）安装choco\n\n`choco`是一个类似于Ubuntu中`apt-get`的工具，可以通过命令行安装软件工具，**并自动添加到全局PATH环境变量中**。\n\n首先右键开始菜单，然后打开管理员终端，输入以下命令。\n```powershell\n# 设置脚本执行权限\n> Set-ExecutionPolicy AllSigned\n\n# 从网络端执行安装脚本\n> Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n测试是否安装成功：\n\n```powershell\n> choco\n# 有版本号输出即为成功\n```\n\n\n\n#### （2）利用choco安装其他工具\n\n部分工具也可自己去官网下载，并用安装包安装，**注意安装时要勾选“添加到PATH环境变量”**。\n\n```powershell\n# 设置choco\n> choco feature enable -n allowGlobalConfirmation\n\n# 安装cmake (也可以把这步替换成从官网下载cmake安装包，注意安装时要勾选添加进PATH环境变量)\n> choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'\n\n# 安装git (也可以把这步替换成从官网下载git安装包，注意安装时要勾选添加到环境变量)\n> choco install git \n\n# 安装python (建议把这步换成从官网下载python3.9安装包，并勾选添加到环境变量,通过choco安装容易出错)\n> choco install python --version=3.9.13\n\n# 安装其他工具\n> choco install ninja gperf dtc-msys2 wget unzip\n```\n\n#### （3）安装GN工具（可选）\n\nGN工具是开发[Matter](https://www.nordicsemi.com/Products/Matter)所需的工具。\n\n从[GN网站](https://gn.googlesource.com/gn/#getting-a-binary)下载编译好的Windows压缩包（Getting a binary），在无中文、无空格的路径下解压。并且添加到PATH环境变量即可。\n\n#### （4）安装west\n\nwest是一个多仓库管理工具（类似Android的repo），支持添加自定义插件。在NCS中除了可以管理NCS仓库外，也通过插件实现了板卡选择、触发编译动作、触发flash烧写的功能。\n\n利用Python的pip进行安装\n\n```powershell\n>  pip3 install west\n# 若不是python3.9，可能会报错\n```\n\n#### （5）安装NCS\n\nnRF Connect SDK前面已经介绍过，含驱动、内核以及第三方库的源码。\n\n1. 在一个无中文、无空格的合适路径下打开终端（powershell或bash）：\n\n```powershell\n #创建并进入文件夹\n> mkdir ncs\n> cd ncs\n\n# 初始化仓库（从github拉取）\n> west init -m https://github.com/nrfconnect/sdk-nrf --mr v2.1.2\n# 也可选择其他版本，如：\n# west init -m https://github.com/nrfconnect/sdk-nrf --mr main\n```\n\n> 备注：\n>\n> - 这一步如果下载失败想重新下载，需要把创建的ncs文件夹下的所有内容删除干净，尤其是`.west`隐藏文件夹;\n> - 如果网络实在差，可以从百度网盘下载，见[《开发你的第一个nRF Connect SDK(NCS)/Zephyr应用程序》 - iini - 博客园 (cnblogs.com)](https://www.cnblogs.com/iini/p/14174427.html)\n\n2. 更新仓库\n\n```powershell\n#更新仓库\n> west update\n```\n\n3. 导出Zephyr CMake package，便于CMake自动识别Zephyr的模板，后续生成工程\n\n```powershell\n> west zephyr-export\n```\n\n4. 安装额外的python依赖\n\n安装python依赖之前，还需要安装\"Microsoft Visual C++ Build Tools 14.0\"或更高版本：[Microsoft C++ Build Tools - Visual Studio](https://visualstudio.microsoft.com/visual-cpp-build-tools/)，用来编译这些python工具。在上述微软链接下载，会获得一个VS安装工具。只在Workloads栏里选择 **\"Desktop Development with C++\"**，然后安装即可。\n\n​\t然后再开始安装python依赖包：\n\n```powershell\n> pip3 install -r zephyr/scripts/requirements.txt\n> pip3 install -r nrf/scripts/requirements.txt\n> pip3 install -r bootloader/mcuboot/scripts/requirements.txt\n```\n\n5. 切换到任意的正式版本\n\n   > ​    NCS利用west管理多个git仓库（nrf, zephyr等），其中nrf是主仓库（Manifest）。主仓库的版本即代表整个west仓库（也就是SDK）的版本。\n\n```powershell\n# 查看nfr仓库下有多少版本\n> cd nrf\n> git tag  # 按键盘上下键翻阅，按q退出\n\n# 检出想要的版本\n> git checkout v2.1.2\n\n# 更新整个仓库\n> west update\n```\n\n\n\n#### （6）安装Zephyr SDK工具链\n\nZephyr SDK是编译器、链接器等工具。建议放在用户目录下。\n\n最新版本的下载地址可从 [Zephyr SDK — Zephyr Project Documentation](https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html#install-zephyr-sdk-on-windows) 获取。\n\n```powershell\n# 进入到用户目录（c:\\Users\\[用户名]）\n> cd $HOME\n# 如果是你的终端是bash而非powershell，则命令为\n# cd ~\n\n# 下载（最新版本的下载地址可从官网链接获取）\n> wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.1/zephyr-sdk-0.15.1_windows-x86_64.zip\n\n# 解压\n> unzip zephyr-sdk-0.15.1_windows-x86_64.zip\n\n# 配置\n> cd zephyr-sdk-0.15.1\nsetup.cmd\n```\n\n>注意：\n>\n>- `setup.cmd`只需执行一次。如果改变了安装位置，需要再次执行。\n>- Zephyr SDK安装完成后，会发现：如果在前面安装了ncs的目录下执行`west --help`会比其他目录下执行`west --help`多出一些扩展指令，如`build`,`board`等等。这是因为NCS中的`.west`文件夹的配置了Zephyer的base路径，提供了这个仓库独有的插件。这些扩展的指令就是调用了插件进行编译、调试、烧写等工作。\n>  为了让其他目录下也能使用Zephyr工具，需要设置全局环境变量：\n>   **在Windows环境变量中新建`ZEPHYR_BASE`环境变量，并把其值设置为`ncs`安装目录下的`zephyr`目录的路径即可。**\n>\n> （这个效果和执行一次`ncs`目录下的`zephyr/zephyr-env.cmd`脚本是一样的，但这个脚本设置环境变量只是临时生效，关闭终端再另开一个终端就不起作用了。而设置全局环境变量是永久生效。）\n\n#### （7）安装VS Code插件\n\n见**自动安装**章节中最后对插件安装的介绍。并把插件设置的工具链路径设为`PATH`即可。\n\n\n\n## 2.3. 打开一个或多个例程并保存工作区\n\n在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择 \"adding an existing application\"：\n\n![image-20221122225724875](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225724875.png)\n\n\n\n从ncs的`nrf`或者`zephyr`目录的`sample`子目录下随便选取一个项目，打开文件夹即可：\n\n项目创建完毕后，默认存储在一个UNTITLED **workspace**中，这是一个**临时的**workspace。\n\n### （1）理解VS Code的Workspace（工作区）\n\n> workspace是VS Code中的一种设计，就是许多同类项目（目录）的集合。这种设计，方便同一类项目统一设定工具链路径、插件等。\n>\n>在VS Code的settings中，可以看到设置分为User, Workspace, Folder三个级别。User就是全局的设置，Worksdpace和Folder就依次是更细一级的设置。后者可以覆盖前者的设置。\n>\n>例如可以只创建一个Nordic NCS专用的workspace，只在这里面启用ncs 插件。在其他workspace中不启用。这样VS Code就可以在不同workspace下进行不同语言、不同领域的开发。（具体方法是：在不打开任何workspace的情况下，在插件管理中禁用nRF Connect for VS Code Extension pack，然后打开workspace时，在插件管理中选择Enable(workspace)，就可以只在这个workspace中使用ncs插件了）\n>\n>VS Code中，工具栏\"File\"菜单中有workspace添加、保存等选项。\n>\n>如果之前没接触过workspace，只是单独打开一个文件夹（File-Open Foledr...），那么就没有Workspace这一个层级，仅有Folder层级。Folder级别的设置就存储在当前目录的`.vscode/settings.json`中。\n\n\n\n可以在VS Code菜单栏中选择 File > Save Workspace As ... ，将工作区另存为一个`xxxxx.code-workspace`文件。这样每次打开这个`.code-workspace`文件就能打开整个工作区。\n\n![image-20221122225912476](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225912476.png)\n\n![image-20221122225949921](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122225949921.png)\n\n可以从工作区内移除项目文件夹：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122230432396.png\" alt=\"image-20221122230432396\" style=\"zoom: 50%;\" />\n\n\n\n也可以向工作区内添加项目文件夹：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122230541745.png\" alt=\"image-20221122230541745\" style=\"zoom:50%;\" />\n\n>注意:\n>\n>- workspace只是一个集合，用`.code-workspace文件`来描述，并不一定是一个真实存在的大文件夹，更不需要所有的项目文件夹都是workspace的子文件夹。\n>- 如果已经保存了workspace，那么下次再打开这个workspace中的项目时，不要再用\"adding an existing application\"。因为这又会把此项目放入一个临时的UNTITLED workspace内。直接从上次保存的`xxxx.code-workspace`文件重新打开工作区即可。\n\n\n\n### （2）理解nRF Connect的workspace\n\nVS Code的workspace本质上是文件夹的集合，VS Code并不在乎文件夹的内容是什么。\n\n但是在nRF Connect插件的APPLICATION视图中，可以看到当前工作区内nrf项目的集合，这些文件夹就必须是可以编译的nrf项目了，如下图：\n\n![image-20221122231125385](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122231125385.png)\n\n\n\n有时在VS Code的workspace中添加、移除文件夹，nRF connect插件的APPLICATIONS视图不会一起同步。这时可以在APPLICATION视图中进行单独的添加或右键移除。“+”按钮的效果和“Add an existing application”是一样的。\n\n此外，也可以在左下角齿轮Settings中，当前WORKSPACE下的`nrfconnect.applications`配置中，对当前工作区中的项目数量进行管理：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122231837769.png\" alt=\"image-20221122231837769\" style=\"zoom:80%;\" />\n\n\n\n## 2.4. 创建一个新工程并用git管理\n\n**打开**一个例程，例程的文件夹还是在ncs仓库内部，受到ncs的git仓库的管理。如果想自己开发项目，并用git管理版本，就需要**创建**新工程。\n\n### （1）创建新工程\n\nNCS支持以例程作为模板，复制并创建新的工程。\n\n在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择`create a new application`：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122232512218.png\" alt=\"image-20221122232512218\" style=\"zoom:80%;\" />\n\n- 需要设置项目的名称、路径。\n- 需要从ncs的例程中选择一个作为模板（可以是nrf/sample, nrf/application, zephyr/sample, zephyr/application目录下的例程）\n- 需要设置Application Type\n\n>#### 理解Application Type\n>\n>新项目的创建方式有freestanding和workspace两种：\n>\n>- freestanding 就是不使用工作区，只使用文件夹来保存一个单独的工程。这种方式，要求电脑上已经装了一个NCS。\n>\n>- workspace就是在创建这个项目时，同时创建一个工作区，并且要设定这个工作区的名称。这种方式不需要安装NCS，它直接从github上拉取一个新的NCS。\n>\n>**【注意】如果创建新工程时，当前VS Code已经打开了一个workspace （临时UNTITLED的也算），那么就只能选择freestanding，不能选择workspace创建方式。并且这个freestanding的工程会强行加入到目前已经打开的workspace中。**如果想避免这种情况，可以在VS Code菜单栏的File...选项中选择关闭当前workspace，或者打开一个新VS Code窗口，再进行操作。\n\n### （2）使用git管理你的新工程\n\n创建好的新工程，可以使用git管理，按Ctrl + \"\\`\" （波浪线那个键）打开终端，然后进入你刚刚创建的新工程的目录（打开终端时，默认的目录可能是workspace中其他的目录，需要手动切过去）。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233158710.png\" alt=\"image-20221122233158710\" style=\"zoom: 67%;\" />\n\n\n\n如果你从没用过git，需要先配置用户名和邮箱。这个用户名和邮箱不是登陆什么网站用的，而是一个签名，用于提交代码时标记这段代码是谁提交的。这个配置存在你电脑的本地，并且是全局的。\n\n```bash\n$ git config --global user.name \"Jayant.Tang\"\n\n$ git config --global user.email \"jayant.tang@nordicsemi.no\"\n```\n\n\n\n在新的工程文件夹下创建新的仓库：\n\n```bash\n$ git init\n```\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233614502.png\" alt=\"image-20221122233614502\" style=\"zoom:50%;\" />\n\n如果你的终端是git bash，右边已经出现了分支名。\n\n\n\n初始化好仓库后，如果你之前build过，就可以看到左侧git窗口有大量的新文件：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122233758040.png\" alt=\"image-20221122233758040\" style=\"zoom:50%;\" />\n\n使用`git status`命令查看也会告诉你，当前有很多未被git仓库跟踪的文件。\n\n但是其中很多文件是编译过程中自动生成的，甚至有些是二进制文件。我们并不关心这些文件的内容如何变化，因此可以在当前工程的根目录下创建一个`.gitignore`文件来配置我们想要忽略的文件或文件夹：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234108052.png\" alt=\"image-20221122234108052\" style=\"zoom:67%;\" />\n\n例如`build/`就是忽略build下所有的文件的变化。\n\n\n\n可以把所有修改添加到暂存区（效果等同于`git add .`）：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234334470.png\" alt=\"image-20221122234334470\" style=\"zoom:67%;\" />\n\n\n\n可以把暂存区的修改全部提交，并添加描述（效果等同于`git commit -m \"init a new project\"` ）\n\n![image-20221122234752701](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122234752701.png)\n\n\n\n如果安装了git history插件，就可以查看提交历史：\n\n![image-20221122235338251](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122235338251.png)\n\n\n\n可以看到每次commit都改动了哪些代码和配置（左侧为旧的，右侧为新的）\n\n![image-20221122235416865](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122235416865.png)\n\n本文不详述git的使用，可以去网上了解其他教程。\n\n\n\n## 2.5. 编译工程\n\n不论是打开的示例工程，还是创建的新工程，都遵循下列步骤进行编译和调试等。\n\n1. 创建一个Build选项，需要选择自己使用的板卡。如果是自己的板子，也可以创建新板子，本文不介绍如何自定义板子。\n\n![image-20221123135000141](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123135000141.png)\n\n\n\n2. 在APPLICATIONS栏选中自己要编译的工程。然后在ACTIONS栏通过build**按钮**进行项目的构建。\n\n![image-20221123140646521](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123140646521.png)\n\n> 自动安装的SDK，可能由于网络原因而缺少文件，并且nRF Connect桌面版不会给出任何提示。\n>\n> 如果编译时提示：`No Such File or Directory...`之类的错误时，很可能就是SDK中缺少文件。\n>\n> 这时需要在SDK目录下打开终端，并执行：\n>\n> ```bash\n> # 查看nfr仓库下有多少版本\n> cd nrf\n> git tag  # 按键盘上下键翻阅，按q退出\n> \n> # 检出想要的版本\n> git checkout v2.1.2\n> \n> # 更新整个仓库\n> west update\n> ```\n>\n> 如果更新时出现问题，往往是网络问题\n\n另外，也可以通过Ctrl + \\` 打开终端，输入命令进行编译：\n\n```bash\n$ west build\n```\n\n\n\n## 2.6. 烧录hex\n\n可以通过ACTIONS栏中的`Flash`按钮触发烧录动作：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160139273.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n也可以在终端中输入:\n\n```bash\n$ west flash\n```\n\n\n\n> 这样直接烧录，有一部分项目可能会烧写失败，显示：\n>\n> ![image-20221123160245857](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160245857.png)\n>\n> 这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。为了安全起见，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。\n>\n> 全片擦除然后烧录：\n>\n> ![image-20221123160832598](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123160832598.png)\n>\n> 或者使用命令行方式：\n>\n> ```bash\n> $ west flash --force --erase\n> ```\n\n\n\n<div style=”page-break-after: always;”></div>\n\n# 3. 示例: 使用nRF9160-DK连接到nRF Cloud\n\n本节将会在nRF9160-DK开发板上，烧录`nrf/applications/asset_tracker_v2`例程。根据国内的网络进行配置，然后把板子连接到nRF Cloud上。\n\n## 3.1. 前期准备\n\n- [nRF9160 DK开发板（本示例使用的版本：v1.1.0）](https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN)：其中nRF9160 SiP**不能**是Revision 1版本，必须是Revision 2或更高版本。\n  （查看SiP封装上的文字，有**B0**则为Rev1版本，有**B1**则为Rev2版本。可参考：[nRF9160 IC Revision Overview](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcomp_matrix_nrf9160%2FCOMP%2Fnrf9160%2Fnrf9160_ic_revision_overview.html)）\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124110534824.png\" alt=\"image-20221124110534824\" style=\"zoom:25%;\" />\n\n- micro USB线缆一根\n- 中国移动NB卡(物联网卡)\n- 一台Windows10或以上版本操作系统的电脑，并按照前述第2节正确安装了NCS开发环境\n- 注册一个 [nRF Cloud账号](https://nrfcloud.com/#/)\n\n![image-20221122191558453](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221122191558453.png)\n\n- 将电源开关拨到on，并确保调试开关处于\"nRF91\"挡位\n- 插好nano SIM卡，并通过microUSB线连接到电脑\n\n> 注：DK附赠的iBASIS SIM卡为国外运营商产品，国内无法使用\n\n## 3.2. 烧录Modem固件\n\nnRF9160的Modem具有独立的固件，这部分固件是Nordic以zip包的形式提供的。\n\n1. 在官网[nRF9160 DK - Downloads - nordicsemi.com](https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK/Download#infotabs)界面，选中最新的Modem固件版本并下载（必须大于1.3.0）。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143324324.png\" alt=\"image-20221123143324324\" style=\"zoom:50%;\" />\n\n\n\n2. 打开nRF Connect桌面版，找到Programmer工具并打开\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143424410.png\" alt=\"image-20221123143424410\" style=\"zoom: 67%;\" />\n\n\n\n3. 先选择板卡，然后选择固件文件（.zip），最后烧录\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123143649354.png\" alt=\"image-20221123143649354\" style=\"zoom:50%;\" />\n\n\n\n4. 烧录完毕\n\n![image-20221123144339925](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123144339925.png)\n\n\n\n## 3.3. 配置、编译并烧录Application固件\n\n### （1）以asset_tracker_v2为模板，创建新工程\n\n> asset_tracker_v2是applications目录下的例程。这个目录下的都是商业级例程，基本改一下就能作为产品使用了。\n\n创建新工程相比于打开例程的好处，在第2.4节中已经描述了。\n\n通过nrf connect插件界面的\"Create a new application\"来创建新的工程。\n\n![image-20221123145304528](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123145304528.png)\n\n从上到下，选项依次为：\n\n- NCS路径\n- Zephyer SDK工具链路径\n- 本项目的存储位置\n- 选取作为模板的sample例程（NCS中的例程）\n- 本项目的名称\n\n关于asset_tracker_v2的更多信息，可以参考：[nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html)\n\n>建议按照2.4.中的描述，为这个新工程创建一个git仓库，便于你记录自己修改了什么。\n\n\n\n### （2）为新工程创建编译选项\n\n板卡选择`nrf9160dk_nrf9160_ns`，然后Build Configuration即可。\n\n![image-20221123145942948](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123145942948.png)\n\n\n\n### （3）修改配置\n\n打开工程根目录下的`prj.conf`文件，进行修改：\n\n1. 与运营商有关的修改\n\n```bash\n# 由于使用移动的NB物联网卡，协议关闭LET-M，使用NB-IoT\nCONFIG_LTE_NETWORK_MODE_LTE_M_GPS=n  # 由y改为n\nCONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y  # 新增\n\n# NB-IoT对ePCO支持的不好，故使用传统的PCO\nCONFIG_PDN=y                         # 新增\nCONFIG_PDN_LEGACY_PCO=y              # 新增\n```\n\n2. 与nRF Cloud连接、注册有关的修改（后面小节会详细说明）\n\n```bash\n# 启用JWT和UUID的云端注册方式\nCONFIG_MODEM_JWT=y                              # 新增\nCONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y  # 新增\n```\n\n\n\n> 【备注】`prj.conf`文件的作用：\n>\n> 在Zephyer编译系统中，Kconfig管理编译选项、各类功能选项的开关，而devicetree用来管理硬件。编译时，通过CMake和ninja会调用一系列python辅助脚本，把Kconfig和device tree变成c代码和头文件。然后进行编译。更多资料，可参考：[Build and Configuration Systems — Zephyr Project Documentation](https://docs.zephyrproject.org/latest/build/index.html#build-and-configuration-systems)\n>\n> 开发时，只需关注Kconfig与device tree如何修改即可。Kconfig中的选项非常多，大多数情况下保持默认即可。Kconfig的默认配置保存在NCS中。\n>\n> `prj.conf`的作用，就是为这个工程单独修改部分Kconfig配置。编译时，构建系统会优先使用prj.conf里的配置来覆盖默认的Kconfig配置。这样每个工程都可以单独配置，不会影响到NCS中的默认配置。\n>\n> `prj.conf`中的选项都必须是Kconfig中可以找到的。\n>\n> 在VS Code中通过图形界面修改完Kconfig时，也可以通过\"Save to file\"按钮，来把修改的部分单独保存到`prj.conf`中，如下图：\n>\n> ![image-20221123154242926](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123154242926.png)\n\n### （4）编译，烧录\n\n参考2.5，2.6节\n\n## 3.4. 联网测试\n\n在nRF Connect桌面版中，打开LTE Link Monitor工具。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123163321689.png\" alt=\"image-20221123163321689\" style=\"zoom:67%;\" />\n\n\n\n然后左上角选择板卡，然后再打开串口。串口共有三个(都是Jlink提供的虚拟串口，在板子上2个连接到9160，1个连接到52840)，其中9160的串口只有一个用于AT Command。\n\n需要依次尝试，点击“AT”按钮就会从串口发送一行“AT”命令，如果有回复OK，说明这个串口就是AT指令的串口。\n\n![image-20221123173504262](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173504262.png)\n\n>在 [Nordic Info Center](https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html)可以查看AT指令手册，并可以在右上角下载PDF。\n\n\n\n左侧的面板显示了联网状态、IP地址、信号强度等信息：\n\n![image-20221123173600818](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173600818.png)\n\n\n\n注意，\"**Automatic Request**\"需要勾选上。勾选以后，在切换串口、点击“AT+CFUN?”指令时，才会自动发送相关AT指令，查询网络状态信息，面板上的信息才会更新。否则面板可能不更新。\n\n![image-20221123173636098](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173636098.png)\n\n即是说，以下状态灯应当全绿，则说明联网成功。但若不是全绿，也不一定是联网失败，可能只是信息没有刷新，参照上一条勾选“**自动请求**”，然后点击“AT+CFUN?”指令再次查询即可。\n\n![image-20221123173817830](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123173817830.png)\n\n>含义：\n>\n>- UART：串口状态\n>- Modem：调制解调器状态\n>- UICC：SIM卡状态\n>- LTE：LTE联网状态\n>- PDN：Packet Data Domain联网状态\n\n\n\n## 3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning)\n\nIoT设备是需要注册到云端的，并且通信都需要加密认证，否则任何人开发的设备都能连接到你的云，就不安全了。\n\n设备注册的流程是：\n\n1. 首先，要有一个自签CA证书，以及对应的密钥文件；\n2. 需要用自签CA证书+设备的UUID，给每个设备单独签发CA证书，并安装单独的私钥到设备中。\n3. 云端持有证书（公钥），这样设备和云端就可以加密通信了。\n\n即：\n\n>【注】什么是非对称加密和CA证书？\n>\n>CA证书具有证书文件（内含公钥）和私钥文件两个部分，公钥和私钥是用来做非对称加密的。公钥加密的数据，只能用私钥解密；用私钥加密的数据，只能用公钥解密。\n>\n>私钥是自己持有的，而公钥公开给所有想与自己通信的对象。\n>\n>假设A要给B发送一段消息M：\n>\n>1. 对于这段消息M，发送者A先利用MD5或SHA256等方式生成一个数字摘要D，再用私钥把消息M加密得到密文C。最后把C+D一起发给接收者B。\n>2. B收到消息后，先用公钥解密C得到M'，再对比M'的数据摘要和D是否一致，若一致，则说明数据确实是**公钥的所有者**发出的。于是确信M'就是要接收的消息M。\n>\n>但B可能拿到假的公钥，黑客发出假的公钥，就可以冒充A给B发消息。为了避免这种情况发生，公钥需要被**认证**，这就是CA证书。\n>\n>一个CA证书文件`ca1`包含公钥P、签名S、所有者信息（国家、城市、单位名称、邮箱等）。`ca1`的签名S，是用另一个证书`ca2`的私钥，对`ca1`的公钥P进行加密得到的。\n>\n>所以利用公开的`ca2`的公钥对S进行解密，如果和P一致，则说明`ca1`是合法的。`ca1`的合法性由`ca2`证明。\n>\n>一个CA证书的安全性由另一个CA证书来证明，这样层层递归下去，形成证书链。而最初的CA证书就是**根证书**。具有颁发**根证书**的资质的机关就是CA（Certificate Authority），也叫“证书授权中心”。CA具有根证书，然后给他信任的其他公司颁发CA证书，这些颁发的CA证书里的签名S就是用根证书的私钥加密的。\n\n\n\n目前nRF Cloud有两种注册方式，一种是通过JITP的方式（Just-in-Time Provisioning）,另一种是[预连接（preconnect provisioning）](https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning)。\n\n### JITP方式注册\n\nJITP（Just-in-Time Provisioning）的方式利用开发板背面贴纸上的IMEI和PIN码，在云端控制台**手动**生成一个CA证书，然后下载到电脑，并通过LTE Link Monitor 工具生成**设备证书**，并把设备证书的私钥安装到9160中。这样设备就可以直接连接到云端并注册。这种方式便于快速开发、验证，但不适合量产，本文不详细介绍。若有兴趣可参考：[Updating The nRF Cloud Certificate](https://docs.nrfcloud.com/Devices/Associations/Provisioning/#just-in-time-provisioning)\n\n### 预连接方式注册\n\n[预连接（preconnect provisioning）](https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning)，是利用nRF Cloud提供的云端REST接口（接口文档见[Provision Devices](https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices)），进行批量的设备注册。具体步骤为：\n\n1. 首先需要一个CA证书（不一定要CA正规机构颁发，可以自己生成）；\n2. 电脑连接到nRF9160 AT串口，为设备分配UUID，并通过**CA证书**和**UUID**为每一个设备生成**设备证书**。通过串口安装这些证书，同时把这一批设备的UUID、公钥等信息记录到CSV表格中。\n3. 通过nRF Cloud的云端REST接口，把这一批设备一次性注册到云端，上传公钥。\n\nnRF Cloud提供了一套工具来帮助完成上述三项工作，可以用TypeScript脚本或Python脚本，官方的github的资料为 [utils/README.md at master · nRFCloud/utils (github.com)](https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#create-device-credentials)。\n\n下面通过Python脚本进行示例：\n\n### （1）前期准备\n\n- 确保9160SiP 为Revision 2或更高版本（查看SiP封装上的文字，有**B0**则为Rev1版本，有**B1**则为Rev2版本。可参考：[nRF9160 IC Revision Overview](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcomp_matrix_nrf9160%2FCOMP%2Fnrf9160%2Fnrf9160_ic_revision_overview.html)）\n  <img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124110504562.png\" alt=\"image-20221124110504562\" style=\"zoom: 25%;\" />\n\n- 确保已经按照[3.2](3.2. 烧录Modem固件)的步骤，烧录了1.3.0或更高版本的Modem固件（这些版本才支持新的安全AT指令，如`KEYGEN`）\n\n- 确保你已经按照[3.3](3.3. 配置、编译并烧录Application固件)的步骤，修改了Application固件的配置参数，启用了JWT和UUID；\n\n- 已经按照[3.4](3.4. 联网测试)的步骤，验证了设备已经成功联网；\n- 已经 [注册了nRF Cloud账号，并登录](https://nrfcloud.com/#/)。\n\n### （2）获取最新的nRF Cloud Utils工具，并安装好依赖\n\n在一个无中文、无空格、无特殊字符的路径下，从github拷贝仓库：\n\n```bash\n$ git clone https://github.com/nRFCloud/utils.git\n```\n\n进入modem firmware 1.3+ 子文件夹，然后安装其python依赖包\n\n```bash\n$ cd utils/python/modem-firmware-1.3+/\n$ pip3 install -r requirements.txt\n```\n\n### （3）生成你的自签CA证书\n\n复制下方的命令，并把对应参数改成你自己需要的信息。\n\n```bash\n$ python create_ca_cert.py \\\n-c CN \\\n-l Shanghai \\\n-o \"Nordic Semiconductor K.K.\" \\\n-ou \"Sales\" \\\n-cn nordic.cn \\\n-e jayant.tang@nordicsemi.no \\\n-p ./my_ca \\\n-f \"Jayant-\"\n```\n\n>参数释义（部分参数未使用）：\n>\n>- `-c` ：2字符的国家代码，`CN`为中国\n>- `-st`：州或省\n>- `-l`：地点\n>- `-o`：公司/组织\n>- `-ou`：组织部门\n>- `-cn`：Common Name\n>- `-dv`：有效天数\n>- `-e`：电子邮箱地址\n>- `-p`：CA证书生成后存储的位置\n>- `-f`：给生成的三个证书文件的文件名添加前缀（字符串）\n\n生成后，可以看到自己指定的目录下已经有了三个证书文件：\n\n![image-20221123223024181](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123223024181.png)\n\n其中，ca是证书，prv是私钥，pub是公钥。\n\n>本例程中，CA证书是我们自己签发的根证书，能让设备和云端的通信被加密即可。这个CA证书本身并不是CA机构签发的正规证书。\n>\n>若想查看CA证书的信息，可以随便找一个[在线CA查看器](https://myssl.com/cert_decode.html)，把xxx_ca.pem拖进去就可以看到信息了：\n>\n>![image-20221123224514523](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123224514523.png)\n>\n\n\n\n### （4）签发并安装设备证书\n\n需要使用`utils/python/modem-firmware-1.3+/`目录下的`device_credentials_installer.py`脚本。\n\n如果想查看最新的脚本使用方式：\n\n```bash\n$ python device_credentials_installer.py -h\n```\n\n\n\n此脚本的功能：\n\n1. 这个脚本会调用同一目录下的`create_device_credentials.py`，给每个设备单独生成设备证书；\n2. 通过电脑串口，给你的设备发送AT指令，生成一个UUID；\n3. 通过电脑串口，给你的设备发送AT指令，把**设备证书**及其**私钥**安装到你的设备中；\n4. 记录这个设备的信息，把UUID等信息存储到2个csv表格文件中。\n5. 量产时，这个脚本可以重复执行。只需要在每次串口上换一个设备时，就执行一次这个脚本。这个设备就会被安装证书，并且设备的信息会记录到2个表格文件中。**最多允许存1000台设备的信息。**\n6. 后续可以把这两个表格文件和证书上传到云端，便于批量注册设备。\n\n\n\n在执行这个脚本之前，确保第（2）步中的CA证书都生成好了。\n\n脚本使用示例如下（windows环境），你需要根据实际情况改变命令的参数配置。\n\n注意，示例执行脚本时，并未指定串口。因为脚本在windows下会自动检测哪个串口是AT指令串口。注意不要开着LTE Link Monitor等工具占用着串口导致安装失败。如果在linux下操作，请增加`--port /dev/ttyS??`来指定串口，详情可参考 [Device Credentials Installer](https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#device-credentials-installer)。\n\n```bash\n$ python device_credentials_installer.py -d -t \"jayant-DK\" --ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem --ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem -a --devinfo_append --csv ./jayant_provision.csv --devinfo ./jayant_devinfo.csv --term CRLF\n```\n\n>参数释义：\n>\n>- `-d`：安装前先从Modem中删除sectag\n>- `-t`：用于设备分组管理的标签，是一个字符串\n>- `-T`：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置\n>- `--ca`：CA证书文件的路径\n>- `--ca_key`：CA证书私钥的路径(prv)\n>- `-a`或`--append`：保存**设备注册信息**到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）\n>- `--devinfo_append `：保存**设备信息**到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）\n>- `--csv`：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据`-a`选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）\n>- `--devinfo`：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据`-a`选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）\n>- `--term`：AT指令的结束符（`NULL`,`CRLF`,` CR` 或`LF`）\n>- `--port`：指定AT指令串口\n\n我只有一块开发板，所以只执行一次。\n\n### （5）把设备信息批量注册到云端\n\n批量的在nRFCloud上进行设备注册（Cloud Provisioning）。\n\n首先，在[nRF Cloud Portal](https://nrfcloud.com/#/) 登录你的nRF Cloud账号（前面应该已经注册好了）。然后获取nRF Cloud REST API key。\n\n在右上角点击进入个人账户页面，然后在下面可以看到API key，复制出来即可。\n\n![image-20221123234437620](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123234437620.png)\n\n\n\n接下来继续执行python脚本，进行云端注册：\n\n```bash\n$ python ./nrf_cloud_provision.py --apikey 3c967ecbd9fxxxxxxxxxxxxxxxxa73cf37049983 --chk --csv ./jayant_provision.csv --devinfo jayant_devinfo.csv --set_mfwv --name_imei --name_pref \"my_dk_\" --res prov.log\n```\n\n>参数释义：\n>\n>- `--apikey`：刚刚复制的API key\n>- `--chk`：**单个设备的注册才使用**，注册前先检查设备是否存在\n>- `--csv` ：上一步生成的，存储着**设备注册信息**的csv表格文件，最多允许1000条数据\n>- `--devinfo ：上一步生成的，存储着**设备信息**的csv表格文件，最多允许1000条数据\n>- `--set_mfwv`：把`--devinfo`中记录的Modem固件版本存储到云端\n>- `--name_imei`：把`--devinfo`中记录的IMEI（芯片ID）作为friendly name\n>- `--name_pref`：给friendly name添加一个前缀字符串\n>- `--res`：存储注册结果的日志文件\n\n\n\n完成后，可以看到成功注册的结果：\n\n![image-20221123235635167](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123235635167.png)\n\n\n\n### （6）在云端查看刚刚注册的设备\n\n![image-20221123235940868](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221123235940868.png)\n\n可以在Device界面看到设备已经注册成功，设备的名称是“前缀字符串” + “IMEI”的形式。\n\n但设备还处于Disconnect的状态。这是因为刚才下载私钥时，把设备设为了离线状态，可以通过LTE Link Monitor输入以下AT指令，也可以简单reset一下设备，或者重新通过LTE Link Monitor查看设备的状态。这样设备应该就会变成已连接了:\n\n```AT\nAT%XSYSTEMMODE=0,1,0,0 // 选择NB网络\nAT+CEREG=5             // 打开调制解调器\nAT+CFUN=1              // 开始联网\n```\n\n![image-20221124000424393](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124000424393.png)\n\n点进设备的详情页面，已经可以看到大量的信息（部分资源在墙外，加载不出属于正常现象，需要代理上网）：\n\n![image-20221124000623033](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124000623033.png)\n\n可以通过terminal窗口，发送json消息，与设备进行交互。也可以进行OTA升级。\n\n在本例程中，板子上的LED指示灯也可以展示状态：详见[Led indication](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#led-indication)。这里只列出DK板的行为。\n\n| State                     | nRF9160 DK solid LEDs      |\n| ------------------------- | -------------------------- |\n| LTE connection search     | LED1 blinking              |\n| GNSS fix search           | LED2 blinking              |\n| Cloud association         | LED3 double pulse blinking |\n| Connecting to cloud       | LED3 triple pulse blinking |\n| Publishing data           | LED3 blinking              |\n| Active mode               | LED4 blinking              |\n| Passive mode              | LED3 and LED4 blinking     |\n| Error                     | All 4 LEDs blinking        |\n| FOTA update               | LED1 and LED2 blinking     |\n| Completion of FOTA update | LED1 and LED2 static       |\n\n\n\n### （7）从云端删除设备\n\n如果你想从云端删除设备，可以直接在网页端操作，从右上角齿轮除点击删除即可。\n\n也可以用云对云的REST API进行删除，后续章节讲解。\n\n<div style=”page-break-after: always;”></div>\n\n# 4. nRF Cloud 设备模型\n\n本节简单介绍nRF Cloud如何定义设备（Device）的，详细的内容请查看官网资料：[Device overview | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Overview/)\n\n## 4.1. 属性\n\n### 4.1.1. 设备类型\n\nnRF Cloud将设备分为三大类，**低功耗蓝牙设备（BLE）**、**网络设备（Internet Protocol）**、**用户自定义设备（Custom）**。\n\n其中，IP设备又有一些**子类型**设备：\n\n- 网关（Gateway）\n- 通常联网设备（Generic）\n- 软设备（Software）:用软件模拟的设备，可以连接MQTT\n\n除了IP设备自己的网关、通常设备等子类型以外，也可以（4）签发并安装设备证书。在[3.5-(4)](#（4）签发并安装设备证书)中可以看到，注册设备时，可以用`-T`参数设置SubType。\n\n### 4.1.2. 设备ID\n\n对于联网设备（IP devices），需要确保它**具有全球连接到nRF Cloud的设备之中唯一的ID**。如果使用MQTT，同时也需要把这个ID作为MQTT Client ID。\n\n推荐使用UUID作为设备ID。所有nRF9160都出厂设定了一个UUID。在[第3节](3. 示例: 使用nRF9160-DK连接到nRF Cloud)中已经介绍了使用方法。\n\n### 4.1.3. 数字孪生（Device Shadow）\n\nDevice Shadow或者说Digital Twin是一个包含了设备在云端存储的所有状态信息的Json。只有**IP设备**才拥有数字孪生。这个Json最大8 KB。\n\nnRF Cloud提供了默认的模板。也可以往Json里加自定义字段。\n\n**最好通过修改Device Shadow中属性值的方式来进行通信，而不是直接Send Message。**比如说，设备连接到MQTT broker，并且订阅`/shadow/delta/delta`主题之后，Shadow值的改变就会可以触发Action。设备也可以设置为重新上线后从shadow同步，这样就不用担心设备掉线重连后的数据初始化问题了。\n\nDevice Shadow来源于亚马逊的AWS，可参考[AWS IoT Device Shadow service - AWS IoT Core (amazon.com)](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)。\n\n## 4.2. 安全性\n\n安全性包含两个概念，身份验证（authentication）和授权（authorization）：\n\n- 身份验证：验证一个设备是否真实可信，不是仿冒的\n- 授权：给不同的人员、设备不同的访问权限\n\n### 4.2.1. 身份验证\n\n身份验证靠**凭证**实现，拥有凭证的个体是**持有者（bearer）**，可以是一个用户或者一台设备。凭证不能给其他人。例如，nRF Cloud登录时输入的密码是一种凭证，通过REST接口调用API时，输入的API key是一种凭证。\n\n不同的API使用不同的凭证：\n\n| API  |                         身份验证机制                         | 凭证                                                         |\n| ---- | :----------------------------------------------------------: | :----------------------------------------------------------- |\n| MQTT | [Mutual TLS](https://en.wikipedia.org/wiki/Mutual_authentication#mTLS) | 两个证书：AWS根证书 和 设备证书<br />前者让设备认证AWS的合法性，后者让AWS认证设备的合法性。<br />如果换用其他云，就需要其他云的证书。 |\n| REST | [JSON Web Token (JWT)](https://en.wikipedia.org/wiki/JSON_Web_Token) over [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) | 用户访问云时，使用API Key;<br />设备和第三方云使用JWT，这里的JWT是使用ES256进行签名的Token。云端使用公钥验证签名。 |\n\n生成证书和密钥对的方式：\n\n| 证书生成方式 | 证书注册方式                                                 | 安全等级           |\n| ------------ | ------------------------------------------------------------ | ------------------ |\n| 在设备上     | 通过[CMNG](https://infocenter.nordicsemi.com/index.jsp?topic=/ref_at_commands/REF/at_commands/security/keygen_set.html) AT 指令直接在设备上生成证书和密钥对 | 高，私钥绝不会泄露 |\n| 在电脑上     | 先生成证书和密钥对，然后通过[CMNG](https://infocenter.nordicsemi.com/index.jsp?topic=/ref_at_commands/REF/at_commands/security/keygen_set.html) AT 指令写入到设备中 | 较低               |\n| 在nRF Cloud  | 通过REST接口 [CreateDeviceCertificate](https://api.nrfcloud.com/v1/#operation/CreateDeviceCertificate)获得Nordic CA证书和设备证书以及密钥对，下载到电脑，然后通过AT指令安装到设备中 | 较低               |\n\n### 4.2.2. 授权\n\nMQTT授权由AWS IoT平台管理，根据设备被加入了哪个Thing Group来决定设备对资源的访问权限。\n\nREST授权跟API key有关，直接在管理员账户的team管理中，就可以管理其他团队成员的账户权限。\n\n### 4.2.3. 在9160上生成证书\n\n已在[3.5-(3)](#（3）生成你的自签CA证书)中演示在电脑上生成的方式。如要使用AT指令在设备上生成，可参考官方资料：[Securely generating credentials on the nRF9160 | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Security/Credentials/)\n\n### 4.2.4. JWT身份验证示例\n\n见后续章节\n\n\n\n## 4.3. 设备管理（Association）\n\n### 4.3.1. 设备注册方式\n\n在[3.5节](3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))中已经介绍\n\n### 4.3.2.  添加与删除设备\n\n通过REST接口即可操作，详见[Adding and removing devices | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Associations/AddingAndRemovingDevices/)\n\n### 4.3.3. 设备组\n\n可以把设备分成不同组，每个组可以自定义名称（不能带空格）。对每个组可以单独进行OTA升级等操作。详见[Device groups | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Associations/DeviceGroups/)\n\n## 4.4. 设备固件升级\n\nnRF Cloud有一套完整的固件升级服务，详见：[Firmware update over-the-air | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/FirmwareUpdate/FOTA/)\n\n## 4.5. 消息\n\n### 4.5.1. 设备消息\n\n设备通过[支持消息存储的MQTT topic](https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics)，或者REST API [SendDeviceMessage](https://api.nrfcloud.com/v1/#operation/SendDeviceMessage)，发送的消息可以存30天。\n\n### 4.5.2. 消息桥接\n\n消息可以通过建立桥接（bridge）的方式进行转发，详见[Setting up a message bridge | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Messages/SetupMessageBridge/)\n\n<div style=”page-break-after: always;”></div>\n\n# 5. Asset Tracker v2 例程分析\n\n本节参考：[Application description — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/asset_tracker_v2_description.html)\n\n## 5.1. 本例程设计原则\n\n- 超低功耗\n- 离线优先：本例程假设大多数情况下是离线的，连接是不可靠的。因此会有数据重发的机制。\n- 时间戳机制：多时间源的时间戳机制，离线情况也可以计时\n- 数据打包：多次数据打包，减少数据发送次数；离线时，数据会被存储，等到下次在线时一起发送\n- 运行时参数修改：支持在运行时修改部分配置参数（例如加速度计灵敏度，或GNSS超时时间）\n\n## 5.2. Zephyr构建系统简介\n\nZephyr Project是Linux基金会推出的一个Apache2.0开源项目，版权非常友好，适合用于商业项目开发。包含RTOS、编译系统、Zephyr组件。NCS中的例程基本都跑在[Zephyr RTOS]([Kernel — Zephyr Project Documentation](https://docs.zephyrproject.org/latest/kernel/index.html))上。\n\nZephyr的构建系统（Build System）分为两个阶段，**配置**和**编译**。\n\n本节介绍对初次接触的人比较费解的**配置**环节。\n\n### CMake\n\nZephyr构建系统使用CMake来进行**配置**。CMake首先根据配置自动生成`.ninja`配置文件，然后编译系统就可以用ninja来调用gcc进行编译和链接，最终生成可执行文件。\n\nZephyr沿用了CMake的目标文件（target）概念。target可以是一个库、hex或者可执行文件。Zephyr中几乎所有的组件都是被编译成一个库的，包括application程序的源码（如`src/main.c`）都会被编译并链接成一个`libapp.a`库文件。所有库文件最终会链接在一起成为MCU的可执行文件。\n\n在例程的`CMakeList.txt`中，可以看到：\n\n```cmake\ntarget_sources(app PRIVATE src/main.c) # 指定main.c为app这一target的源码\n```\n\n>- PRIVATE：源文件只被包含在这个app target中，修改源文件后，此target需要重新编译\n>- PUBLIC：源文件也会被包含进所有与此app链接的其他target中，修改源文件后，所有与app链接的target都要重新编译。一般PUBLIC只用于Include路径的设置。\n\n**配置**时，CMake首先处理当前项目文件夹下的`CMakeList.txt`，而这个`CMakeList.txt`又包含了NCS中`zephyr`目录下的`CMakeList.txt`，并依次包含所有的构建树中的`CMakeList.txt`。最终生成`Ninja`配置文件。\n\n除此之外CMake还会同时调用一些python脚本生成其他文件，用于后续的编译环节。如DeviceTree和Kconfig的处理都是在这一配置阶段进行的。\n\n### DeviceTree\n\nZephyr像Linux一样使用dts（设备树源码）来描述硬件，但Zephyr并不像Linux一样把dts编译成dtb，而是直接用python脚本把dts处理成头文件，直接编译进固件。\n\n> 硬件信息包括CPU数量和架构、内存基地址和大小、总线和桥、外设的连接、中断使用情况、GPIO使用情况、时钟使用情况等。最开始这些内容被hard code在Linux内核源码中，但是这让kernel源码非常庞大臃肿。后来就使用DTS来描述硬件，然后在编译时将其编译为DTB，并在运行时由bootloader传递给kernel。\n>\n> 但Zephyr在MCU上运行，资源受限。所以直接在编译前，构建系统使用python脚本将dts转换为`.h`头文件，并包含进项目代码。\n\n由于dts是描述硬件的，所以**每块板子**都可以用一个dts描述，如`nrf9160dk_nrf9160_ns.dts`。这个板子的配置文件是放在NCS目录下的`zephyr/boards`中的。\n\n**不同的板子可能有共同的部分**，比如使用相同的MCU。所以dts是可以包含其他dts的，通常描述**芯片**的文件为`.dtsi`，如`nrf9160_common.dtsi`。这个芯片的配置文件是放在NCS目录下的`zephyr/dts`中的。\n\n**同一块板子可能配置成不同的功能**，为了方便修改，可以在**当前工程文件夹**下，`boards`文件夹下的`<board>.overlay`来进行覆盖。overlay文件中只需要一小部分要修改的配置，在编译时，如果overlay和原板的dts配置了相同的项目，则优先采用overlay中的配置。\n\n最终的配置生成顺序如下：\n\n![img](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/1366713-20201222155014422-1085261766.png)\n\n通过板子本身标准的dts，以及覆盖的配置overlay，在`build/zephyr`路径下合并成完整的`zephyr.dts`。并最终转换成`build/zephyr/include/generated`目录下的`devicetree_unfixed.h`头文件。这就是最终源码中参考的头文件。\n\n通常我们只修改overlay，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。\n\nnRF Connect for VS Code插件提供了查看硬件配置的图形化界面。编译完毕后，就可以查看：\n\n![image-20221128153536593](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128153536593.png)\n\n如上图，先选择工作区中想要查看的项目，然后下方就会出现板卡的硬件描述。点进每一个描述，就可以跳转到对应层级的设备树文件中（`dtsi`,`dts`或`overlay`）。\n\n>安全特性：\n>\n>Nordic开发板的硬件描述（dts）有`xxxdk_xxx.dts`和`xxxdk_xxx_ns.dts`两种。对应安全（secure）和非安全（**n**on-**s**ecure）两种配置。安全配置用到了TF-M，可参考[Introduction — Trusted Firmware-M documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/tfm/introduction/index.html)。\n\n### Kconfig\n\nKconfig定义了配置项以及配置项之间的依赖关系。\n\n**项目文件夹中的`Kconfig`文件定义了本项目包含了哪些模块。**每个模块（如蓝牙controller、CAN总线controller等）都有自己的Kconfig选项配置。Kconfig之间也有包含关系。只要你的项目包含了这个模块，就要通过Kconfig的选项来配置这个模块。\n\n 模块的配置、编译器的编译、链接器的relocation等都可以通过Kconfig来进行。此外，application也可以定义自己的配置项。这样，最终本项目的Kconfig就会组合形成一个有几千个配置项的大菜单。当然大多数情况下，我们只使用默认配置。\n\n和device tree一样，Kconfig也是支持**覆盖**的。Kconfig中大多数都是模块自带的默认配置，要想覆盖其中的某些配置，只需修改项目文件夹下的`prj.conf`文件即可。\n\n![img](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/1366713-20201222154609536-1676614851.png)\n\n如上图，`.conf`是最终合并的Kconfig，位于build目录下。而`autoconf.h`位于`build/zephyr/include/generated`目录下。\n\n通常我们只修改`prj.conf`，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。\n\n若想图形化地修改Kconfig，可以在VS Code的NCS Action栏中找到：\n\n![image-20221128162406563](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128162406563.png)\n\n右侧三个点也支持使用`menuconfig`和`guiconfig`的方式进行查看。\n\n保存Kconfig时，有三个选择：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221128162604764.png\" alt=\"image-20221128162604764\" style=\"zoom: 80%;\" />\n\n- Save：临时保存到build目录下的`.config`中。如果下次修改了其他配置，重新编译，此配置就会失效。\n- Save to file：只保存修改的部分，可以选择保存到工程目录下的`prj.conf`或`boards/<board>.conf`中，后者的配置比前者优先生效。\n  这个修改是永久的，只对本项目有效，且不会影响到NCS中模块本身的默认Kconfig。\n- Save (minimal) to new file：只保存修改的部分到一个新文件中。\n\n\n\n## 5.3. 例程代码分析\n\n### 5.3.1. 工程结构分析\n\n首先看项目根目录下的`Kconfig`的包含关系：\n\n```\nKconfig\n|-- Asset Tracker v2  // 本应用的配置\n|   |-- src/modules/Kconfig.modules_common\n|   |-- src/modules/Kconfig.app_module\n|   |-- src/modules/Kconfig.cloud_module\n|   |-- src/cloud/Kconfig.lwm2m_integration\n|   |-- src/modules/Kconfig.data_module\n|   |-- src/modules/Kconfig.gnss_module\n|   |-- src/modules/Kconfig.modem_module\n|   |-- src/modules/Kconfig.sensor_module\n|   |-- src/modules/Kconfig.ui_module\n|   |-- src/modules/Kconfig.util_module\n|   |-- src/modules/Kconfig.led_module\n|   |-- src/modules/Kconfig.debug_module\n|   |\n|   |-- src/cloud/cloud_codec/Kconfig\n|   |-- src/watchdog/Kconfig\n|   |-- src/events/Kconfig\n|   \n|-- Zephyr Kernel  // 操作系统内核的配置\n|\t|-- Kconfig.zephyr\n|\n|-- 日志打印等级配置\n```\n\n可以看到，除了Zephyr操作系统内核外，还包含了src目录下许多的模组，这些模组不同于NCS中作为库的模组，而是Nordic官方为了Asset Tracker V2这个例程开发的应用模组。你也可以开发自己的模组。\n\n直接用图形化界面查看，就可以看到Kconfig中的选项了：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129154636314.png\" alt=\"image-20221129154636314\" style=\"zoom: 67%;\" />\n\n\n\n### 5.3.2. main.c文件分析\n\n我们进入到`src/main.c`中的`main()`函数，可以看到，首先是判断是否启用了`lwm2m`库：\n\n```c\nif (!IS_ENABLED(CONFIG_LWM2M_CARRIER)) {\n\t\thandle_nrf_modem_lib_init_ret();\n}\n```\n\n\n\n在[nRF Connect SDK]([Welcome to the nRF Connect SDK! — nRF Connect SDK 2.1.2 documentation](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/index.html))官方文档中有丰富的资料，所有不懂的东西都可以在里面搜索，我们搜索`lwm2m`：\n\n<img src=\"./../../../AppData/Roaming/Typora/typora-user-images/image-20221129132733110.png\" alt=\"image-20221129132733110\" style=\"zoom: 50%;\" />\n\n\n\n点进第一个搜索结果：\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129132903784.png\" alt=\"image-20221129132903784\" style=\"zoom: 50%;\" />\n\n根据这个页面的内容我们可以知道，Nordic提供一个叫做Cloud wrapper API的东西，它把各种IoT云的客户端库接口都给封装起来，只暴露出发送、连接、断开之类的常用功能，把每个云端特定的接口给隐藏了。\n\n那么Cloud wrapper API都封装了哪些云端提供的库呢？往下面翻可以看到，有亚马逊AWS IoT、微软Azure IoT Hub、nRF Cloud以及LwM2M。看到这里我们就知道LwM2M应该是某种云的客户端库。再往下就是介绍技术细节了。如果要详细了解LwM2M，就可以去其它搜索引擎继续搜索了。\n\n由于我们使用的是nRF Cloud，因此本文不再探究LwM2M的内容。\n\n>注意：\n>\n>我们查资料时一定要注意资料的适用范围：\n>\n>![image-20221129160526320](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129160526320.png)\n>\n>从这个资料的路径可以看出，Cloud wrapper API只是Nordic为了 Asset Tracker v2这个项目开发的一个API，是项目内部的一个实现，并非是NCS中通用的库。\n\n\n\n接着往下看可以看到，调用了一个App Event Manager的初始化函数。并且注释告诉我们这个App Event Manager必须初始化成功，否则就无法实现功能，需要重启。\n\n```c\nif (app_event_manager_init()) {\n\t\t/* Without the Application Event Manager, the application will not work\n\t\t * as intended. A reboot is required in an attempt to recover.\n\t\t */\n\t\tLOG_ERR(\"Application Event Manager could not be initialized, rebooting...\");\n\t\tk_sleep(K_SECONDS(5));\n\t\tsys_reboot(SYS_REBOOT_COLD);\n\t} else {\n\t\tmodule_set_state(MODULE_STATE_READY);\n\t\tSEND_EVENT(app, APP_EVT_START);\n\t}\n```\n\n\n\n我们可以右键跳转到对应的代码\n\n![image-20221129134046131](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134046131.png)\n\n在VS Code上方文件地址栏，就可以知道Application Event Manager是Nordic提供的`nrf`仓库下的一个subsystem。\n\n![image-20221129134230597](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134230597.png)\n\n\n\n既然Application Event Manager是一个模组，那么当然在Kconfig中也是可以搜到它的配置的。\n\n![image-20221129134432904](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134432904.png)\n\n由此我们可以体会到`Zephyr`这个配置系统的方便之处：只要是官方提供的模组，不论是nrf、zephyr还是第三方的模组，只要用Kconfig包含这个模组，就可以在本项目的Kconfig菜单中轻松的进行配置。\n\n\n\n当然，在NCS官方文档中进行搜索也是可以的，这里给出链接[Application Event Manager — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/app_event_manager.html#application-event-manager)\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129134707130.png\" alt=\"image-20221129134707130\" style=\"zoom:67%;\" />\n\n\n\n接下来，获取当前线程（main函数）的线程id，然后启动本模组：\n\n```c\n\tself.thread_id = k_current_get();\n\n\terr = module_start(&self);\n\tif (err) {\n\t\tLOG_ERR(\"Failed starting module, error: %d\", err);\n\t\tSEND_ERROR(app, APP_EVT_ERROR, err);\n\t}\n```\n\n\n\n这里，我们不知道`self`是什么意思，就查看前面的变量定义：\n\n```c\n/* 消息结构体定义（联合体）：\n * 来自其他模块的事件（Event），会被Application Event Manager包装成\n * 消息（Message）。然后放入消息队列，供主程序app处理。\n *\n * 这里可以看到消息的来源就有各种模组，包括云、Ui、sensor等\n */\nstruct app_msg_data {\n\tunion {\n\t\tstruct cloud_module_event cloud;\n\t\tstruct ui_module_event ui;\n\t\tstruct sensor_module_event sensor;\n\t\tstruct data_module_event data;\n\t\tstruct util_module_event util;\n\t\tstruct modem_module_event modem;\n\t\tstruct app_module_event app;\n\t} module;\n};\n\n/*\n * 消息队列的定义，这种用宏进行定义的方法是Zephyr提供的\n */\nK_MSGQ_DEFINE(msgq_app, sizeof(struct app_msg_data), APP_QUEUE_ENTRY_COUNT,\n\t      APP_QUEUE_BYTE_ALIGNMENT);\n\n/* \n * 用于保存app模组信息的数据结构。\n */\nstatic struct module_data self = {\n\t.name = \"app\",\n\t.msg_q = &msgq_app,\n\t.supports_shutdown = true,\n};\n```\n\n我们就可以知道，这个项目把application也当成是一个模组，和其他官方提供模组的地位是等价的。模组之间通过消息队列进行通信。\n\n\n\n接下来就可以看到，由于前面app模组获取的线程id正是main函数的id，所以app模组直接就在main函数中用while(1)循环来处理其他模组的消息了。\n\n```c\nwhile (true) {\n\t// 从队列中取出消息\t\n    module_get_next_msg(&self, &msg);\n\t\t\n    // 主状态机\n    switch (state) {\n        case STATE_INIT:\n            on_state_init(&msg);\n            break;\n        \n        case STATE_RUNNING:\n            switch (sub_state) {\n                case SUB_STATE_ACTIVE_MODE:\n                    on_sub_state_active(&msg);\n                    break;\n                case SUB_STATE_PASSIVE_MODE:\n                    on_sub_state_passive(&msg);\n                    break;\n                default:\n                    LOG_WRN(\"Unknown application sub state\");\n                    break;\n            }\n\n            on_state_running(&msg);\n            break;\n        case STATE_SHUTDOWN:\n            /* The shutdown state has no transition. */\n            break;\n        default:\n            LOG_WRN(\"Unknown application state\");\n            break;\n    }\n\n    on_all_events(&msg); \n}\n```\n\n\n\n接下来，看到在`main`文件末尾的定义：\n\n```c\n// 这里MODULE的值是main\nAPP_EVENT_LISTENER(MODULE, app_event_handler);\nAPP_EVENT_SUBSCRIBE_EARLY(MODULE, cloud_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, app_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, data_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, util_module_event);\nAPP_EVENT_SUBSCRIBE_FINAL(MODULE, ui_module_event);\nAPP_EVENT_SUBSCRIBE_FINAL(MODULE, sensor_module_event);\nAPP_EVENT_SUBSCRIBE_FINAL(MODULE, modem_module_event);\n```\n\n根据前面的学习方法（搜索代码、文档），可以知道这些宏就是Application Event Manager模组提供的，可以参考其文档。这些宏的大概作用就是：给一个名为“MODULE”的模组（实际宏定义是main），定义了一个事件接收器，然后订阅了剩下那些模组的事件消息。\n\n> Zephyr中有大量的在文件末尾通过宏定义进行配置的方法，它们往往都是描述一些**运行时**的配置。例如，把一个函数当作一个线程进行注册，或者把一个函数当成是初始化函数在开机初始化阶段运行。\n>\n> 例如`src/modules/ui_module.c`的最后一行：\n>\n> ```c\n> SYS_INIT(setup, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);\n> ```\n>\n> 就是让系统在初始化阶段自动调用`setup()`这个函数，不需要我们在main的开头显式地调用这个函数。假设我们有非常多模组，这样做就可以简化`main()`函数的代码，便于模块化的开发。\n>\n> 初始化等级是`APPLICATION`，这说明这个函数要在Zephyr操作系统的Kernel初始化完毕之后才运行。\n>\n> `CONFIG_APPLICATION_INIT_PRIORITY`是·`autoconf.h`中的，我们知道可以在Kconfig中配置它。在Kconfig菜单中搜索可以知道，这个配置是Zephyr Kernel的一个配置，是所有application级别的init函数的优先级。\n\n\n\n### 5.3.3. 云端连接相关模组的代码分析\n\n在`src/modules/cloud_module.c`中，文件的最下方，可以看到：\n\n```c\nK_THREAD_DEFINE(cloud_module_thread, CONFIG_CLOUD_THREAD_STACK_SIZE,\n\t\tmodule_thread_fn, NULL, NULL, NULL,\n\t\tK_LOWEST_APPLICATION_THREAD_PRIO, 0, 0);\n\n// 这里MODULE宏的值是cloud_module\nAPP_EVENT_LISTENER(MODULE, app_event_handler);\nAPP_EVENT_SUBSCRIBE(MODULE, data_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, app_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, modem_module_event);\nAPP_EVENT_SUBSCRIBE_FIRST(MODULE, cloud_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, gnss_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, debug_module_event);\nAPP_EVENT_SUBSCRIBE_EARLY(MODULE, util_module_event);\n```\n\n和`main.c`一样，这里也使用Application Event Manager模组的功能，创建了一个event lisener，并且订阅了其他模组的消息。\n\n并且这里定义了一个线程，`cloud_module_thread`，线程的函数是`module_thread_fn()`。\n\n线程函数内部也是一个状态机：\n\n```c\nstatic void module_thread_fn(void)\n{\n    ...\n\twhile (true) {\n\t\tmodule_get_next_msg(&self, &msg);\n\n\t\tswitch (state) {\n\t\tcase STATE_LTE_INIT:\n\t\t\ton_state_init(&msg);\n\t\t\tbreak;\n\t\tcase STATE_LTE_CONNECTED:\n\t\t\t...\n\t\t\tbreak;\n\t\tcase STATE_LTE_DISCONNECTED:\n\t\t\ton_state_lte_disconnected(&msg);\n\t\t\tbreak;\n\t\tcase STATE_SHUTDOWN:\n\t\t\t/* The shutdown state has no transition. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"Unknown Cloud module state.\");\n\t\t\tbreak;\n\t\t}\n\t\t...\n\t}\n}\n```\n\n经过代码的分析可知，状态开始时从`STATE_LTE_INIT`进入到`STATE_LTE_DISCONNECTED`。在断开状态下，如果收到`MODEM_EVT_LTE_CONNECTED`的消息，就会把状态变为`CONNECTED`。\n\n通过定义的跳转和搜索，可以知道`MODEM_EVT_LTE_CONNECTED`这条消息是从`src/modules/modem_module.c`中的模组发出的。\n\n```c\n// src/modules/modem_module.c 的末尾定义，也是定义了一个线程和1个lisener.\nK_THREAD_DEFINE(modem_module_thread, CONFIG_MODEM_THREAD_STACK_SIZE,\n\t\tmodule_thread_fn, NULL, NULL, NULL,\n\t\tK_LOWEST_APPLICATION_THREAD_PRIO, 0, 0);\n\nAPP_EVENT_LISTENER(MODULE, app_event_handler);\nAPP_EVENT_SUBSCRIBE_EARLY(MODULE, modem_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, app_module_event);\nAPP_EVENT_SUBSCRIBE(MODULE, cloud_module_event);\nAPP_EVENT_SUBSCRIBE_FINAL(MODULE, util_module_event);\n```\n\n\n\n层层搜索下去，可知`MODEM_EVT_LTE_CONNECTED`是PDN模组的消息，只要PDN模组收到了`PDN_EVENT_ACTIVATED`事件，就说明9160已经联网。PDN模组相关的文档，可参考：[PDN — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/modem/pdn.html#pdn)\n\n\n\n我们再回到`src/modules/cloud_module.c`中，进入线程的主状态机，可以看到在LTE已连接的状态下，还有两个子状态`SUB_STATE_CLOUD_CONNECTED`和`SUB_STATE_CLOUD_DISCONNECTED`。\n\n为了了解设备是如何从未连接到云变成已连接到云的，我们进入未连接状态的回调函数。可以看到，它调用了一个连接到云的函数：\n\n```c\nconnect_cloud()；\n```\n\n并且，在LTE未连接状态下的回调函数中，第一次成功连网时，也会调用此函数去连云。说明这正是我们要找的连接云的函数:\n\n```c\nstatic void connect_cloud(void)\n{\n\t...\n    ...\n        \n\terr = cloud_wrap_connect();\n\tif (err) {\n\t\tLOG_ERR(\"cloud_connect failed, error: %d\", err);\n\t}\n\n\t...\n    ...\n        \n\t/* Start timer to check connection status after backoff */\n\tk_work_reschedule(&connect_check_work, K_SECONDS(backoff_sec));\n}\n```\n\n其中的`cloud_wrap_connect()`正是前面搜索过的Cloud Wrapper API。\n\n此函数在`src/cloud/cloud_wrapper.h`中声明，但是在以下多个文件中都被定义：\n\n- 亚马逊 AWS：`src/cloud/aws_iot_integration.c`\n- 微软 Azure：`src/cloud/azure_iot_hub_integration.c`\n- Nordic nRF Cloud：`src/cloud/nrf_cloud_integration.c`\n- LwM2M：`lwm2m_integration.c`\n\n由于在`prj.conf`中，对Kconfig进行了覆盖：\n\n```bash\n# Default cloud transport service\nCONFIG_NRF_CLOUD_MQTT=y\n```\n\n默认选择了nRF Cloud的客户端库。\n\n\n\n而在`src/cloud/cloud_codec/Kconfig`中，有如下描述：\n\n```Kconfig\nchoice\n\tprompt \"Application cloud codec backend\"\n\tdefault CLOUD_CODEC_NRF_CLOUD if NRF_CLOUD_MQTT\n\tdefault CLOUD_CODEC_AWS_IOT if AWS_IOT\n\tdefault CLOUD_CODEC_AZURE_IOT_HUB if AZURE_IOT_HUB\n\tdefault CLOUD_CODEC_LWM2M if LWM2M_INTEGRATION\n```\n\n即，只要`NRF_CLOUD_MQTT`被配置为`y`，就会自动选择`CLOUD_CODEC_NRF_CLOUD`作为云端。\n\n我们从Kconfig的图形界面中也可以确认这点，打开Kconfig图形配置页面。在`Asset Tracker V2 -> Application cloud codec -> Application cloud codc backend`选项，可以看到默认选择了`nRF Cloud`作为我们的云端：\n\n![image-20221129155334071](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129155334071.png)\n\n而在`src\\cloud\\cloud_codec\\CMakeLists.txt`中，有如下描述:\n\n```cmake\ntarget_sources_ifdef(CONFIG_CLOUD_CODEC_AWS_IOT app\n                     PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/aws_iot/aws_iot_codec.c)\n\ntarget_sources_ifdef(CONFIG_CLOUD_CODEC_AZURE_IOT_HUB app\n                     PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/azure_iot_hub/azure_iot_hub_codec.c)\n\ntarget_sources_ifdef(CONFIG_CLOUD_CODEC_NRF_CLOUD app\n                     PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/nrf_cloud/nrf_cloud_codec.c)\n\ntarget_sources_ifdef(CONFIG_CLOUD_CODEC_LWM2M app\n                     PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/lwm2m/lwm2m_codec.c)\n\n```\n\n可以看出，由于我们只定义了`CLOUD_CODEC_NRF_CLOUD`，CMake在编译时就只会包含`nrf_cloud_codec.c`中的函数。也就是wrapper的具体实现，最终只会使用连接到nRF Cloud的函数。\n\n\n\n回到这个函数，在`src/cloud/nrf_cloud_integration.c`中，`cloud_wrap_connect()`调用了真正的连接函数，`nrf_cloud_connect()`。这是NCS库中的，nRF Cloud提供的客户端库提供的函数。关于这个库的介绍，可以参考：[nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html#nrf-cloud)。\n\n所有连接、与云端通信的内容都是通过这个库完成的，所有资料都可以在上面链接里找到。而这个库是经过wrapper封装的，app代码实际调用的是wrapper。\n\n### 5.3.4. 数据传输相关代码\n\n以Data模组为例，根据[Asset Tracker v2官方说明](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html)，本例程中的Data模组的作用是从其他模组中搜集数据，并上报给云端。而与云端交互的工作是Cloud模组实现的。\n\n先看Data模组，在`src/modules/data_module.c`的末尾，可以看到线程的定义。\n\n进入到线程函数`module_thread_fn()`中，也是有一个状态机：\n\n![image-20221129171438897](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129171438897.png)\n\n\n\n在已连接到云的状态下（`STATE_CLOUD_CONNECTED`），查看对应的状态处理函数。当收到`DATA_EVT_DATA_READY`消息时，就会准备向云端发送数据：\n\n![image-20221129171800871](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129171800871.png)\n\n\n\n我们分析这个`data_encode()`函数\n\n- 先使用`cloud_codec_encode_batch_data(...)`对所有数据进行json编码。由于不同的云端Json格式肯定不一样，所以这个函数也是Cloud API Wrapper提供的。\n- `data_send(DATA_EVT_DATA_SEND_BATCH, &codec)`发送这个json。**但这并不是发送到云端**，而是通过Application Event Manager发送到消息池中，事件类型是`DATA_EVT_DATA_SEND_BATCH`。\n\n\n\n接下来，通过VS Code左侧搜索`DATA_EVT_DATA_SEND_BATCH`，看这个消息被哪里接收了。可以知道此消息已经传输到Cloud模组，打开`src/modules/cloud_module.c`：\n\n![image-20221129172213052](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129172213052.png)\n\n这里并没有直接发送到云端，而是调用了一个QoS（Quality of Service）库的函数。我们继续去NCS官方文档搜索[Quality of Service](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/qos.html#quality-of-service)。\n\n根据文档内容，我们知道，NCS的QoS只提供两种服务质量：\n\n- `ACK_DISABLED`：只管发送，不管云端是否已收到\n- `ACK_REQUIRED`：需要确保云端收到并回复，若超时未回复，需要重发。\n\n> 还有一种服务质量是，需要确保对方收到，且仅收到一次。但嵌入式设备往往不能提供这样的QoS，而是要算力更强的云端去做消息去重。\n\n\n\n文档中的序列图给出了很详细的示例：\n\n![Sequence diagram general](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/qos_sequence.svg)\n\n1. 当发送一个数据包需要ACK时，Application调用QoS库的`qos_add_message()`，将消息记录在一个列表中。\n2. 然后QoS库把一个回调函数放入kernel提供的工作队列（[Workqueue](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/services/threads/workqueue.html#c.k_work_reschedule)）中，并且设定为一个延时的工作。\n3. 接下来，QoS库通知给Application，消息已经记录好了，可以发送了。\n4. Application接收到QoS库的消息`QOS_EVT_MESSAGE_NEW`，真正的发送数据。\n5. 根据数据的接收方是否按时回复ACK，有两种不同的行为：\n   - 若接收方按时回复，则 Application 需要调用`qos_message_remove`函数，从列表中移除这个消息。然后从工作队列中取消之前注册的函数。\n   - 若接收方超时未回复，则工作队列中的回调函数被调用，QoS库发送消息`QOS_EVT_MESSAGE_EXPIRED`。Application收到此消息后，执行一次重发。\n\n\n\n有了上面关于QoS的知识，我们就知道，只有收到QoS库的`QOS_EVT_MESSAGE_NEW`消息时，Application才会真正的把数据发送到云端：\n\n在`src/moudles/cloud_module.c`中，有一个`qos_event_handler()`函数：\n\n![image-20221130113448664](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130113448664.png)\n\n![image-20221130113827493](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130113827493.png)\n\n在初始化时，这个`qos_event_handler()`函数被注册到QoS库中，让Cloud模组能够处理来自QoS的消息。\n\n> 注意，QoS库与Cloud模组之间消息的传递，并不是通过Application Event Manager来进行的。而是通过回调函数的方式来进行的。\n\n\n\n这里又出现一个新的事件，`CLOUD_EVT_DATA_SEND_OQS`。搜索这个事件，可以发现这个事件是cloud模组接收的。在状态机中，`on_sub_state_cloud_connected()`和`on_sub_state_cloud_disconnected()`这两个函数中都有调用：\n\n![image-20221130114341395](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130114341395.png)\n\n\n\n在这里，可以看到最初的Batch数据最终是通过Cloud Wrapper API的`cloud_wrapper_batch_send()`发送到云端。\n\n\n\n### 5.3.5. 例程代码总结\n\n![Relationship between modules and the Application Event Manager](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/asset_tracker_v2_module_hierarchy.svg)\n\n- Zephyer风格的代码就是把一切都写成模组，每个模组可以有自己的线程、初始化代码。自己编写的模组之间通过Application Event Manager提供的消息机制进行通信。\n\n\n\n\n\n![Cloud module hierarchy](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/asset_tracker_v2_cloud_module_hierarchy.svg)\n\n- 设备和云端的连接是通过Cloud Wrapper API进行的，由于`prj.conf`中配置了`CONFIG_NRF_CLOUD_MQTT=y`，所以Kconfig就选择nRF Cloud Library作为客户端。CMake系统也只编译了与nRF Cloud有关的代码，并把其作为wrapper的内容。\n\n\n\n\n\n![image-20221130120212409](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130120212409.png)\n\n- 设备到云端的数据发送，经历了QoS库的处理，然后通过内部各种消息传输，最终通过Cloud Wrapper API发送到云端。上图仅展示数据是如何发送出去的，未展示QoS超时校验的部分。\n\n\n\n- 要了解更多关于此项目的实现内容，可以参考例程的官方说明，非常详细：[nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html)\n\n\n\n<div style=”page-break-after: always;”></div>\n\n# 6. nRF Cloud API介绍 \n\nnRF Cloud提供REST和MQTT两种API。\n\n- REST API 用于**用户到云**、**第三方云到云**的连接；其中少部分API也可被设备调用。\n- MQTT API用于**设备和云**的连接\n\n\n\n## 6.1. REST API\n\nnRF Cloud REST API文档，参考：[nRF Cloud REST API Documentation](https://api.nrfcloud.com/v1)\n\n###  REST API 认证方式\n\n在使用REST API时，用户、设备、nRF Cloud、第三方云端之间的通信都是需要认证的。在通讯的消息中需要一个key，来证明消息发出源是可信的。不同类型的对象之间访问，使用不同类型的key：\n\n- **用户到设备** 或者**用户到云**的认证：这种访问方式需要**API key**来认证，通常是用来做设备注册、获取设备数据、查看用户账户或使用信息的。在[3.5-(5)](#（5）把设备信息批量注册到云端)小节中已经介绍如何从网页端获取这个Key；\n\n- **设备到云**（D2C）的认证：使用[JSON Web Token](https://docs.nrfcloud.com/APIs/REST/RESTIntro/#authentication) (**JWT**)，确保安全性。\n- **云到云**（C2C）的认证：也使用**JWT**进行认证。用来做像是通过代理服务器进行位置服务的集成的功能。云到云的API调用需要购买专业版（Pro）或者企业版（Enterprise）服务。\n\n\n\n### REST API 调用示例\n\n本小节将使用电脑模拟一台**设备**，通过REST接口注册设备，并使用JWT的认证方式，调用一个REST API。官方文档可参考：[JWT authentication on nRF Cloud | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Security/JWT/)。\n\n整个注册过程和[3.5小节](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))的流程是一模一样的。但是本小节中展示的注册过程没有使用python脚本，而是使用最基本的HTTP请求来展示API调用的过程。\n\n在**开始之前**，找一个[在线UUID生成器](https://www.uuidgenerator.net/)，生成一个UUID。本例生成的是：`64520de4-e0a0-45cf-bf56-1f43f80a4f37`，这个UUID就代表一台设备，本例中代表的是这台电脑。\n\n\n\n**（1）生成CA证书和设备证书**\n\n在[3.5-(3)](#（3）生成你的自签CA证书)小节中，我们已经通过Nordic提供的python脚本生成了一套CA证书文件和私钥。这套utils工具中也包含一套TypeScript脚本。你也可以两种都不使用，而只使用OpenSSL进行生成，可参考[JWT authentication on nRF Cloud | nRF Cloud Docs](https://docs.nrfcloud.com/Devices/Security/JWT/)。\n\n后面在[3.5-(4)](#（4）签发并安装设备证书)中，我们通过这个CA证书给nRF9160签发了设备证书，给设备安装了设备独立的私钥。\n\n现在我们要用电脑模拟一台设备，就需要通过刚刚生成的UUID和**CA证书**，来生成一个新的**设备证书**。\n\n进入[3.5-(2)](#（2）获取最新的nRF Cloud Utils工具，并安装好依赖)中安装utils的文件夹：\n\n```bash\n# 在终端中进入utils文件夹后，再进行后续操作\n\n# 进入python工具文件夹\n$ cd python/modem-firmware-1.3+/\n\n# 生成设备证书\n$ python create_device_credentials.py \\\n-ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem \\\n-ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem \\\n-c CN \\\n-l Shanghai \\\n-o \"Nordic Semiconductor K.K.\" \\\n-ou \"Sales\" \\\n-cn 64520de4-e0a0-45cf-bf56-1f43f80a4f37 \\\n-e jayant.tang@nordicsemi.no \\\n-dv 2000 \\\n-p ./dev_credentials \\\n-f \"Jayant-Device-\"\n```\n\n> 参数释义：\n>\n> - `-ca`：CA证书文件\n> - `-ca_key`：CA证书密钥文件\n> - `-c`：2字符国家代码\n> - `-st`：美国、加拿大的州或省代码\n> - `-l`：地点\n> - `-o`：组织\n> - `-o`u：组织部门\n> - `-cn`：Common Name。使用nRF CLoud Device ID 或者 MQTT Client ID。这里使用UUID。\n> - `-e`：e-mail\n> - `-dv`：证书合法天数\n> - `-p`：用于生成设备证书的目录\n> - `-f`：生成的证书文件名前缀\n\n\n\n**（2）生成设备注册信息表格**\n\n本小节参考 [REST 设备注册API （ProvisionDevices）](https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices)。\n\n打开Excel，创建一个新的空表格，并另存为csv格式。\n\n<img src=\"https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124150045752.png\" alt=\"image-20221124150045752\" style=\"zoom: 80%;\" />\n\n在表格中从左往右填入以下内容：\n\n- 第一列：设备ID，这里是UUID\n\n- 第二列：设备子类型，可以写温湿度传感器之类的文字，可以留空；\n\n- 第三列：用于设备分类的标签，这里填[3.5-(4)](#（4）签发并安装设备证书)中nRF9160一样的tag名称就行，也可以留空\n\n- 第四列：固件类型，可以和9160例程填一样的，也可以留空\n\n- 第五列：设备证书。从上一小节的设备证书中，把`xxxx_crt.pem`中的内容拷贝进去即可\n\n  （注意，excel单元格类型要设置成“文本”，否则可能把等号、加号识别为公式）\n\n![image-20221124150540606](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124150540606.png)\n\n保存csv表格，此处给出我的csv文件内容，方便对比格式是否正确：\n\n`fake-device.csv`\n\n注意，逗号用于区分每一列，回车用于区分每一行，双引号中的内容为字符串（引号中的回车不算作换行）。\n\n```csv\n64520de4-e0a0-45cf-bf56-1f43f80a4f37,fake-device,jayant-DK,APP|MODEM,\"-----BEGIN CERTIFICATE-----\nMIICPTCCAeICFHx8JF+NRorZfBQF0sr+jzKSmg9gMAoGCCqGSM49BAMCMIGSMQsw\nCQYDVQQGEwJDTjERMA8GA1UEBwwIU2hhbmdoYWkxIjAgBgNVBAoMGU5vcmRpYyBT\nZW1pY29uZHVjdG9yIEsuSy4xDjAMBgNVBAsMBVNhbGVzMRIwEAYDVQQDDAlub3Jk\naWMuY24xKDAmBgkqhkiG9w0BCQEWGWpheWFudC50YW5nQG5vcmRpY3NlbWkubm8w\nHhcNMjIxMTI0MDY1MjEwWhcNMjgwNTE2MDY1MjEwWjCBrTELMAkGA1UEBhMCQ04x\nETAPBgNVBAcMCFNoYW5naGFpMSIwIAYDVQQKDBlOb3JkaWMgU2VtaWNvbmR1Y3Rv\nciBLLksuMQ4wDAYDVQQLDAVTYWxlczEtMCsGA1UEAwwkNjQ1MjBkZTQtZTBhMC00\nNWNmLWJmNTYtMWY0M2Y4MGE0ZjM3MSgwJgYJKoZIhvcNAQkBFhlqYXlhbnQudGFu\nZ0Bub3JkaWNzZW1pLm5vMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6OIeO6C0\n/kJzfaWUHt/Xg4J6bdAphzmX5sCLGV+oEeSi1sUQKpBLugda2OwG9FxOCikg8ih7\nCvMm7C98+fr+nTAKBggqhkjOPQQDAgNJADBGAiEAuCdq6D1K329hwU9e+4S5//2b\nupwtaqT+j6Mckpmj6XUCIQCaAqjWRMXMiOd/pXRkcf7SjKyZifBnxoepRqbNyKUG\nOA==\n-----END CERTIFICATE-----\n\"\n```\n\n\n\n**（3）利用REST接口注册设备**\n\n使用[ProvisionDevices](https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices)接口。\n\n这属于**用户到云**的接口调用，需要使用**API key**。\n\n```bash\n# 向nRF Cloud发送请求，注册设备。\n$  curl --request POST --url https://api.nrfcloud.com/v1/devices \\\n--header 'Authorization: Bearer 3c967ecbd9f3cxxxxxxxxxxfa73cf37049983' \\\n--header 'content-type: text/csv' \\\n--data-binary @./fake-device.csv\n```\n\n>注意：\n>\n>- 把API Key改成你自己的API Key\n>- 用curl发送csv文件时，必须使用二进制流。否则curl可能会丢掉文件末尾的换行符。也可以不用curl，而是通过Postman软件来进行API的调用测试。\n\n云端返回结果：\n\n```\n{\"bulkOpsRequestId\":\"01GK0NECJPXVNDNKVA4XE98HDE\"}\n```\n\n如果是一次真实的批量注册，这个bulkOpsRequestId需要记录下来，用于调用[FetchBulkOpsRequest](https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest) API。这个API的作用是用来检查自己批量注册的进度。但是本次是一次模拟，只注册了一个设备，所以不用关心。\n\n> FetchBulkOpsRequest使用方法：\n>\n> url的最后是上面获取的bulkOpsRequestId\n>\n> ```bash\n> curl --request GET \\\n> --url https://api.nrfcloud.com/v1/bulk-ops-requests/01GK0NECJPXVNDNKVA4XE98HDE \\\n> -H \"Authorization: Bearer 3c967ecbd9fxxxxxxxxxxxxxx3cf37049983\"\n> ```\n>\n> 返回结果：\n>\n> ```json\n> {\n> \t\"bulkOpsRequestId\":\"01GK0NECJPXVNDNKVA4XE98HDE\",\n>     \"status\":\"SUCCEEDED\",\n>     \"endpoint\":\"PROVISION_DEVICES\",\n>     \"requestedAt\":\"2022-11-29T03:03:48.054Z\",   // 这个时间应该是GMT+1的时间\n>     \"completedAt\":\"2022-11-29T03:03:51.365Z\",\n>     \"uploadedDataUrl\":\"https://bulk-ops-requests.nrfcloud.com/a9d25242-adad-479e-b526-xxxxxxxxxxxx/provision_devices/01GK0NECJPXVNDNKVA4XE98HDE.csv\"\n> }\n> ```\n\n\n\n利用[FetchDevice](https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice)接口来获取新注册的这个设备的信息：\n\n其中`{device-id}`要换成UUID\n\n```bash\n$ curl --request GET \\\n--url https://api.nrfcloud.com/v1/devices/{device-id} \\\n--header 'Authorization: Bearer 3c967ecbxxxxxxxxxxxxe81cfa73cf37049983'\n```\n\n返回结果：\n\n```json\n{\n    \"id\":\"64520de4-e0a0-45cf-bf56-1f43f80a4f37\",\n    \"tags\":[\n        \"jayant-DK\"\n    ],\n    \"tenantId\":\"a9d25242-adad-479e-b526-xxxxxxxxxxx\",\n    \"$meta\":{\n        \"createdAt\":\"2022-11-29T03:03:53.127Z\"\n    },\n    \"name\":\"64520de4-e0a0-45cf-bf56-1f43f80a4f37\",\n    \"type\":\"Generic\",\n    \"subType\":\"fake-device\",\n    \"firmware\":{\n        \"supports\":[\n            \"APP\",\n            \"MODEM\"\n        ]\n    },\n    \"state\":{\n        \"desired\":{\n            \"nrfcloud_mqtt_topic_prefix\":\"prod/a9d25242-adad-479e-b526-777082c5b7c5/\",\n            \"pairing\":{\n                \"state\":\"paired\",\n                \"topics\":{\n                    \"d2c\":\"prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/d2c\",\n                    \"c2d\":\"prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/+/r\"\n                }\n            }\n        },\n        \"version\":3,\n        \"metadata\":{\n            \"desired\":{\n                \"nrfcloud_mqtt_topic_prefix\":{\n                    \"timestamp\":1669691031\n                },\n                \"pairing\":{\n                    \"state\":{\n                        \"timestamp\":1669691031\n                    },\n                    \"topics\":{\n                        \"d2c\":{\n                            \"timestamp\":1669691031\n                        },\n                        \"c2d\":{\n                            \"timestamp\":1669691031\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n可以看到里面包含设备的信息，除了之前自己在CSV表格中填写的信息外，还包括MQTT的topic、时间戳等信息。\n\n设备注册成功后，在网页端也已经可以看到这个虚拟的设备：\n\n![image-20221124154802151](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221124154802151.png)\n\n\n\n**（4）生成JWT**\n\n**设备到云**（D2C）的API调用需要JWT认证，我们先生成一个JWT：\n\n打开[ jwt.io](https://jwt.io/)，上方选择ES256签名算法，然后PAYLOAD中填入：\n\n```json\n{\n    \"sub\": \"你的UUID\"\n}\n```\n\n下方公钥、私钥区域粘贴上一小节中生成的设备证书的公钥（pub.pem）和私钥（\\prv.pem）的内容。\n\n（注意，不是CA证书，而是设备证书）\n\n![image-20221129114051110](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114051110.png)\n\n左下角显示\"Signature Verified\"，则说明公钥与私钥是成对的。可以把左侧编码好的JWT复制出来，这就是设备与云端通信所需要的 Token：\n\n```\neyJhbGciOiJFUzI1Nixxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxx78F5NXw\n```\n\n\n\n**（5）测试一个设备API接口**\n\n我们利用[GetAssistanceData](https://api.nrfcloud.com/v1/#operation/GetAssistanceData)来测试接口，在官方API文档页面，我们可以看到：\n\n![image-20221130102929376](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130102929376.png)\n\n- 展示了URL、参数\n- 有两种请求方式，Basci Request和 Cuscom Request，后者需要携带更多参数\n- 提供了`curl`命令示例，如何携带参数\n- 展示了认证方式，有 API Key 和 JWT两种，展开有详细说明\n\n下方是一个Custom Request的调用示例，与API文档中的例子不同，没有使用`-d`选项，这里是直接把参数写在了URL中：\n\n```bash\n$ curl --request GET \\\n  --url 'https://api.nrfcloud.com/v1/location/agps?requestType=custom&customTypes=1%2C3%2C4%2C6%2C7%2C8%2C9&mcc=310&mnc=410&tac=36874&eci=84485647' \\\n  --header 'Accept: application/octet-stream' \\\n  --header 'Authorization: Bearer eyJhbGciOiJFUzI1Nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxm6Hx78F5NXw' \\\n  --header 'range: bytes=0-500'\n```\n\n请求已经成功返回，但是返回的数据是二进制内容，curl提示我们它不会展示二进制内容，以免打乱终端文字。\n\n![image-20221129114408304](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114408304.png)\n\n也可以用Postman软件进行测试，结果是一样的，返回206，说明数据请求成功：\n\n![image-20221129114544096](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221129114544096.png)\n\n\n\n**（6）总结：**\n\n本小节展示了[ProvisionDevices](https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices)，[FetchBulkOpsRequest](https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest)，[FetchDevice](https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice)，[GetAssistanceData](https://api.nrfcloud.com/v1/#operation/GetAssistanceData)这5个REST接口的调用。大多数接口都是云到云的，需要用户的APP key来进行认证。最后一个接口展示了设备到云的REST接口调用，需要使用JWT来进行认证。\n\n\n\n## 6.2. MQTT API\n\nnRF Cloud是部署在亚马逊AWS上的，并且使用[AWS IoT Core](https://docs.aws.amazon.com/iot/latest/developerguide/iot-gs.html)的MQTT broker。\n\nMQTT API的通信，只要订阅topic即可。这里需要有2个topic，`d2c`和`c2d`。\n\n- `d2c`：设备发布，云端订阅\n- `c2d`：云端发布，设备订阅\n\n只要每个设备能获得这两个topic，就能与云端进行通信。这个topic可以通过REST API获得，下一小节会介绍。但是实际开发应用的时候，并不需要关心，因为nRF Cloud Library已经帮我们封装好了，我们只需调用`connect()`，`send()`之类的就好了。\n\n### MQTT topic前缀的获取\n\n用户可以通过REST API获取topic前缀，接口是 [FetchAccountInfo](https://api.nrfcloud.com/v1/#operation/FetchAccountInfo)。需要使用用户的API Key进行认证。接口会返回很多数据，其中就包含：\n\n```json\n{\n\t\"mqttEndpoint\": \"mqtt.nrfcloud.com\",\n\t\"mqttTopicPrefix\": \"prod/a5592ec1-18ae-4d9d-bc44-xxxxxxxxx/\"\n}\n```\n\n不用REST API，也可以在网页端获取。点击右上角下拉菜单-Teams：\n\n![image-20221130132356346](https://raw.githubusercontent.com/Tang-JY/Imgs/main/img/image-20221130132356346.png)\n\n可以看到Team的信息，其中就有team id。`mqttTopicPrefix`就是`prod/<team_id>`。\n\n### 云端的认证\n\n所有到AWS IoT MQTT broker的连接都必须使用在8883端口上进行的Mutual TLS。所有用MQTT的设备都必须有一个[X.509 device certificate](https://docs.nrfcloud.com/Devices/Security/Security/#authentication)，并且已经**注册到云端（Provisioned）**。这正是我们在[3.5](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))和[6.1](#REST API 调用示例 )中已经介绍过的部分。\n\n### Topic\n\nnRF Cloud部署在AWS上，除了[AWS保留的topic](https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html)外，还有一些是nRF Cloud自定义的。官方文档请参考：\n\n[nRF Cloud MQTT topics | nRF Cloud Docs](https://docs.nrfcloud.com/APIs/MQTT/Topics/)\n\n### 代码分析\n\n有关nRF Cloud Library底层的细节，官方文档为 [nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)](https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html)。\n\n在[5.3.4](#5.3.4. 数据传输相关代码)中，我们知道9160是通过Cloud Wrapper API包装了nRF Cloud Library相关的接口进行的。其中发送到云端就是`cloud_wrap_batch_send()`：\n\n```c\nint cloud_wrap_batch_send(char *buf, size_t len, bool ack, uint32_t id)\n{\n\tint err;\n\tstruct nrf_cloud_tx_data msg = {\n\t\t.data.ptr = buf,\n\t\t.data.len = len,\n\t\t.id = id,\n\t\t.qos = ack ? MQTT_QOS_1_AT_LEAST_ONCE : MQTT_QOS_0_AT_MOST_ONCE,\n\t\t.topic_type = NRF_CLOUD_TOPIC_BULK,\n\t};\n\n\terr = nrf_cloud_send(&msg);\n\tif (err) {\n\t\tLOG_ERR(\"nrf_cloud_send, error: %d\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n```\n\n这里面，准备好要发送的数据`msg`即可，数据类型是`nrf_cloud_tx_data_msg`。Topic是`NRF_CLOUD_TOPIC_BULK`。\n\n这恰好就是[官方MQTT API手册](https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics)中的topic，作用是发送一组bulk数据。只要仿照wrapper中的格式，就可以写出自己的发送函数。\n","tags":["Nordic","nRF91","nRF_Cloud"],"categories":["Nordic","LTE"]}]