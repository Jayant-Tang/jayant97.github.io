[{"title":"NCS Matter例程详解","url":"/jayant97.github.io/2025/01/5645a5cab10c/","content":"<p>本文将会简单介绍Nordic Matter开发流程，然后详细分析一个Matter over Thread窗帘例程代码</p>\n<h1 id=\"1-Matter简介\"><a href=\"#1-Matter简介\" class=\"headerlink\" title=\"1. Matter简介\"></a>1. Matter简介</h1><h2 id=\"什么是Matter？\"><a href=\"#什么是Matter？\" class=\"headerlink\" title=\"什么是Matter？\"></a>什么是Matter？</h2><p>从产品角度：</p>\n<ul>\n<li>Matter是一个<strong>跨生态</strong>的智能家居标准，有众多大厂支持</li>\n<li>消费者购买Matter产品无需考虑品牌、部署。只要支持Matter，都是开箱即用的</li>\n</ul>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103161208933.webp\" alt=\"image-20250103161208933\"></p>\n<p>从技术角度：</p>\n<ul>\n<li>Matter是基于IPv6的<strong>应用层</strong>协议(CHIP, Connect Home over IP)</li>\n<li>建立在成熟的网络协议之上（Wi-Fi&#x2F;Thread&#x2F;Ethernet ）</li>\n<li>Matter有一套成熟的设备发现和入网机制（UDP-SD或Bluetooth LE）</li>\n<li>Matter协议是安全的。设备必须经过认证才能加入Matter网络；入网后，设备会获得一个证书用于加密通讯。</li>\n</ul>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103161824130.webp\" alt=\"image-20250103161824130\"></p>\n<h2 id=\"开发Matter其实是在开发数据模型\"><a href=\"#开发Matter其实是在开发数据模型\" class=\"headerlink\" title=\"开发Matter其实是在开发数据模型\"></a>开发Matter其实是在开发数据模型</h2><p>Matter规定了许多<a href=\"https://matter.cn/dev/device-type\">设备类型</a>，厂商只能开发Matter已经规定的设备类型。如下图为Matter1.0发布时规定的部分设备类型：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103163009545.webp\" alt=\"image-20250103163009545\"></p>\n<p>这些不同的设备类型，其实就是不同的数据模型。在Matter协议栈中，应用层之下就是Data Model层：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103163420400.webp\" alt=\"image-20250103163420400\"></p>\n<ul>\n<li>Node：一个具有完整Matter stack的实体，具有唯一的网络地址。大多数情况下，一个设备就是一个Node。</li>\n<li>Endpoint：功能交互端点。例如一个Node可以有“锁”和“温度传感器”两个Endpoint。</li>\n<li>Cluster：每个Endpoint可能有多个具体的功能集合，就是cluster。例如锁的控制、电池电量的上报</li>\n<li>Attribute&#x2F;Events&#x2F;Commands：也就是所谓的属性&#x2F;事件&#x2F;服务，是数据实体。</li>\n</ul>\n<blockquote>\n<p>Endpoint0比较特殊，是必须的，它负责Matter基本功能的Cluster。</p>\n<p>一个具体的示例：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103164446104.webp\" alt=\"image-20250103164446104\"></p>\n<p>一个门锁设备，Endpoint0 提供基本信息、访问控制、配网等Matter基本功能的Cluster。</p>\n<p>Endpoint1提供Identify和门锁基本功能的Cluster。</p>\n<p>每个Cluster由多个Attributes组成，Attributes就是实际存储器中的变量或常量</p>\n</blockquote>\n<h2 id=\"Matter的网络拓扑\"><a href=\"#Matter的网络拓扑\" class=\"headerlink\" title=\"Matter的网络拓扑\"></a>Matter的网络拓扑</h2><p>由于Matter只是应用层协议，所以Matter的网络拓扑就是它采用的底层通讯方式的网络拓扑：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103164904210.webp\" alt=\"image-20250103164904210\"></p>\n<p>Matter网络建立后，互相之间通过前述数据模型进行交互。手机、智能音箱等可以操控所有设备。</p>\n<ul>\n<li>Wi-Fi：只要AP覆盖到的地方，设备都可以入网。AP之间通过以太网互联，在家庭中很常见。</li>\n<li>Thread：功耗更低，且Thread设备之间可以构成Mesh，只要多级跳转最终能连接到Border Router即可。一些位于中转位置的节点最好是常供电的（如Light Switch）。</li>\n<li>其他本地网络：如Zigbee，BLE Mesh等未在Matter标准中使用的协议，需要一个<strong>Matter Bridge</strong>来做中转。Matter Bridge负责向Matter网络提供数据模型，处理Matter交互，然后将其转换为其他协议。Matter并不规定Matter之外的协议如何处理，因此开发者可以让Bridge自由适配任何其他协议。</li>\n<li>互联网：Matter协议是局域网的。Matter生态商（如苹果、谷歌、亚马逊、三星）负责让你的手机可以通过外网发送到家中的控制中枢，从而控制家中的Matter设备。</li>\n</ul>\n<blockquote>\n<p>Thread网络是支持IPv6 UDP的。但Thread网络要和其他网络连接，需要边界路由器（OTBR， OpenThread Border Router）。<br>Apple Home Pod已经内置Border Router。此外iPhone 15 Pro和Pro Max已经内置Thread网卡，可以直接控制Thread设备。</p>\n</blockquote>\n<h2 id=\"Matter设备发现与入网\"><a href=\"#Matter设备发现与入网\" class=\"headerlink\" title=\"Matter设备发现与入网\"></a>Matter设备发现与入网</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103165708864.webp\" alt=\"image-20250103165708864\"></p>\n<p>BLE是目前最常见的入网方式，流程为：</p>\n<ol>\n<li>设备发出BLE广播</li>\n<li>【设备发现】手机扫描二维码后，或者输入Manual Pairing Code后，根据Paring Code信息自动连接对应的BLE广播</li>\n<li>【PASE】二者通过Out-of-band信息（二维码中的passcode）建立加密通道。确认设备经过认证，安装后续加密通讯需要的证书（NOC, Node Operational Certificate）。然后设备入网（传输Wi-Fi密钥，Thread网络Key等等），这个过程无需人工输入密码。</li>\n<li>【CASE】设备入网后，每次通讯都要建立一个新的AES加密连接。</li>\n</ol>\n<p>以上过程在SDK中都已经提供，无需再开发。</p>\n<p>其他的设备发现方式还有DNS-SD或Wi-Fi Soft-AP。</p>\n<h2 id=\"Matter-Controller\"><a href=\"#Matter-Controller\" class=\"headerlink\" title=\"Matter Controller\"></a>Matter Controller</h2><p>Matter Controller是网络中非常重要的节点，在消费者家中负责设备的远程控制和入网。如Apple HomePod，Google Nest, Amazon Alexa。</p>\n<p>在Matter开发环境中，也需要Matter Controller来调试Matter设备。可以使用CHIP Tool作为Matter Controller。可以直接用命令行的方式直观地进行配网、数据模型交互。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103170010741.webp\" alt=\"image-20250103170010741\"></p>\n<p>CHIP Tool可以运行在Linux和mac OS环境中（Windows中需要Linux虚拟机）：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103171447107.webp\" alt=\"image-20250103171447107\"></p>\n<p>CHIP Tool是一个软件命令行工具，为了控制Matter设备，它所在的机器需要有BLE和IP网络。其中IP网络分为Thread, Wi-Fi和以太网。如果你是开发Matter Over Wi-Fi，则需要BLE和Wi-Fi&#x2F;以太网；如果你是开发Matter Over Thread，则需要BLE和Thread。</p>\n<ul>\n<li>Wi-Fi&#x2F;以太网：PC和树莓派自带Wi-Fi或以太网，无需额外准备。如果是Windows内的Linux虚拟机，则需要确保Linux虚拟机和宿主机在同一局域网下（Bridge模式）。</li>\n<li>Thread：PC和树莓派通常没有Thread网卡，因此需要一个Nordic开发板来充当网卡。比较推荐的是上图的nRF52840 Dongle，然后烧录Thread RCP例程(<code>nrf/samples/openthread/coprocessor</code>)</li>\n<li>BLE：PC和树莓派自带蓝牙网卡，无需额外准备。如果是Windows内的Linux虚拟机，则需要一个USB蓝牙网卡，通过USB透传进虚拟机。购买一个USB网卡也可以；使用Nordic nRF52840 Dongle也可以，烧录HCI_USB例程（<code>zephyr/samples/bluetooth/hci_usb</code>）；如果只有nRF52832（无USB），也可以烧录HCI_UART例程（<code>zephyr/samples/bluetooth/hci_uart</code>），按照例程文档说明通过命令行挂载一下蓝牙网卡即可。</li>\n</ul>\n<h1 id=\"2-Matter开发流程\"><a href=\"#2-Matter开发流程\" class=\"headerlink\" title=\"2. Matter开发流程\"></a>2. Matter开发流程</h1><p>Matter SDK是开源的，用Nordic SDK和硬件开发和评估Matter也不需要申请资质，软件全部是公开可下载的。开发前，先下载好<a href=\"https://csa-iot.org/developer-resource/specifications-download-request/\">技术文档</a>。</p>\n<p>下载对应Matter版本的3个文档：</p>\n<ul>\n<li>Matter Core Specification</li>\n<li>Matter Device Library Specification</li>\n<li>Matter Application Cluster Specification</li>\n</ul>\n<p>但最终要开发Matter产品并上市，还是要成为CSA会员并对设备进行认证。参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/end_product/certification.html#ug-matter-device-certification\">认证流程</a>。</p>\n<h2 id=\"芯片选型\"><a href=\"#芯片选型\" class=\"headerlink\" title=\"芯片选型\"></a>芯片选型</h2><p>主要是根据Flash RAM占用情况选用合适的芯片。Nordic有多个Matter例程，并且提供了它们在不同开发板上的<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/getting_started/hw_requirements.html#ram_and_flash_memory_requirements\">资源占用情况</a>。最好按照Nordic提供的芯片组合来开发自己的Matter产品，这样开发量最小：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103170553365.webp\" alt=\"image-20250103170553365\"></p>\n<blockquote>\n<p>注意：NCS中，通过无线进行OTA一定需要双分区。由于Matter应用比较大，因此需要一个外部flash作为，其大小不低于内部Flash（52840为1M Bytes, 5340为1.5M Bytes）。且最好使用QSPI，并且注意使用QSPI专用的高速引脚（参考Nordic官方开发板）。</p>\n</blockquote>\n<h2 id=\"申请或购买Nordic开发板，直接在开发板运行Matter例程\"><a href=\"#申请或购买Nordic开发板，直接在开发板运行Matter例程\" class=\"headerlink\" title=\"申请或购买Nordic开发板，直接在开发板运行Matter例程\"></a>申请或购买Nordic开发板，直接在开发板运行Matter例程</h2><p>按照NCS <a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/getting_started/adding_bt_services.html\">Matter例程文档</a>在开发板上编译和烧录，运行例程。</p>\n<h2 id=\"进行项目开发\"><a href=\"#进行项目开发\" class=\"headerlink\" title=\"进行项目开发\"></a>进行项目开发</h2><p>搭建Matter开发环境，<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/protocols/matter/getting_started/tools.html#chip_tool_for_linux_or_macos\">安装CHIP Tool</a>；进行软件与硬件开发；<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/getting_started/adding_clusters.html\">添加自己的endpoint, cluster</a>。</p>\n<p>如有必要，还可以<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/getting_started/adding_bt_services.html\">添加Matter之外的蓝牙广播和蓝牙服务</a>。</p>\n<h2 id=\"产品优化\"><a href=\"#产品优化\" class=\"headerlink\" title=\"产品优化\"></a>产品优化</h2><p><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/getting_started/low_power_configuration.html\">优化功耗</a>，主要是网络的功耗和一些外设的功耗。</p>\n<h2 id=\"生成Factory-Data\"><a href=\"#生成Factory-Data\" class=\"headerlink\" title=\"生成Factory Data\"></a>生成Factory Data</h2><p>认证通过后，进行产测工具的开发，通过证书为每台设备<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/end_product/factory_provisioning.html\">生成Factory Data</a></p>\n<h2 id=\"Matter文档与SDK\"><a href=\"#Matter文档与SDK\" class=\"headerlink\" title=\"Matter文档与SDK\"></a>Matter文档与SDK</h2><p>以上只是一个粗略的流程总结，具体开发步骤还是要参考Matter文档。</p>\n<p>Nordic官方文档：</p>\n<ul>\n<li><p><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/protocols/matter/index.html\">NCS - 协议简介 - Matter</a></p>\n</li>\n<li><p><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/samples/matter.html\">NCS - 例程文档 - Matter</a></p>\n</li>\n<li><p><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/matter/index.html\">Matter官方文档（Nordic相关）</a></p>\n<blockquote>\n<p>Matter官方文档可能出现一些NCS已经做好了，因此不必要再重复的内容（如编译Matter SDK）。为了避免混淆，最好主要参考前两个NCS中的文档。必要时，前两个文档会跳转到第三个文档中的内容。</p>\n</blockquote>\n</li>\n</ul>\n<p>NCS中已经包含了 Matter SDK （<a href=\"https://github.com/project-chip/connectedhomeip%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%AD%90%E4%BB%93%E5%BA%93%EF%BC%8C%E6%97%A0%E9%9C%80%E5%86%8D%E5%8D%95%E7%8B%AC%E4%B8%8B%E8%BD%BDMatter\">https://github.com/project-chip/connectedhomeip）作为子仓库，无需再单独下载Matter</a> SDK。（modules&#x2F;lib&#x2F;matter）</p>\n<p>NCS中Matter例程的路径为：<code>nrf/samples/matter/</code><br>此外还有两个成熟的商业级例程：<br>         <code>nrf/applications/matter_weather_station</code><br>        <code> nrf/applications/matter_bridge</code></p>\n<h1 id=\"3-运行Matter窗帘例程\"><a href=\"#3-运行Matter窗帘例程\" class=\"headerlink\" title=\"3. 运行Matter窗帘例程\"></a>3. 运行Matter窗帘例程</h1><p>本次演示首先通过nRF Connect for VS Code中的“Copy a sample”功能，拷贝了<code>nrf/samples/matter/window_covering</code>工程。工程放在SDK外部。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103173810111-1735897091967-1.webp\" alt=\"image-20250103173810111\"></p>\n<p>并且把SDK和这个工程放在同一个VS Code workspace中，这样做是为了方便后续代码跳转阅读。</p>\n<blockquote>\n<p>注意最新的nRF Connect for VS Code插件进行了更新：要在build界面选择SDK和toolchain的版本。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103173843411.webp\" alt=\"image-20250103173843411\"></p>\n</blockquote>\n<p>编译烧录流程参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.8.0/page/nrf/samples/matter/window_covering/README.html\">例程文档</a>。烧录之后就可以用CHIP Tool进行配网和控制。</p>\n<p>如果有iPhone手机和HomePod，则可以直接配置到Apple Home中。</p>\n<p>通过串口LOG的网址打开二维码，Home APP中扫描即可。由于例程用的证书都是一样的，用例程文档里的二维码也可：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103173947629.webp\" alt=\"image-20250103173947629\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103173951338.webp\" alt=\"image-20250103173951338\"></p>\n<p>窗帘开关反映为LED的亮度。可以用Button控制窗帘，也可以在手机APP中控制。</p>\n<p>更多按钮和LED的功能，参考例程文档。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103174025955.webp\" alt=\"image-20250103174025955\"></p>\n<h1 id=\"4-窗帘例程代码解析\"><a href=\"#4-窗帘例程代码解析\" class=\"headerlink\" title=\"4. 窗帘例程代码解析\"></a>4. 窗帘例程代码解析</h1><h2 id=\"工程文件分析\"><a href=\"#工程文件分析\" class=\"headerlink\" title=\"工程文件分析\"></a>工程文件分析</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103174121007.webp\" alt=\"image-20250103174121007\"></p>\n<p>以下文件和NCS 2.6.x之前版本的作用是一样的：</p>\n<ul>\n<li>工程通用的配置文件prj.conf&#x2F; prj_release.conf</li>\n<li>boards&#x2F;下的配置文件与设备树overlay</li>\n<li>用于Flash分区的Partition Manager文件（yml）</li>\n<li>工程配置菜单文件Kconfig </li>\n<li>工程源码管理文件CMakeLists.txt</li>\n</ul>\n<p>然后是新增的内容：</p>\n<p><strong>sysbuild</strong></p>\n<p>Sysbuild代替了原来的parent-child image配置. 是为了多镜像工程服务的。</p>\n<p>每个子镜像也可以单独添加配置，和原来的child_image&#x2F;文件夹差不多。</p>\n<p>但是Sysbuild也可以添加一个High-level的配置，这些High-level的配置将应用到所有子镜像（App, Bootloader, 以及可能存在的网络核固在的网络核固件）中：</p>\n<ul>\n<li>Kconfig.sysbuild 与 sysbuild.conf</li>\n<li>sysbuild.cmake (本例程中未使用)</li>\n</ul>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103174616698.webp\" alt=\"image-20250103174616698\"></p>\n<p>此外，有一部分应用层代码并不位于本工程中，而是位于<code>nrf/samples/matter/common</code><br>这是所有Matter例程共用的一部分代码。这部分代码是CMakeLists.txt中下面这一行引入的：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Include all source files that are located in the Matter common directory.</span></span><br><span class=\"line\"><span class=\"keyword\">include</span>(<span class=\"variable\">$&#123;ZEPHYR_NRF_MODULE_DIR&#125;</span>/samples/matter/common/cmake/source_common.cmake)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"main-cpp\"><a href=\"#main-cpp\" class=\"headerlink\" title=\"main.cpp\"></a>main.cpp</h3><p>首先看main.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CHIP_ERROR err = AppTask::<span class=\"built_in\">Instance</span>().<span class=\"built_in\">StartApp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">LOG_ERR</span>(<span class=\"string\">&quot;Exited with code %&quot;</span> CHIP_ERROR_FORMAT, err.<span class=\"built_in\">Format</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err == CHIP_NO_ERROR ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例程代码是C++写的，但是开发者后续也可添加C代码，和其他的NCS工程开发起来没有什么区别。C代码添加自己的线程即可，和C++互相不干扰。</p>\n<p>main函数中，只是调用了AppTask这个类的启动函数，便启动了Matter协议栈。</p>\n<p>并且，正常情况下这个函数应该永远不退出。</p>\n<h3 id=\"AppTask-h\"><a href=\"#AppTask-h\" class=\"headerlink\" title=\"AppTask.h\"></a>AppTask.h</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AppTask</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> AppTask &amp;<span class=\"title\">Instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> AppTask sAppTask;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sAppTask;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CHIP_ERROR <span class=\"title\">StartApp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">IdentifyStartHandler</span><span class=\"params\">(Identify *)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">IdentifyStopHandler</span><span class=\"params\">(Identify *)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">AppTask</span>() = <span class=\"keyword\">default</span>; <span class=\"comment\">// 这一行是我添加的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">CHIP_ERROR <span class=\"title\">Init</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ToggleMoveType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">OpenHandler</span><span class=\"params\">(<span class=\"type\">const</span> WindowButtonAction &amp;action)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">CloseHandler</span><span class=\"params\">(<span class=\"type\">const</span> WindowButtonAction &amp;action)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">ButtonEventHandler</span><span class=\"params\">(Nrf::ButtonState state, Nrf::ButtonMask hasChanged)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    OperationalState mMoveType&#123; OperationalState::MovingUpOrOpen &#125;;</span><br><span class=\"line\">    <span class=\"type\">bool</span> mMovementTimerActive&#123; <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"type\">bool</span> mOpenButtonIsPressed&#123; <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"type\">bool</span> mCloseButtonIsPressed&#123; <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    <span class=\"type\">bool</span> mMoveTypeRecentlyChanged&#123; <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>AppTask这个类，涵盖了应用层的所有任务。</p>\n<p>注意到，这个类采用了单例模式，其默认构造函数没有定义（为了安全，应该改为private，空的构造函数）。</p>\n<p>意思是，这个类只能有1个对象实例，代码的其他地方不能通过静态定义或者动态allocate这个对象。<br>要调用这个类的函数时，必须使用<code>AppTask::Instance()</code> 这个唯一的实例对象，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">CHIP_ERROR err = AppTask::<span class=\"built_in\">Instance</span>().<span class=\"built_in\">StartApp</span>();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这也是非常合理的，因为这个类管理的是当前设备的硬件行为。一块板子上的硬件外设本来就有唯一性，定义多个对象实例没有意义。</p>\n</blockquote>\n<h3 id=\"AppTask-cpp\"><a href=\"#AppTask-cpp\" class=\"headerlink\" title=\"AppTask.cpp\"></a>AppTask.cpp</h3><p>前面看到，在main.cpp中执行了AppTask::Instance().StartApp()这个函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">CHIP_ERROR <span class=\"title\">AppTask::StartApp</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">ReturnErrorOnFailure</span>(<span class=\"built_in\">Init</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        Nrf::<span class=\"built_in\">DispatchNextTask</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> CHIP_NO_ERROR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它首先初始化了Matter。然后处理事件循环。</p>\n<h4 id=\"Matter初始化\"><a href=\"#Matter初始化\" class=\"headerlink\" title=\"Matter初始化\"></a>Matter初始化</h4><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103175838230.webp\" alt=\"image-20250103175838230\"></p>\n<p><code>AppTask::Init()</code>中进行了Matter协议栈的初始化。</p>\n<p>所有<code>Nrf::</code>类中的函数，都是<code>nrf/samples/matter/common</code>提供的，不是Matter SDK原始的API。其目的是封装和简化Matter例程代码。</p>\n<p>第一部分是初始化Matter Stack</p>\n<p>第二部分是注册硬件按钮回调函数</p>\n<p>第三部分是注册Matter事件回调函数，这部分最重要。设备何时开启蓝牙广播、何时入网、断开连接，都在里面有回调.现在注册的是common里面提供的默认回调函数。你可以把这个函数拷贝出来到AppTask.cpp，并重写自己的功能，再注册回去。</p>\n<p>第四部分是开启Matter协议栈。</p>\n<h4 id=\"AppTask事件循环\"><a href=\"#AppTask事件循环\" class=\"headerlink\" title=\"AppTask事件循环\"></a>AppTask事件循环</h4><p>这个事件循环，其实和Zephyr Work Queue (k_work)的功能差不多。在各种Matter或者硬件中断的回调函数中，我们希望能够快速退出回调，防止卡中断或者协议栈，因此可以把一些耗时的任务提交到Workqueue中去运行（Workqueue有单独的线程）。</p>\n<p>使用Zephyr Work Queue 当然是可以的，但是比较麻烦的是每次都要自己定义一个k_work结构体，还要初始化这个work，注册k_work的回调，重复性的代码比较多。</p>\n<p>Matter例程是C++编写的，因此利用了C++的Lambda表达式可以作为匿名函数的功能：<br>简单理解，Lambda表达式就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[args...] &#123; </span><br><span class=\"line\">      ... <span class=\"comment\">// your code</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>这是个匿名函数。直接把它整体丢进队列，事件循环中就可以从队列中取出这个函数，然后执行了。省去了定义函数名和函数指针的麻烦，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Matter Identify事件回调，要求设备LED闪烁，以辨识设备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AppTask::IdentifyStartHandler</span><span class=\"params\">(Identify *)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此函数的参数，就是一个完整的lambda表达式，整体作为匿名函数传参</span></span><br><span class=\"line\">    Nrf::<span class=\"built_in\">PostTask</span>([] &#123;</span><br><span class=\"line\">        WindowCovering::<span class=\"built_in\">Instance</span>().<span class=\"built_in\">GetLiftIndicator</span>().<span class=\"built_in\">SuppressOutput</span>();</span><br><span class=\"line\">        Nrf::<span class=\"built_in\">GetBoard</span>().<span class=\"built_in\">GetLED</span>(Nrf::DeviceLeds::LED2).<span class=\"built_in\">Blink</span>(Nrf::LedConsts::kIdentifyBlinkRate_ms);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，[]中的内容叫作捕获组，可以把当前函数的局部变量捕获到lambada表达式中，当作参数传递使用，非常方便。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 硬件按钮事件回调，需要调用比较耗时的开启或关闭窗帘函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AppTask::ButtonEventHandler</span><span class=\"params\">(Nrf::ButtonState state, Nrf::ButtonMask hasChanged)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (OPEN_BUTTON_MASK &amp; hasChanged) &#123;</span><br><span class=\"line\">        WindowButtonAction action =</span><br><span class=\"line\">            (OPEN_BUTTON_MASK &amp; state) ? WindowButtonAction::Pressed : WindowButtonAction::Released;</span><br><span class=\"line\">        Nrf::<span class=\"built_in\">PostTask</span>([action] &#123; <span class=\"built_in\">OpenHandler</span>(action); &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CLOSE_BUTTON_MASK &amp; hasChanged) &#123;</span><br><span class=\"line\">        WindowButtonAction action =</span><br><span class=\"line\">            (CLOSE_BUTTON_MASK &amp; state) ? WindowButtonAction::Pressed : WindowButtonAction::Released;</span><br><span class=\"line\">        Nrf::<span class=\"built_in\">PostTask</span>([action] &#123; <span class=\"built_in\">CloseHandler</span>(action); &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"zcl-callbacks-cpp\"><a href=\"#zcl-callbacks-cpp\" class=\"headerlink\" title=\"zcl_callbacks.cpp\"></a>zcl_callbacks.cpp</h3><p>前面Matter协议栈初始化后，BLE和Thread就全部被Matter接管并初始化好了，无需开发者再关注。<br>包括配网的功能已经全部被SDK实现。</p>\n<p>Matter要开发的，其实就是如何处理数据交互（Endpoint, Cluster, Attributes）。</p>\n<p>Matter的数据模型都是通过ZAP Tool进行图形化编辑的，编辑后自动生成代码。<br>但是自动生成的代码是空的，应用层需要实现这个代码。</p>\n<p>例如，zcl_callbacks.cpp中，就实现了当自己Attributes被网络中的其他设备修改时，要执行的回调函数。<br>每个Attribute都有自己的ID，通过ID来判断是哪个Attribute被修改了。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103180220665.webp\" alt=\"image-20250103180220665\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103180230824.webp\" alt=\"image-20250103180230824\"></p>\n<h3 id=\"WindowCovering-cpp\"><a href=\"#WindowCovering-cpp\" class=\"headerlink\" title=\"WindowCovering.cpp\"></a>WindowCovering.cpp</h3><p>WindowCovering类，提供的就是“真正”的窗帘控制代码了。前面ZCL的回调之中调用的就是WindowCovering类的代码。</p>\n<p>但是实际上这里是用LED的亮度变化来模拟窗帘的打开程度。这个class的代码不重要，开发者完全可以把它删了改成自己的。只需要能够完美处理zcl_callback.cpp中的回调事件即可。</p>\n<p>而且由于同时支持竖向窗帘和横向窗帘，这个类的代码写的比较复杂。</p>\n<p>这里简单分为两类：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103180439164.webp\" alt=\"image-20250103180439164\"></p>\n<ul>\n<li>窗帘目标位置发生改变：执行StartMove函数。注意这里并没有传递参数，告知具体的目标位置是什么。因为Attribute是随时可读的，可以在后续具体执行运动时，再去Get这个Attribute值。</li>\n<li>窗帘实际位置发生改变：更新LED状态。同理，也不需要传参。</li>\n</ul>\n<p>这里直接跳到以下函数：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103180531498.webp\" alt=\"image-20250103180531498\"></p>\n<p>从前面的<code>StartMove(….LIFT)</code>，调用到上面展示的<code>DriveCurrentLiftPosition()</code>函数，中间跳转了很多层。本质上就是为了模拟窗帘的运动。</p>\n<p><code>DriveCurrentLiftPosition()</code>是一个软定时器的回调函数。每200ms把当前位置向目标位置挪动一步，一步是初始差值的5%，用来模拟窗帘慢慢移动到窗帘的实际位置。这里细节我们不必过于深究，只需要知道Matter API如何调用：</p>\n<ul>\n<li>要Get Attribute值，需要调用<code>Attributes::属性名::Get(Endpoint(), xxx)</code></li>\n<li>要Set Attribute值，需要调用<code>Attributes::属性名::Set(Endpoint(), xxx)</code></li>\n</ul>\n<p>这里的参数Endpoint()其实就是个整数。因为WindowCovering这个类，也是一个单例模式的类。它对应的就是Endpoint1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WindowCovering.h中class的定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> chip::EndpointId <span class=\"title\">Endpoint</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>此外，注意上述Attribute操作的API是在窗帘Cluster的name space调用的，如果开发其他产品，要换成其他的namespace：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chip::app::Clusters::WindowCovering;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AppTask这个类负责应用层的杂项业务代码，有自己的事件循环（占用main线程）。也负责Matter协议栈的初始化。</p>\n<p>default_zap&#x2F;zap_generated下的代码是zap tool根据Matter数据模型自动生成的。用户可以用zap tool来修改当前工程的Matter数据模型。自动生成的代码只有定义，没有实现。开发者需要实现这些应用层代码。</p>\n<p>WindowCovering这个类，是Nordic提供的应用层示例代码，用LED的灯光亮度来模拟窗帘的运动。开发者完全可以实现自己的类，而不必继续使用这个类。只需学习它的Attribute的操作方法，以及各种Matter API的使用即可。</p>\n<h1 id=\"5-实战-增加电量显示\"><a href=\"#5-实战-增加电量显示\" class=\"headerlink\" title=\"5. 实战-增加电量显示\"></a>5. 实战-增加电量显示</h1><h2 id=\"参考Matter标准文档\"><a href=\"#参考Matter标准文档\" class=\"headerlink\" title=\"参考Matter标准文档\"></a>参考Matter标准文档</h2><p>在添加新的Cluster前，首先要参考Matter的标准文档。</p>\n<p>电池电量不属于application cluster，而是在核心规范中定义。我们直接参考matter-1-3-core-specification.pdf</p>\n<p>电源相关的cluster定义在11.7 Power Source Cluster。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181214254.webp\" alt=\"image-20250103181214254\"></p>\n<h2 id=\"使用ZAP-Tool修改数据模型\"><a href=\"#使用ZAP-Tool修改数据模型\" class=\"headerlink\" title=\"使用ZAP Tool修改数据模型\"></a>使用ZAP Tool修改数据模型</h2><p>为自己的当前build打开一个nRF Connect命令行：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181417476.webp\" alt=\"image-20250103181417476\"></p>\n<blockquote>\n<p>现在也可以从这里打开：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181337558.webp\" alt=\"image-20250103181337558\"></p>\n</blockquote>\n<p>输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west zap-gui</span><br><span class=\"line\"><span class=\"comment\">## </span></span><br><span class=\"line\"><span class=\"comment\"># 可添加参数：</span></span><br><span class=\"line\"><span class=\"comment\"># -z zap配置文件位置. 也就是$(pwd)/src/default_zap/window-app.zap</span></span><br><span class=\"line\"><span class=\"comment\"># -j zcl.json模板位置</span></span><br><span class=\"line\"><span class=\"comment\"># -m Matter SDK安装位置</span></span><br><span class=\"line\"><span class=\"comment\">##</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在直接执行上述命令，会自动连网安装zap tool，不需要自己手动下载。也不需要添加参数设置位置。会按照SDK的zap tool的相对路径来查找。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181539141.webp\" alt=\"image-20250103181539141\"></p>\n<p>在Endpoint 1中，因为PowerSource不属于application cluster，而是Matter的Cluster，所以在CHIP（Connect Home over IP）分类下寻找。</p>\n<p>选中Power Source Cluster，并开启Server。Server的含义是存储Attribute的地方，可以被Client读取或修改。</p>\n<p>再点击右侧齿轮进行进一步修改。</p>\n<blockquote>\n<p>可以先什么都不改，直接用<code>west zap-generate</code>生成代码，相当于进行了一次代码格式化。代码格式化后commit一次。后续改了zap，再生成代码，就方便通过git看自动生成了哪些callback。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181648145.webp\" alt=\"image-20250103181648145\"></p>\n<p>每个Cluster会有很多Feature。例如核心规范中规定，有4个Feature。电源线供电，电池供电，可充电电池，可更换电池。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181736638.webp\" alt=\"image-20250103181736638\"></p>\n<p>其中，Conformance字段表示某种依赖性。方括号[]的意思是依赖，如果想要使能RECHG或者REPLC，就必须要使能BAT。</p>\n<p>由于我们要显示电池电量，电池电量这个Attribute肯定是属于BAT这个Feature的，因此Feature Map的Bit 1就要置1。也就是把FeatureMap置为0x02：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181807061.webp\" alt=\"image-20250103181807061\"></p>\n<p>(这里显示out of range是ZAP Tool的显示bug，实际是正确的)</p>\n<p>继续阅读文档，发现BatPercentRemaining这个Attribute就是我们需要的电池电量。取值范围是0-200。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181844938.webp\" alt=\"image-20250103181844938\"></p>\n<p>并且其依赖[BAT]这个Feature，这个我们前面已经设置好了。</p>\n<p>但是，后面还有三个Attribute，他们的Conformance是不带方括号的BAT。</p>\n<p>不带方括号的意思是，当使能了BAT，就必须要开启这三项attribute:</p>\n<ul>\n<li>BatChargeLevel：枚举（正常、电量低、状态危险）</li>\n<li>BatReplacementNeeded：bool，电池是否需要更换</li>\n<li>BatReplaceability：枚举（未定义、不可更换、用户可更换、返厂可更换）</li>\n</ul>\n<p>总共要开启4项：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103181925963.webp\" alt=\"image-20250103181925963\"></p>\n<p>点击File-&gt;Save保存。保存后，通过git会发现window-app.zap数据模型文件已经新增了Power Source cluster。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103182137910.webp\" alt=\"image-20250103182137910\"></p>\n<h2 id=\"自动生成数据模型对应的代码\"><a href=\"#自动生成数据模型对应的代码\" class=\"headerlink\" title=\"自动生成数据模型对应的代码\"></a>自动生成数据模型对应的代码</h2><p>使用<code>west zap-generate</code>自动按照默认路径生成代码.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west zap-generate </span><br><span class=\"line\"><span class=\"comment\">## </span></span><br><span class=\"line\"><span class=\"comment\"># 可添加参数：</span></span><br><span class=\"line\"><span class=\"comment\"># -z zap配置文件位置. 也就是$(pwd)/src/default_zap/window-app.zap</span></span><br><span class=\"line\"><span class=\"comment\"># -o 自动生成代码的位置。不能用相对路径。</span></span><br><span class=\"line\"><span class=\"comment\"># -m Matter SDK安装位置</span></span><br><span class=\"line\"><span class=\"comment\">##</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在不需要添加参数设置位置。会按照SDK的zap tool的相对路径来查找。</p>\n</blockquote>\n<p>通过git查看新增的代码：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103182244065.webp\" alt=\"image-20250103182244065\"></p>\n<p>自动生成代码后，会发现只增加了一个InitCallback.</p>\n<p>因为电池电量不可能被其他设备写，只能被读，所以不会新增一个像窗帘那样的AttributeChangedCallback.</p>\n<h2 id=\"添加回调\"><a href=\"#添加回调\" class=\"headerlink\" title=\"添加回调\"></a>添加回调</h2><p>在zcl_callbacks.cpp中实现上述新增的callback</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">emberAfPowerSourceClusterInitCallback</span><span class=\"params\">(EndpointId endpoint)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Protocols::InteractionModel::Status status;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> featureMap;</span><br><span class=\"line\">    ::chip::app::Clusters::PowerSource::Attributes::FeatureMap::<span class=\"built_in\">Get</span>(endpoint, &amp;featureMap);</span><br><span class=\"line\">    <span class=\"built_in\">ChipLogProgress</span>(Zcl, <span class=\"string\">&quot;PowerSource::Attributes::FeatureMap = 0x%x&quot;</span>, featureMap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 要确保在zap-gui中已经配置feature支持电池电量</span></span><br><span class=\"line\">    __ASSERT((featureMap &amp; <span class=\"number\">0x02</span>) != <span class=\"number\">0</span>, <span class=\"string\">&quot;PowerSource::Attributes::FeatureMap does not support battery!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    app::DataModel::Nullable&lt;<span class=\"type\">uint8_t</span>&gt; BatPercentRemaing;</span><br><span class=\"line\">    status = ::chip::app::Clusters::PowerSource::Attributes::BatPercentRemaining::<span class=\"built_in\">Get</span>(endpoint, BatPercentRemaing);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BatPercentRemaing.<span class=\"built_in\">IsNull</span>()) &#123;</span><br><span class=\"line\">        BatPercentRemaing.<span class=\"built_in\">SetNonNull</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">        status = ::chip::app::Clusters::PowerSource::Attributes::BatPercentRemaining::<span class=\"built_in\">Set</span>(endpoint, <span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (status != Protocols::InteractionModel::Status::Success) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">ChipLogError</span>(Zcl, <span class=\"string\">&quot;Failed to set PowerSource %s: %x&quot;</span>, <span class=\"string\">&quot;BatPercentRemaining&quot;</span>, <span class=\"built_in\">to_underlying</span>(status));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个多出来的回调并没有那么严格，上面是一个示例，只是打印一些log而已。</p>\n<p>只需要学会电池电量的attribute如何设置即可。后续在业务代码中直接调用相关函数，进行设置。注意把代码放到事件循环中执行。</p>\n<h2 id=\"验证效果\"><a href=\"#验证效果\" class=\"headerlink\" title=\"验证效果\"></a>验证效果</h2><p>在设备详情页面多了电量显示。但是一直是0，因为只在InitCallback中设置电量是不够的，要在程序运行起来后去设置。</p>\n<p>注意电量范围是0-200，因此要设置200才是100%电量</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250103182535706.webp\" alt=\"image-20250103182535706\"></p>\n","categories":["Matter"],"tags":["Nordic","Matter"]},{"title":"NCS 低功耗日志打印","url":"/jayant97.github.io/2025/01/aeb1d94c5ebc/","content":"<p>本文第一节直接给出配置，第二节介绍原理，第三节介绍踩的一个坑</p>\n<h1 id=\"低功耗日志打印配置\"><a href=\"#低功耗日志打印配置\" class=\"headerlink\" title=\"低功耗日志打印配置\"></a>低功耗日志打印配置</h1><blockquote>\n<p>【注意】本文介绍的方法，仅支持NCS<code>v2.8.0</code>之后的版本。</p>\n</blockquote>\n<h2 id=\"软件配置\"><a href=\"#软件配置\" class=\"headerlink\" title=\"软件配置\"></a>软件配置</h2><p>以下代码与config直接在<code>zephyr/samples/hello_world</code>中进行配置即可。</p>\n<p>配置文件：<code>prj.conf</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启LOG功能，并选择后端为串口</span></span><br><span class=\"line\">CONFIG_LOG=y</span><br><span class=\"line\">CONFIG_LOG_MODE_DEFERRED=y</span><br><span class=\"line\">CONFIG_LOG_BACKEND_UART=y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志对应串口开启异步输出（DMA）功能</span></span><br><span class=\"line\">CONFIG_LOG_BACKEND_UART_ASYNC=y</span><br><span class=\"line\">CONFIG_UART_ASYNC_API=y</span><br><span class=\"line\">CONFIG_UART_0_INTERRUPT_DRIVEN=n</span><br><span class=\"line\">CONFIG_UART_0_ASYNC=y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下为异步串口硬件计数功能</span></span><br><span class=\"line\"><span class=\"comment\"># 只影响RX，不影响TX，因此日志串口无需打开</span></span><br><span class=\"line\"><span class=\"comment\"># CONFIG_UART_0_NRF_HW_ASYNC=y</span></span><br><span class=\"line\"><span class=\"comment\"># CONFIG_UART_0_NRF_HW_ASYNC_TIMER=1</span></span><br><span class=\"line\"><span class=\"comment\"># CONFIG_NRFX_TIMER1=y</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启Console功能，并选择后端为串口</span></span><br><span class=\"line\">CONFIG_PRINTK=y</span><br><span class=\"line\">CONFIG_UART_CONSOLE=y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭一切与输入有关的feature</span></span><br><span class=\"line\">CONFIG_SHELL=n</span><br><span class=\"line\">CONFIG_CONSOLE_HANDLER=n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># printk不重定向到LOG buffer</span></span><br><span class=\"line\">CONFIG_LOG_PRINTK=n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下两个选项需要同时打开或同时关闭</span></span><br><span class=\"line\"><span class=\"comment\"># 不要只打开CONFIG_PM_DEVICE=y</span></span><br><span class=\"line\">CONFIG_PM_DEVICE_RUNTIME=y</span><br><span class=\"line\">CONFIG_PM_DEVICE=y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭RTT通道</span></span><br><span class=\"line\">CONFIG_USE_SEGGER_RTT=n</span><br><span class=\"line\">CONFIG_RTT_CONSOLE=n</span><br></pre></td></tr></table></figure>\n\n<p>设备树overlay文件（没有可自己新建<code>app.overlay</code>）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uart0 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    zephyr,pm-device-runtime-auto; // 如果前面开了CONFIG_PM_DEVICE_RUNTIME=y，这里一定要使能</span><br><span class=\"line\">    /delete-property/ hw-flow-control;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 原本uart0的Pinctrl是有流控CTS和RTS引脚的，</span><br><span class=\"line\">// 这里直接覆盖去掉那两个引脚</span><br><span class=\"line\">&amp;uart0_default &#123;</span><br><span class=\"line\">    group1 &#123;</span><br><span class=\"line\">        psels = &lt;NRF_PSEL(UART_TX, 0, 6)&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    group2 &#123;</span><br><span class=\"line\">        psels = &lt;NRF_PSEL(UART_RX, 0, 8)&gt;;</span><br><span class=\"line\">        bias-pull-up;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;uart0_sleep &#123;</span><br><span class=\"line\">    group1 &#123;</span><br><span class=\"line\">        psels = &lt;NRF_PSEL(UART_TX, 0, 6)&gt;,</span><br><span class=\"line\">            &lt;NRF_PSEL(UART_RX, 0, 8)&gt;;</span><br><span class=\"line\">        low-power-enable;</span><br><span class=\"line\">        bias-pull-up; // 这里控制休眠期间引脚是上拉还是下拉。上拉可节省100nA。</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码<code>main.c</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/logging/log.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">LOG_MODULE_REGISTER(main);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;   </span><br><span class=\"line\">        <span class=\"comment\">// 通过stdout输出，最终是通过串口阻塞API，一个字符一个字符输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World! %s\\n&quot;</span>, CONFIG_BOARD_TARGET);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// CONFIG_LOG_PRINTK=n 时，通过串口阻塞API，一个字符一个字符输出</span></span><br><span class=\"line\">        <span class=\"comment\">// CONFIG_LOG_PRINTK=y 时，通过logging subsystem的buffer输出</span></span><br><span class=\"line\">        printk(<span class=\"string\">&quot;Hello World! %s\\n&quot;</span>, CONFIG_BOARD_TARGET);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// CONFIG_LOG_BACKEND_UART=y 时，通过异步串口API输出（DMA）</span></span><br><span class=\"line\">        LOG_INF(<span class=\"string\">&quot;Hello World! %s&quot;</span>, CONFIG_BOARD_TARGET);</span><br><span class=\"line\">        </span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">1000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"硬件配置\"><a href=\"#硬件配置\" class=\"headerlink\" title=\"硬件配置\"></a>硬件配置</h2><p>以nRF52840DK为例：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250126235219464.webp\" alt=\"image-20250126235219464\"></p>\n<p>首先切开焊盘SB40，这个是MCU供电流过的地方。</p>\n<ol>\n<li>如果用电流表测试，则接<strong>电流流出</strong>和<strong>电流流入</strong></li>\n<li>如果用电源测试，则接<strong>电流流入</strong>和<strong>GND</strong></li>\n<li>如果使用PPK II，支持以上两种模式，可以3个引脚都接</li>\n<li>如果使用示波器，可以在焊盘R90上焊接一个10欧姆高精度电阻，然后用示波器双通道2个探头分别接入<strong>电流流入</strong>和<strong>电流流出</strong>，再接地。示波器双通道相减获得电流。</li>\n</ol>\n<blockquote>\n<p>PPK II推荐使用<strong>电流表模式</strong>。如果要使用<strong>电源模式，一定要确保供电电压和板子本身供电电压相同</strong>。否则MCU引脚和板子上其他器件会有压差，导致漏电。</p>\n<p>这里使用nRF52840DK，如果用电压源模式需要选择3V供电。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250126235758123.webp\" alt=\"image-20250126235758123\"></p>\n<p>此外，即使你使用电源模式，USB也是必须要接的：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/969d3d8a3a037e411d2636670789c9f1.webp\" alt=\"969d3d8a3a037e411d2636670789c9f1\"></p>\n<p>否则电源供电会通过一些开关芯片漏到板子上的其他器件上，造成功耗评估严重偏高。</p>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>板子上JLINK （Interface MCU）自带串口，直接电脑打开JLINK上的串口即可：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250127003520771.webp\" alt=\"image-20250127003520771\"></p>\n<p>日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*** Booting nRF Connect SDK v2.8.0-a2386bfc8401 ***</span><br><span class=\"line\">*** Using Zephyr OS v3.7.99-0bc3393fb112 ***</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:00.354,217] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:01.360,687] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:02.367,248] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:03.373,809] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:04.380,371] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:05.386,932] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:06.393,463] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:07.400,054] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">[00:00:08.406,585] &lt;inf&gt; main: Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br><span class=\"line\">Hello World! nrf52840dk/nrf52840</span><br></pre></td></tr></table></figure>\n\n<p><code>printk</code>和<code>printf</code>以及<code>LOG</code>都连续输出2次。这说明这三种方式内部分别各自存在buffer，buffer满了才会输出。</p>\n<p>底电流：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250127000857325.webp\" alt=\"image-20250127000857325\"></p>\n<p>IDLE线程的底电流2.54uA，符合手册中System ON条件下，CPU不工作时的功耗：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/75adeaab93a5d89a9b48ffa11ff3137f.webp\" alt=\"75adeaab93a5d89a9b48ffa11ff3137f\"></p>\n<blockquote>\n<p>相对的，System OFF的功耗非常低，但是只能用reset或GPIO唤醒，且唤醒后必定reset。</p>\n</blockquote>\n<h1 id=\"配置解析\"><a href=\"#配置解析\" class=\"headerlink\" title=\"配置解析\"></a>配置解析</h1><h2 id=\"异步串口\"><a href=\"#异步串口\" class=\"headerlink\" title=\"异步串口\"></a>异步串口</h2><p>根据我之前的文章<a href=\"https://www.cnblogs.com/jayant97/articles/17828907.html\">《Zephyr驱动与设备树实战——串口》</a>，我们知道异步串口只要不是正在发送或接收，就是低功耗的。RX时的功耗比较高，因为需要一直等待。但好在日志是一个不需要RX的功能，因此我们关闭所有RX：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_SHELL=n</span><br><span class=\"line\">CONFIG_CONSOLE_HANDLER=n</span><br></pre></td></tr></table></figure>\n\n<p>其他关于异步串口的配置，可以看那篇文章解释。</p>\n<h2 id=\"Zephyr-Device-Power-Management\"><a href=\"#Zephyr-Device-Power-Management\" class=\"headerlink\" title=\"Zephyr Device Power Management\"></a>Zephyr Device Power Management</h2><p>接下来是关于低功耗的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_PM_DEVICE_RUNTIME=y</span><br><span class=\"line\">CONFIG_PM_DEVICE=y</span><br></pre></td></tr></table></figure>\n\n<p>这是Zephyr Device Power Management Subsystem的功能。Zephyr中把电源管理分为System Power Management 和 Device Power Managment。System Power Management的强大功能我们已经见识过了：只要其他线程都在阻塞（不论是在sleep还是在等待信号量），进入IDLE线程后，系统会自动让CPU休眠。当有EVENT到来时，CPU自动唤醒，无需开发者操心CPU的休眠。</p>\n<p>而<strong>Device Power Managment</strong>管理的是外设的功耗，包括片上外设和外挂的总线外设。如果你开发了一段时间Zephyr，会发现Zephyr的外设API是没有init和uninit的。因为外设的初始化是在main线程运行之前就已经被驱动程序做好了。</p>\n<p><code>CONFIG_PM_DEVICE=y</code>就让你可以在应用层手动去开关这些外设，具体的API为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/pm/device.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">uart0</span> =</span> DEVICE_DT_GET(DT_NODELABEL(uart0));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_0_enter_low_power</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pm_device_action_run(uart0, PM_DEVICE_ACTION_SUSPEND);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_1_exit_low_power</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pm_device_action_run(uart0, PM_DEVICE_ACTION_RESUME);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>驱动层已经实现了<code>PM_DEVICE_ACTION_SUSPEND</code>和<code>PM_DEVICE_ACTION_RESUME</code>对应的功能，开发者无需再关心其初始化的细节。</p>\n<p>通过这种方式你可以手动地全局开关一些外设。</p>\n<p>但是有时候手动去开关还是太麻烦，可能你会想这样做来实现低功耗：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">pm_device_action_run(&amp;my_dev, PM_DEVICE_ACTION_SUSPEND);</span><br><span class=\"line\">operate_my_dev(&amp;my_dev);</span><br><span class=\"line\">pm_device_action_run(&amp;my_dev, PM_DEVICE_ACTION_RESUME);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>但是这么做不是线程安全的，如果这段代码在不同线程里运行会出问题（常见于SPI，I2C等总线外设）。另外可能这个外设被Zephyr系统用到了，但是却在那之前被你关掉了，那就会出问题（尤其常见于QSPI外挂Flash）。</p>\n<p> <code>CONFIG_PM_DEVICE_RUNTIME=y</code>就是Zephyr提供的另外一个库，它相当于对Device Management的API进行了一层封装：</p>\n<p><img src=\"https://docs-be.nordicsemi.com/bundle/ncs-latest/page/zephyr/_images/devr-sync-ops.svg?_LANG=enus\" alt=\"../../_images/devr-sync-ops.svg\"></p>\n<p>当应用层调用外设的API时，驱动层先调用<code>pm_device_runtime_get()</code>函数，使得<code>usage</code>变量+1。当usage变量大于1时，PM Subsystem就会调用<code>pm_device_action_run(dev, PM_DEVICE_ACTION_RESUME)</code>来让驱动层打开这个外设。</p>\n<p>当这个外设不再使用时（发送完毕&#x2F;接收完毕），驱动层则调用<code>pm_device_runtime_put()</code>函数，使得<code>usage</code>变量-1。当<code>usage == 0</code>时，PM Subsystem就会调用<code>pm_device_action_run(dev, PM_DEVICE_ACTION_SUSPEND)</code>来让驱动层关闭这个外设。</p>\n<p>这种实现是线程安全的，并且不需要应用层手动控制这个外设。此外，即使应用层重复地进行<code>get</code>或者<code>put</code>，也不会影响它实际的运行逻辑。</p>\n<blockquote>\n<p> NCS v2.8.0之后，Nordic串口驱动才加入了Runtime的支持。</p>\n</blockquote>\n<p>Runtime电源管理的功能，要看驱动程序是否支持，主要是看它有没有调用<code>pm_device_runtime_put</code>和<code>pm_device_runtime_get</code>。</p>\n<p>另外，Runtime的功能一定要对每个外设分别使能。你可以在设备树里添加一个配置，让它自动使能：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uart0 &#123;</span><br><span class=\"line\">    zephyr,pm-device-runtime-auto;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此外，Nordic串口驱动做了更多事情。<strong>如果<code>CONFIG_PM_DEVICE</code>和<code>CONFIG_PM_DEVICE_RUNTIME</code>都不打开</strong>，此串口驱动也实现了自己的私有runtime低功耗：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 见/zephyr/drivers/serial/Kconfig.nrfx_uart_instance</span><br><span class=\"line\"></span><br><span class=\"line\">config UART_$(nrfx_uart_num)_NRF_ASYNC_LOW_POWER</span><br><span class=\"line\">    bool &quot;Low power mode&quot;</span><br><span class=\"line\">    depends on HAS_HW_NRF_UARTE$(nrfx_uart_num)</span><br><span class=\"line\">    depends on UART_ASYNC_API</span><br><span class=\"line\">    depends on UART_NRFX_UARTE_LEGACY_SHIM</span><br><span class=\"line\">    default y if !PM_DEVICE</span><br><span class=\"line\">    help</span><br><span class=\"line\">      When enabled, UARTE is enabled before each TX or RX usage and disabled</span><br><span class=\"line\">      when not used. Disabling UARTE while in idle allows to achieve lowest</span><br><span class=\"line\">      power consumption. It is only feasible if receiver is not always on.</span><br><span class=\"line\">      This option is irrelevant when device power management (PM) is enabled</span><br><span class=\"line\">      because then device state is controlled by the PM actions.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因此，两个都不打开也是可以低功耗的，只要其他配置与本文保持一致即可（异步串口）。</p>\n<p>但是，很多NCS例程是只开了<code>CONFIG_PM_DEVICE</code>，没有开<code>CONFIG_PM_DEVICE_RUNTIME</code>，导致两种低功耗场景都沾不上边，<strong>这种情况下，底电流约为15uA</strong>。</p>\n</blockquote>\n<h1 id=\"踩坑记录\"><a href=\"#踩坑记录\" class=\"headerlink\" title=\"踩坑记录\"></a>踩坑记录</h1><p>记录一个坑中坑的情况，当打开以下配置时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_LOG_PRINTK=y</span><br></pre></td></tr></table></figure>\n\n<p>printk会从LOG的后端进行输出，也就是利用异步串口DMA进行输出，而不是串口阻塞API一个字节一个字节输出，这听起来很美好。</p>\n<p>但是，当我们只用printk，且输出字符为刚好33字节时（含<code>\\n</code>）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        printk(<span class=\"string\">&quot;12345678901234567890123456789012\\n&quot;</span>);        </span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>功耗会来到惊人的367uA!!!</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250127005910755.webp\" alt=\"image-20250127005910755\"></p>\n<p>并且，多一个字节或者少一个字节，功耗都是正常的！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        <span class=\"comment\">//printk(&quot;12345678901234567890123456789012\\n&quot;);</span></span><br><span class=\"line\">        printk(<span class=\"string\">&quot;1234567890123456789012345678901\\n&quot;</span>); </span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250127010021221.webp\" alt=\"image-20250127010021221\"></p>\n<p>我猜想这可能是因为33字节会刚好触发了Power Management打开串口，但是却又差一个字节才能发出去，导致实际没发出去，要等下一次数据来才能发出去。但是发送完毕后，又马上打开了串口。</p>\n<p>这个问题最坑的点在于…</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">printk(<span class=\"string\">&quot;Hello World! %s\\n&quot;</span>, CONFIG_BOARD_TARGET);</span><br></pre></td></tr></table></figure>\n\n<p><code>&quot;Hello World! nrf52840dk/nrf52840\\n&quot;</code> 刚好就是33字节…</p>\n<p>并且，在printk后面加一个LOG_INF输出，也不会出现这个问题。</p>\n<p>这个Bug的出现让我一度怀疑我的其他配置出现了问题，各种修改尝试、切换SDK、翻阅源码，都无法找出原因，直到有次随手修改了打印的内容…</p>\n<p>总之分享出来，让其他人别踩这个坑吧。</p>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr"]},{"title":"Nordic GPIO硬件原理与NCS应用详解","url":"/jayant97.github.io/2024/01/b74491c1a080/","content":"<h1 id=\"本文主题\"><a href=\"#本文主题\" class=\"headerlink\" title=\"本文主题\"></a>本文主题</h1><ol>\n<li>Nordic MCU的GPIO硬件简介、GPIOTE是什么、PPI是什么</li>\n<li>Zephyr中GPIO的使用、与外设引脚复用的方法（pinctrl）</li>\n</ol>\n<blockquote>\n<p>声明：本文在解释硬件方面会比较详细，其目的是让读者在遇到问题时方便查阅，并debug底层寄存器信号。并非是推荐开发者直接进行寄存器开发，大多数情况下直接使用Nordic提供的外设API进行开发即可，可参考本文第3、4、5章。</p>\n</blockquote>\n<h1 id=\"1-GPIO硬件介绍\"><a href=\"#1-GPIO硬件介绍\" class=\"headerlink\" title=\"1. GPIO硬件介绍\"></a>1. GPIO硬件介绍</h1><p>在介绍NCS中的GPIO和引脚复用（pinctrl）之前，有必要先介绍Nordic平台的GPIO相关硬件。</p>\n<h2 id=\"1-1-GPIO编号与分配表\"><a href=\"#1-1-GPIO编号与分配表\" class=\"headerlink\" title=\"1.1. GPIO编号与分配表\"></a>1.1. GPIO编号与分配表</h2><p>每个Port上最多有32个GPIO，编号为0 ～ 31。Port从0开始，根据芯片封装的不同，可能还会有Port 1。<strong>例如，在代码中，P0.12对应的引脚编号就是12，而P1.12对应的引脚编号就是32+12，也就是44。</strong></p>\n<p>在每个手册的“Hardware and layout”章节，有不同MCU封装的GPIO功能说明，我们点进去可以看到每个引脚的用途。不仅是GPIO，还有一些电源和晶振引脚也包含其中：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c7d1ed9cc5d16e4daa3597d494a60c89.png\" alt=\"image-20240122163623759\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/07e201fb13fbc90479ad9d52e035c82f.png\" alt=\"image-20240122164712134\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4bdab7ecda1cfd8cbff65cccb054fe8f.png\" alt=\"image-20240122164636172\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/98dc18fa7eef5779f5eef71b2f429f51.png\" alt=\"image-20240122164939613\"></p>\n<blockquote>\n<p>这里面值得一提的一些信息有：</p>\n<ol>\n<li><strong>模拟引脚是固定的</strong>，标有Analog input的引脚才能作为模拟输入。</li>\n<li>外设的<strong>数字引脚基本上是可以任意分配的</strong>。但有些外设会有推荐的引脚，例如上图中的QSPI。</li>\n<li>某些引脚只能配置为Standard drive，无法作为高驱动模式。因此<strong>不适合高速数据传输</strong>的外设引脚。</li>\n</ol>\n</blockquote>\n<h2 id=\"1-2-GPIO硬件\"><a href=\"#1-2-GPIO硬件\" class=\"headerlink\" title=\"1.2. GPIO硬件\"></a>1.2. GPIO硬件</h2><p>下图来自于nRF52833 Product Specification。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c5c177122aeb8695fe5b1b51a48bed68.png\" alt=\"image-20240122162605569\"></p>\n<p>从框图可以看出，GPIO可以作为模拟输入，也可以作为数字输入和输出。</p>\n<blockquote>\n<p>只有部分GPIO可以作为模拟输入，见1.2小节</p>\n</blockquote>\n<h3 id=\"寄存器介绍\"><a href=\"#寄存器介绍\" class=\"headerlink\" title=\"寄存器介绍\"></a>寄存器介绍</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/efbf5d9684190fc343c964608cd7b612.png\" alt=\"image-20240130104903444\"></p>\n<p>Nordic平台的GPIO，每个port最多有32个引脚。</p>\n<ul>\n<li>OUT：32bit寄存器，bit写1使对应的GPIO输出高，写0使对应的GPIO输出低</li>\n<li>OUTSET：32bit寄存器，bit写1使对应的GPIO输出高，写0不影响对应的GPIO的状态</li>\n<li>OUTCLR：32bit寄存器，bit写1使对应的GPIO输出低，写0不影响对应的GPIO的状态</li>\n<li>IN：32bit寄存器，读取每个bit即为读取每个GPIO的状态</li>\n<li>DIR：32bit寄存器，bit写1使对应的GPIO配置为输出模式，写0使对应的GPIO配置为输入模式</li>\n<li>DIRSET：32bit寄存器，bit写1使对应的GPIO配置为输出模式，写0不影响对应的GPIO的模式</li>\n<li>DIRCLR：32bit寄存器，bit写1使对应的GPIO配置为输入模式，写0不影响对应的GPIO的模式</li>\n<li>LATCH：与休眠唤醒配置有关，见下方</li>\n<li>DETECTMODE：与休眠唤醒配置有关，见下方</li>\n<li>PIN_CONF：32个32bit寄存器。单独配置每个GPIO的输入输出（可覆盖DIR寄存器），输出模式、输出驱动能力、内部上下拉。</li>\n</ul>\n<h3 id=\"GPIO输出状态与驱动能力配置\"><a href=\"#GPIO输出状态与驱动能力配置\" class=\"headerlink\" title=\"GPIO输出状态与驱动能力配置\"></a>GPIO输出状态与驱动能力配置</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8d88eaf30211c26cfc8593ea9b89dec9.png\" alt=\"Introduction to GPIO - General Purpose I/O - NerdyElectronics\"></p>\n<p>我们知道GPIO的<strong>输出电路</strong>内部是两个MOS管作为开关，也就是说，GPIO其实有三种状态：</p>\n<ul>\n<li>输出高电平：上管导通、下管关断。通常代表逻辑1。</li>\n<li>输出低电平：上管关断，下管导通。通常代表逻辑0。</li>\n<li>输出高阻态：上下管均关断。可以代表逻辑0或逻辑1，取决于电路设计者自身的定义。</li>\n</ul>\n<p>但我们控制GPIO时，代码中只会写0和1两种状态。这就要求我们提前配置好GPIO的输出模式（推挽、漏极开路、源极开路），每一种都代表不同的高、低电平或高阻态的组合：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e3efd7b8077d02e8abc1bfb9fdd58201.png\" alt=\"image-20240122170147234\"></p>\n<p>以上8种状态，包含了推挽、漏极开路、源极开路的状态。此外，当GPIO输出高电平或低电平时，还有标准驱动能力（Standard）和高驱动能力（High drive）两种选择。</p>\n<p>举例来说，S0S1就是推挽（Push-Pull）输出；而S0D1就是开漏（Open-Drain）输出。我们知道开漏输出是为了做“线与”操作的，I2C协议就需要这种配置。同理，D0S1就是源极开路输出，可以实现“线或”操作。</p>\n<blockquote>\n<p>线与：相连的GPIO中只要有一个输出低电平，则整个线保持低电平，且不能出现短路；</p>\n<p>线或：相连的GPIO中只要有一个输出高电平，则整个线保持高电平，且不能出现短路。 </p>\n</blockquote>\n<p>这里除了标准驱动能力（Standard）之外，还有高驱动能力（High drive）可以选择。它相比于Standard可以输出更高的电流：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/26bc6c2789100c12be754ac9bcf7d667.png\" alt=\"image-20240122171447781\"></p>\n<p>上图中，GPIO的Electrical specification章节记录了GPIO的电气特性。可以看到标准输出和高驱输出时，拉电流与灌电流的承受范围。</p>\n<blockquote>\n<p>GPIO输出电压的变化，本质是给线上的等效电容充电或放电。因此GPIO输入输出电流的能力越强，则输出高频信号的能力越强。</p>\n</blockquote>\n<h3 id=\"GPIO数字输入\"><a href=\"#GPIO数字输入\" class=\"headerlink\" title=\"GPIO数字输入\"></a>GPIO数字输入</h3><p>关于输入，值得一提的是Nordic的输入是可以断开的（从框图中也能看出）。因此只要不使能输入和输出，GPIO内部就是断开的，不用担心漏电导致功耗问题。</p>\n<h3 id=\"GPIO内部上拉-x2F-下拉电阻\"><a href=\"#GPIO内部上拉-x2F-下拉电阻\" class=\"headerlink\" title=\"GPIO内部上拉&#x2F;下拉电阻\"></a>GPIO内部上拉&#x2F;下拉电阻</h3><p>导线高低电平的电磁学本质，是把导线和地平面之间看作一个微小的电容。输出高电平即为给电容充电，输出低电平即为给电容放电。</p>\n<p>上&#x2F;下拉电阻的作用是，当导线上的所有GPIO都处于高阻态时，通过这个上&#x2F;下拉电阻给导线充、放电，使得导线的电平处于一个确定的状态。</p>\n<p>例如I2C总线，线路上所有的IO都是开漏输出，因此需要一个上拉电阻。当所有IO都输出逻辑1（高阻态）时，能通过这个上拉电阻给导线电容充电，使的线路电平被拉高。</p>\n<p>如果PCB上没有上拉电阻，就需要MCU配置内部上拉。配置相关的寄存器如下：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/516447374f263597522004f29a6374b5.png\" alt=\"image-20240130111651505\"></p>\n<p>使用内部上拉时，需要注意电阻的阻值，典型值为13千欧。线路上的RC值影响线路上电平变化的速度。当无外挂电容，只考虑线路寄生电容时，使用此内部上拉电阻，I2C总线<strong>最高只能配置为100kbps</strong>。若想要配置到400kbps，请使用外部4.7千欧或更低的上拉电阻。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/f696dc3aaa43ff01ebc7f81daa7dcefc.png\" alt=\"image-20240130111825537\"></p>\n<blockquote>\n<p>除了有提高电平变化速度的场景，还有需要降低电平变化速度的场景。例如，一些通过边沿触发的GPIO中断、或者Reset引脚的触发等。<strong>不要认为有了上拉电阻，线路的电压就会稳定不受干扰</strong>。因为如果线路上电容值很小，微小的电荷变化就会引起巨大的电压变化。因此线路要保持稳定的电平与上拉电阻关系不太大，反而与线路上的电容关系很大。</p>\n</blockquote>\n<h2 id=\"1-3-GPIO复用\"><a href=\"#1-3-GPIO复用\" class=\"headerlink\" title=\"1.3. GPIO复用\"></a>1.3. GPIO复用</h2><p>Nordic平台的外设配置GPIO时，基本上是可以任意选择的。并且，<strong>外设的配置可以自动覆盖（Override）GPIO的输入输出方向、输出值等配置</strong>。见本文1.2.小节框图中的几个OVERRIDE信号。但是，GPIO的上下拉、输出模式等配置，还是要在GPIO的寄存器中进行配置。</p>\n<h3 id=\"数字复用\"><a href=\"#数字复用\" class=\"headerlink\" title=\"数字复用\"></a>数字复用</h3><p>要配置一个外设所使用的GPIO，只需直接在这个外设对应的寄存器中进行配置。例如，下图是PWM外设中的PSEL（Pin Select）寄存器，就是可以选择任意一个port的任意一个pin作为输出引脚。当你在PWM外设的寄存器中配置引脚之后，会自动按照本文1.2小节框图中的OVERRIDE信号来覆盖对应GPIO的。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8910ba2d07720eb2d40103d0419da2c5.png\" alt=\"image-20240130114131417\"></p>\n<h3 id=\"模拟复用\"><a href=\"#模拟复用\" class=\"headerlink\" title=\"模拟复用\"></a>模拟复用</h3><p>模拟复用不能选择任意的GPIO，只能选择具有Analog Input功能的GPIO。以SAADC为例，这里只能选择AINx或者内部VDD、内部VDD&#x2F;5作为输入，而不是GPIO的引脚编号。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a0f1293e228846b7f2129632e8ea8f0a.png\" alt=\"image-20240130114325318\"></p>\n<h3 id=\"特殊GPIO（RESET和NFC-Tag）\"><a href=\"#特殊GPIO（RESET和NFC-Tag）\" class=\"headerlink\" title=\"特殊GPIO（RESET和NFC Tag）\"></a>特殊GPIO（RESET和NFC Tag）</h3><p>Nordic平台具有UICR寄存器，这是一个flash之外的掉电不丢失区域，用于存储一些用户配置，可擦写。其中具有RESET和NFC Tag引脚的配置，以52840为例：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/bdc2e489f13bd9d613cbfff44bfb00cc.png\" alt=\"image-20240131100105700\"></p>\n<blockquote>\n<p>nRF54L15的reset pin没有被分配GPIO编号。因此54L15的reset pin不能当作普通GPIO使用。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/6d91c86599c6fc1fabb633700ea0b46e.png\" alt=\"image-20240131100201965\"></p>\n<p>对于reset引脚来说，<code>PSELRESET[0]</code>和<code>PSELREET[1]</code>的值都是PIN&#x3D;18，PORT&#x3D;0，CONNECT&#x3D;0的情况下，P0.18才会作为Reset引脚使用。否则，P0.18作为普通GPIO使用。<strong>Reset信号无法映射到其他GPIO</strong>。</p>\n<blockquote>\n<p>软件控制reset引脚作为普通GPIO使用：</p>\n<ul>\n<li><p>在nRF5 SDK中，<strong>不要</strong>设置全局宏定义<code>CONFIG_GPIO_AS_PINRESET</code></p>\n</li>\n<li><p>在NCS v2.5.0之后，需要在设备树overlay中增加：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uicr&#123;</span><br><span class=\"line\">    // Pin used as GPIO, not nRESET</span><br><span class=\"line\">    /delete-property/ gpio-as-nreset;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    /delete-property/ gpio-reserved-ranges;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>（在老版本NCS中是直接设置<code>CONFIG_GPIO_AS_PINRESET=n</code>）</p>\n</blockquote>\n<p>NFC引脚是固定的两个，对于nRF52833来说是P0.09和P0.10。默认情况下这两个IO是GPIO，只有UICR中对应的bit写1之后，这两个IO才能作为NFC来工作。</p>\n<blockquote>\n<p>软件控制NFC引脚作为普通GPIO使用：</p>\n<ul>\n<li>在nRF5 SDK中，在Keil&#x2F;SES&#x2F;Makefile中设置全局宏定义<code>CONFIG_NFCT_PINS_AS_GPIOS</code></li>\n<li>在NCS v2.5.0之后，需要在设备树overlay中增加：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uicr&#123;</span><br><span class=\"line\">    // Pin used as GPIO, not NFC</span><br><span class=\"line\">    nfct-pins-as-gpios;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    /delete-property/ gpio-reserved-ranges;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>添加后，系统启动时会自动擦写UICR并重启。</p>\n<p>（在老版本NCS中是直接设置&#96;CONFIG_NFCT_PINS_AS_GPIOS&#x3D;y）</p>\n</blockquote>\n<p>至于其他型号的MCU，注意看对应的uicr设备树compatible中规定了哪些值即可。</p>\n<h2 id=\"1-4-GPIO的Sense机制\"><a href=\"#1-4-GPIO的Sense机制\" class=\"headerlink\" title=\"1.4. GPIO的Sense机制\"></a>1.4. GPIO的Sense机制</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/6f5774a43c1dd4420a207aca001b74b0.png\" alt=\"image-20240415155234948\"></p>\n<p>从GPIO的框图中我们可以看出，每个GPIO在处于输入模式的情况下，有一个SENSE信号。它可以被每个引脚的PIN_CNF寄存器中对应的bit位控制。可以配置为高电平触发或低电平触发。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c239182986954ff8f53ebab7fd37b8e5.png\" alt=\"image-20240415155410982\"></p>\n<p><strong>所有引脚的Sense信号会汇聚成一个DETECT信号。这个DETECT信号有两种作用：</strong></p>\n<ul>\n<li><strong>使系统从System Off模式中唤醒（也就是GPIO唤醒休眠）</strong></li>\n<li><strong>在GPIOTE外设中产生Port中断（后续在GPIOTE章节中介绍）</strong></li>\n</ul>\n<p>这个DETECT信号本身又有两种模式，通过DETECTMODE寄存器进行配置。</p>\n<p>第一种是单纯的把所有引脚的PINx.DETECT信号进行<strong>逻辑或运算</strong>，也就是标准的DETECT信号。</p>\n<p>另一种是在逻辑或之前加了一个锁存器（Latch），当PINx.DETECT置1时，相当于RS锁存器的Set端写1，LATCH寄存器中的对应Bit会被写1；当PINx.DETECT置0时，LATCH寄存器中的对应Bit会被锁存，不会变化。LATCH寄存器中对应的bit只有被CPU显式地写1时才会清0，相当于RS锁存器的Clear端写1。这个叫做LDETCT信号。</p>\n<h1 id=\"2-GPIOTE与PPI介绍\"><a href=\"#2-GPIOTE与PPI介绍\" class=\"headerlink\" title=\"2. GPIOTE与PPI介绍\"></a>2. GPIOTE与PPI介绍</h1><p>对于第一次接触Nordic平台的开发者，首先要明白一个概念：GPIOTE和GPIO是完全不同的外设。要理解为什么是这样，需要先理解Nordic外设接口（Peripheral interface）。</p>\n<h2 id=\"2-1-外设接口（Peripheral-interface）\"><a href=\"#2-1-外设接口（Peripheral-interface）\" class=\"headerlink\" title=\"2.1. 外设接口（Peripheral interface）\"></a>2.1. 外设接口（Peripheral interface）</h2><p>在Nordic平台中，无论是什么外设，都遵循类似的外设接口，其框图如下：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/216025fa4203288e7e2b4af6d5c5e99e.png\" alt=\"image-20240415161448616\"></p>\n<p>整个框图代表外设，这个外设可以是Timer、串口、ADC等等。接下来详细解释内部框图的意思，框图中展示的都是所有外设都有的共通的部分。</p>\n<h3 id=\"TASK寄存器\"><a href=\"#TASK寄存器\" class=\"headerlink\" title=\"TASK寄存器\"></a>TASK寄存器</h3><p>TASK寄存器代表这个外设的输入。例如Timer计时的开始、结束、清零；ADC采样的开始、结束；串口的发送开始、结束等等。<strong>只要CPU给对应的TASK寄存器写1，外设就会去执行对应的动作。</strong></p>\n<h3 id=\"EVENT寄存器与INTEN寄存器\"><a href=\"#EVENT寄存器与INTEN寄存器\" class=\"headerlink\" title=\"EVENT寄存器与INTEN寄存器\"></a>EVENT寄存器与INTEN寄存器</h3><p>EVENT寄存器代表这个外设的输出。例如串口DMA缓存接收满、ADC采样完成等等。这些事件（EVENT）可以用来触发CPU中断，只需要在INTEN寄存器中使能某个EVENT对应的中断，那么这个EVENT就能触发IRQ信号到NVIC模块。</p>\n<h3 id=\"SHORTS寄存器\"><a href=\"#SHORTS寄存器\" class=\"headerlink\" title=\"SHORTS寄存器\"></a>SHORTS寄存器</h3><p>Shorts意为短路。它可以让某个外设的EVENT自动触发自己的TASK，从而实现自动循环执行，无需CPU的干预。</p>\n<p>这个短路路径是预设好的，固定的几条，不能自由搭配。以定时器为例：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b8959c71d6d864b6e3bf53dc3b4e8918.png\" alt=\"image-20240415162841413\"></p>\n<p>定时器最多有6个比较（Compare）通道。当定时器中的count值增长到某个通道的compare值时，触发compare事件。这里可以通过使能对应的SHORT寄存器，让这个COMPARE EVENT去触发定时器的CLEAR TASK，从而实现自动循环计数。也可以让这个COMPARE EVENT去触发定时器的STOP TASK，从而实现单次计数。</p>\n<p>这里是无法把compare event连接到start task的（虽然这种连接本身没有意义），因为SHORTS寄存器里的路径是预设好的。</p>\n<h2 id=\"2-2-PPI-Programmable-Peripheral-Interconnect\"><a href=\"#2-2-PPI-Programmable-Peripheral-Interconnect\" class=\"headerlink\" title=\"2.2.  PPI (Programmable Peripheral Interconnect)\"></a>2.2.  PPI (Programmable Peripheral Interconnect)</h2><p>在2.1章节中我们了解了外设的接口。从框图中可以看到TASK和EVENT寄存器上，还连接了PPI。这个PPI本身也是一个外设，它可以让你<strong>把一个外设的EVENT寄存器直接连接到另一个外设的TASK寄存器上，从而实现外设之间的自动联动，无需CPU参与处理</strong>。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/7b60a3e4ebe3381524cb85bac71489b3.png\" alt=\"image-20240415164008994\"></p>\n<p>图中的竖线，代表PPI的通道（Channel），nRF52833共有32条通道，其中前20条可以自由配置。<strong>每个通道可以连接1个EVENT，和2个TASK。</strong>（把EVENT寄存器的地址写入到CH[n].EEP寄存器；然后把想触发的TASK写到CH[n].TEP或者FORK[n].TEP中即可）。</p>\n<blockquote>\n<p>举一个实际的例子，就是<a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/\">《Zephyr驱动与设备树实战——串口》</a>中的提到高速异步串口：首先，Nordic的串口硬件具有DMA的功能，可以直接把数据从串口搬运到内存；然后，Nordic的串口驱动软件具有空闲计时的功能，当一定时间没有收到数据，DMA缓存还没存满的时候，就直接不等DMA中断了，直接产生串口回调函数，让CPU提前处理。</p>\n<p>这里就产生了一个问题：此时DMA缓存未满，CPU只知道首地址，如何知道数据的长度呢？毕竟串口外设本身可没有计数功能。（RXD.AMOUNT寄存器只有DMA传输完毕才能读，这种提前读取的场景是不知道有多少的）。</p>\n<p>一个纯软件的方法，就是每读到1个字节，就进入CPU中断，把一个变量+1。当传输完成时，读取这个变量，就知道一共收到了多少字节了。但是这种方法非常消耗CPU资源，且功耗高。当串口波特率达到921600时，CPU几乎无法做别的事情了。</p>\n<p>Nordic的驱动代码采用的是PPI的方法。每收到一个字节（EVENTS_RXDRDY），就通过PPI让Timer的计数器+1（TASKS_COUNT）。等到传输完毕时，直接读取Timer的计数值即可。整个传输过程中CPU都处于休眠状态，只有串口、timer、总线、内存等在工作。从而实现高性能、低功耗。</p>\n<p>同理，带有流控的串口发送也是如此。串口正在发送时，突然收到流控制停止发送的信号，这时串口DMA立即停止发送。当重新恢复发送时，如何知道该从第几个字节开始重新发？也是一样使用Timer进行计数。</p>\n</blockquote>\n<h3 id=\"PPI的使能与分组\"><a href=\"#PPI的使能与分组\" class=\"headerlink\" title=\"PPI的使能与分组\"></a>PPI的使能与分组</h3><p>PPI每个通道可以单独使能或关闭。通过CHEN寄存器写1使能，写0关闭。或者通过CHENSET和CHENCLR寄存器这种类似于SR锁存器的操作方式进行使能或关闭。</p>\n<p>nRF52833的PPI外设还有6个通道组。每个通道组有32个bit，对应32条通道。只要某个Bit置1，那么对应的通道就会被包含在这个通道组里：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/52f9072930d77cd88eb0cf1c159d79fc.png\" alt=\"image-20240415171821442\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/f1269abbf3a3c12964bd6adc5df92432.png\" alt=\"image-20240415171810227\"></p>\n<p>通道组的作用仅仅只是让你可以同时使能或者关闭一组通道。</p>\n<h3 id=\"固定的PPI通道\"><a href=\"#固定的PPI通道\" class=\"headerlink\" title=\"固定的PPI通道\"></a>固定的PPI通道</h3><p>对于nRF52833来说，20～31号通道是不可编程的，它的连接是固定的。通常用于连接RADIO、加密、RTC等外设。Nordic提供的无线协议栈（例如SoftDevice蓝牙低功耗协议栈）内部会用到这些PPI。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e861a9069b8b9eed6a86a3437816baef.png\" alt=\"image-20240415172000272\"></p>\n<h3 id=\"分布式PPI（DPPI）\"><a href=\"#分布式PPI（DPPI）\" class=\"headerlink\" title=\"分布式PPI（DPPI）\"></a>分布式PPI（DPPI）</h3><p>从nRF5340、nRF9160开始，Nordic内部的PPI升级为DPPI。从而把1对2的PPI通道升级为多对多的PPI通道。</p>\n<p>每个外设的TASK寄存器会有对应的SUBSCRIBE（订阅）寄存器；EVENT寄存器会有对应的PUBLISH（发布）寄存器。通过发布-订阅不同的DPPI通道，实现了多对多的外设事件传输。</p>\n<p>具体可以参考nRF5340或nRF9160的手册。</p>\n<h3 id=\"NCS中的PPI代码\"><a href=\"#NCS中的PPI代码\" class=\"headerlink\" title=\"NCS中的PPI代码\"></a>NCS中的PPI代码</h3><p>前面都是讲解原理，比较详细。实际到NCS的代码中，PPI并不那么复杂。只需记住两个原则：</p>\n<ol>\n<li>NCS中无论是PPI还是DPPI，都被封装为gppi接口，因此开发者无需关注它们的区别；</li>\n<li>永远不要自己指定某个具体的通道号来使用。因为Nordic的很多驱动代码里都用到了PPI，如果自己指定，很有可能和驱动中已经使用的通道冲突。因此我们应该用API来自动分配PPI通道，而不是自己指定。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;helpers/nrfx_gppi.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;nrfx_timer.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;nrfx_gpiote.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 分别获取两个外设的特定EVENT和TASK地址</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> EVENT = nrfx_timer_compare_event_address_get(&amp;timer_inst, NRF_TIMER_CC_CHANNEL0);</span><br><span class=\"line\"><span class=\"type\">uint32_t</span> TASK = nrfx_gpiote_out_task_address_get(&amp;gpiote_inst, OUTPUT_PIN));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动分配一个空闲的PPI通道</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> gppi_channel;</span><br><span class=\"line\">nrfx_gppi_channel_alloc(&amp;gppi_channel);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用此通道连接一个EVENT寄存器和一个TASK寄存器</span></span><br><span class=\"line\">nrfx_gppi_channel_endpoints_setup(gppi_channel, EVENT, TASK);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使能通道</span></span><br><span class=\"line\">nrfx_gppi_channels_enable(BIT(gppi_channel));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>PPI例程位置：${NCS}&#x2F;modules&#x2F;hal&#x2F;nordic&#x2F;nrfx&#x2F;samples&#x2F;src&#x2F;nrfx_gppi</p>\n</blockquote>\n<h2 id=\"2-3-GPIOTE-GPIO-Tasks-amp-Events\"><a href=\"#2-3-GPIOTE-GPIO-Tasks-amp-Events\" class=\"headerlink\" title=\"2.3. GPIOTE (GPIO Tasks &amp; Events)\"></a>2.3. GPIOTE (GPIO Tasks &amp; Events)</h2><p><strong>GPIOTE和GPIO是不同的外设</strong>。通过第一章的介绍，我们知道GPIO作为输入输出，可以被CPU和其他外设使用。但是GPIO本身并不具有TASK和EVENT寄存器，因此无法与我们第二章介绍的PPI联动起来。</p>\n<h3 id=\"GPIOTE-Pin-Task-Pin-Event\"><a href=\"#GPIOTE-Pin-Task-Pin-Event\" class=\"headerlink\" title=\"GPIOTE: Pin Task, Pin Event\"></a>GPIOTE: Pin Task, Pin Event</h3><p>GPIOTE也有很多通道（Channels），对于nRF52833来说有8个，每一个通道可以连接1个GPIO。给这个GPIO扩展出TASK和EVENT寄存器，分别是：</p>\n<ul>\n<li>TASKS_SET：使对应的GPIO输出高电平</li>\n<li>TASKS_CLR：使对应的GPIO输出低电平</li>\n<li>TASKS_OUT：使对应的GPIO输出一个预设的行为（在GPIOTE-&gt;CONFIG寄存器的POLARITY bits中配置，这个预设的行为可以是输出高、输出低、翻转）</li>\n<li>EVENTS_IN：当对应的GPIO检测到预设的波形时，产生一个EVENT（同样在GPIOTE-&gt;CONFIG寄存器的POLARITY bits中配置。这个预设的行为可以是上升沿、下降沿、双边沿）</li>\n</ul>\n<p>你可以用这些通道连接一个具体的GPIO，这样，本来不能产生中断的GPIO就可以通过EVENT寄存器产生中断了。</p>\n<blockquote>\n<p>要查看具体的代码，同样可以查看${NCS}&#x2F;modules&#x2F;hal&#x2F;nordic&#x2F;nrfx&#x2F;samples&#x2F;src&#x2F;nrfx_gppi例程。注意到GPIOTE的通道也是一种可以分配的资源。和PPI类似，使用时，不要自己指定具体的通道号，而应该用<code>nrfx_gpiote_channel_alloc()</code>函数来申请一个空闲的通道，以免和Nordic驱动代码中已经使用的GPIOTE通道冲突。</p>\n</blockquote>\n<h3 id=\"GPIOTE-Port-Event\"><a href=\"#GPIOTE-Port-Event\" class=\"headerlink\" title=\"GPIOTE: Port Event\"></a>GPIOTE: Port Event</h3><p>GPIOTE还有一个EVENT寄存器叫做EVENTS_PORT。在第一章节讲述GPIO时，提到GPIO有一个SENSE机制，全体GPIO的SENSE信号进行或运算后，会得到DETECT信号。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c5c177122aeb8695fe5b1b51a48bed68.png\" alt=\"image-20240122162605569\"></p>\n<p>这里GPIOTE的EVENTS_PORT就是用来把这个DETECT信号变成一个Events寄存器，从而可以用来产生中断，或者连接PPI。</p>\n<blockquote>\n<p>注意，DETCT信号虽然不是一个EVENT，但是DETECT信号本身就能把CPU从System Off模式唤醒，无需GPIOTE。</p>\n</blockquote>\n<h1 id=\"3-在Zephyr系统中使用GPIO\"><a href=\"#3-在Zephyr系统中使用GPIO\" class=\"headerlink\" title=\"3. 在Zephyr系统中使用GPIO\"></a>3. 在Zephyr系统中使用GPIO</h1><p>前面两章详细介绍了GPIO、GPIOTE和PPI的硬件，目的是让开发者在遇到问题时可以知道该从哪里去Debug，该看什么寄存器。但在一开始软件开发时，不需要关心这么多细节。只需调用现成的驱动API即可。</p>\n<h2 id=\"3-1-在Zephyr-DeviceTree中配置GPIO\"><a href=\"#3-1-在Zephyr-DeviceTree中配置GPIO\" class=\"headerlink\" title=\"3.1. 在Zephyr DeviceTree中配置GPIO\"></a>3.1. 在Zephyr DeviceTree中配置GPIO</h2><p>由于Zephyr所有硬件操作都在DeviceTree中完成，故需要先配置DeviceTree。下图演示了如何在一个node中写gpio：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">n: node &#123;</span><br><span class=\"line\">   foo-gpios = &lt;&amp;gpio0 <span class=\"number\">1</span> GPIO_ACTIVE_LOW&gt;,</span><br><span class=\"line\">               &lt;&amp;gpio1 <span class=\"number\">2</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，由于GPIO的配置是一个<strong>属性</strong>，因此必须写在一个节点（Node）内，例如<code>led_0</code>内。</p>\n<blockquote>\n<p>在<a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">《详解Zephyr设备树（DeviceTree）与驱动模型》</a>一文中，我们知道DeviceTree的节点不能自己随便添加，每个节点都有对应的compatible，而compatible又必须有对应的Device Binding yaml文件，以及对应的驱动文件。现在问题是，<strong>如果我只想单纯的添加一个自由的GPIO，不使用任何led或者button驱动程序，该如何做？</strong></p>\n<p>你可以把gpio放在<code>/zephyr,user</code>节点下。这是一个自由的节点，就是用来绕过Device Binding，专门放开发者一些自由的device tree属性的，想在里面写什么都可以。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    zephyr,user&#123;</span><br><span class=\"line\">        my-gpios = &lt;&amp;gpio0 <span class=\"number\">12</span> (GPIO_ACTIVE_HIGH|GPIO_PUSH_PULL|GPIO_PULL_DOWN)&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>然后是属性的名字，<strong>属性的名称必须以<code>gpios</code>结尾</strong>，也可以只写<code>gpios</code>。这样它才能被编译系统识别。</p>\n<p>然后是属性的值，这是一个phandle-array类型的属性，可以写很多组。每个元素都是由三个部分组成：</p>\n<ul>\n<li>GPIO Controller：也就是我们俗称的port。这里可以直接引用label，例如<code>&amp;gpio0</code>。</li>\n<li>GPIO Pin Number：这个就是引脚编号。P0.12的编号就是12。</li>\n<li>GPIO配置：激活状态、输入输出、上下拉等等。可以在这里配置，也可以后续在应用代码里配置修改。</li>\n</ul>\n<blockquote>\n<p>注意，部分开发者会有误解。</p>\n<p>激活状态<code>GPIO_ACTIVE_LOW</code>的意思是“逻辑1 &#x3D; 低电平”；<code>GPIO_ACTIVE_HIGH</code>的意思是“逻辑1 &#x3D; 高电平”。<strong>这是用于配置激活状态的参数，而不是部分人误解的配置默认输出高低电平的参数。</strong></p>\n<p><code>GPIO_ACTIVE_LOW</code>常见于LED灯。因为MCU gpio灌电流能力比拉电流能力强，因此LED电路往往是电流流入GPIO，也就是“低电平 &#x3D; LED灯亮”。</p>\n</blockquote>\n<p>更多GPIO配置的参数选项，请参考文档：<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/gpio.html\">https://docs.zephyrproject.org/latest/hardware/peripherals/gpio.html</a></p>\n<h2 id=\"3-2-在代码中控制GPIO\"><a href=\"#3-2-在代码中控制GPIO\" class=\"headerlink\" title=\"3.2. 在代码中控制GPIO\"></a>3.2. 在代码中控制GPIO</h2><p>首先，需要在conf文件中使能GPIO的驱动（大多数例程都是默认使能的）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_GPIO=y</span><br></pre></td></tr></table></figure>\n\n<p>在代码中，首先包含头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/device.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式一：以gpio-pin为对象进行控制\"><a href=\"#方式一：以gpio-pin为对象进行控制\" class=\"headerlink\" title=\"方式一：以gpio pin为对象进行控制\"></a>方式一：以gpio pin为对象进行控制</h3><p>在main函数中创建一个<code>gpio_dt_sepc</code>结构体，这个是操作一个单独GPIO的句柄：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">my_gpio</span> =</span> GPIO_DT_SPEC_GET(DT_PATH(zephyr_user), my_gpios);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>device tree中的内容都不可更改，故用cosnt变量存储最好</li>\n<li><code>GPIO_DT_SPEC_GET()</code>可以直接从device tree中读取到一个结构体的值</li>\n<li>第一个参数是node_id，由于我们放在<code>/zephyr,user</code>节点下，故可以用绝对路径来指明这个节点，<code>DT_PATH(zephyr_user)</code>。其中逗号是名称的一部分，在C语言中要变成下划线，才能当作名称的一部分。</li>\n<li>第二个参数是device tree的属性，也就是<code>my-gpios</code>。在C语言中，<code>-</code>需要变成下划线。</li>\n</ol>\n<p>然后就可以配置、读写该GPIO</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// write</span></span><br><span class=\"line\">gpio_pin_configure_dt(&amp;my_gpio, GPIO_OUTPUT);</span><br><span class=\"line\">gpio_pin_set_dt(&amp;my_gpio, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//read</span></span><br><span class=\"line\">gpio_pin_configure_dt(&amp;my_gpio, GPIO_INPUT);</span><br><span class=\"line\"><span class=\"type\">int</span> val = gpio_pin_get_dt(&amp;my_gpio);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二：以gpio-port为对象进行控制\"><a href=\"#方式二：以gpio-port为对象进行控制\" class=\"headerlink\" title=\"方式二：以gpio port为对象进行控制\"></a>方式二：以gpio port为对象进行控制</h3><p>使用port控制不需要像前面一样给单独的pin编写device tree，适合快速写一些测试用的代码。<strong>但它的缺点是，你使用的所有GPIO都不会在DeviceTree中有提示，如果有GPIO使用冲突，编译时无法帮你检查出来。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取GPIO Port的句柄</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev_gpio0</span> =</span> DEVICE_DT_GET(DT_NODELABEL(gpio0));</span><br><span class=\"line\"></span><br><span class=\"line\">gpio_pin_configure(dev_gpio0, <span class=\"number\">12</span>, GPIO_OUTPUT);</span><br><span class=\"line\">gpio_pin_set(dev_gpio0, <span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gpio_pin_configure(dev_gpio0, <span class=\"number\">12</span>, GPIO_INPUT);</span><br><span class=\"line\"><span class=\"type\">int</span> val = gpio_pin_get(dev_gpio0, <span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n\n<p>更多API，请参考<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/gpio.html\">Zephyr GPIO文档</a>。</p>\n<h3 id=\"配置GPIO的电流驱动能力\"><a href=\"#配置GPIO的电流驱动能力\" class=\"headerlink\" title=\"配置GPIO的电流驱动能力\"></a>配置GPIO的电流驱动能力</h3><p>从第1章我们知道，Nordic MCU的IO口驱动能力是可以配置的，这个是Nordic独有的功能，与Zephyr无关，具体参数为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Standard drive for &#x27;0&#x27; (default, used with GPIO_OPEN_DRAIN) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_S0    (0U &lt;&lt; 8U)</span></span><br><span class=\"line\"><span class=\"comment\">/** High drive for &#x27;0&#x27; (used with GPIO_OPEN_DRAIN) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_H0    (1U &lt;&lt; 8U)</span></span><br><span class=\"line\"><span class=\"comment\">/** Standard drive for &#x27;1&#x27; (default, used with GPIO_OPEN_SOURCE) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_S1    (0U &lt;&lt; 9U)</span></span><br><span class=\"line\"><span class=\"comment\">/** High drive for &#x27;1&#x27; (used with GPIO_OPEN_SOURCE) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_H1    (1U &lt;&lt; 9U)</span></span><br><span class=\"line\"><span class=\"comment\">/** Standard drive for &#x27;0&#x27; and &#x27;1&#x27; (default) */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_S0S1    (NRF_GPIO_DRIVE_S0 | NRF_GPIO_DRIVE_S1)</span></span><br><span class=\"line\"><span class=\"comment\">/** Standard drive for &#x27;0&#x27; and high for &#x27;1&#x27; */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_S0H1    (NRF_GPIO_DRIVE_S0 | NRF_GPIO_DRIVE_H1)</span></span><br><span class=\"line\"><span class=\"comment\">/** High drive for &#x27;0&#x27; and standard for &#x27;1&#x27; */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_H0S1    (NRF_GPIO_DRIVE_H0 | NRF_GPIO_DRIVE_S1)</span></span><br><span class=\"line\"><span class=\"comment\">/** High drive for &#x27;0&#x27; and &#x27;1&#x27; */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NRF_GPIO_DRIVE_H0H1    (NRF_GPIO_DRIVE_H0 | NRF_GPIO_DRIVE_H1)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>需要包含头文件，才可以使用这些参数</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/dt-bindings/gpio/nordic-nrf-gpio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">gpio_pin_configure_dt(&amp;my_gpio, GPIO_OUTPUT | GPIO_OPEN_DRAIN | NRF_GPIO_DRIVE_H0);</span><br><span class=\"line\"><span class=\"comment\">// 开漏输出，且低电平为高电流驱动能力</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-使用GPIO输入中断\"><a href=\"#3-3-使用GPIO输入中断\" class=\"headerlink\" title=\"3.3. 使用GPIO输入中断\"></a>3.3. 使用GPIO输入中断</h2><p>使用GPIO输入中断也很简单，参考<code>$&#123;NCS&#125;/zephyr/samples/basic/button</code>即可。具体步骤为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_pressed</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> gpio_callback *cb,<span class=\"type\">uint32_t</span> pins)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">&quot;Button pressed at %lu \\n&quot;</span>, k_cycle_get_32());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// get the gpio dt specifier</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">button</span> =</span> GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// configure pin</span></span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;button, GPIO_INPUT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// configure interrupt: rising edge</span></span><br><span class=\"line\">    gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init and add your callbacks</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_callback</span> <span class=\"title\">button_cb_data</span>;</span></span><br><span class=\"line\">    gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));</span><br><span class=\"line\">    gpio_add_callback(button.port, &amp;button_cb_data);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，不要真的拿这个代码去处理按钮。因为这个是最底层的GPIO中断，并没有按键消抖功能。</p>\n<p>按钮通常用GPIO input轮询方式实现。即使用中断实现按钮，也应该增加一个电容来去抖。</p>\n</blockquote>\n<h2 id=\"3-4-注意开发板保留GPIO\"><a href=\"#3-4-注意开发板保留GPIO\" class=\"headerlink\" title=\"3.4. 注意开发板保留GPIO\"></a>3.4. 注意开发板保留GPIO</h2><p>Nordic开发板上某些GPIO已经被板载的外设使用了，所以，在开发板上这些<strong>引脚对应的GPIO插座是没有连接的</strong>。例如52840DK：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250526155758973.png\" alt=\"image-20250526155758973\"></p>\n<p>用于NFC的引脚以及用于QSPI Flash的引脚，在开发板上都被空焊盘断开了。这些信息也可以通过开发板背面的丝印示意图获得。</p>\n<p>为了防止用户误使用这些GPIO，实际用示波器检测引脚又没有波形，浪费时间。Nordic在<strong>开发板的设备树</strong>中把这些引脚设为保留的（Reserved）。见gpio0或gpio1的设备树：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    gpio-reserved-ranges = &lt;0 2&gt;, &lt;6 1&gt;, &lt;8 3&gt;, &lt;17 7&gt;;</span><br><span class=\"line\">    gpio-line-names = &quot;XL1&quot;, &quot;XL2&quot;, &quot;AREF&quot;, &quot;A0&quot;, &quot;A1&quot;, &quot;RTS&quot;, &quot;TXD&quot;,</span><br><span class=\"line\">        &quot;CTS&quot;, &quot;RXD&quot;, &quot;NFC1&quot;, &quot;NFC2&quot;, &quot;BUTTON1&quot;, &quot;BUTTON2&quot;, &quot;LED1&quot;,</span><br><span class=\"line\">        &quot;LED2&quot;, &quot;LED3&quot;, &quot;LED4&quot;, &quot;QSPI CS&quot;, &quot;RESET&quot;, &quot;QSPI CLK&quot;,</span><br><span class=\"line\">        &quot;QSPI DIO0&quot;, &quot;QSPI DIO1&quot;, &quot;QSPI DIO2&quot;, &quot;QSPI DIO3&quot;,&quot;BUTTON3&quot;,</span><br><span class=\"line\">        &quot;BUTTON4&quot;, &quot;SDA&quot;, &quot;SCL&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gpio-reserved-ranges</code>，每个cell表示（gpio起始编号，gpio数量）的组合。以上赋值表示P0.00，P0.01，P0.06，P0.08～P0.10，P0.17～P0.23均为保留GPIO。</p>\n<p>如果用户使用了这些引脚，将会出现Assert报错，从而提示用户：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ASSERTION FAIL [(cfg-&gt;port_pin_mask &amp; (gpio_port_pins_t)(1UL &lt;&lt; (pin))) != 0U] @ WEST_TOPDIR/zephyr/include/zephyr/drivers/gpio.h:1019</span><br><span class=\"line\">        Unsupported pin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，这个保护是开发板的设备树才有的。如果你使用自定义boards，本身默认就没有配置<code>gpio-reserved-ranges</code>。</p>\n</blockquote>\n<p>如果开发者知晓自己在做什么，知晓如何控制这些GPIO，则开发者可以主动去除这一限制：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    /delete-property/ gpio-reserved-ranges;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-GPIO配置示例\"><a href=\"#3-5-GPIO配置示例\" class=\"headerlink\" title=\"3.5. GPIO配置示例\"></a>3.5. GPIO配置示例</h2><p>这里展示最复杂的情况，配置使用reset脚和NFC引脚当作gpio output使用：</p>\n<p>设备树overlay：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 使用zephyr,user节点自由放置GPIO配置</span><br><span class=\"line\">    zephyr,user&#123;</span><br><span class=\"line\">        reset-gpios = &lt;&amp;gpio0 18 GPIO_ACTIVE_HIGH&gt;;</span><br><span class=\"line\">        nfc-gpios = &lt;&amp;gpio0 9 GPIO_ACTIVE_HIGH&gt;, </span><br><span class=\"line\">                    &lt;&amp;gpio0 10 GPIO_ACTIVE_HIGH&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;uicr&#123;</span><br><span class=\"line\">    // 不把gpio当作reset使用</span><br><span class=\"line\">    /delete-property/ gpio-as-nreset;</span><br><span class=\"line\"></span><br><span class=\"line\">    // nfc引脚当作gpio使用</span><br><span class=\"line\">    nfct-pins-as-gpios;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    // 删除预留保护</span><br><span class=\"line\">    /delete-property/ gpio-reserved-ranges;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/device.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取单个的gpio specifier</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">reset_pins</span> =</span> GPIO_DT_SPEC_GET(DT_PATH(zephyr_user), reset_gpios);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取复数的gpio specifier</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">nfc_pins</span>[2] =</span> &#123;</span><br><span class=\"line\">        GPIO_DT_SPEC_GET_BY_IDX(DT_PATH(zephyr_user), nfc_gpios, <span class=\"number\">0</span>),</span><br><span class=\"line\">        GPIO_DT_SPEC_GET_BY_IDX(DT_PATH(zephyr_user), nfc_gpios, <span class=\"number\">1</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"comment\">// 设备树只包含GPIO逻辑电平。这里追加配置输入输出。</span></span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;reset_pins, GPIO_OUTPUT_INACTIVE);</span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;nfc_pins[<span class=\"number\">0</span>], GPIO_OUTPUT_INACTIVE);</span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;nfc_pins[<span class=\"number\">1</span>], GPIO_OUTPUT_INACTIVE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制GPIO输出</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        gpio_pin_toggle_dt(&amp;reset_pins);</span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">500</span>));</span><br><span class=\"line\">        gpio_pin_toggle_dt(&amp;nfc_pins[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">500</span>));</span><br><span class=\"line\">        gpio_pin_toggle_dt(&amp;nfc_pins[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">500</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际测量时，注意开发板上的空焊盘。</p>\n</blockquote>\n<h1 id=\"4-在Zephyr中分配外设引脚（pinctrl）\"><a href=\"#4-在Zephyr中分配外设引脚（pinctrl）\" class=\"headerlink\" title=\"4. 在Zephyr中分配外设引脚（pinctrl）\"></a>4. 在Zephyr中分配外设引脚（pinctrl）</h1><h2 id=\"4-1-把引脚分配给外设\"><a href=\"#4-1-把引脚分配给外设\" class=\"headerlink\" title=\"4.1. 把引脚分配给外设\"></a>4.1. 把引脚分配给外设</h2><p>从第一章我们知道，Nordic的引脚基本上可以任意分配给所有外设的。在Zephyr中，外设的引脚分配大部分使用<code>pinctrl</code>进行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设备的引脚分配，引用pinctrl节点</span></span><br><span class=\"line\">&amp;spi3 &#123;</span><br><span class=\"line\">    status = <span class=\"string\">&quot;okay&quot;</span>;</span><br><span class=\"line\">    cs-gpios = &lt;&amp;arduino_header <span class=\"number\">16</span> GPIO_ACTIVE_LOW&gt;; <span class=\"comment\">/* D10 */</span></span><br><span class=\"line\">    pinctrl<span class=\"number\">-0</span> = &lt;&amp;spi3_default&gt;;</span><br><span class=\"line\">    pinctrl<span class=\"number\">-1</span> = &lt;&amp;spi3_sleep&gt;;</span><br><span class=\"line\">    pinctrl-names = <span class=\"string\">&quot;default&quot;</span>, <span class=\"string\">&quot;sleep&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只要是用Zephyr驱动的外设，其引脚分配都在这里</span></span><br><span class=\"line\">&amp;pinctrl&#123;</span><br><span class=\"line\">    spi3_default: spi3_default &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(SPIM_SCK, <span class=\"number\">1</span>, <span class=\"number\">15</span>)&gt;, <span class=\"comment\">// P1.15</span></span><br><span class=\"line\">                &lt;NRF_PSEL(SPIM_MISO, <span class=\"number\">1</span>, <span class=\"number\">14</span>)&gt;,    <span class=\"comment\">// P1.14</span></span><br><span class=\"line\">                &lt;NRF_PSEL(SPIM_MOSI, <span class=\"number\">1</span>, <span class=\"number\">13</span>)&gt;;    <span class=\"comment\">// P1.13</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    spi3_sleep: spi3_sleep &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(SPIM_SCK, <span class=\"number\">1</span>, <span class=\"number\">15</span>)&gt;, <span class=\"comment\">// P1.15</span></span><br><span class=\"line\">                &lt;NRF_PSEL(SPIM_MISO, <span class=\"number\">1</span>, <span class=\"number\">14</span>)&gt;,    <span class=\"comment\">// P1.14</span></span><br><span class=\"line\">                &lt;NRF_PSEL(SPIM_MOSI, <span class=\"number\">1</span>, <span class=\"number\">13</span>)&gt;;    <span class=\"comment\">// P1.13</span></span><br><span class=\"line\">            low-power-enable;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个外设的节点内部有<code>pinctrl-0</code>，<code>pinctrl-1</code>这样的属性，指向<code>&amp;pinctrl</code>下的子节点。通常只有<code>default</code>和<code>sleep</code>两种状态，分别处于外设处于运行或休眠时的引脚状态。</p>\n<blockquote>\n<p>Zephyr中的外设在main之前就已经被初始化。因此程序运行后，<strong>使用Zephyr驱动的外设</strong>无法<code>uninitial</code>或<code>disable</code>，取而代之的是<code>suspend</code>和<code>resume</code>。</p>\n</blockquote>\n<p>这个其实不用太深入理解，改引脚时照葫芦画瓢即可。例如，以上代码定义了两种状态，分别叫”default”和”sleep”，两种状态的GPIO配置并不相同。当外设休眠或唤醒时，这个外设的<strong>Zephyr驱动程序</strong>会自动把这一组引脚状态适用。</p>\n<h2 id=\"4-2-外设引脚的驱动能力、上下拉、开漏推挽\"><a href=\"#4-2-外设引脚的驱动能力、上下拉、开漏推挽\" class=\"headerlink\" title=\"4.2. 外设引脚的驱动能力、上下拉、开漏推挽\"></a>4.2. 外设引脚的驱动能力、上下拉、开漏推挽</h2><p>只需注意，外设的引脚也是可以配置IO口电流驱动能力、上下拉的，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">i2c0_default: i2c0_default &#123;</span><br><span class=\"line\">    group1 &#123;</span><br><span class=\"line\">        psels = &lt;NRF_PSEL(TWIM_SDA, <span class=\"number\">0</span>, <span class=\"number\">26</span>)&gt;,</span><br><span class=\"line\">            &lt;NRF_PSEL(TWIM_SCL, <span class=\"number\">0</span>, <span class=\"number\">27</span>)&gt;;</span><br><span class=\"line\">        nordic,drive-mode = &lt;NRF_DRIVE_S0D1&gt;; <span class=\"comment\">// standard 0, disconnect 1</span></span><br><span class=\"line\">        bias-pull-up;                         <span class=\"comment\">// internal pull-up</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>具体可配置的参数，大家可以Ctrl+鼠标左键，先跳转到pinctrl节点。然后再Ctrl+鼠标左键，点进”nordic,nrf-pinctrl”，查看DeviceBinding文件即可。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0418d6bf15b39793998cb2322af376b3.png\" alt=\"image-20240416171800803\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/1d81a68b42f00bc6dbe719bb476a1883.png\" alt=\"image-20240416172102262\"></p>\n<h2 id=\"4-3-注意Bootloader引脚\"><a href=\"#4-3-注意Bootloader引脚\" class=\"headerlink\" title=\"4.3. 注意Bootloader引脚\"></a>4.3. 注意Bootloader引脚</h2><p>NCS支持MCUBOOT作为bootloader。MCUBOOT也会通过设备树来配置自己的外设引脚和GPIO。当系统上电后，先执行MCUBOOT，MCUBOOT也会初始化他自己的外设）。</p>\n<p>当MCUBOOT跳转到APPLICATION时，它不会关闭自己开启的外设。这就导致一些配置可能并未重置。</p>\n<p>最常见的是日志串口，MCUBOOT中的日志串口开启了流控，而APPLICATION的同一个串口未开启流控。这时，因为该UART的寄存器已经在bootloader阶段被配置，把对应GPIO配置成了流控引脚。导致到了Application阶段，流控引脚无法作为普通GPIO使用。</p>\n<p>解决方案就是要确保bootloader的设备树和application的设备树一直。MCUBOOT的设备树可以在当前工程的”sysbuild&#x2F;mcuboot&#x2F;“下的相关配置文件中进行修改。</p>\n<h1 id=\"5-LED与Button库\"><a href=\"#5-LED与Button库\" class=\"headerlink\" title=\"5. LED与Button库\"></a>5. LED与Button库</h1><p>前面都是GPIO的基础用法。如果你需要的只是驱动LED或者Button，可以直接使用Nordic现成的驱动API。</p>\n<h3 id=\"DK-Libary\"><a href=\"#DK-Libary\" class=\"headerlink\" title=\"DK Libary\"></a>DK Libary</h3><p>文档：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/others/dk_buttons_and_leds.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/others/dk_buttons_and_leds.html</a></p>\n<p>这是Nordic为开发板（Development Kit）提供的一个简易的库，支持<strong>4个以内的LED和Button</strong>。其中Button已经做了去抖。</p>\n<p>我们在开发板默认的Device Tree中看到的led和button节点就是为这个库服务的。许多简单的例程就是用它来控制GPIO。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">需要开启的配置</span></span><br><span class=\"line\">CONFIG_DK_LIBRARY=y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通用应用程序框架（Common-Application-Framework-CAF）\"><a href=\"#通用应用程序框架（Common-Application-Framework-CAF）\" class=\"headerlink\" title=\"通用应用程序框架（Common Application Framework, CAF）\"></a>通用应用程序框架（Common Application Framework, CAF）</h3><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/caf/index.html\">CAF</a>是Nordic为商业级应用程序开发的一个框架库。里面有蓝牙、功耗管理、SMP DFU等等模组，其中当然也包含按钮和LED。</p>\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/caf/leds.html\">CAF: LEDS</a>库提供了基本的GPIO LED和PWM LED功能，<strong>并且可以配置灯效</strong>。</p>\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/caf/buttons.html\">CAF: Buttons</a>库除了提供基本的Button去抖功能以外，还支持低功耗（不用时把按钮disable掉），<strong>并且支持矩阵键盘</strong>。</p>\n<h1 id=\"6-GPIO映射（GPIO-nexus）\"><a href=\"#6-GPIO映射（GPIO-nexus）\" class=\"headerlink\" title=\"6. GPIO映射（GPIO nexus）\"></a>6. GPIO映射（GPIO nexus）</h1><p>nRF52和nRF53系列的开发板上面的GPIO插座都是兼容Ardiono UNO接口的。</p>\n<p>因此开发板的默认设备树中有默认定义，例如<code>v3.0.0/zephyr/boards/nordic/nrf52840dk/nrf52840dk_nrf52840.dts</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">arduino_header: connector &#123;</span><br><span class=\"line\">    compatible = &quot;arduino-header-r3&quot;;</span><br><span class=\"line\">    #gpio-cells = &lt;2&gt;;</span><br><span class=\"line\">    gpio-map-mask = &lt;0xffffffff 0xffffffc0&gt;;</span><br><span class=\"line\">    gpio-map-pass-thru = &lt;0 0x3f&gt;;</span><br><span class=\"line\">    gpio-map = &lt;0 0 &amp;gpio0 3 0&gt;,\t/* A0 */</span><br><span class=\"line\">           &lt;1 0 &amp;gpio0 4 0&gt;,\t/* A1 */</span><br><span class=\"line\">           &lt;2 0 &amp;gpio0 28 0&gt;,\t/* A2 */</span><br><span class=\"line\">           &lt;3 0 &amp;gpio0 29 0&gt;,\t/* A3 */</span><br><span class=\"line\">           &lt;4 0 &amp;gpio0 30 0&gt;,\t/* A4 */</span><br><span class=\"line\">           &lt;5 0 &amp;gpio0 31 0&gt;,\t/* A5 */</span><br><span class=\"line\">           &lt;6 0 &amp;gpio1 1 0&gt;,\t/* D0 */</span><br><span class=\"line\">           &lt;7 0 &amp;gpio1 2 0&gt;,\t/* D1 */</span><br><span class=\"line\">           &lt;8 0 &amp;gpio1 3 0&gt;,\t/* D2 */</span><br><span class=\"line\">           &lt;9 0 &amp;gpio1 4 0&gt;,\t/* D3 */</span><br><span class=\"line\">           &lt;10 0 &amp;gpio1 5 0&gt;,\t/* D4 */</span><br><span class=\"line\">           &lt;11 0 &amp;gpio1 6 0&gt;,\t/* D5 */</span><br><span class=\"line\">           &lt;12 0 &amp;gpio1 7 0&gt;,\t/* D6 */</span><br><span class=\"line\">           &lt;13 0 &amp;gpio1 8 0&gt;,\t/* D7 */</span><br><span class=\"line\">           &lt;14 0 &amp;gpio1 10 0&gt;,\t/* D8 */</span><br><span class=\"line\">           &lt;15 0 &amp;gpio1 11 0&gt;,\t/* D9 */</span><br><span class=\"line\">           &lt;16 0 &amp;gpio1 12 0&gt;,\t/* D10 */</span><br><span class=\"line\">           &lt;17 0 &amp;gpio1 13 0&gt;,\t/* D11 */</span><br><span class=\"line\">           &lt;18 0 &amp;gpio1 14 0&gt;,\t/* D12 */</span><br><span class=\"line\">           &lt;19 0 &amp;gpio1 15 0&gt;,\t/* D13 */</span><br><span class=\"line\">           &lt;20 0 &amp;gpio0 26 0&gt;,\t/* D14 */</span><br><span class=\"line\">           &lt;21 0 &amp;gpio0 27 0&gt;;\t/* D15 */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>gpio-map</code>规定了nRF52840的GPIO是如何映射到Arduino UNO接口的，基本规则为：</p>\n<table>\n<thead>\n<tr>\n<th>Arduino引脚编号</th>\n<th>Arduino引脚配置</th>\n<th>nRF gpio controller</th>\n<th>nRF引脚编号</th>\n<th>nRF引脚配置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td>gpio0</td>\n<td>3</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>gpio0</td>\n<td>4</td>\n<td>0</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p><code>#gpio-cells</code>表示的是GPIO的设备树配置有几个<code>uint32</code>单元，这里的2就表示<code>&lt;0 0&gt;</code>这样的配置单元长度是2。在Zephyr中GPIO的配置基本都是2个单元，一个代表引脚号，一个代表配置的标志位（flags）。</p>\n<p><code>gpio-map-mask</code>：引脚映射时忽略一些特定的bit。比如，<code>&lt;&amp;arduino_header 11 1&gt;</code>，在<code>gpio-map</code>中并没有映射吗，<code>gpio-map</code>中只有<code>&lt;11 0&gt;</code>。而<code>gpio-map-mask</code>会和这两个cell进行<strong>按位与运算</strong>，从而忽略最低的6个bit，将其全部变成0。于是就能匹配上<code>&lt;11 0 &amp;gpio1 6 0&gt;</code>，从而知道是P1.06。</p>\n<p><code>gpio-map-pass-thru</code>：在引脚匹配完成之后，把之前忽略的引脚配置传递过去。也就是把最低6bit的引脚配置传递给nRF52的驱动。</p>\n<p><strong>为什么要有转接定义？</strong>举例来说，Nordic的nRF7002EK扩展板：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fbb3c06dc66d64e255569adf6696fe9c.webp\" alt=\"nRF7002 EK\"></p>\n<p>为什么这个扩展板可以同时兼容nRF52，nRF53和nRF91，而不用在乎这些开发板的引脚编号不同？</p>\n<p>因为扩展板设备树的定义采用的是Arduino引脚编号。只要开发板上有Ardiono引脚定义，就可以实现兼容。见<code>zephyr/boards/shields/nrf7002ek/nrf7002ek.overlay</code>。</p>\n<p>GPIO NEXUS的设计比较适合<strong>开发自己的模块</strong>的场景。你只需要定义自己的device tree bindings文件，就可以在设备树中定义自己的GPIO nexus节点。</p>\n<p>自定义device tree bindings文件，<strong>位置</strong>在你的工程目录下，例如<code>&lt;my_project&gt;/dts/bindings/xxxx.yaml</code>。</p>\n<p>其内容可以参考Ardiono转接头的定义，位于：<code>v3.0.0/zephyr/dts/bindings/gpio/arduino-header-r3.yaml</code>。</p>\n<p>只要设备树和bindings文件的compatible相同，就会自动识别。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Copyright (c) 2019 Foundries.io</span></span><br><span class=\"line\"><span class=\"comment\"># Copyright (C) 2019 Peter Bigot Consulting, LLC</span></span><br><span class=\"line\"><span class=\"comment\"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    GPIO pins exposed on Arduino Uno (R3) headers.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">    <span class=\"string\">The</span> <span class=\"string\">Arduino</span> <span class=\"string\">Uno</span> <span class=\"string\">layout</span> <span class=\"string\">provides</span> <span class=\"string\">four</span> <span class=\"string\">headers,</span> <span class=\"string\">two</span> <span class=\"string\">each</span> <span class=\"string\">along</span></span><br><span class=\"line\">    <span class=\"string\">opposite</span> <span class=\"string\">edges</span> <span class=\"string\">of</span> <span class=\"string\">the</span> <span class=\"string\">board.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">Proceeding counter-clockwise:</span></span><br><span class=\"line\">    <span class=\"string\">*</span> <span class=\"string\">An</span> <span class=\"number\">8</span><span class=\"string\">-pin</span> <span class=\"string\">Power</span> <span class=\"string\">Supply</span> <span class=\"string\">header.</span>  <span class=\"literal\">No</span> <span class=\"string\">pins</span> <span class=\"string\">on</span> <span class=\"string\">this</span> <span class=\"string\">header</span> <span class=\"string\">are</span> <span class=\"string\">exposed</span></span><br><span class=\"line\">      <span class=\"string\">by</span> <span class=\"string\">this</span> <span class=\"string\">binding.</span></span><br><span class=\"line\">    <span class=\"string\">*</span> <span class=\"string\">A</span> <span class=\"number\">6</span><span class=\"string\">-pin</span> <span class=\"string\">Analog</span> <span class=\"string\">Input</span> <span class=\"string\">header.</span>  <span class=\"string\">This</span> <span class=\"string\">has</span> <span class=\"string\">analog</span> <span class=\"string\">input</span> <span class=\"string\">signals</span></span><br><span class=\"line\">      <span class=\"string\">labeled</span> <span class=\"string\">from</span> <span class=\"string\">A0</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">top</span> <span class=\"string\">through</span> <span class=\"string\">A5</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">bottom.</span></span><br><span class=\"line\">    <span class=\"string\">*</span> <span class=\"string\">An</span> <span class=\"number\">8</span><span class=\"string\">-pin</span> <span class=\"string\">header</span> <span class=\"string\">(opposite</span> <span class=\"string\">Analog</span> <span class=\"string\">Input).</span>  <span class=\"string\">This</span> <span class=\"string\">has</span> <span class=\"string\">digital</span> <span class=\"string\">input</span></span><br><span class=\"line\">      <span class=\"string\">signals</span> <span class=\"string\">labeled</span> <span class=\"string\">from</span> <span class=\"string\">D0</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">bottom</span> <span class=\"string\">D7</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">top;</span></span><br><span class=\"line\">    <span class=\"string\">*</span> <span class=\"string\">A</span> <span class=\"number\">10</span><span class=\"string\">-pin</span> <span class=\"string\">header</span> <span class=\"string\">(opposite</span> <span class=\"string\">Power</span> <span class=\"string\">Supply).</span>  <span class=\"string\">This</span> <span class=\"string\">has</span> <span class=\"string\">six</span> <span class=\"string\">additional</span></span><br><span class=\"line\">      <span class=\"string\">digital</span> <span class=\"string\">input</span> <span class=\"string\">signals</span> <span class=\"string\">labelled</span> <span class=\"string\">from</span> <span class=\"string\">D8</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">bottom</span> <span class=\"string\">through</span> <span class=\"string\">D13</span></span><br><span class=\"line\">      <span class=\"string\">towards</span> <span class=\"string\">the</span> <span class=\"string\">top,</span> <span class=\"string\">skipping</span> <span class=\"string\">two</span> <span class=\"string\">pins,</span> <span class=\"string\">then</span> <span class=\"string\">finishing</span> <span class=\"string\">with</span> <span class=\"string\">D14</span> <span class=\"string\">and</span></span><br><span class=\"line\">      <span class=\"string\">D15</span> <span class=\"string\">at</span> <span class=\"string\">the</span> <span class=\"string\">top.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">This</span> <span class=\"string\">binding</span> <span class=\"string\">provides</span> <span class=\"string\">a</span> <span class=\"string\">nexus</span> <span class=\"string\">mapping</span> <span class=\"string\">for</span> <span class=\"number\">20</span> <span class=\"string\">pins</span> <span class=\"string\">where</span> <span class=\"string\">parent</span> <span class=\"string\">pins</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"string\">through</span> <span class=\"number\">5</span> <span class=\"string\">correspond</span> <span class=\"string\">to</span> <span class=\"string\">A0</span> <span class=\"string\">through</span> <span class=\"string\">A5,</span> <span class=\"string\">and</span> <span class=\"string\">parent</span> <span class=\"string\">pins</span> <span class=\"number\">6</span> <span class=\"string\">through</span> <span class=\"number\">21</span></span><br><span class=\"line\">    <span class=\"string\">correspond</span> <span class=\"string\">to</span> <span class=\"string\">D0</span> <span class=\"string\">through</span> <span class=\"string\">D15,</span> <span class=\"attr\">as depicted below:</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                 <span class=\"string\">D15</span>  <span class=\"number\">21</span></span><br><span class=\"line\">                                 <span class=\"string\">D14</span>  <span class=\"number\">20</span></span><br><span class=\"line\">                                 <span class=\"string\">AREF</span> <span class=\"bullet\">-</span></span><br><span class=\"line\">                                 <span class=\"string\">GND</span>  <span class=\"bullet\">-</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">N/C</span>                    <span class=\"string\">D13</span>  <span class=\"number\">19</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">IOREF</span>                  <span class=\"string\">D12</span>  <span class=\"number\">18</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">RESET</span>                  <span class=\"string\">D11</span>  <span class=\"number\">17</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">3V3</span>                    <span class=\"string\">D10</span>  <span class=\"number\">16</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">5V</span>                     <span class=\"string\">D9</span>   <span class=\"number\">15</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">GND</span>                    <span class=\"string\">D8</span>   <span class=\"number\">14</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">GND</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">VIN</span>                    <span class=\"string\">D7</span>   <span class=\"number\">13</span></span><br><span class=\"line\">                                 <span class=\"string\">D6</span>   <span class=\"number\">12</span></span><br><span class=\"line\">        <span class=\"number\">0</span> <span class=\"string\">A0</span>                     <span class=\"string\">D5</span>   <span class=\"number\">11</span></span><br><span class=\"line\">        <span class=\"number\">1</span> <span class=\"string\">A1</span>                     <span class=\"string\">D4</span>   <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"number\">2</span> <span class=\"string\">A2</span>                     <span class=\"string\">D3</span>    <span class=\"number\">9</span></span><br><span class=\"line\">        <span class=\"number\">3</span> <span class=\"string\">A3</span>                     <span class=\"string\">D2</span>    <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"number\">4</span> <span class=\"string\">A4</span>                     <span class=\"string\">D1</span>    <span class=\"number\">7</span></span><br><span class=\"line\">        <span class=\"number\">5</span> <span class=\"string\">A5</span>                     <span class=\"string\">D0</span>    <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">compatible:</span> <span class=\"string\">&quot;arduino-header-r3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">include:</span> [<span class=\"string\">gpio-nexus.yaml</span>, <span class=\"string\">base.yaml</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Nordic"],"tags":["Nordic","Zephyr","DeviceTree","GPIO","GPIOTE","PPI"]},{"title":"Zephyr驱动与设备树实战——串口","url":"/jayant97.github.io/2023/11/4c8e1d7d162d/","content":"<blockquote>\n<p>2025.7.26更新：</p>\n<ul>\n<li>新增54L15串口硬件介绍</li>\n<li>新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。</li>\n<li>增加全新的串口例程代码并上传GitHub</li>\n</ul>\n<p>2025.5.5更新：</p>\n<ul>\n<li>增加了对串口硬件的介绍</li>\n<li>增加串口API更详细的介绍与图示</li>\n</ul>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。</p>\n<p>今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中<code>zephyr/samples/hello_world</code>例程为基础。分别添加<strong>串口</strong>、<strong>USB CDC ACM</strong>、<strong>低功耗串口</strong>的功能。采用<strong>完全相同的应用层代码</strong>，只需要修改config和dts即可切换。</p>\n<h1 id=\"2-Hello-world解析—printk如何输出\"><a href=\"#2-Hello-world解析—printk如何输出\" class=\"headerlink\" title=\"2. Hello world解析—printk如何输出\"></a>2. Hello world解析—printk如何输出</h1><p>开发板我选择nRF52840DK。首先以<code>zephyr/samples/hello_world</code>例程为模板，创建一个新工程，我在这里把工程命名为<code>learning_zephyr_serial</code>。</p>\n<h2 id=\"工程目录结构\"><a href=\"#工程目录结构\" class=\"headerlink\" title=\"工程目录结构\"></a>工程目录结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|--src</span><br><span class=\"line\">|  |</span><br><span class=\"line\">|  `--main.c</span><br><span class=\"line\">|--CMakeLists.txt</span><br><span class=\"line\">`--prj.conf</span><br></pre></td></tr></table></figure>\n\n<p><code>CMakeLists.txt</code>中先把Zephyr作为包来导入，然后把main.c添加为源码。</p>\n<p><code>prj.conf</code>目前是空的，在这里可以写一些配置用来覆盖默认的Kconfig。</p>\n<p>例程默认没使用<code>Kconfig</code>菜单文件，是因为本工程太简单，没有自己的配置项，所以不需要自己的Kconfig文件。这种情况完全等价于Kconfig文件中只写了下面的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>\n\n<p>相当于项目中只有Zephyr的菜单，可以让我们配置Zephyr系统的配置项，以及SDK中各个module的的配置项。选择板子，编译并烧录后，打开串口，reset一下，就能看到刚启动时串口输出的hello world了。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8065d44b86cceb9ff0e8b1ab1417eda2.png\" alt=\"image-20231112183822534\"></p>\n<h2 id=\"printk输出配置\"><a href=\"#printk输出配置\" class=\"headerlink\" title=\"printk输出配置\"></a>printk输出配置</h2><p>很多新上手Zephyr的读者会有疑惑，这工程里几乎没什么代码，也没看到CONFIG和device tree文件，串口到底是怎么输出的？</p>\n<p>其实，在我们选择板子时，板子就已经自带了默认的device tree和config文件。因此编译时采用的全部是板子和Zephyr系统的默认值，我们的工程中并没有对这些默认值进行修改。</p>\n<p>我们可以在<code>build/zephyr/</code>目录下看到<code>.config</code>文件和<code>zephyr.dts</code>文件。这个就是项目最终编译采用的配置项和设备树。</p>\n<p>在<code>.config</code>中，我们可以看到：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_PRINTK=y</span><br></pre></td></tr></table></figure>\n\n<p>也就是启用了<code>printk()</code>输出的功能。</p>\n<p>我们把这一行复制到prj.conf中（这个行为本身没有意义，因为默认就是y），然后就可以用<strong>Ctrl+鼠标左键</strong>点击这个选项，跳转到这个配置项定义的地方，就可以看到这个配置项的说明：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a2ee0a066378d3944f23bccfebfedc5f.png\" alt=\"image-20231112184745524\"></p>\n<p>当然，你也可以在Kconfig GUI中找到这个配置项：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/09529eaa5aec7ff3197ab355163f7b47.png\" alt=\"image-20231112184921595\"></p>\n<blockquote>\n<p>到这里，是否对“<code>Kconfig</code>定义了一个菜单，而<code>prj.conf</code>文件是对菜单中配置项的默认值进行修改”这句话有了一定的感受呢？</p>\n</blockquote>\n<h2 id=\"console设备与console驱动\"><a href=\"#console设备与console驱动\" class=\"headerlink\" title=\"console设备与console驱动\"></a>console设备与console驱动</h2><p>根据此配置项的说明，我们知道<code>printk()</code>是Zephyr的一个内核服务，它可以让通过<code>printk()</code>函数打印的内容通过”console”输出。这里的console指的是一个设备，可以让Zephyr系统输入和输出字节流。</p>\n<p>通过查看<code>build/zephyr/zephyr.dts</code>，可以看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">    chosen &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        zephyr,console = &amp;uart0;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在<code>/chosen</code>节点下，有很多<strong>属性</strong>。Zephyr系统内核的代码在运行一些功能时，并不在乎底层的硬件具体是什么，它只从<code>/chosen</code>节点下找到对应的硬件。只要这个硬件已经在RTOS初始化之前就被驱动程序初始化了，具有Zephyr标准外设接口，那么Zephyr内核就可以操作这个硬件。</p>\n<p>例如，要想获得这里的console设备的DeviceTree Node ID，就可以用<code>DT_CHOSEN(zephyr_console)</code>。</p>\n<p>我们自然可以联想到，可以把console换成其他<strong>串口设备</strong>，就可以让日志从其他串口输出了。这里，可以参考我的另一篇随笔<a href=\"https://www.cnblogs.com/jayant97/p/17784156.html\">《Zephyr重定向日志打印到USB串口》</a>。</p>\n<p>如果你只是修改设备树中的console设备，那么不管如何修改，输出日志的设备都必须是一个“串口”（在Zephyr中USB CDC ACM设备也是串口，后文会解释）。在<code>build/zephyr/.config</code>中，我们还可以看到：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_UART_CONSOLE=y</span><br></pre></td></tr></table></figure>\n\n<p>原来，在当前配置下，Zephyr默认的console后端都必须是“串口”设备。</p>\n<p>我们可以尝试把console后端改成RTT，在<code>prj.conf</code>中，添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_UART_CONSOLE=n</span><br><span class=\"line\">CONFIG_RTT_CONSOLE=y</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/551a9a209c0745054d3342e2217c28c8.png\" alt=\"image-20231112191457497\"></p>\n<p>然后就可以看到，printk()的日志从RTT中打印出来了。</p>\n<p>对于探究心强的读者，到这里肯定又会有疑问：为什么把console后端改成了RTT，只改了config，设备树就不用改了？</p>\n<p>关于这个问题，我想先传达出一个观点，那就是一个系统无论使用了什么样的框架，<strong>最终一定要落实到代码</strong>。通过在NCS中全局搜索<code>CONFIG_RTT_CONSOLE</code>和<code>CONFIG_UART_CONSOLE</code>，我们最终能找到这样的一个文件，<code>$&#123;NCS&#125;/zephyr/drivers/console/CMakeLists.txt</code>：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_RTT_CONSOLE rtt_console.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_UART_CONSOLE uart_console.c)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>console本身作为一个中间件，也是要通过驱动程序向Zephyr提供标准console API的。在这里，CMake根据不同的CONFIG配置项，添加了不同的console驱动源码进入系统之中，进行编译。</p>\n<p>在uart_console.c中，我们明显能看到，此驱动代码需要通过device tree来找到标准的串口设备，然后调用标准的串口API来通信。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">const</span> <span class=\"title\">uart_console_dev</span> =</span></span><br><span class=\"line\">    DEVICE_DT_GET(DT_CHOSEN(zephyr_console));</span><br></pre></td></tr></table></figure>\n\n<p>而在rtt_console.c中，我们可以看到此代码不需要获取任何device tree的信息。因此，当我们选择RTT作为后端时，无论device tree中的<code>/chosen</code>节点中如何选择<code>zephyr,console</code>，对于RTT console驱动代码来说都是没有意义的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过前面的分析，我们可以有以下结论：</p>\n<p>首先，在Zephyr系统中有许多功能，我们可以用Kconfig的方式进行配置或裁减。</p>\n<p>此外，Zephyr中有非常明显的“分层设计”，例如，Nordic提交nrf系列串口驱动代码，提供Zephyr标准串口API；Zephyr有console驱动代码，向更上层提供标准console API；如果console是串口驱动，它还会调用标准串口 API来把日志输出到底层串口中；由于API是标准的，因此console驱动代码并不在乎底层到底是物理串口还是USB CDC ACM设备。</p>\n<p>前面分析了Hello world是如何通过console输出的。在Zephyr中，console主要是用来做一些字节流的传输，用来实现一些更上层的服务，例如自定义<code>shell</code>命令。而用户要开发自己的程序，肯定是需要自己直接操作串口，而不是用什么printf。</p>\n<h1 id=\"3-Nordic串口硬件\"><a href=\"#3-Nordic串口硬件\" class=\"headerlink\" title=\"3. Nordic串口硬件\"></a>3. Nordic串口硬件</h1><h2 id=\"UART\"><a href=\"#UART\" class=\"headerlink\" title=\"UART\"></a>UART</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/47b66b8aa6839171773ff5e5abf53fb5.png\" alt=\"image-20250505231527537\"></p>\n<p>UART是最简单的硬件串口功能。图中小正方形为对外的硬件引脚，而箭头代表串口在MCU内部的输入、输出信号。</p>\n<ul>\n<li><p><strong>接收</strong>：在串口接收已经使能（STARTRX）的状态下，从RX线来的数据会被放入RXD寄存器，并产生RXDRDY事件。​</p>\n<p>接收FIFO长度为6。RXD的数据被CPU读取后，立即从FIFO中把下一个数据填入RXD，并产生RXDRDY事件。（若使能流控，会在FIFO还剩4个空位时把RTS拉高以阻止对方发送）</p>\n</li>\n<li><p><strong>发送</strong>：在串口发送已使能（STARTTX）的情况下，向TXD写入1个字节就会发送。发送完毕后，UART产生TXDRDY事件。</p>\n</li>\n</ul>\n<p>这些事件都能用来触发中断，或者作为PPI信号触发其他外设的task。</p>\n<h2 id=\"UARTE\"><a href=\"#UARTE\" class=\"headerlink\" title=\"UARTE\"></a>UARTE</h2><p>UARTE和UART是不同的外设，但是共用了部分寄存器和电路。在使用时，这种具有相同地址的外设被称为同一个<strong>实例（Instance）</strong>，<strong>不能同时使能</strong>。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fc3805662646766f565b4b9f4c4e2c3b.png\" alt=\"image-20250505232121430\"></p>\n<p>他们的ENABLE寄存器地址是相同的，但是使能所用的bit不同：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fcca18a4a9b88168f161c24e7088e1cc.png\" alt=\"image-20250505232133627\"></p>\n<p>UARTE (UART with EasyDMA) 功能和UART是类似的，只不过有了EasyDMA的帮助，可以自动从RAM中取出数据发出；也可以把收到的数据直接存入RAM。无需CPU参与单个字节的收发处理，提升了效率，降低了功耗。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0a3a5712a20c3b9b9dda64a66061394e.png\" alt=\"image-20250505232323499\"></p>\n<h3 id=\"UARTE发送逻辑\"><a href=\"#UARTE发送逻辑\" class=\"headerlink\" title=\"UARTE发送逻辑\"></a>UARTE发送逻辑</h3><p> <img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3b12c40231d46b93b26dffabd1d6874c.png\" alt=\"image-20250505232526893\"></p>\n<ol>\n<li>TXD.PTR填入数据在RAM中的首地址，TXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>\n<li>使用STARTTX来启动自动的传输</li>\n<li>传输完毕后，有ENDTX事件提示</li>\n<li>中间每个字节的TXDRDY事件，CPU可以无视</li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li><strong>串口的发送功能</strong>只在<strong>STARTTX和ENDTX之间</strong>有功耗，其余时间几乎不产生电流消耗</li>\n<li>EasyDMA只能在RAM和外设之间传输数据，不能在RAM之间传输，也不能有FLASH参与。</li>\n</ul>\n</blockquote>\n<h3 id=\"UARTE接收逻辑\"><a href=\"#UARTE接收逻辑\" class=\"headerlink\" title=\"UARTE接收逻辑\"></a>UARTE接收逻辑</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4a1b1a2b4f6c7d42deed43321b23e45f.png\" alt=\"image-20250505232812582\"></p>\n<ol>\n<li>RXD.PTR填入数据首地址，RXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>\n<li>使用STARTRX来启动自动的接收</li>\n<li>传输完毕后（指RAM中存的数据长度已经达到了MAXCNT），有ENDRX事件提示</li>\n<li>中间每个字节的RXDRDY事件，无需再使能中断（从而降低功耗，提高CPU效率）</li>\n</ol>\n<p>特别地，RXD.PTR具有双缓存（影子寄存器）。也就是说，不用等到传输完成，只需在第一次接收开始后（RXSTARTED），就马上给RXD.PTR写入下一次要用的buffer首地址。这样下次传输时，就能立刻用上新的buffer。便于应用层实现<strong>双buffer</strong>。</p>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>串口在接收状态（STARTRX）会有功耗，有几百uA。因此需要避免待机时一直开着RX。</li>\n<li>UARTE只有在接收完毕（buffer满）时才会产生中断。本身没有空闲帧中断，或者说超时机制。需要其他外设辅助实现。</li>\n</ul>\n</blockquote>\n<h2 id=\"nRF54系列UARTE硬件新功能\"><a href=\"#nRF54系列UARTE硬件新功能\" class=\"headerlink\" title=\"nRF54系列UARTE硬件新功能\"></a>nRF54系列UARTE硬件新功能</h2><p>以nRF54L15为例，有以下功能更新：</p>\n<h3 id=\"（1）-4Mbps串口\"><a href=\"#（1）-4Mbps串口\" class=\"headerlink\" title=\"（1） 4Mbps串口\"></a>（1） 4Mbps串口</h3><p>在默认低频时钟域（16MHz）的情况下，串口的波特率可以由寄存器设置，如下最高为1Mbps。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/894689018edad6a0629abdbdda936465.png\" alt=\"image-20250726225627521\"></p>\n<p>但是，nRF54L15的 <strong>UARTE00</strong> 位于MCU PowerDomain，其时钟频率为128MHz：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/32231108676d0bbe54cf8b10b61a32ea.png\" alt=\"image-20250726225904621\"></p>\n<p>这时，串口的实际波特率就和寄存器中的定义不相同，实际的公式手册中已经给出。</p>\n<p>但是我们做软件开发时无需关心这部分，因为在54L15芯片的原始设备树dtsi中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">uart00: uart@4a000 &#123;</span><br><span class=\"line\">    compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class=\"line\">    reg = &lt;0x4a000 0x1000&gt;;</span><br><span class=\"line\">    interrupts = &lt;74 NRF_DEFAULT_IRQ_PRIORITY&gt;;</span><br><span class=\"line\">    clocks = &lt;&amp;hfpll&gt;;</span><br><span class=\"line\">    status = &quot;disabled&quot;;</span><br><span class=\"line\">    endtx-stoptx-supported;</span><br><span class=\"line\">    frame-timeout-supported;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其已经指明了使用的是hfpll时钟。</p>\n<p>然后，在最新（目前为NCS v3.0.2）的UARTE的驱动代码<code>uart_nrfx_uarte.c</code>中，已经自动考虑了低频时钟和高频时钟的情况：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* When calculating baudrate we need to take into account that high speed instances</span></span><br><span class=\"line\"><span class=\"comment\"> * must have baudrate adjust to the ratio between UARTE clocking frequency and 16 MHz.</span></span><br><span class=\"line\"><span class=\"comment\"> * Additionally, &gt;1Mbaud speeds are calculated using a formula.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UARTE_GET_BAUDRATE2(f_pclk, current_speed)                    \\</span></span><br><span class=\"line\"><span class=\"meta\">    ((f_pclk &gt; NRF_UARTE_BASE_FREQUENCY_16MHZ) &amp;&amp; (current_speed &gt; 1000000)) ?\t\\</span></span><br><span class=\"line\"><span class=\"meta\">        UARTE_GET_CUSTOM_BAUDRATE(f_pclk, current_speed) :\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">        (NRF_BAUDRATE(current_speed) / UARTE_GET_BAUDRATE_DIV(f_pclk))</span></span><br></pre></td></tr></table></figure>\n\n<p>因此我们在软件上是感知不到这个差别的，只需正常配置我们需要的波特率即可。需要4M就配置<code>current-speed = &lt;4000000&gt;</code>；需要115200就配置<code>current-speed = &lt;115200&gt;</code>。</p>\n<h3 id=\"（2）支持4至9bits-帧\"><a href=\"#（2）支持4至9bits-帧\" class=\"headerlink\" title=\"（2）支持4至9bits 帧\"></a>（2）支持4至9bits 帧</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/6567df1a02e316811b9c173667ee9705.png\" alt=\"image-20250726231953984\"></p>\n<p>数据帧支持被配置为4bit ~ 9bit。</p>\n<p>其中，当配置为9bit时，第9个bit是地址位。当其为1时，代表前8个bits是地址；当其为0时，代表前8个是数据。</p>\n<p>且9bit模式下，只有先收到地址和ADDRESS寄存器匹配的第一个地址包时，才会接收后面的数据包。否则忽略所有收到的串口数据。</p>\n<h3 id=\"（3）帧超时中断\"><a href=\"#（3）帧超时中断\" class=\"headerlink\" title=\"（3）帧超时中断\"></a>（3）帧超时中断</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b893b6f7b506da554c2fb02217dda58c.png\" alt=\"image-20250726232649715\"></p>\n<p>帧超时中断，或者说空闲帧中断，指的是：</p>\n<ul>\n<li>当连续一定时间没有收到串口数据时，就认为传输已经结束</li>\n<li>此时不再等待DMA缓冲存满，而是直接产生DMA传输完成中断</li>\n<li>应用层可以及时把数据取出进行处理</li>\n</ul>\n<p>之前的nRF52和53系列是没有这个功能的，需要操作系统软定时器进行计时，把一个timeout分成5份设定k_timer周期。如果每次软定时器到期，串口已经收到的数据量没有增长，那么就说明串口空闲了。这时由驱动层软件主动结束串口接收。这就不如nRF54系列UARTE硬件自带空闲帧超时来的方便。</p>\n<p>只有<strong>异步串口</strong>才需要这个功能。因为<strong>阻塞</strong>和<strong>基于中断</strong>的串口都是按字节实时同步接收串口数据的。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/54c73f2e0da701646bbed68f13480de9.png\" alt=\"image-20250726233308626\"></p>\n<p>空闲帧中断最大超时时间为 2^10 - 1&#x3D; 1023 bits。在115200波特率下，大约是8.88ms。而使用软定时器的方式，可以设置更长时间。</p>\n<p>nRF54L15的设备树默认开启了空闲帧的功能。如果你不需要，可以在设备树去掉这个配置，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uart20 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    /delete-property/ frame-timeout-supported;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>异步串口初始化时，通过<code>uart_rx_enable(dev, buf, len, timeout)</code>打开RX时，传入的timeout值（单位：微秒）会经过如下处理：</p>\n<ul>\n<li>如果开启了空闲帧中断，则取应用层传入的 timeout 和 1023 bits 之中，取时间更短的一个，会被设置到FRAMETIMEOUT寄存器中</li>\n<li>如果没开启空闲帧中断，则用k_timer实现此功能</li>\n</ul>\n<h1 id=\"4-Zephyr标准串口API\"><a href=\"#4-Zephyr标准串口API\" class=\"headerlink\" title=\"4. Zephyr标准串口API\"></a>4. Zephyr标准串口API</h1><p>上一节以nRF52系列的串口外设为例介绍了硬件部分，Nordic其他产品的串口基本也是一致的。</p>\n<p>本节介绍Zephyr中的串口API。</p>\n<p>Zephyr中的串口API分为**<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-polling-api\">阻塞（Polling）</a><strong>、</strong><a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-interrupt-api\">基于中断（Interrupt-driven）</a>**、<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-async-api\"><strong>异步（Asynchronous）</strong></a>三种。</p>\n<p>Zephyr串口API是一套软件接口，与硬件细节无关。除了Nordic的UART&#x2F;UARTE硬件可以用这套接口，其他厂商的串口实现也可以支持这套接口。甚至我们后面会介绍到的USB虚拟串口，也支持这套接口。这里给出<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html\">Zephyr标准串口API文档</a>，供参考。</p>\n<blockquote>\n<p>NCS中的例程太多，对于不熟悉的人来说，随便复制代码，很有可能出现：代码里用的是一种API，但CONFIG使能的却是另一种API的情况，最终导致程序无法运行。</p>\n<p>一般来说，同一个串口实例，基于中断的和异步的API是不能同时使用的。但是阻塞的API可以和前两者中的一种混用。</p>\n</blockquote>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><p>基于阻塞的API是最简单的API。</p>\n<ul>\n<li><code>uart_poll_in()</code>：读取时，只读一个字节。有就返回0，无就返回-1，不阻塞；</li>\n<li><code>uart_poll_out()</code>：发送时，只发一个字节。发送完毕后才返回，阻塞行为。</li>\n</ul>\n<h2 id=\"基于中断\"><a href=\"#基于中断\" class=\"headerlink\" title=\"基于中断\"></a>基于中断</h2><p>首先声明，Zephyr串口API是一套软件接口，<strong>与硬件细节无关</strong>。基于中断的API只是抽象地认为有串口外设<strong>应当有</strong>发送ready中断和接收ready中断。具体如何映射到硬件？完全由厂商提供的驱动代码实现，不需要应用开发者实现。这也是USB虚拟串口也能使用这套API的原因。</p>\n<p>NCS中，使用串口中断API的例程很多。<strong>但是它们在应用层编写callback函数的方式五花八门，与应用层本身的功能混在一起，这对于初学者来说容易抓不到重点</strong>。这也侧面说明，中断API适合添加一些应用层自定义的东西。因此我在这里总结出基于中断的API的使用流程，方便开发者结合代码进行观看。</p>\n<p>以下为流程：</p>\n<ol>\n<li>开始时，用<code>uart_irq_callback_set()</code>函数设置好“应用层的”中断回调函数，这个函数会在串口ISR中根据情况被串口驱动程序调用。然后，开启<code>uart_irq_rx_enable()</code>，使能接收。</li>\n<li>要发送时，先准备好要发送的数据（首地址和长度），然后<code>uart_irq_tx_enable()</code>开启发送中断。</li>\n<li>发生中断，进入预先设置好的回调函数时，先用<code>uart_irq_update()</code>更新中断状态，再用<code>uart_irq_is_pending()</code>判断是否有中断（以防是别处误调用了该回调函数）。再之后用<code>uart_irq_tx_ready()</code>和<code>uart_irq_rx_ready()</code>来判断是发送中断还是接收中断。</li>\n<li>如果是接收中断，<strong>在中断里</strong>用<code>uart_fifo_read()</code>循环读取，每次读取1个字节（Nordic的驱动实现是只读1个字节），直到返回值为0（表示缓存里已无数据）。</li>\n<li>如果是发送中断，说明发送器已经ready，<strong>在中断里</strong>用<code>uart_irq_tx_fill()</code>，把前面准备好要发送的数据传入，即可发送。</li>\n</ol>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>不要在中断callback里进行耗时的处理和阻塞行为。善用queue和work queue。</li>\n<li><code>uart_fifo_read()</code>和<code>uart_fifo_fill()</code>只能在这个中断callback函数内部调用</li>\n</ul>\n</blockquote>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步API是本文介绍的重点，它带有DMA，因此可以让数据传输时，不影响CPU的运行。但是它的配置最复杂，功能最强大。</p>\n<h3 id=\"异步发送\"><a href=\"#异步发送\" class=\"headerlink\" title=\"异步发送\"></a>异步发送</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b161ff61daac34105ac418a0d8ff86b4.png\" alt=\"image-20250506000430849\"></p>\n<p>调用<code>uart_tx(dev, *buf, len, timeout)</code>，给定首地址和长度即可，函数不阻塞。Timeout是给流控用的，如果输出被对方的流控阻止，自己能等待多久，如果没有流控就不用在意。</p>\n<p>发送过程由驱动层和硬件自动处理。</p>\n<p>发送完毕后，回调函数里会收到<strong>UART_TX_DONE</strong>事件。</p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>注意发送数据buffer的生命周期，不能是局部变量</li>\n<li>如果buffer的地址不属于于RAM，Nordic的驱动程序会先自动执行一个拷贝到RAM中的动作。因为硬件不支持RAM以外的地方到外设的DMA。</li>\n<li>uart_tx这个行为是低功耗的。只要不在发送，就没有发送行为相关的功耗。无需disable串口。</li>\n</ol>\n</blockquote>\n<p>在DMA传输期间，如果再次执行uart_tx()，函数会返回<code>-EBUSY</code>错误码：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0c8c3cc39029da6d8d7da1eeafbabc38.png\" alt=\"image-20250727000130872\"></p>\n<p>后续例程会展示如何实现发送缓冲线程。</p>\n<h3 id=\"异步接收\"><a href=\"#异步接收\" class=\"headerlink\" title=\"异步接收\"></a>异步接收</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/617d9c8e5b5060c0dcc1e9f741850e20.png\" alt=\"image-20250506000958480\"></p>\n<ol>\n<li>用<code>uart_rx_enable(dev, *buf, len, timeout_us)</code>来首次使能接收。给定Buffer和长度。Buffer收满以后会产生UART_RX_RDY事件。</li>\n<li>Timeout是空闲超时机制。在至少收到1个字节之后，即使buffer未满，如果超时，也会产生<code>UART_RX_RDY</code>事件。这是为了方便收取一个小于buffer长度的包的情况。单位是微秒。timeout时间设为SYS_FOREVER_US会关闭这个机制。</li>\n<li>如果buffer未满，下次数据接收会继续填充在此buffer内。如果buffer已满，紧接在UART_RX_RDY事件之后，会产生UART_RX_BUF_RELEASED事件。告知应用层，一开始的buffer已经不再使用，可以释放。</li>\n<li>异步API也提供双Buffer机制。当每次接收开始时，驱动层会立即产生UART_RX_BUF_REQUEST事件。向应用层请求第二个buffer。应用层有两个选择：<ul>\n<li>用uart_rx_buf_rsp(dev, *buf, len)来设置第二个buffer。当第一个buffer满时，驱动层自动开始用第二个buffer。</li>\n<li>无视这个请求。那么这次接收完毕时，整个接收会被disable。需要再次enable才能开始接收。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/5d9b9ad4db0201e8f1dc44ae7342d418.png\" alt=\"image-20250506000854098\"></p>\n<h2 id=\"Zephyr串口驱动\"><a href=\"#Zephyr串口驱动\" class=\"headerlink\" title=\"Zephyr串口驱动\"></a>Zephyr串口驱动</h2><p>无论是阻塞、基于中断、还是异步API。它们都是由Nordic的驱动程序提供的。</p>\n<p>当<code>CONFIG_SERIAL=y</code>，就使能了Zephyr的串口驱动。Zephyr系统内的CMake规则会自动把相关MCU的串口驱动编译进去。</p>\n<p>而Nordic是提供了三种驱动的：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2d16fa1b03901a6cfd6347d0d8b5208b.png\" alt=\"image-20250506001935633\"></p>\n<p>使用时，注意在device tree中设置正确的compatible，来选择正确的驱动。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2753bd1faeeebb2e7251143b27988756.png\" alt=\"image-20250506001833817\"></p>\n<blockquote>\n<p><strong>设备树的compatible和驱动程序是如何对应的？</strong></p>\n<p>​    设备树的compatible属性，在编译阶段会被转换成C语言命名规范允许的形式（特殊符号全变为下划线），如<code>nordic_nrf_uarte</code>。</p>\n<p>​    每个驱动程序会用自己的方法遍历设备树中所有compatible与自己相匹配的节点。然后基于这个节点的信息来初始化硬件外设。</p>\n<p><strong>uarte和uarte2有什么区别？</strong></p>\n<p>​    见<code>zephyr/driver/serial/CMakeLists.txt</code></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (CONFIG_UART_NRFX_UARTE)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (CONFIG_UART_NRFX_UARTE_LEGACY_SHIM)</span><br><span class=\"line\">    zephyr_library_sources(uart_nrfx_uarte.c)</span><br><span class=\"line\">  <span class=\"keyword\">else</span>()</span><br><span class=\"line\">    <span class=\"keyword\">message</span>(DEPRECATION</span><br><span class=\"line\">        <span class=\"string\">&quot;Do not set CONFIG_UART_NRFX_UARTE_LEGACY_SHIM=n as this option is deprecated.&quot;</span>)</span><br><span class=\"line\">    zephyr_library_sources(uart_nrfx_uarte2.c)</span><br><span class=\"line\">  <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"5-异步串口代码示例\"><a href=\"#5-异步串口代码示例\" class=\"headerlink\" title=\"5. 异步串口代码示例\"></a>5. 异步串口代码示例</h1><p>示例代码：<a href=\"https://github.com/Jayant-Tang/learning_zephyr_serial\">Jayant-Tang&#x2F;learning_zephyr_serial: An example that shows how to use zephyr Async UART</a></p>\n<p>读者可以下载示例代码后，对照阅读本文</p>\n<blockquote>\n<p>【注意】<br>本文基于NCS v3.0.2。若读者使用v2.4.2或以下版本，代码中的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> UART_RX_BUF_RELEASED:</span><br><span class=\"line\">    k_mem_slab_free(&amp;uart_slab, (<span class=\"type\">void</span> *)evt-&gt;data.rx_buf.buf);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>需要改回：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> UART_RX_BUF_RELEASED:</span><br><span class=\"line\">    k_mem_slab_free(&amp;uart_slab, (<span class=\"type\">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n<p>因为版本升级后<code>k_mem_slab_free</code>的实现不同，参数从二级指针变为了一级指针。</p>\n</blockquote>\n<h2 id=\"src-x2F-app-uart-x2F-app-uart-c\"><a href=\"#src-x2F-app-uart-x2F-app-uart-c\" class=\"headerlink\" title=\"src&#x2F;app_uart&#x2F;app_uart.c\"></a>src&#x2F;app_uart&#x2F;app_uart.c</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>首先是获得device，这里的方法是用aliases别名来获取：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* serial device */</span> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_INST DT_ALIAS(learning_serial)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">uart_dev</span> =</span> DEVICE_DT_GET(UART_INST);</span><br></pre></td></tr></table></figure>\n\n<p>因为在不同板子的设备树中，都已经选好了对应的串口：</p>\n<p><code>nrf54l15dk_nrf54l15_cpuapp.overlay</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    aliases&#123;</span><br><span class=\"line\">        learning-serial = &amp;uart20;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>nrf52840dk_nrf52840.overlay</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    aliases&#123;</span><br><span class=\"line\">        learning-serial = &amp;uart0;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后是初始化时，注册异步回调函数，并开启串口接收。这里除了device结构体指针之外，还有两组配置。一个是接收缓存及其长度、一个是超时时间：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT_US);</span><br></pre></td></tr></table></figure>\n\n<p>接收缓存用的是Zephyr的<a href=\"https://docs.zephyrproject.org/latest/kernel/memory_management/slabs.html#memory-slabs\">memory slab</a>功能。代码中用<code>K_MEM_SLAB_DEFINE</code>定义了几块静态的缓存区域，可以用allocate和free来进行内存块的分配和释放操作。相当于是一个私有的动态内存区域。在<code>main()</code>函数中，先取出了一块内存，然后传入<code>rx_enable</code>作为接收缓存。</p>\n<p>超时时间，指的是串口空闲一定时间，没有新数据来，就直接认为接收完毕。即使DMA接收缓存还未满，也要产生空闲事件，并直接调用callback。<strong>这里为了演示，设置为1秒超时</strong>。</p>\n<blockquote>\n<p>这个超时功能，一般情况下是用软定时器（k_timer）实现的。</p>\n<p>但是，对于nRF54L15这种串口硬件本身支持超时帧中断的情况，会使用硬件本身的超时功能。这时，超时时间的最大值就是UARTE硬件帧中断支持的最大时间。比如54l15的串口，空闲帧的最大值为10个bit宽度，在115200波特率下大约为8.9ms。因此，这种情况下设置所有超过8.9ms的时间都会被缩短到8.9ms。</p>\n</blockquote>\n<h3 id=\"串口回调\"><a href=\"#串口回调\" class=\"headerlink\" title=\"串口回调\"></a>串口回调</h3><p>在回调函数中，每次接收缓存已满，或者达到了超时时间，就会产生<code>UART_RX_RDY</code>事件。在事件结构体中，<code>buf</code>是缓存的首地址，<code>offset</code>是本次收到的数据在缓存中的位置，<code>len</code>是本次收到的数据的长度。因此，本次接收到的数据的真实首地址为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br></pre></td></tr></table></figure>\n\n<p>每次接收缓存满时，串口rx驱动代码会向应用层申请新的接收缓存，即<code>UART_RX_BUF_REQUEST</code>事件。这时我们从memory slab中分配一块新的内存给它即可。</p>\n<p>当串口驱动获得了新的接收缓存时，它也会向应用层申请释放掉旧的接收缓存，即<code>UART_RX_BUF_RELEASED</code>事件。这时我们用memory slab的free函数将其释放即可。</p>\n<blockquote>\n<p>这里有一些小细节：</p>\n<ol>\n<li><p>回调函数的形参evt，在call stack中上一层的驱动代码里是一个局部变量。在回调函数返回后，evt会被释放。因此这里如果要实现回环，需要拷贝一份到静态内中。即<code>static uint8_t buf[128]</code>。</p>\n</li>\n<li><p>如果某一次接收到了很多数据，超出了buffer的剩余空间。那么这次收到的数据就会被分成两部分，产生两次接收回调。这也意味着，我们必须把接收到的数据看作是“字节流”而不是“包”。开发者应该自己实现字节流解包处理函数，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; evt-&gt;data.rx.len; i++)&#123;</span><br><span class=\"line\">    bytes_to_packet(p[i]); <span class=\"comment\">// 开发者自行实现解包函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main.c中已经实现了这一点。</p>\n</li>\n<li><p>回调函数实际上运行在中断服务函数内部，因此不要做一些阻塞的行为。如果真的有计算量大的任务，可以把任务提交到<a href=\"https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html\">Workqueue Threads</a>。这样你就能把耗时的任务从<strong>特权模式</strong>移动到<strong>用户模式</strong>，也就是从中断内部移动到线程中。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"串口接收线程\"><a href=\"#串口接收线程\" class=\"headerlink\" title=\"串口接收线程\"></a>串口接收线程</h3><p>串口接收到数据时，将数据拷贝并通过消息队列发送到RX线程。然后执行应用层的回调函数。再之后free掉申请的内存。</p>\n<h3 id=\"串口发送线程\"><a href=\"#串口发送线程\" class=\"headerlink\" title=\"串口发送线程\"></a>串口发送线程</h3><p>应用层要发送数据时，数据先被拷贝并通过消息队列发送到TX线程，然后进行发送。线程会等待发送完毕，然后free掉申请的内存</p>\n<h2 id=\"main-c\"><a href=\"#main-c\" class=\"headerlink\" title=\"main.c\"></a>main.c</h2><p>通过<code>app_uart_rx_cb_register()</code>注册回调函数。当串口收到数据时，回调函数会<strong>在RX线程中被执行</strong>。</p>\n<p>要发送数据时，执行<code>app_uart_tx()</code>。此函数不阻塞且会拷贝数据。因此可以从ISR或Thread中调用，也可以传入局部变量。</p>\n<p>收到的串口数据是字节流而不是包。因此通过有限状态机实现了串口数据流解包函数，以连续的CRLF（<code>\\r\\n</code>）为分界，进行数据的解包。</p>\n<h2 id=\"异步串口配置\"><a href=\"#异步串口配置\" class=\"headerlink\" title=\"异步串口配置\"></a>异步串口配置</h2><p><code>prj.conf</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">use RTT as console</span></span><br><span class=\"line\">CONFIG_USE_SEGGER_RTT=y</span><br><span class=\"line\">CONFIG_RTT_CONSOLE=y</span><br><span class=\"line\">CONFIG_UART_CONSOLE=n</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">enable</span> logging</span></span><br><span class=\"line\">CONFIG_LOG=y</span><br><span class=\"line\">CONFIG_LOG_BACKEND_RTT=y</span><br><span class=\"line\">CONFIG_LOG_MODE_DEFERRED=y</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_SEGGER_RTT_MODE_NO_BLOCK_SKIP=y</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">use ASYNC uart API</span></span><br><span class=\"line\">CONFIG_SERIAL=y</span><br><span class=\"line\">CONFIG_UART_ASYNC_API=y</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">need k_malloc</span></span><br><span class=\"line\">CONFIG_HEAP_MEM_POOL_SIZE=4096</span><br></pre></td></tr></table></figure>\n\n<p>首先，把console改为RTT，防止日志和我们的串口数据混在一起。</p>\n<p><code>CONFIG_SERIAL=y</code>的作用是，使能Zephyr标准串口驱动；<code>CONFIG_UART_ASYNC_API=y</code>使能了异步API。这两项都是Zephyr的串口配置项，来自于<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig</code>。</p>\n<p>由于我们需要用到动态内存分配，因此这里要设置HEAP大小<code>CONFIG_HEAP_MEM_POOL_SIZE=4096</code>。</p>\n<p><code>boards/&lt;board&gt;.conf</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_UART_xx_ASYNC=y</span><br><span class=\"line\">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</span><br></pre></td></tr></table></figure>\n\n<p><code>CONFIG_UART_xx_ASYNC=y</code>来自于Nordic的配置<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig.nrfx</code>。Zephyr只提供了全局的串口API选择（异步、中断、阻塞）。但是Nordic允许开发者给不同的串口使用不同的API。因此这里需要给特定的串口实例单独启用ASYNC API。</p>\n<h2 id=\"强化RX功能\"><a href=\"#强化RX功能\" class=\"headerlink\" title=\"强化RX功能\"></a>强化RX功能</h2><p>上述第二配置，<strong>对性能和功耗影响很大</strong>。虽说串口API是异步的，但底层驱动的实现却有很多变化。当一个外设通过DMA传输数据时，通常来说是DMA缓存写满了，才产生中断，然后把整个缓存传给应用层。但别忘了，我们的异步串口有<strong>空闲超时功能</strong>，如果DMA缓存还没有写满，但因为串口一直没有收到新的数据，超时了，需要立即把目前已经收到的数据传到应用层。这种情况下，<strong>如何才能知道目前已经接收了多少个字节数据呢？</strong></p>\n<p>纯软件的方法就是，每收到一个字节就产生中断，在中断服务函数里，通过软件的方式+1，这也是大多数普通的单片机的做法。<strong>如果你不添加最后两行CONFIG配置，那么<code>uart_nrfx_uarte.c</code>驱动就会采用这种方法</strong>。但是当串口速率很高时（如1Mbps），每一个字节都产生中断一定会大量占用CPU资源，效率极低。</p>\n<p>因此这里需要强化版RX（Enhanced RX）功能。在底层驱动代码中，当<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX</code>开启时，单个字节的中断不会被使能：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fe23eea8c563759f1a57c14b8ab88644.png\" alt=\"image-20250727044332567\"></p>\n<p>这就确保了不会产生单个字节的中断，从而影响CPU性能。</p>\n<p>另一方面，在底层驱动的RX enable函数中，使能了连接FRAMETIMEOUT event和 STOP_RX task的SHORT寄存器：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/1bd7e9bcb8d16788c65066091e036adc.png\" alt=\"image-20250727044930863\"></p>\n<blockquote>\n<p>SHORT寄存器（意为短路）就是可以让一个外设的event自动触发该外设的一个task，无需CPU参与。当FRAME_TIMEOUT发生时，外设自动执行STOP_RX。</p>\n</blockquote>\n<p>对于nRF52系列这种不支持FRAME_TIMEOUT的老系列。超时是靠k_timer软定时器实现的，在rx enable的函数内，把超时时间分成了5份：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">async_rx-&gt;timeout_us = timeout;</span><br><span class=\"line\">async_rx-&gt;timeout_slab = timeout / RX_TIMEOUT_DIV; <span class=\"comment\">// RX_TIMEOUT_DIV = 5</span></span><br></pre></td></tr></table></figure>\n\n<p>底层驱动在RX Started中断里，开始计时：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3237942a0bf438792701ab9bc7ae34b0.png\" alt=\"image-20250727045514187\"></p>\n<p>如果连续5次都超时，则软件触发STOPRX中断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (async_rx-&gt;idle_cnt == (RX_TIMEOUT_DIV - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这和前面的SHORT寄存器是一个思路。</p>\n<p>不论是前面二者中的哪种情况，当STOP RX中断发生时，就会进入底层驱动的<code>endrx_isr()</code>。在这里读取DMA的AMOUNT寄存器，就可以在DMA缓存区未满的情况下，获取串口已经收到的字节数了。</p>\n<h2 id=\"硬件计数器（不再推荐）\"><a href=\"#硬件计数器（不再推荐）\" class=\"headerlink\" title=\"硬件计数器（不再推荐）\"></a>硬件计数器（不再推荐）</h2><p>在之前版本的文章中，我介绍过Timer+PPI的方式：</p>\n<p>Nordic的单片机有独特的功能—— PPI (Programmable peripheral interconnect)。简单来说，就是每个外设都有许多event和task寄存器。event寄存器可以产生中断让CPU去处理；CPU也可以去写task寄存器让外设去执行某些工作。前面介绍过，SHORT寄存器可以把同一个外设的event和它自己的task连接起来。</p>\n<p>而PPI可以把两个不同外设的event寄存器和task寄存器连接起来，实现<strong>自动联动，而无需CPU处理</strong>。</p>\n<p>如此一来，Nordic串口驱动可以把一个Timer配置为计数器模式（Counter Mode），并且把他的COUNT TASK与串口的接收到单个字节的EVENT通过PPI连接起来。这样计数器就可以自动记录收到了多少个字节。当接收超时的时候，直接从counter中读取计数即可。</p>\n<p>在52840中，可以这样配置，将timer2用作uart0的计数器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_UART_0_ASYNC=y</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=n</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_UART_0_NRF_HW_ASYNC=y</span><br><span class=\"line\">CONFIG_UART_0_NRF_HW_ASYNC_TIMER=2</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>\n\n<p>在54L15中，不推荐用硬件计数，请直接使用<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</code>，这里也不给出配置，经过我实测：</p>\n<ul>\n<li>54L15使用硬件计数，开启FRAMTIMEOUT时。出现bug，FRAMETIMEOUT不生效，必须收到大于DMA长度的包才能产生中断；</li>\n<li>54L15使用硬件计数，关闭FRAMTIMEOUT，k_timer实现超时功能。出现bug，收到的数据包最后2个字节完全错误，且尾部还会再增加一个随机错误字节。</li>\n</ul>\n<h2 id=\"异步串口设备树\"><a href=\"#异步串口设备树\" class=\"headerlink\" title=\"异步串口设备树\"></a>异步串口设备树</h2><p>我们并不需要额外修改设备树，直接采用默认值即可。我们这里只是给串口起一个别名，方便不同MCU平台统一代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    aliases&#123;</span><br><span class=\"line\">        learning-serial = &amp;uart20;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;uart20 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>至于这个串口的具体配置，我们可以直接查看编译后的完整设备树，位于<code>build/&lt;application_name&gt;/zephyr/zephyr.dts</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">uart0: uart@40002000 &#123;</span><br><span class=\"line\">            compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class=\"line\">            reg = &lt; 0x40002000 0x1000 &gt;;</span><br><span class=\"line\">            interrupts = &lt; 0x2 0x1 &gt;;</span><br><span class=\"line\">            status = &quot;okay&quot;;</span><br><span class=\"line\">            current-speed = &lt; 0x1c200 &gt;;</span><br><span class=\"line\">            pinctrl-0 = &lt; &amp;uart0_default &gt;;</span><br><span class=\"line\">            pinctrl-1 = &lt; &amp;uart0_sleep &gt;;</span><br><span class=\"line\">            pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>主要属性介绍：</p>\n<ul>\n<li><p><code>reg = &lt; 0x40002000 0x1000 &gt;</code>：芯片自带的属性，外设的地址</p>\n</li>\n<li><p><code>compatible = &quot;nordic,nrf-uarte&quot;</code>：此处选择了uarte的驱动而非uart驱动。因此最终编译时用的代码是uart_nrfx_uarte.c而非uart_nrfx_uart.c</p>\n</li>\n<li><p><code>status = &quot;okay&quot;</code>：驱动代码自动初始化外设时，只会初始化状态为<code>&quot;okay&quot;</code>的节点。</p>\n</li>\n<li><p><code>current-speed = &lt; 0x1c200 &gt;</code>：波特率，也就是写十进制<code>current-speed = &lt; 115200 &gt;</code></p>\n</li>\n</ul>\n<h2 id=\"硬件连接\"><a href=\"#硬件连接\" class=\"headerlink\" title=\"硬件连接\"></a>硬件连接</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e1f8ca33f0a8e621f288179dd9ab2173.png\" alt=\"image-20221209144123203\"></p>\n<p>Nordic开发板的串口0默认GPIO都是在板子上直接连接到Jlink上，然后Jlink把串口转发到USB上，因此电脑上看到的是Jlink的USB串口。</p>\n<p>右上角开关，nRF Only是只给单片机核心电路供电，外围LED、Jlink等都不供电，用于测量功耗。因此应该拨到DEFAULT档位。</p>\n<p>板载Jlink，USB插左边即可。左下角电源开关打开。</p>\n<h2 id=\"异步串口代码运行\"><a href=\"#异步串口代码运行\" class=\"headerlink\" title=\"异步串口代码运行\"></a>异步串口代码运行</h2><p>烧录好程序后，分别打开RTT和串口。从串口发送hello（包含回车+换行），串口就会把hello回环打印出来。并且RTT的日志中会显示收到了7字节，发送了7字节：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/d4f6f910dc63966549e3cda4036916b6.png\" alt=\"image-20250727053522774\"></p>\n<blockquote>\n<ul>\n<li>不要用VS Code里面nRF插件提供的这个串口终端。在里面按下回车不是<code>\\r\\n</code>，无法形成完整数据包。可以用nRF Connect for Desktop里面的串口助手。</li>\n<li>如果是52840，前面设置了1s超时，hello就会在发送后1s回环打印出来。如果是54L15，不采用这个超时，而是采用空闲帧中断，hello会在1023个bit时间内打印出来（约8.9ms）。</li>\n</ul>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/befde71fdc0717db731e044fb030feb6.png\" alt=\"image-20250727054355433\"></p>\n<p>如果一次性发送大量数据，则我们可以看到产生了多个接收完毕中断。由于我们的<code>CONFIG_APP_UART_RX_DMA_BLOCK_SIZE</code>设置的是64，因此每收到64字节，串口驱动就会重新申请一块新的内存。</p>\n<p>而应用层<code>main.c</code>中，已经实现了解包函数，因此最终是按照一整包回环发送回来的。</p>\n<h1 id=\"6-USB-CDC-ACM串口\"><a href=\"#6-USB-CDC-ACM串口\" class=\"headerlink\" title=\"6. USB CDC ACM串口\"></a>6. USB CDC ACM串口</h1><p>前面介绍了硬件串口的异步API，接下来我们介绍USB CDC ACM串口。</p>\n<blockquote>\n<p> nRF54L15不含USB，后续用nRF52840DK继续。</p>\n</blockquote>\n<p>应用层代码无需改动。只需修改一些配置就可以把前面的异步串口代码变为USB CDC ACM串口代码。</p>\n<h2 id=\"USB串口设备树\"><a href=\"#USB串口设备树\" class=\"headerlink\" title=\"USB串口设备树\"></a>USB串口设备树</h2><p>在<code>usb.overlay</code>中，有如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    aliases &#123;</span><br><span class=\"line\">        my-usb-serial = &amp;usb_serial0;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;zephyr_udc0 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    usb_serial0: cdc_acm_uart0 &#123;</span><br><span class=\"line\">        compatible = &quot;zephyr,cdc-acm-uart&quot;;</span><br><span class=\"line\">        status = &quot;okay&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们给usbd节点新增了一个子节点<code>/soc/usbd@4002700/cdc_acm_uart0</code>，并且也给其添加了一个label：<code>usb_serial0</code>。</p>\n<h2 id=\"USB串口配置\"><a href=\"#USB串口配置\" class=\"headerlink\" title=\"USB串口配置\"></a>USB串口配置</h2><p>在<code>prj_usb.conf</code>中，和<code>prj.conf</code>相比增加了以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># enable USB Device</span></span><br><span class=\"line\">CONFIG_USB_DEVICE_STACK=y</span><br><span class=\"line\">CONFIG_USB_DEVICE_PRODUCT=<span class=\"string\">&quot;Zephyr CDC ACM sample&quot;</span></span><br><span class=\"line\">CONFIG_USB_DEVICE_PID=0x0001</span><br><span class=\"line\">CONFIG_USB_CDC_ACM=y</span><br><span class=\"line\">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class=\"line\">CONFIG_UART_LINE_CTRL=y</span><br><span class=\"line\">CONFIG_USB_DEVICE_REMOTE_WAKEUP=n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># enable USB ASYNC Adapter</span></span><br><span class=\"line\">CONFIG_UART_ASYNC_ADAPTER=y</span><br></pre></td></tr></table></figure>\n\n<p>最后一项是Nordic的一个中间件。<strong>由于USB串口驱动只实现了基于中断的API，没有实现异步API。因此通过这个Adapter给USB CDC ACM串口驱动附加一层异步API。</strong></p>\n<h2 id=\"USB串口代码\"><a href=\"#USB串口代码\" class=\"headerlink\" title=\"USB串口代码\"></a>USB串口代码</h2><p>代码和前面的异步串口代码几乎一样。只是换了一个串口设备：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/435dc3353a9dec6cfd3f33f93d2d9508.png\" alt=\"image-20250727062621425\"></p>\n<p>另外，在初始化阶段使能了usb，并应用了uart_async_adapter:</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b5a8857c9630e54e55050af81ac89af0.png\" alt=\"image-20250727062711807\"></p>\n<blockquote>\n<p>串口异步接收超时的单位是微秒。在老的异步串口API中，而这个async adapter里实现的rx_enable函数，传入的参数单位是毫秒。因此，注意<code>RX_INACTIVE_TIMEOUT</code>的值。</p>\n<p>不过最新的NCS v3.0.2已经修复了此问题。现在单位统一为毫秒。</p>\n</blockquote>\n<h2 id=\"编译USB串口例程\"><a href=\"#编译USB串口例程\" class=\"headerlink\" title=\"编译USB串口例程\"></a>编译USB串口例程</h2><p>编译时选好配置文件和设备树：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4f06c74858516b61a28a039ec11affc1.png\" alt=\"image-20250727063009578\"></p>\n<p>或者用命令编译：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build <span class=\"literal\">-d</span> build_usb <span class=\"literal\">-p</span> <span class=\"literal\">-b</span> nrf52840dk/nrf52840 <span class=\"literal\">--sysbuild</span> <span class=\"literal\">--</span> <span class=\"literal\">-DCONF_FILE</span>=<span class=\"string\">&quot;prj_usb.conf&quot;</span> <span class=\"literal\">-DEXTRA_DTC_OVERLAY_FILE</span>=<span class=\"string\">&quot;boards/nrf52840dk_nrf52840.overlay&quot;</span> <span class=\"literal\">-DDTC_OVERLAY_FILE</span>=<span class=\"string\">&quot;usb.overlay&quot;</span> </span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"运行并测试USB串口\"><a href=\"#运行并测试USB串口\" class=\"headerlink\" title=\"运行并测试USB串口\"></a>运行并测试USB串口</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8ada0b901ff5c008dd17acc90971ae89.png\" alt=\"image-20231113111154639\"></p>\n<p>左侧是Jlink USB，下方是nRF52840的USB Device接口。在串口助手里选中USB串口：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a193007588cb8eb0477e7058cbb42c45.png\" alt=\"image-20250727063204480\"></p>\n<p>可以看到功能和前面的异步串口完全相同：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ffaa699ebd81acdad4bfbc16e3758957.png\" alt=\"image-20250727063250261\"></p>\n<h1 id=\"7-串口休眠\"><a href=\"#7-串口休眠\" class=\"headerlink\" title=\"7. 串口休眠\"></a>7. 串口休眠</h1><p>待补充。一个是通过GPIO主动使能、关闭串口。一个是用RX引脚数据的下降沿来触发GPIO中断，使能串口。</p>\n<h1 id=\"8-Nordic-LPUART低功耗串口\"><a href=\"#8-Nordic-LPUART低功耗串口\" class=\"headerlink\" title=\"8. Nordic LPUART低功耗串口\"></a>8. Nordic LPUART低功耗串口</h1><p>在不开启串口等非必要外设的情况下，Nordic的System On休眠（也就是Zephyr IDLE状态下）的待机功耗只有几微安。但若是开启RX一直等待着数据接收，即使同时没在发送任何数据，大概也会有三百微安左右的功耗。这肯定是低功耗产品不能接受的。</p>\n<p>好在，Nordic nrfx异步串口API本身就有一定的低功耗特性：对于发送来说，只要数据发送完毕，tx就会关闭；对于接收来说，只要不被<code>uart_rx_enable()</code>使能，接收也会关闭。发送和接收都关闭时，串口本身就是关闭的，没有功耗。</p>\n<p>发送行为本身就已经是低功耗的了，我们不用做任何修改。对于接收行为来说，串口接收空闲超时会产生<code>UART_RX_RDY</code>事件，我们可以在这个事件里关掉串口。但是如何在数据来之前就提前预知，打开串口呢？</p>\n<p>一个比较简单的方案是同时把RX引脚配置成下降沿触发的外部中断。当检测到外部中断时，禁用GPIO中断，打开rx；当接收完毕时，关闭rx，打开GPIO中断。</p>\n<blockquote>\n<p>这种方案，波特率不能超过9600，且GPIO中断内部执行要非常快，连Log也不能打印，否则时间来不及处理。</p>\n<p>此外，如果接收到的数据大于缓存剩余的大小，可能会在缓存满时先产生一个<code>UART_RX_RDY</code>事件，等到数据完全接收完毕，空闲超时时又产生一个<code>UART_RX_RDY</code>事件。如何处理这种corner case？还需要开发者去思考一下。</p>\n</blockquote>\n<h2 id=\"Nordic-Software-LPUART原理\"><a href=\"#Nordic-Software-LPUART原理\" class=\"headerlink\" title=\"Nordic Software LPUART原理\"></a>Nordic Software LPUART原理</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/18e69822c987a7b0bf2b4c81b9f2203f.png\" alt=\"image-20231113114031848\"></p>\n<p>Nordic提供了一个软件实现的低功耗串口，通过额外的两根线来识别是否有数据发出。由于是对称连接的，这里只给出一个MCU的TX和REQ引脚的实测波形图：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a6d7bd513642ec913005d0f59b25e346.png\" alt=\"image-20231113114358096\"></p>\n<p>通信步骤：</p>\n<ol>\n<li>发送端要发送数据前，先拉高REQ引脚；然后把REQ引脚配置为上拉输入模式。</li>\n<li>接收端RDY检测到上升沿，把串口RX使能。然后从RDY引脚输出一个几毫秒的负脉冲。然后把RDY引脚配置为上拉输入模式。</li>\n<li>发送端REQ引脚检测到上升沿，才通过TX发出数据</li>\n<li>发送完毕后，发送端拉低REQ引脚</li>\n<li>接收端检测到RDY引脚下降沿，关闭串口RX。并产生<code>UART_RX_RDY</code>事件给应用层。</li>\n</ol>\n<blockquote>\n<p>可以看出，这时<code>UART_RX_RDY</code>事件并不是空闲超时产生的，而是RDY引脚上拉产生的。因此会比普通的异步串口回调更早执行。</p>\n</blockquote>\n<h2 id=\"Nordic-LPUART例程\"><a href=\"#Nordic-LPUART例程\" class=\"headerlink\" title=\"Nordic LPUART例程\"></a>Nordic LPUART例程</h2><p>相关链接：</p>\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples/peripheral/lpuart/README.html\">lpuart例程说明</a></p>\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/uart_nrf_sw_lpuart.html#uart-nrf-sw-lpuart\">lpuart库说明</a></p>\n<p>lpuart例程位置：<code>$&#123;NCS&#125;/nrf/samples/peripheral/lpuart</code></p>\n<p>例程有<strong>基于中断</strong>和<strong>异步串口</strong>两种模式。相信看完了前面内容的你，看懂这些代码对你来说已经轻而易举了。</p>\n<p>这里只再说一些配置相关的内容。</p>\n<p>首先是设备树，在<code>boards/nrf52840dk_nrf52840.overlay</code>中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uart1 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    pinctrl-0 = &lt;&amp;uart1_default_alt&gt;;</span><br><span class=\"line\">    pinctrl-1 = &lt;&amp;uart1_sleep_alt&gt;;</span><br><span class=\"line\">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class=\"line\">    lpuart: nrf-sw-lpuart &#123;</span><br><span class=\"line\">        compatible = &quot;nordic,nrf-sw-lpuart&quot;;</span><br><span class=\"line\">        status = &quot;okay&quot;;</span><br><span class=\"line\">        req-pin = &lt;46&gt;;</span><br><span class=\"line\">        rdy-pin = &lt;47&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在串口1的节点内新增了一个子节点<code>nrf-sw-lpuart</code>，其标签为<code>lpuart</code>，兼容的驱动为<code>&quot;nordic,nrf-sw-lpuart&quot;</code>。</p>\n<p>代码里，获取的串口也不再是硬件串口，而是这个子节点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">lpuart</span> =</span> DEVICE_DT_GET(DT_NODELABEL(lpuart));</span><br></pre></td></tr></table></figure>\n\n<p>系统在启动时，会自动初始化串口1，并初始化sw-lpuart。应用层获取的device结构体是sw-lpuart驱动初始化的。</p>\n<p>后续的代码，和前面的异步串口一样。底层的REQ，RDY引脚操作都不需要用户编写代码，已经在驱动代码里被实现了。</p>\n<p>再看一下<code>prj.conf</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_NRF_SW_LPUART=y</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_UART_1_ASYNC=y</span><br><span class=\"line\">CONFIG_UART_1_INTERRUPT_DRIVEN=n</span><br><span class=\"line\">CONFIG_UART_1_NRF_HW_ASYNC=y</span><br><span class=\"line\">CONFIG_UART_1_NRF_HW_ASYNC_TIMER=2</span><br><span class=\"line\">CONFIG_UART_1_NRF_ASYNC_LOW_POWER=y</span><br><span class=\"line\">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，和前面的异步串口的config相比，只是多出来了<code>CONFIG_NRF_SW_LPUART=y</code>来使能这个库。</p>\n<h2 id=\"LPUART例程运行\"><a href=\"#LPUART例程运行\" class=\"headerlink\" title=\"LPUART例程运行\"></a>LPUART例程运行</h2><p>例程本身需要外部回环，因此你需要用两根杜邦线进行跳线：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e9fb7b22da2ba7a6fddaa96215d7bd23.png\" alt=\"image-20231113120440376\"></p>\n<p>RDY和REQ引脚一定要接，否则驱动程序内部的状态会乱掉，出现错误。你可以像我这样先跳线，然后外面再用示波器、逻辑分析仪或USB转串口的RX进行监测。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/37beaef79cc277d49537c2a2c7722bfe.png\" alt=\"image-20231113120838710\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/11fccc413349dcc1ae6cf706ca0c0dff.png\" alt=\"image-20231113121238377\"></p>\n<h2 id=\"功耗表现\"><a href=\"#功耗表现\" class=\"headerlink\" title=\"功耗表现\"></a>功耗表现</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/dc680e16ca1f22348ab265bc82d7bcfa.png\" alt=\"image-20231113131330118\"></p>\n<p>可以看到，在空闲无数据传输时，平均功耗在3.74uA左右。</p>\n<h1 id=\"9-开发自己的程序\"><a href=\"#9-开发自己的程序\" class=\"headerlink\" title=\"9. 开发自己的程序\"></a>9. 开发自己的程序</h1><h2 id=\"把串口程序集成到自己的应用中\"><a href=\"#把串口程序集成到自己的应用中\" class=\"headerlink\" title=\"把串口程序集成到自己的应用中\"></a>把串口程序集成到自己的应用中</h2><p>本例程已经非常完善，基本上把<code>app_uart</code>文件夹拷贝到自己的工程中，然后在Kconfig和CMakeLists.txt中引用即可。这也是模块化开发的思想。而且本工程思路还是比较清晰的，开发者想增加自己的代码也会非常容易。</p>\n<h2 id=\"阻塞与低功耗\"><a href=\"#阻塞与低功耗\" class=\"headerlink\" title=\"阻塞与低功耗\"></a>阻塞与低功耗</h2><p>这里讨论一下软件上的低功耗问题。Zephyr中的操作系统的阻塞行为（比如<code>k_sleep()</code>和这里的<code>k_msgq_get()</code>），都会让线程暂停，让出CPU资源。当除了IDLE线程外，所有的线程都不在运行，则Zephyr会运行IDLE线程。而IDLE线程在很短的一段时间后会自动让进入CPU休眠。</p>\n<p>这意味着开发者可以放心大胆地在自己的线程中使用操作系统的阻塞API，Zephyr系统会自动在合适的时候让CPU休眠。</p>\n<h2 id=\"串口API的兼容\"><a href=\"#串口API的兼容\" class=\"headerlink\" title=\"串口API的兼容\"></a>串口API的兼容</h2><p>我们前面提到，异步API和基于中断的API是完全不同的两套API。<br>而在串口驱动目录下的<code>Kconfig.nrfx</code>中可以看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config UART_1_ASYNC</span><br><span class=\"line\">    bool &quot;Asynchronous API support on port 1&quot;</span><br><span class=\"line\">    depends on UART_ASYNC_API &amp;&amp; !UART_1_INTERRUPT_DRIVEN</span><br><span class=\"line\">    default y</span><br><span class=\"line\">    help</span><br><span class=\"line\">      This option enables UART Asynchronous API support on port 1.</span><br></pre></td></tr></table></figure>\n<p>要使用异步API，必须单独禁用这个串口的中断API。<br>如果你要使用USB CDC ACM（需要中断API）的同时使用串口0的异步API，则需要这样配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class=\"line\">CONFIG_UART_0_INTERRUPT_DRIVEN=n</span><br></pre></td></tr></table></figure>\n<p>意思是，对于整个串口驱动来说，启用中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig）。<br>但是对于串口0来说，关闭中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig.nrfx）</p>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr","DeviceTree"]},{"title":"nRF9151蜂窝模组简介与定位例程解析","url":"/jayant97.github.io/2025/04/f1f289c546d9/","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><h2 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h2><p>nRF9151是支持NB-IoT和CAT-M的低功耗蜂窝LTE模组。支持OpenMCU开发，和Nordic其他产品线统一SDK。支持GPS定位。</p>\n<p>nRF Cloud是部署在AWS上的物联网云。支持MQTT和HTTPS（REST）API。提供设备注册、设备管理、OTA、定位（基站定位、Wi-Fi定位、AGPS、PGPS）等服务。</p>\n<p>nRF7002是一个2.4G&#x2F;5G低功耗双频Wi-Fi6收发器，可以用来模拟nRF7000。nRF7000是一个只能scan，不能connect的wifi6双频收发器，主要用于做Wi-Fi定位。</p>\n<h2 id=\"本文内容\"><a href=\"#本文内容\" class=\"headerlink\" title=\"本文内容\"></a>本文内容</h2><p>介绍如何搭建环境、编译nrf_cloud_multi_service工程。这是一个支持多个nRF Cloud服务的设备端工程。让nRF9151连接到nRF Cloud云端，并进行GPS定位、基站定位、Wi-Fi定位。</p>\n<p>介绍如何进行Modem Trace抓包分析基站内容。</p>\n<p>分析代码框架思路。</p>\n<h1 id=\"2-硬件准备\"><a href=\"#2-硬件准备\" class=\"headerlink\" title=\"2. 硬件准备\"></a>2. 硬件准备</h1><ul>\n<li>nRF9151开发板（或其他91系列开发板）</li>\n<li>NB-IoT物联网卡，这里是中国移动的。左边是开发板送的2张卡，在国内不好用。</li>\n<li>（可选）nRF7002EK。</li>\n</ul>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/Image%20(2).jpeg\" alt=\"Image (2)\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/Image%20(3).jpeg\" alt=\"Image (3)\"></p>\n<blockquote>\n<p>关于SIM卡：</p>\n<ol>\n<li>9151DK赠送的两张卡（Onomondo和Wireless Logic）都是预先激活好的，不需要再次激活，并且带有一定的流量和使用期限。如果扫描二维码进行注册，可以获得更多的免费流量。</li>\n<li>Onomondo和Wireless Logic是虚拟运营商。他们会和全球的运营商合作，让自己的卡能够漫游到全球大部分地区，支持CAT-M和NB-IoT。具体覆盖范围可以去他们官网查询。国内在上海我试过Onomondo的NB IoT是可用的，Wireless Logic没有漫游成功。</li>\n<li>使用国内的物联网卡，如中国移动的物联网卡时，注意是要支持NB-IoT的，并且注意国内的卡都会锁设备。也就是说新卡一但在一台设备上使用了，就不能换到其他设备上了。</li>\n</ol>\n</blockquote>\n<h1 id=\"3-软件准备\"><a href=\"#3-软件准备\" class=\"headerlink\" title=\"3. 软件准备\"></a>3. 软件准备</h1><h2 id=\"安装开发环境与烧录工具\"><a href=\"#安装开发环境与烧录工具\" class=\"headerlink\" title=\"安装开发环境与烧录工具\"></a>安装开发环境与烧录工具</h2><p>首先按照<a href=\"https://www.cnblogs.com/jayant97/articles/17794804.html\">《nRF Connect SDK安装与入门》</a>装好开发环境NCS v2.9.0，相关工具（nRF Connect for Desktop, nrfutil, Jlink驱动等）。</p>\n<h2 id=\"烧录Modem-Firmware\"><a href=\"#烧录Modem-Firmware\" class=\"headerlink\" title=\"烧录Modem Firmware\"></a>烧录Modem Firmware</h2><p>在<a href=\"https://www.nordicsemi.com/Products/nRF9151/Download?lang=en#infotabs\">9151官网页面</a>下载最新版Modem Firmware (MFW)。</p>\n<p>MFW是Modem专门的固件，是不开源的，以zip包的形式提供。Modem有独立的CPU和存储空间，不占用App Core的Flash和RAM。</p>\n<p>可以用nRF Connect for Desktop里面的Programmer烧录。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250424130251452.png\" alt=\"image-20250424130251452\"></p>\n<p>也可以用nrfutil命令行操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrfutil self-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看可安装的工具</span></span><br><span class=\"line\">nrfutil search</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装蜂窝系列模组工具</span></span><br><span class=\"line\">nrfutil install 91</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 烧录modem firmware</span></span><br><span class=\"line\">nrfutil 91 modem-firmware-upgrade --firmware ./project/mfw_nrf91x1_2.0.2.zip --all-jlinks</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置模拟开关\"><a href=\"#配置模拟开关\" class=\"headerlink\" title=\"配置模拟开关\"></a>配置模拟开关</h2><p>nRF9160无需此步骤。</p>\n<p>目前比较新的开发板都使用Interface MCU来控制板子上的模拟开关，而非物理开关。通过nRF Connect for Desktop上的Board Configurator控制。</p>\n<p>nRF9151DK上有两种方式可以连接LEDs和Buttons。一种是GPIO直连，一种是通过I2C接口的IO扩展器连接。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427124819121.png\" alt=\"image-20250427124819121\"></p>\n<p>如果你要使用7002EK扩展Wi-Fi功能，那么默认的LED就会占用7002要用的GPIO。因此，7002EK的DeviceTree文件会使能I2C接口的IO扩展器。</p>\n<p>见<code>zephyr/boards/nordic/nrf9151dk/dts/nrf9151dk_leds_on_io_expander.dtsi</code>。</p>\n<p>对应地就需要在开发板上把模拟开关切换到IO扩展器。使用nRF Connect for Desktop的Board Configurator来配置：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250424134257883.png\" alt=\"image-20250424134257883\"></p>\n<p>配置完毕后点击左边写入。这里写入是把配置写入到板子上的Interface MCU（即Jlink DEBUGGER）中。</p>\n<h1 id=\"4-修改、编译并烧录例程\"><a href=\"#4-修改、编译并烧录例程\" class=\"headerlink\" title=\"4. 修改、编译并烧录例程\"></a>4. 修改、编译并烧录例程</h1><p>通过copy a sample的形式复制并创建例程nRF Could Multi Service（<code>v2.9.0/nrf/samples/cellular/nrf_cloud_multi_service</code>）。</p>\n<p>修改<code>prj.conf</code>，增加以下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">移动物联网卡需要单独配置PDN</span></span><br><span class=\"line\">CONFIG_PDN=y              </span><br><span class=\"line\">CONFIG_PDN_LEGACY_PCO=y</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">默认是NB+CATM+GPS，国内去掉CATM</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置连接nRF Cloud时，使用UUID作为本机ID</span></span><br><span class=\"line\">CONFIG_MODEM_JWT=y                              </span><br><span class=\"line\">CONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y </span><br></pre></td></tr></table></figure>\n\n<p>创建编译目标。如果有7002ek，就增加以下参数。如果没有就不加：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427125146231.png\" alt=\"image-20250427125146231\"></p>\n<p>也可以用命令行编译：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -p \\</span><br><span class=\"line\">-b nrf9151dk/nrf9151/ns \\</span><br><span class=\"line\">-- \\</span><br><span class=\"line\">  -DSHIELD=nrf7002ek_nrf7000 \\</span><br><span class=\"line\">  -DSB_CONF_FILE=<span class=\"string\">&quot;sysbuild_nrf700x-wifi-scan.conf&quot;</span> \\</span><br><span class=\"line\">  -DEXTRA_CONF_FILE=<span class=\"string\">&quot;overlay-nrf7002ek-wifi-scan-only.conf&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>这个CMake参数等价于在CMakeLists.txt的开头写<code>set(SHIELD nrf7002ek_nrf7000)</code>，也就是会把7002ek这个扩展板的Kconfig配置和设备树overlay附加到当前工程的nrf9151板子上。</li>\n<li>7002ek有很多变体（<code>nrf7002ek</code>，<code>nrf7002ek_7001</code>，<code>nrf7002ek_7000</code>）。硬件上是2.4G&#x2F;5GHz双频的nRF7002，通过这种变体配置来模拟7001（只有2.4GHz）和7000（只能scan不能连接）</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[447/447] Linking C executable zephyr/zephyr.elf</span><br><span class=\"line\">Memory region         Used Size  Region Size  %age Used</span><br><span class=\"line\">           FLASH:      275888 B       384 KB     70.16%</span><br><span class=\"line\">             RAM:      111608 B     215832 B     51.71%</span><br><span class=\"line\">        IDT_LIST:          0 GB        32 KB      0.00%</span><br><span class=\"line\">Generating files from /home/jayant/OneDrive_Nordic/Customer/Meari/nrf_cloud_multi_service/build/nrf_cloud_multi_service/zephyr/zephyr.elf for board: nrf9151dk</span><br><span class=\"line\">image.py: sign the payload</span><br><span class=\"line\">image.py: sign the payload</span><br><span class=\"line\">[1/213] Preparing syscall dependency handling</span><br><span class=\"line\"></span><br><span class=\"line\">[6/213] Generating include/generated/zephyr/version.h</span><br><span class=\"line\">-- Zephyr version: 3.7.99 (/home/jayant/project/ncs/v2.9.0/zephyr), build: v3.7.99-ncs2</span><br><span class=\"line\">[213/213] Linking C executable zephyr/zephyr.elf</span><br><span class=\"line\">Memory region         Used Size  Region Size  %age Used</span><br><span class=\"line\">           FLASH:       48296 B      81408 B     59.33%</span><br><span class=\"line\">             RAM:       28944 B        32 KB     88.33%</span><br><span class=\"line\">        IDT_LIST:          0 GB        32 KB      0.00%</span><br><span class=\"line\">Generating files from /home/jayant/OneDrive_Nordic/Customer/Meari/nrf_cloud_multi_service/build/mcuboot/zephyr/zephyr.elf for board: nrf9151dk</span><br><span class=\"line\">[20/20] Generating ../merged.hex</span><br></pre></td></tr></table></figure>\n\n<p>编译完成后可以看到应用和bootloader的占用。</p>\n<p>然后烧录，使用nRF Connect for Desktop中的Serial Monitor查看串口：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427133846267.png\" alt=\"image-20250427133846267\"></p>\n<p>能观察到：</p>\n<ul>\n<li>nRF Cloud的客户端ID是UUID，不是IMEI</li>\n<li>设备可以附着基站，可以连网。但是无法连接到nRF Cloud MQTT</li>\n</ul>\n<h1 id=\"5-nRF-Cloud设备注册简介\"><a href=\"#5-nRF-Cloud设备注册简介\" class=\"headerlink\" title=\"5. nRF Cloud设备注册简介\"></a>5. nRF Cloud设备注册简介</h1><h2 id=\"设备注册\"><a href=\"#设备注册\" class=\"headerlink\" title=\"设备注册\"></a>设备注册</h2><p>nRF Cloud是Nordic的物联网云服务器，设置在AWS上，有设备托管、OTA、位置定位等服务。开放MQTT和HTTP（REST）的接口。</p>\n<p>此例程需要把设备注册（Provision）到nRF Cloud上。</p>\n<p>所谓的设备注册，就是让云端把这台设备的ID等信息注册在在你的个人账户下。除此之外，设备端和云端还需要各自持有对方的<strong>TLS证书（公钥）</strong>，这样才能进行双向的认证和加密。</p>\n<p>这里，云端的证书就是AWS的根证书，而设备端的证书是X.509格式的设备证书。</p>\n<h2 id=\"证书文件\"><a href=\"#证书文件\" class=\"headerlink\" title=\"证书文件\"></a>证书文件</h2><p>要阅读这部分，首先你需要了解非对称加密和TLS证书。</p>\n<p>设备内部需要三个证书文件（credentials）：</p>\n<ul>\n<li><strong>服务器根证书（Root CA）</strong>：这里是AWS根证书，用于确保自己连接的云服务器不是冒充的</li>\n<li><strong>设备证书（Client certificate）</strong>：预先给云服务器上传此证书。后续进行访问时，云服务器通过证书来验证设备是否真正是注册的设备。</li>\n<li><strong>设备私钥（Client private key）</strong>：通过密钥加密的数据，可以用设备证书携带的公钥解密。因此持有密钥的设备就是证书代表的设备。</li>\n</ul>\n<p>这三个文件都是存储在<strong>Modem</strong>里面的，不占用Application Core的flash空间。</p>\n<p>要管理modem里的证书，需要通过<code>AT%CMNG</code>命令来操作。可以写入云服务器的证书、自动生成证书和私钥等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">%CMNG=&lt;opcode&gt;[,&lt;sec_tag&gt;[,&lt;type&gt;[,&lt;content&gt;[,&lt;passwd&gt;]]]]</span><br></pre></td></tr></table></figure>\n\n<p>这里<code>&lt;opcode&gt;</code>代表写、读等操作。</p>\n<p><code>&lt;sec_tag&gt;</code>很重要，代表的是一组证书的句柄标签，范围是0–2147483647。例如，<strong>nRF Cloud的句柄就是16842753</strong>。当代码中通过网络访问nRF Cloud时，就通过16842753这个sec tag来获取到对应的证书，进行TLS通讯。</p>\n<p><code>&lt;type&gt;</code>代表这个密钥文件的类型：</p>\n<ul>\n<li>0 – Root CA certificate (ASCII text).</li>\n<li>1 – Client certificate (ASCII text).</li>\n<li>2 – Client private key (ASCII text).</li>\n<li>……</li>\n</ul>\n<p>同一个sec_tag之下，可以存<strong>一组</strong>证书文件。这里指的就是不同的<code>&lt;type&gt;</code>。这里我们连接nRF Cloud，就需要0, 1, 2这三种整数文件。</p>\n<p>某些云平台会直接把这三个证书文件都生成好，让你把服务器根证书、设备证书和设备私钥直接烧录到设备中。这种方式有暴露设备私钥的风险（毕竟经历了云端，下载到PC，再烧录到设备）。</p>\n<p>nRF91系列可以直接在设备上生成私钥，使用<code>AT%KEYGEN</code>命令生成。私钥生成后无法读出，可以调用API使用这个私钥来进行加密、解密，但是绝对无法读取到私钥本身。而设备证书是可以读取的。</p>\n<p>更多参数详见：<a href=\"https://docs.nordicsemi.com/bundle/ref_at_commands_nrf91x1/page/REF/at_commands/security/cmng.html\">https://docs.nordicsemi.com/bundle/ref_at_commands_nrf91x1/page/REF/at_commands/security/cmng.html</a></p>\n<blockquote>\n<p>所有证书文件操作时都必须先关闭网络（<code>AT+CFUN=4</code>）</p>\n</blockquote>\n<h2 id=\"nRF-Cloud注册方式\"><a href=\"#nRF-Cloud注册方式\" class=\"headerlink\" title=\"nRF Cloud注册方式\"></a>nRF Cloud注册方式</h2><p>通过前面的介绍，我们知道配网需要完成2件事：</p>\n<ol>\n<li>把服务器的根证书存储到设备上</li>\n<li>把设备的证书上传到服务器，并且确保设备中有该证书对应的私钥</li>\n</ol>\n<p>nRF Cloud提供3种注册方式：</p>\n<h3 id=\"1-连接前注册（Preconnect-onboarding）\"><a href=\"#1-连接前注册（Preconnect-onboarding）\" class=\"headerlink\" title=\"1. 连接前注册（Preconnect onboarding）\"></a>1. 连接前注册（Preconnect onboarding）</h3><p>设备在生产完成后，还没有连网，就注册到云端。</p>\n<p>可以用电脑手动给云端上传一个csv表格，里面包含设备的ID和证书公钥等信息。适合设备在生产时阶段就批量注册到云端的情况。</p>\n<p>其中，证书的来源又有2种：</p>\n<ul>\n<li>用<code>AT%KEYGEN</code>让设备自动生成证书与私钥，再把证书记录到表格中（安全）</li>\n<li>先用电脑生成好设备证书和私钥，然后烧录到设备中（可能不安全）</li>\n</ul>\n<p>前者对应文档：<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/samples/cellular/nrf_cloud_multi_service/README.html#onboarding_a_device_without_the_nrf_cloud_provisioning_service\">Onboarding a device without the nRF Cloud Provisioning Service</a>;</p>\n<p>后者对应文档：<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/samples/cellular/nrf_cloud_multi_service/README.html#onboarding_with_hard-coded_device_credentials\">Onboarding with hard-coded device credentials</a></p>\n<h3 id=\"2-部署时注册（Auto-onboarding）\"><a href=\"#2-部署时注册（Auto-onboarding）\" class=\"headerlink\" title=\"2. 部署时注册（Auto-onboarding）\"></a>2. 部署时注册（Auto-onboarding）</h3><p>设备在生产完成后不注册到云端。而是等到现场部署时，再通过现场的人员操作进行证书生成、云端注册。</p>\n<p>这需要在编译时，就在代码中开启Provisionning Service相关的配置。</p>\n<p>本文不介绍这种方式，可以参考官方文档：<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/samples/cellular/nrf_cloud_multi_service/README.html#provisioning_with_the_nrf_cloud_provisioning_service\">https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/samples/cellular/nrf_cloud_multi_service/README.html#provisioning_with_the_nrf_cloud_provisioning_service</a></p>\n<h3 id=\"3-JITP（Just-in-Time-provisioning）\"><a href=\"#3-JITP（Just-in-Time-provisioning）\" class=\"headerlink\" title=\"3. JITP（Just-in-Time provisioning）\"></a>3. JITP（Just-in-Time provisioning）</h3><p>用于开发板评估的快速注册。由于开发板生产时都烧录好了证书，nRF Cloud也已经存储了这些证书。只需要扫描二维码就能把这个开发板对应的证书绑定到你的nRF Cloud账号里。</p>\n<p>但是如果你已经重新烧了modem firmware，或者是量产的产品，则不能使用这种方式。</p>\n<p><a href=\"https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html#jitp\">https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html#jitp</a></p>\n<h1 id=\"6-将设备注册到nRF-Cloud\"><a href=\"#6-将设备注册到nRF-Cloud\" class=\"headerlink\" title=\"6. 将设备注册到nRF Cloud\"></a>6. 将设备注册到nRF Cloud</h1><h2 id=\"注册nRF-Cloud账号并获取API-Key\"><a href=\"#注册nRF-Cloud账号并获取API-Key\" class=\"headerlink\" title=\"注册nRF Cloud账号并获取API Key\"></a>注册nRF Cloud账号并获取API Key</h2><ul>\n<li>免费注册一个 <a href=\"https://nrfcloud.com/#/\">nRF Cloud</a> 账号</li>\n</ul>\n<p><a href=\"https://img2023.cnblogs.com/blog/3028998/202303/3028998-20230311145904031-1781812259.png\"><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20230311145904031-1781812259.png\" alt=\"image-20221205005305505\"></a></p>\n<p>注册登录后，右上角进入User Account界面</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427165923803.png\" alt=\"image-20250427165923803\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427170019787.png\" alt=\"image-20250427170019787\"></p>\n<p>记录自己的API Key。</p>\n<blockquote>\n<p><strong>注意</strong>：API Key非常重要，可以通过API Key控制你账号下的所有设备、所有权限、调用付费API等。千万不能泄露！！！</p>\n<p>如果你怀疑API Key泄露，可以点击右边的Regenerate API Key重新生成。</p>\n</blockquote>\n<h2 id=\"安装nRF-Cloud-Utils\"><a href=\"#安装nRF-Cloud-Utils\" class=\"headerlink\" title=\"安装nRF Cloud Utils\"></a>安装nRF Cloud Utils</h2><p>需要python3环境。</p>\n<p>可以直接用pip安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install nrfcloud-utils</span><br></pre></td></tr></table></figure>\n\n<p>也可以直接clone仓库：<a href=\"https://github.com/nRFCloud/utils/\">https://github.com/nRFCloud/utils/</a></p>\n<blockquote>\n<p>如果是pip安装，则直接执行命令，如<code>create_ca_cert</code>。</p>\n<p>如果是clone方式安装，则进入<code>src /nrfcloud_utils/</code>，然后执行脚本，如<code>create_ca_cert.py</code></p>\n</blockquote>\n<p><strong>推荐以pip安装的方式进行</strong>。</p>\n<h2 id=\"设置临时环境变量\"><a href=\"#设置临时环境变量\" class=\"headerlink\" title=\"设置临时环境变量\"></a>设置临时环境变量</h2><p>在命令行中设置临时环境变量，方便后面执行脚本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Linux</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> API_KEY=&lt;your_api_key&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Windows Powershell</span></span><br><span class=\"line\"><span class=\"variable\">$env:API_KEY</span>=&lt;your_api_key&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成自签CA证书\"><a href=\"#生成自签CA证书\" class=\"headerlink\" title=\"生成自签CA证书\"></a>生成自签CA证书</h2><p>生成一个你自己签名的根证书，私钥由你持有。后续所有的设备证书都由这个CA证书来签发。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">create_ca_cert \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">--ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">--cn nordic.cn \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-p ./my_ca \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数解释可查看<code>create_ca_cert --help</code>。证书会生成到<code>-p</code>参数指定的目录下，这里是<code>/my_ca</code></p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427172427929.png\" alt=\"image-20250427172427929\"></p>\n<p>文件分别为：证书、私钥、公钥。</p>\n<p>其中证书内包含公钥。</p>\n<h2 id=\"给设备签发设备证书\"><a href=\"#给设备签发设备证书\" class=\"headerlink\" title=\"给设备签发设备证书\"></a>给设备签发设备证书</h2><p>让设备生成公私钥，利用自签CA给设备签发设备证书，并把设备证书保存到csv表格中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">device_credentials_installer \\</span><br><span class=\"line\">-d \\</span><br><span class=\"line\">-t <span class=\"string\">&quot;jayant-DK&quot;</span> \\</span><br><span class=\"line\">--ca ./my_ca/Jayant-0x112b0b2f2db47ba510eb57430f349de6f76d882_ca.pem \\</span><br><span class=\"line\">--ca-key ./my_ca/Jayant-0x112b0b2f2db47ba510eb57430f349de6f76d882_prv.pem \\</span><br><span class=\"line\">-a \\</span><br><span class=\"line\">--devinfo-append \\</span><br><span class=\"line\">--csv ./jayant_provision.csv \\</span><br><span class=\"line\">--devinfo ./jayant_devinfo.csv \\</span><br><span class=\"line\">--term CRLF \\</span><br><span class=\"line\">--port /dev/ttyACM0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li><code>-d</code>：安装前先从Modem中删除sectag</li>\n<li><code>-t</code>：用于设备分组管理的标签，是一个字符串</li>\n<li><code>-T</code>：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置</li>\n<li><code>--ca</code>：CA证书文件的路径</li>\n<li><code>--ca-key</code>：CA证书私钥的路径(prv)</li>\n<li><code>-a</code>或<code>--append</code>：保存<strong>设备注册信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--devinfo-append</code>：保存<strong>设备信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--csv</code>：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）</li>\n<li><code>--devinfo</code>：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）</li>\n<li><code>--term</code>：AT指令的结束符（<code>NULL</code>,<code>CRLF</code>,<code>CR</code> 或<code>LF</code>）</li>\n<li><code>--port</code>：指定AT指令串口（windows上是COM口，Linux上是&#x2F;dev&#x2F;tty*）</li>\n</ul>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427173557275.png\" alt=\"image-20250427173557275\"></p>\n<p>公私钥生成后，脚本自动读取了设备信息并将其保存到了csv表格中。</p>\n<p>由于添加了<code>-a</code>和<code>--devinfo-append</code>，如果你有多个设备要注册，这些信息会追加添加到表格中。</p>\n<p>注册时，最大支持一次性注册3000台设备。</p>\n<blockquote>\n<p>这种方式是用<code>AT%KEYGEN</code>自动生成私钥的，比较安全。</p>\n<p>如果你想用前面提到的“先用电脑生成设备私钥，再烧录进去”的方式。可以参考：<code>create_device_credentials</code>命令来进行生成。然后用<code>AT%CMNG</code>命令烧录三个证书文件（服务器CA证书、设备证书、设备私钥）。烧录前记得AT+CFUN&#x3D;4关闭网络。AWS IoT CA证书在这里下载（<a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem%EF%BC%89\">https://www.amazontrust.com/repository/AmazonRootCA1.pem）</a></p>\n</blockquote>\n<h2 id=\"把注册信息上传到云端\"><a href=\"#把注册信息上传到云端\" class=\"headerlink\" title=\"把注册信息上传到云端\"></a>把注册信息上传到云端</h2><p>可以继续使用命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrf_cloud_onboard --api-key <span class=\"variable\">$API_KEY</span> --csv jayant_provision.csv</span><br></pre></td></tr></table></figure>\n\n<p>利用前面获得的API_KEY来上传csv表格，注册设备。</p>\n<p>也可以直接在网页端操作：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427175008402.png\" alt=\"image-20250427175008402\"></p>\n<p>选择批量注册：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427175032694.png\" alt=\"image-20250427175032694\"></p>\n<p>然后把<code>jayant_provision.csv</code>表格拖进去就可以注册了。</p>\n<h2 id=\"检查连网情况\"><a href=\"#检查连网情况\" class=\"headerlink\" title=\"检查连网情况\"></a>检查连网情况</h2><p>由于安装证书时，设备被设置为飞行模式。这里打开串口，再reset一下。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427175858824.png\" alt=\"image-20250427175858824\"></p>\n<p>可以看到设备成功连网并访问到nRF Cloud.</p>\n<h1 id=\"7-查看定位\"><a href=\"#7-查看定位\" class=\"headerlink\" title=\"7. 查看定位\"></a>7. 查看定位</h1><p>我们进入nRF Cloud会发现设备已经上线：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427180107690.png\" alt=\"image-20250427180107690\"></p>\n<p>点击ID进入设备详情页：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427180227357.png\" alt=\"image-20250427180227357\"></p>\n<p>可以看到，设备通过MQTT已经上传了经纬度。同时，网页通过谷歌地图渲染了这个经纬度的地点（需要翻墙代理才能看到）。</p>\n<p>并且根据颜色不同，有单基站、多基站、Wi-Fi和GPS定位：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250427180437793.png\" alt=\"image-20250427180437793\"></p>\n<p>我这里在室内，所以GPS定位失败。但是Wi-Fi定位还是很准的。</p>\n<h1 id=\"8-Modem-Trace抓包\"><a href=\"#8-Modem-Trace抓包\" class=\"headerlink\" title=\"8. Modem Trace抓包\"></a>8. Modem Trace抓包</h1><p>本节介绍如何进行Modem Trace抓包。Modem Trace就是让nRF9151和基站之间交互的数据包以二进制格式通过串口等方式输出，方便进行抓包调试。</p>\n<p>要使能Modem Trace，需要打开一些config和进行一些设备树配置。Zephyr中支持通过snippets的形式提供一组config和设备树配置，这样就不用一个一个手动添加了。</p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430161938500.png\" alt=\"image-20250430161938500\"></p>\n<p>在Build Configuration中添加<code>nrf91-modem-trace-uart</code>即可。</p>\n<p>如果是命令行编译的方法，就添加<code>-D&lt;image_name&gt;_SNIPPET=&quot;nrf91-modem-trace-uart&quot;</code>参数，如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -p \\</span><br><span class=\"line\">-b nrf9151dk/nrf9151/ns \\</span><br><span class=\"line\">-- \\</span><br><span class=\"line\">  -DSHIELD=nrf7002ek_nrf7000 \\</span><br><span class=\"line\">  -DSB_CONF_FILE=<span class=\"string\">&quot;sysbuild_nrf700x-wifi-scan.conf&quot;</span> \\</span><br><span class=\"line\">  -DEXTRA_CONF_FILE=<span class=\"string\">&quot;overlay-nrf7002ek-wifi-scan-only.conf&quot;</span> \\</span><br><span class=\"line\">  -Dnrf_cloud_multi_service_SNIPPET=<span class=\"string\">&quot;nrf91-modem-trace-uart&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果你想查看snippets具体添加了哪些配置，可以查看Build信息：</p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430163301076.png\" alt=\"image-20250430163301076\"></p>\n<p>可以看到使用的是串口1，波特率1M：</p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430163326698.png\" alt=\"image-20250430163326698\"></p>\n</blockquote>\n<p><strong>编译完毕后重新烧录固件</strong>。</p>\n<p>把9151DK通过USB连接到电脑。在nRF Connect for Desktop中打开Cellular Monitor：</p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430163535426.png\" alt=\"image-20250430163535426\"></p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430170545090.png\" alt=\"image-20250430170545090\"></p>\n<p>nRF9151的UART0和UART1，在板子上直接连到Jink USB的，因此无需再接串口。</p>\n<p>这里一个串口是日志输出和AT Commands通道，另一个是Modem Trace，注意不要选错。Modem Trace database选择你下载的Modem Firmware的版本。</p>\n<p><strong>nRF Connect下的所有软件可以共享串口，所以你可以同时打开“Open Serial Terminal”，查看日志和AT Commands.</strong></p>\n<p>之后点击Start就可以开始抓包：</p>\n<p><img src=\"/jayant97.github.io/./_posts/nRF9151%E8%9C%82%E7%AA%9D%E6%A8%A1%E7%BB%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BE%8B%E7%A8%8B%E8%A7%A3%E6%9E%90.assets/image-20250430171642316.png\" alt=\"image-20250430171642316\"></p>\n<p>左下角为抓包文件存储位置。</p>\n<p>你也可以在Start之前，打开“Open in Wireshark”：</p>\n<h1 id=\"9-代码解析\"><a href=\"#9-代码解析\" class=\"headerlink\" title=\"9. 代码解析\"></a>9. 代码解析</h1>"},{"title":"使用Ubuntu进行WiFi抓包","url":"/jayant97.github.io/2022/12/5dfa479d25f0/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t在之前的文章里，我介绍了如何在Windows中使用NPCAP把无线网卡变为monitor模式，并用Wireshark进行抓包。但是Windows下支持monitor的无线网卡实在是太少了，笔记本自带的PCIE无线网卡更是无法支持。\t</p>\n<p>​\t本文介绍如何在Linux系统下进行WiFi的抓包，并且在本地或者用另一台Windows电脑的Wireshark进行实时分析。</p>\n<p>​\t本文使用的硬件环境：</p>\n<ul>\n<li>Ubuntu笔记本电脑：<ul>\n<li>操作系统：Ubuntu 22.04</li>\n<li>WiFi网卡：Intel(R) Wi-Fi 6E AX211 160MHz （支持WiFi6E）</li>\n<li>有线网口（可选）：WiFi网卡变成monitor模式后，用有线网让Windows电脑远程连接到Ubuntu电脑</li>\n</ul>\n</li>\n<li>路由器：支持wifi6的路由器</li>\n<li>手机：支持wifi6的手机</li>\n<li>Windows笔记本电脑（可选）</li>\n</ul>\n<p>​\t示意图如下，虚线内容是可选的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216162542858.png\" alt=\"image-20221216162542858\"></p>\n<blockquote>\n<p>在linux下查看自己的WiFi网卡是否支持抓包：</p>\n<p><strong>网卡驱动已经安装的情况</strong>：</p>\n<ol>\n<li><p>查看自己电脑上的所有网卡，并查看其驱动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo lshw -C network                                                            </span><br><span class=\"line\">   [sudo] password <span class=\"keyword\">for</span> jayant:</span><br><span class=\"line\">  *-network</span><br><span class=\"line\">       description: Wireless interface</span><br><span class=\"line\">       product: Alder Lake-P PCH CNVi WiFi</span><br><span class=\"line\">       vendor: Intel Corporation</span><br><span class=\"line\">      ...</span><br><span class=\"line\">       logical name: wlp0s20f3mon</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      ...</span><br><span class=\"line\">       configuration: broadcast=<span class=\"built_in\">yes</span> driver=iwlwifi driverversion=5.15.0-56-generic firmware=64.97bbee0a.0 so-a0-gf-a0-64.uc latency=0 <span class=\"built_in\">link</span>=<span class=\"built_in\">yes</span> multicast=<span class=\"built_in\">yes</span> wireless=IEEE 802.11</span><br><span class=\"line\">       resources: iomemory:600-5ff irq:16 memory:601d1cc000-601d1cffff</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>  可以看到 在configuration中，<code>driver=iwlwifi</code>，说明wifi网卡的驱动是<code>iwlwifi</code>。</p>\n<ol start=\"2\">\n<li>在<a href=\"https://wireless.wiki.kernel.org/en/users/drivers\">Linux Wireless</a>网站中搜索这个驱动，可以看到这个驱动是支持monitor模式的，说明可以用来抓包：</li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216232607399.png\" alt=\"image-20221216232607399\"></p>\n<p><strong>网卡驱动未安装的情况</strong></p>\n<ol>\n<li>如果<code>ifconfig</code>和<code>iwconfig</code>看不到无线网卡，则可能是没有驱动</li>\n<li>根据是USB网卡还是PCIE网卡，可以先执行<code>lsusb</code>和<code>lspci</code>来看一下是否能识别到硬件</li>\n<li>如果能识别到硬件，再去google上搜索此款网卡的驱动，并在<a href=\"https://wireless.wiki.kernel.org/en/users/drivers\">Linux Wireless</a>网站上搜索此驱动是否支持Monitor模式。</li>\n</ol>\n</blockquote>\n<h1 id=\"2-在Linux环境下进行抓包\"><a href=\"#2-在Linux环境下进行抓包\" class=\"headerlink\" title=\"2. 在Linux环境下进行抓包\"></a>2. 在Linux环境下进行抓包</h1><p>​\t本节参考的文章：<a href=\"https://www.aneasystone.com/archives/2016/08/wireless-analysis-one-monitoring.html\">实战无线网络分析（篇一）无线监听 - aneasystone’s blog</a></p>\n<h2 id=\"2-1-安装工具\"><a href=\"#2-1-安装工具\" class=\"headerlink\" title=\"2.1. 安装工具\"></a>2.1. 安装工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt install -y wireshark net-tools wireless-tools aircrack-ng</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-无线网卡改为Monitor模式\"><a href=\"#2-2-无线网卡改为Monitor模式\" class=\"headerlink\" title=\"2.2. 无线网卡改为Monitor模式\"></a>2.2. 无线网卡改为Monitor模式</h2><blockquote>\n<p>注意，在Linux系统中，当一个无线网卡被改为Monitor模式后，就无法用来上网了。</p>\n</blockquote>\n<p>​\t查看无线网卡名称：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ iwconfig</span><br><span class=\"line\">lo        no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">wlp0s20f3  IEEE 802.11  ESSID:off/any</span><br><span class=\"line\">          Mode:Managed  Access Point: Not-Associated   Tx-Power=-2147483648 dBm</span><br><span class=\"line\">          Retry short <span class=\"built_in\">limit</span>:7   RTS thr:off   Fragment thr:off</span><br><span class=\"line\">          Power Management:on</span><br><span class=\"line\"></span><br><span class=\"line\">enx000ec6259ae4  no wireless extensions.</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到网卡名称是<code>wlp0s20f3</code></p>\n<p>​\t将网卡改为Monitor模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo airmon-ng start wlp0s20f3        </span><br><span class=\"line\"></span><br><span class=\"line\">PHY    Interface\tDriver\t\tChipset</span><br><span class=\"line\"></span><br><span class=\"line\">phy0    wlp0s20f3\tiwlwifi\t\tIntel Corporation Alder Lake-P PCH CNVi WiFi (rev 01)</span><br><span class=\"line\">        (mac80211 monitor mode vif enabled <span class=\"keyword\">for</span> [phy0]wlp0s20f3 on [phy0]wlp0s20f3mon)</span><br><span class=\"line\">        (mac80211 station mode vif disabled <span class=\"keyword\">for</span> [phy0]wlp0s20f3)</span><br></pre></td></tr></table></figure>\n\n<p>​\t这时使用<code>iwconfig</code>查看，会出现一个新的网卡，<strong>网卡名称也发生了改变</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">~$ iwconfig</span><br><span class=\"line\">lo        no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">enx000ec6259ae4  no wireless extensions.</span><br><span class=\"line\"></span><br><span class=\"line\">wlp0s20f3mon  IEEE 802.11  Mode:Monitor  Frequency:2.457 GHz  Tx-Power=-2147483648 dBm</span><br><span class=\"line\">          Retry short <span class=\"built_in\">limit</span>:7   RTS thr:off   Fragment thr:off</span><br></pre></td></tr></table></figure>\n\n<p>可以看到名称变为<code>wlp0s20f3mon</code>，并且Mode变为了Monitor</p>\n<blockquote>\n<p>注意：</p>\n<p>​\t有些教程会让你使用<code>sudo airmon-ng check kill</code>来自动杀死一些会影响Monitor网卡的守护进程，这些进程可能会导致网卡的信道被切换，也可能把网卡切回Managed模式。</p>\n<p>​\t但是这样直接杀死 Network Manager，会导致其他的网卡（比如有线网络）在拔掉后也无法自动连回。目前比较好的解决方法是：使用<code>nmtui</code>命令（NetworkManager的图形菜单），在Edit Connection中，把你要抓包的这张网卡记住的WiFi都改成“不自动连接”，这样你的网卡就不会被Network Manager改回Manged模式了。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223152925995.png\" alt=\"image-20221223152925995\"></p>\n</blockquote>\n<h2 id=\"2-3-在Linux中进行抓包\"><a href=\"#2-3-在Linux中进行抓包\" class=\"headerlink\" title=\"2.3. 在Linux中进行抓包\"></a>2.3. 在Linux中进行抓包</h2><p>首先，以root权限打开Wireshark</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo wireshark</span><br></pre></td></tr></table></figure>\n\n<p>然后，在”Capture –&gt; Options…”窗口中，可以看到<code>wlp0s20f3mon</code>网卡：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216165935706.png\" alt=\"image-20221216165935706\"></p>\n<blockquote>\n<p>注意到Monitor Mode栏并不能打勾，但是没关系，网卡本身已经是Monitor模式了</p>\n</blockquote>\n<p>​\t</p>\n<h2 id=\"2-4-设置要抓包的信道\"><a href=\"#2-4-设置要抓包的信道\" class=\"headerlink\" title=\"2.4. 设置要抓包的信道\"></a>2.4. 设置要抓包的信道</h2><p>​\t本节参考：<a href=\"https://netbeez.net/blog/linux-channel-hopping-wifi-packet-capturing/\">Linux for Network Engineers: How to do channel hopping during WiFi packet capturing | NetBeez</a></p>\n<h3 id=\"2-4-1-信道与带宽介绍\"><a href=\"#2-4-1-信道与带宽介绍\" class=\"headerlink\" title=\"2.4.1. 信道与带宽介绍\"></a>2.4.1. 信道与带宽介绍</h3><p>​\t在Monitor模式下，只能扫描<strong>固定的信道和带宽</strong>。为了能够找到自己想要抓的设备到底在哪个信道进行通信，需要先进行<strong>跳频Channel Hopping）</strong>。跳频时，不可避免的会扫不到一些包，但是等找到自己想要监听的信道之后，再切回固定信道的方式即可。</p>\n<blockquote>\n<p>什么是WiFi的信道和带宽？</p>\n<p>​\t不同版本的WiFi协议，其无线电载波工作在不同的频率上，常见的如2.4 GHz和5 GHz。但这都不是指一个频率的值，而是指一个范围。因为固定频率的波是无法承载信息的，只有能切换频率的波才能承载信息。把这个频率范围分成很多份，就是<strong>信道</strong>，每个信道的频率宽度称为<strong>带宽</strong>。</p>\n<p>例如：2.4 GHz （802.11 b&#x2F;g&#x2F;n）频段分配，共有14个信道</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223160719938.png\" alt=\"image-20221223160719938\"></p>\n<p>​\t如果每个信道的带宽是22MHz，那么2.4G最多只能同时使用三个信道（1，6和11）。14信道是特殊的，大多数国家不允许使用。<br>​\t如果信道带宽是20MHz，那么最多可以同时使用四个信道（1，5，9，13）.</p>\n<p>​\t同理，5GHz频段，信道从5.000GHz（信道0）开始编码，每5MHz一个信道。但FCC开放的频率从5.150GHz开始，故实际使用的信道是从36开始的，频宽20MHz，可用信道每次+4，如36，40，44，48 … 64 。</p>\n<p>​\t每个国家可用的信道，可参考：<a href=\"https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8\">无线局域网信道列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>\n</blockquote>\n<p>​\t</p>\n<p>​\t查看自己无线网卡<strong>支持</strong>的信道：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下命令将输出大量信息</span></span><br><span class=\"line\">$ iw list</span><br><span class=\"line\">Wiphy phy0</span><br><span class=\"line\">        ... </span><br><span class=\"line\">        Available Antennas: TX 0x3 RX 0x3   <span class=\"comment\"># 天线数量</span></span><br><span class=\"line\">        Configured Antennas: TX 0x3 RX 0x3</span><br><span class=\"line\">        Supported interface modes:          <span class=\"comment\"># 网卡支持的模式</span></span><br><span class=\"line\">                 * IBSS</span><br><span class=\"line\">                 * managed</span><br><span class=\"line\">                 * AP</span><br><span class=\"line\">                 * AP/VLAN</span><br><span class=\"line\">                 * monitor   <span class=\"comment\"># 支持 monitor</span></span><br><span class=\"line\">                 * P2P-client</span><br><span class=\"line\">                 * P2P-GO</span><br><span class=\"line\">                 * P2P-device</span><br><span class=\"line\">        Band 1:</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                Frequencies: <span class=\"comment\"># 2.4 GHz 信道，disabled为不可用</span></span><br><span class=\"line\">                        * 2412 MHz [1] (22.0 dBm)</span><br><span class=\"line\">                        * 2417 MHz [2] (22.0 dBm)</span><br><span class=\"line\">                        * 2422 MHz [3] (22.0 dBm)</span><br><span class=\"line\">                        * 2427 MHz [4] (22.0 dBm)</span><br><span class=\"line\">                        * 2432 MHz [5] (22.0 dBm)</span><br><span class=\"line\">                        * 2437 MHz [6] (22.0 dBm)</span><br><span class=\"line\">                        * 2442 MHz [7] (22.0 dBm)</span><br><span class=\"line\">                        * 2447 MHz [8] (22.0 dBm)</span><br><span class=\"line\">                        * 2452 MHz [9] (22.0 dBm)</span><br><span class=\"line\">                        * 2457 MHz [10] (22.0 dBm)</span><br><span class=\"line\">                        * 2462 MHz [11] (22.0 dBm)</span><br><span class=\"line\">                        * 2467 MHz [12] (22.0 dBm)</span><br><span class=\"line\">                        * 2472 MHz [13] (22.0 dBm)</span><br><span class=\"line\">                        * 2484 MHz [14] (disabled)</span><br><span class=\"line\">        Band 2:</span><br><span class=\"line\">               ...</span><br><span class=\"line\">                Frequencies: <span class=\"comment\"># 5 GHz 信道，disabled为不可用</span></span><br><span class=\"line\">                        * 5180 MHz [36] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5200 MHz [40] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5220 MHz [44] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5240 MHz [48] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5260 MHz [52] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5280 MHz [56] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5300 MHz [60] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5320 MHz [64] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5340 MHz [68] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5480 MHz [96] (disabled)</span><br><span class=\"line\">                        * 5500 MHz [100] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5720 MHz [144] (22.0 dBm) (no IR, radar detection)</span><br><span class=\"line\">                        * 5745 MHz [149] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5765 MHz [153] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5785 MHz [157] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5805 MHz [161] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5825 MHz [165] (22.0 dBm) (no IR)</span><br><span class=\"line\">                        * 5845 MHz [169] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 5905 MHz [181] (disabled)</span><br><span class=\"line\">        Band 4:</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                Frequencies:  <span class=\"comment\"># 6 GHz 信道，中国不可用</span></span><br><span class=\"line\">                        * 5955 MHz [1] (disabled)</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        * 7115 MHz [233] (disabled)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t</p>\n<p>​\t查看无线网卡<strong>当前</strong>的信道和带宽：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ iw wlp0s20f3mon info</span><br><span class=\"line\">Interface wlp0s20f3mon</span><br><span class=\"line\">        ifindex 4</span><br><span class=\"line\">        wdev 0x3</span><br><span class=\"line\">        addr 00:93:37:90:08:3a</span><br><span class=\"line\">        <span class=\"built_in\">type</span> monitor</span><br><span class=\"line\">        wiphy 0</span><br><span class=\"line\">        channel 10 (2457 MHz), width: 20 MHz (no HT), center1: 2457 MHz</span><br><span class=\"line\">        txpower 0.00 dBm</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到，当前使用信道10，带宽20MHz，这与Wireshark中的信息是一致的，说明我们目前只能抓到信道10、带宽20MHz的包：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221217162609725.png\" alt=\"image-20221217162609725\"></p>\n<h3 id=\"2-4-2-修改信道与带宽\"><a href=\"#2-4-2-修改信道与带宽\" class=\"headerlink\" title=\"2.4.2.  修改信道与带宽\"></a>2.4.2.  修改信道与带宽</h3><p>​\t由于Wireshark不提供切换信道的功能。我们只能自己手动切换信道和带宽，以下为设置信道和带宽的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo iw dev wlp0s20f3mon <span class=\"built_in\">set</span> channel 149 80MHz</span><br><span class=\"line\"><span class=\"comment\"># 网卡名：wlp0s20f3mon</span></span><br><span class=\"line\"><span class=\"comment\"># 频道：149</span></span><br><span class=\"line\"><span class=\"comment\"># 带宽：可选的参数有</span></span><br><span class=\"line\"><span class=\"comment\">#     NOHT  : 不使用802.11n，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#     HT20  : 802.11n/ac/ax 20MHz频宽</span></span><br><span class=\"line\"><span class=\"comment\">#     HT40+ : 802.11n/ac/ax 双20MHz，控制信道比扩展信道频率高</span></span><br><span class=\"line\"><span class=\"comment\">#     HT40- : 802.11n/ac/ax 双20MHz，控制信道比扩展信道频率低</span></span><br><span class=\"line\"><span class=\"comment\">#    5MHz  : 5MHz，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#     10MHz : 10MHz，基本很少用</span></span><br><span class=\"line\"><span class=\"comment\">#    80MHz : 802.11ac/ax</span></span><br><span class=\"line\"><span class=\"comment\">#     160MHz: 802.11ac/ax</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t以上命令，是可以在抓包时<strong>实时</strong>执行的，无需重启Wireshark，可以看到信道立即发生了改变：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221217163934869.png\" alt=\"image-20221217163934869\"></p>\n<h3 id=\"2-4-3-实时跳频\"><a href=\"#2-4-3-实时跳频\" class=\"headerlink\" title=\"2.4.3. 实时跳频\"></a>2.4.3. 实时跳频</h3><p>​\t<strong>信道×带宽</strong>的排列组合选项太多，我们不知道哪些组合是合法的，以及自己的网卡是否支持这些组合。我们需要2个脚本，来自动帮我们完成一些工作：</p>\n<ul>\n<li>配置识别：自动识别出当前网卡哪些<strong>信道</strong>+<strong>带宽</strong>的排列组合是合法的，并记录下来</li>\n<li>自动跳频：在前一个脚本的范围内，无限循环跳频扫描</li>\n</ul>\n<p>第一个脚本，<strong>配置识别</strong>：</p>\n<p><code>test-channels.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># Make sure that the wifi adapter below is in Monitor mode.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Wi-Fi Adapter</span></span><br><span class=\"line\">DEFAULT_INTERFACE=<span class=\"string\">&quot;wlp0s20f3mon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_24=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14&quot;</span></span><br><span class=\"line\">channels_50=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">widths=<span class=\"string\">&quot;HT20 HT40+ HT40- 80MHz 160MHz&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">result_2g4=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">result_5g=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">current_user=$(<span class=\"built_in\">whoami</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$current_user</span>&quot;</span> != <span class=\"string\">&quot;root&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;[Error] Please run this script with sudo!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> width <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;widths&#125;</span>;<span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    valid_channels=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels_24&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> iw <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> info | grep <span class=\"string\">&quot;channel <span class=\"variable\">$&#123;channel&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">                valid_channels=<span class=\"string\">&quot;<span class=\"variable\">$&#123;valid_channels&#125;</span>&quot;</span><span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span> &quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">fi</span>    </span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">    result_2g4=<span class=\"string\">&quot;<span class=\"variable\">$&#123;result_2g4&#125;</span>&quot;</span><span class=\"string\">&quot;Width:<span class=\"variable\">$&#123;width&#125;</span>, Valid Channels:<span class=\"variable\">$&#123;valid_channels&#125;</span>\\n&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> width <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;widths&#125;</span>;<span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    valid_channels=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels_50&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> iw <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> info | grep <span class=\"string\">&quot;channel <span class=\"variable\">$&#123;channel&#125;</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">                valid_channels=<span class=\"string\">&quot;<span class=\"variable\">$&#123;valid_channels&#125;</span>&quot;</span><span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span> &quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">fi</span>    </span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">    result_5g=<span class=\"string\">&quot;<span class=\"variable\">$&#123;result_5g&#125;</span>&quot;</span><span class=\"string\">&quot;Width:<span class=\"variable\">$&#123;width&#125;</span>, Valid Channels:<span class=\"variable\">$&#123;valid_channels&#125;</span>\\n&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;  &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;===================================================&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2.4G:&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;result_2g4&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5G:&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;result_5g&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>给这个脚本添加执行权限，修改脚本中的网卡名，并用sudo执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> +x ./test-channels.sh</span><br><span class=\"line\">$ sudo ./test-channels.sh</span><br><span class=\"line\">...</span><br><span class=\"line\">===================================================</span><br><span class=\"line\">2.4G:</span><br><span class=\"line\">Width:HT20, Valid Channels:1 2 3 4 5 6 7 8 9 10 11 12 13 </span><br><span class=\"line\">Width:HT40+, Valid Channels:1 2 3 4 5 6 7 8 9 </span><br><span class=\"line\">Width:HT40-, Valid Channels:5 6 7 8 9 10 11 12 13 </span><br><span class=\"line\">Width:80MHz, Valid Channels:</span><br><span class=\"line\">Width:160MHz, Valid Channels:</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">5G:</span><br><span class=\"line\">Width:HT20, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165 </span><br><span class=\"line\">Width:HT40+, Valid Channels:36 44 52 60 100 108 116 124 132 140 149 157 </span><br><span class=\"line\">Width:HT40-, Valid Channels:40 48 56 64 104 112 120 128 136 144 153 161 </span><br><span class=\"line\">Width:80MHz, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 </span><br><span class=\"line\">Width:160MHz, Valid Channels:36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 </span><br></pre></td></tr></table></figure>\n\n<p>可以看出此脚本列举出了5G、2.4G频段下，各个带宽下支持的扫描信道。</p>\n<p>第二个脚本，<strong>自动跳频</strong>：</p>\n<p>自动跳频的脚本内记录了每种带宽下，网卡可以支持的信道。这些数据来源是前一个脚本的输出结果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">DEFAULT_INTERFACE=<span class=\"string\">&quot;wlp0s20f3mon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_2G4_HT20=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9 10 11 12 13&quot;</span></span><br><span class=\"line\">channels_2G4_HT40p=<span class=\"string\">&quot;1 2 3 4 5 6 7 8 9&quot;</span></span><br><span class=\"line\">channels_2G4_HT40m=<span class=\"string\">&quot;5 6 7 8 9 10 11 12 13&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">channels_5G_HT20=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165&quot;</span></span><br><span class=\"line\">channels_5G_HT40p=<span class=\"string\">&quot;36 44 52 60 100 108 116 124 132 140 149 157&quot;</span></span><br><span class=\"line\">channels_5G_HT40m=<span class=\"string\">&quot;40 48 56 64 104 112 120 128 136 144 153 161&quot;</span></span><br><span class=\"line\">channels_5G_80MHz=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161&quot;</span></span><br><span class=\"line\">channels_5G_160MHz=<span class=\"string\">&quot;36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">current_user=$(<span class=\"built_in\">whoami</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">&quot;<span class=\"variable\">$current_user</span>&quot;</span> != <span class=\"string\">&quot;root&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;[Error] Please run this script with sudo!&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -n <span class=\"variable\">$1</span> ] </span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"variable\">$1</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"string\">&quot;HT20&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT20</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT20</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;HT40+&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT40p</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT40p</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;HT40-&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_2G4_HT40m</span>&quot;</span><span class=\"string\">&quot; &quot;</span><span class=\"string\">&quot;<span class=\"variable\">$channels_5G_HT40m</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;80MHz&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_5G_80MHz</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&quot;160MHz&quot;</span>)</span><br><span class=\"line\">        channels=<span class=\"string\">&quot;<span class=\"variable\">$channels_5G_160MHz</span>&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    *)</span><br><span class=\"line\">        echp <span class=\"string\">&quot;Invalid Bandwidth: <span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;no bandwidth set! i.e. &#x27;sudo channel-hopping.sh HT20&#x27;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">width=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> channel <span class=\"keyword\">in</span> <span class=\"variable\">$&#123;channels&#125;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Setting channel <span class=\"variable\">$&#123;channel&#125;</span>, <span class=\"variable\">$&#123;width&#125;</span>&quot;</span></span><br><span class=\"line\">    iw dev <span class=\"variable\">$&#123;DEFAULT_INTERFACE&#125;</span> <span class=\"built_in\">set</span> channel <span class=\"string\">&quot;<span class=\"variable\">$&#123;channel&#125;</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;width&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">sleep</span> 0.5</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>给这个脚本添加执行权限，修改脚本中的网卡名，并用sudo执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">chmod</span> +x channel-hopping.sh</span><br><span class=\"line\">$ sudo ./channel-hopping.sh HT20</span><br></pre></td></tr></table></figure>\n\n<p>执行脚本时，指定要使用的带宽，脚本将会每 0.5s 切换一次信道。</p>\n<p>脚本只会循环执行一次，之后你可以手动指定信道和带宽。</p>\n<h3 id=\"2-4-4-过滤器\"><a href=\"#2-4-4-过滤器\" class=\"headerlink\" title=\"2.4.4. 过滤器\"></a>2.4.4. 过滤器</h3><p>跳频时，可以设置过滤器来抓自己设备的包。</p>\n<p><strong>显示过滤器</strong>语法：</p>\n<p><strong>Source Address:</strong> <code>wlan.sa==XX:XX:XX:XX:XX:XX</code><br><strong>Destination Address:</strong> <code>wlan.da==XX:XX:XX:XX:XX:XX</code><br><strong>Receiver Address:</strong>  <code>wlan.ra==XX:XX:XX:XX:XX:XX</code><br><strong>Transmitter Address:</strong>  <code>wlan.ta==XX:XX:XX:XX:XX:XX</code></p>\n<p>例如，可以在手机上查看MAC地址，然后输入到wireshark中</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221223155547191.png\" alt=\"image-20221223155547191\"></p>\n<p>可以看到，成功抓到了手机的WiFi6包（802.11ax）</p>\n<h2 id=\"2-5-关闭monitor模式的方法\"><a href=\"#2-5-关闭monitor模式的方法\" class=\"headerlink\" title=\"2.5. 关闭monitor模式的方法\"></a>2.5. 关闭monitor模式的方法</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo airmon-ng stop wlp0s20f3mon</span><br></pre></td></tr></table></figure>\n\n<p>注意网卡名是变为monitor之后的网卡名。</p>\n<h1 id=\"3-在Windows上远程抓包\"><a href=\"#3-在Windows上远程抓包\" class=\"headerlink\" title=\"3. 在Windows上远程抓包\"></a>3. 在Windows上远程抓包</h1><h2 id=\"3-1-确保Ubuntu上安装了ssh服务\"><a href=\"#3-1-确保Ubuntu上安装了ssh服务\" class=\"headerlink\" title=\"3.1. 确保Ubuntu上安装了ssh服务\"></a>3.1. 确保Ubuntu上安装了ssh服务</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-让用户执行sudo命令不用输入密码\"><a href=\"#3-2-让用户执行sudo命令不用输入密码\" class=\"headerlink\" title=\"3.2. 让用户执行sudo命令不用输入密码\"></a>3.2. 让用户执行sudo命令不用输入密码</h2><p>​\t抓包需要root权限，并且我们用wireshark远程抓包的时候无法输入sudo密码。网上会有两种不太推荐的方法解决问题：</p>\n<ul>\n<li>直接打开root的ssh登陆权限，后续Windows电脑的Wireshark直接通过root登录</li>\n<li>让自己的用户执行sudo时不需要密码</li>\n</ul>\n<p>​\t但是以上两种方法是很不安全的，下面介绍一种通过改sudo配置的方式，让你的linux用户只在执行一些指定的命令的时候不需要输入sudo密码，而其他时候还是要密码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用visudo编辑器，在/etc/sudoers.d/下创建个人的sudo配置</span></span><br><span class=\"line\">sudo visudo </span><br></pre></td></tr></table></figure>\n\n<p>​\t填入以下内容，然后保存：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">jayant ALL=(root)NOPASSWD:/usr/bin/tcpdump</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>释义：</p>\n<pre><code>- jayant：用户名或组名，如果是组名，前面加`%`\n- ALL：主机名，多服务器才有用，这里设置ALL即可\n- (root)：完整写法是(用户名:组名)，这里只写了用户名。这里指jayant可以作为root运行后面的指令。如果只有组名，写`(:组名)`\n- NOPASSWD:/usr/bin/tcpdump ：指定的命令，前面`NOPASSWD:`指不需要密码。这里需要填命令的绝对地址，如果你不知道绝对地址，可以输入`which tcpdump `查看。\n</code></pre>\n<p>其他说明：</p>\n<p>​\t在 <code>/etc/sudoers</code>中，有<code>@include</code>语句包含了<code>/etc/sudoers.d/</code>下的所有文件（文件名不含<code>.</code>和<code>~</code>），所以我们不需要修改<code>/etc/sudoers</code>，而是在<code>/etc/sudoers.d/</code>目录中增加自己的配置文件；</p>\n<p>​\t使用visudo文本编辑器进行编辑，可以在保存时自动提示是否有语法错误。\t</p>\n</blockquote>\n<p>测试一下<code>sudo tcpdump</code>是不是已经不需要输入密码了。</p>\n<h2 id=\"3-3-按照第二节的做法，把网卡设为monitor模式\"><a href=\"#3-3-按照第二节的做法，把网卡设为monitor模式\" class=\"headerlink\" title=\"3.3. 按照第二节的做法，把网卡设为monitor模式\"></a>3.3. 按照第二节的做法，把网卡设为monitor模式</h2><p>​\t请参考第2节的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo airmon-ng check <span class=\"built_in\">kill</span></span><br><span class=\"line\">sudo airmon-ng start &lt;网卡名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-在Windows上安装sshdump\"><a href=\"#3-4-在Windows上安装sshdump\" class=\"headerlink\" title=\"3.4. 在Windows上安装sshdump\"></a>3.4. 在Windows上安装sshdump</h2><p>​\t安装Wireshark时勾选即可</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194013150.png\" alt=\"image-20221216194013150\"></p>\n<h2 id=\"3-5-在Windows上设置Wireshark\"><a href=\"#3-5-在Windows上设置Wireshark\" class=\"headerlink\" title=\"3.5. 在Windows上设置Wireshark\"></a>3.5. 在Windows上设置Wireshark</h2><img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194117135.png\" alt=\"image-20221216194117135\" style=\"zoom: 50%;\" />\n\n<p>设置远程主机地址和ssh端口：</p>\n<img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194137684.png\" alt=\"image-20221216194137684\" style=\"zoom: 50%;\" />\n\n<p>我这里使用密钥登录，也可以使用密码：</p>\n<img src=\"/jayant97.github.io/imgs/使用Ubuntu进行WiFi6抓包.assets/image-20221216194206105.png\" alt=\"image-20221216194206105\" style=\"zoom:50%;\" />\n\n<p>设置网卡名：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194235505.png\" alt=\"image-20221216194235505\"></p>\n<h2 id=\"3-6-开始抓包\"><a href=\"#3-6-开始抓包\" class=\"headerlink\" title=\"3.6. 开始抓包\"></a>3.6. 开始抓包</h2><p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8Ubuntu%E8%BF%9B%E8%A1%8CWiFi6%E6%8A%93%E5%8C%85.assets/image-20221216194816124.png\" alt=\"image-20221216194816124\"></p>\n<p>​\t</p>\n","categories":["网络","WiFi"],"tags":["Linux","Wireshark","WiFi"]},{"title":"nRF9160与nRF Cloud应用示例","url":"/jayant97.github.io/2022/12/175d0fa05ecc/","content":"<h1 id=\"1-产品简介\"><a href=\"#1-产品简介\" class=\"headerlink\" title=\"1. 产品简介\"></a>1. 产品简介</h1><h2 id=\"1-1-nRF-Cloud\"><a href=\"#1-1-nRF-Cloud\" class=\"headerlink\" title=\"1.1. nRF Cloud\"></a>1.1. nRF Cloud</h2><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221204174543482.png\" alt=\"image-20221204174543482\" style=\"zoom: 67%;\" />\n\n<p>​\tnRF Cloud是Nordic Semiconducotr公司在AWS上搭建的IoT平台，提供<strong>设备注册（Cloud Provisioning）</strong>、<strong>OTA升级</strong>、<strong>数据存储</strong>、<strong>位置服务</strong>等业务，所有这些功能都可通过Web界面进行管理。此外还有账号权限控制功能，客户可以为不同的团队配置不同级别的账户管理权限。本文会介绍上述功能的具体使用方法。</p>\n<blockquote>\n<p>​\t除了设备注册、OTA、消息存储等物联网云平台常见的功能外，nRF Cloud的重要卖点是位置服务（Location Service）：</p>\n<ul>\n<li>AGPS&#x2F;PGPS：设备根据附近的基站信息，从Location Service获取当前地区GPS卫星的信息，从而缩小搜星范围，把搜星的几十秒缩短到几秒，极大的节省功耗</li>\n<li>基站定位：根据上传附近的基站id，从云端获取获取当前定位，支持单基站和多基定位</li>\n<li>WiFi定位：根据附近的WiFi SSID获取定位</li>\n</ul>\n</blockquote>\n<p>​\tnRF Cloud为Nordic nRF91系列产品提供了方便快速的上云方式，通过NCS的例程可以很方便的连入nRF Cloud。<strong>当然，非Nordic产品也是可以注册到nRF Cloud的，本文最后就会介绍如何使用随机生成的UUID来注册到nRF Cloud。</strong></p>\n<p>​\tnRF Cloud目前有Devloper，Pro和Enterprise三种收费计划。其中开发者计划（Developer plan）是<strong>完全免费</strong>的，你可以不用任何开发板，只使用PC就能连上云端进行测试。并且开发者计划每月有500条免费的Location Service。</p>\n<p>​\t设备通过nRF Cloud APIs与nRF Cloud进行连接，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221125164136165.png\" alt=\"image-20221125164136165\"></p>\n<p>​\t设备可以直接通过MQTT API或REST API接入到云。nRF Cloud也通过REST API为客户提供了<strong>云-云对接</strong>的接口。</p>\n<p>​\tnRF Cloud的MQTT连接使用X.509证书进行认证和加密。<strong>此证书不必是CA收费签发的证书，可以使用自签证书</strong>。Nordic提供了一套方便的脚本（TypeScript和Python可选）来进行证书的生成、签发、烧录。本文后续会介绍具体步骤。</p>\n<p>​\t要想调用nRF Cloud的REST API，对用户来说，使用常见的API Key进行认证；对IoT设备来说，需要使用JWT进行认证。JWT需要使用前述的X.509证书进行生成，本文后续会介绍IoT设备以及PC端测试JWT生成的方法。</p>\n<blockquote>\n<p>REST API 是通过HTTP请求来调用的</p>\n</blockquote>\n<p>​\t更多有关nRF Cloud的信息，可以参考：</p>\n<ul>\n<li><a href=\"https://docs.nrfcloud.com/\">nRF Cloud | nRF Cloud Docs</a></li>\n</ul>\n<h2 id=\"1-2-nRF9160-SiP\"><a href=\"#1-2-nRF9160-SiP\" class=\"headerlink\" title=\"1.2. nRF9160 SiP\"></a>1.2. nRF9160 SiP</h2><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-SiP-rev2-1016-front-and-back.webp\" alt=\"application\" style=\"zoom: 50%;\" />\n\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122134533863.png\" alt=\"image-20221122134533863\" style=\"zoom: 33%;\" />\n\n<p>​\tnRF9160是一款高集成度的低功耗SiP（System-in-Package），具有完整的LTE-M&#x2F;NB-IoT Modem、射频前端、电源管理系统，还具有一颗Cortex-M33应用处理器，便于开发自定义应用。nRF9160是目前市面上<strong>最紧凑、最完整、功耗最低</strong>的蜂窝物联网解决方案。</p>\n<p>​\tnRF9160内置的调制解调器（Modem）在全球范围内同时支持<strong>LTE-M</strong>和<strong>NB-IoT</strong>，并且支持<strong>eDRX和PSM省电模式</strong>，支持传输层安全（TCP&#x2F;TLS），支持GPS。</p>\n<p>​\tModem固件由Nordic以二进制形式提供，Modem固件可以通过OTA进行升级。</p>\n<blockquote>\n<p>中国大陆地区目前只有NB-IoT覆盖，无LTE-M。</p>\n</blockquote>\n<p>​\tCortex-M33应用处理器具有独享的1 MB Flash，256 KB SRAM和多种外设接口，可以让用户自行开发高效率的应用。</p>\n<p>​\t除了直接在9160上开发以外，也可以把nRF9160当作外挂模组，让外部MCU通过AT指令进行操作，拓展连网能力。在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看并下载AT指令手册。</p>\n<p>​\t在把9160当作外挂模组时，除了3GPP标准AT指令（以<code>AT+</code>开头），以及Nordic自定义的Modem相关指令（以<code>AT%</code>开头）以外。还可以在前述Cortex-M33应用核中烧录<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/applications/serial_lte_modem/README.html\">SLM（Serial LTE modem）</a>例程，这样就可以扩展出大量实用指令（以<code>AT#</code>开头），可以实现Socket、TCP&#x2F;UDP、MQTT、FOTA、DFU、FTP、GNSS、GPIO等实用功能，使得9160作为外挂模组时也能充分发挥其片上资源的作用。</p>\n<p>​\t在安全方面：Arm TrustZone技术可为固件和外设提供安全隔离和保护。使应用可实现Secure Boot、受信任固件升级、受信任的Root等安全需求，且不影响性能。Arm CryptoCell通过加密和安全资源来保护物联网应用程序免受各种攻击威胁。</p>\n<p>​\tnRF9160支持SIM和eSIM。今后随着与虚拟运营商的合作，还将在海内外支持SoftSIM。</p>\n<blockquote>\n<p>SoftSIM无需卡或芯片，SIM的信息直接烧录在9160内部。</p>\n</blockquote>\n<p>​\tnRF91的功耗极低，在PSM休眠时可以做到2.7uA的电流。\t</p>\n<p>​\t更多信息，可参考：</p>\n<ul>\n<li><a href=\"https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/Translated-versions/04_nRF9160-SiP-1.4_SC.pdf?la=en&hash=A1F478B9D8593C70FA143C1CA09C2759C8ED51B6\">nRF9160中文brief - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/nRF9160\">nRF9160 - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_PS_v2.1.pdf\">nRF9160 Product Specifications v2.1.pdf</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/Low-power-cellular-IoT/nRF9160-Certifications\">nRF9160 全球认证信息 - nordicsemi.com</a></li>\n</ul>\n<h2 id=\"1-3-nRF9160-DK-和-PPK-II\"><a href=\"#1-3-nRF9160-DK-和-PPK-II\" class=\"headerlink\" title=\"1.3. nRF9160 DK 和 PPK II\"></a>1.3. nRF9160 DK 和 PPK II</h2><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-DK.webp\" alt=\"nRF9160 DK promo\"></p>\n<p>​\tnRF9160 DK是一款优秀设计的预认证开发套件，带有一颗nRF9160 SiP和一颗nRF52840低功耗蓝牙MCU（用于开发BLE网关产品）。</p>\n<p>​\t板载一个支持多个频段的LTE-M和NB-IoT天线、一个GPS贴片天线和一个2.4G陶瓷天线（用于BLE）。其中LTE和2.4G天线接口提供SWF射频连接端子，便于测量RF信号。所有三款连接器均允许使用外部天线。</p>\n<p>​\t开发板引出了所有GPIO和接口，兼容Arduino Uno Rev3。提供可编程LED(4)、按钮(2)、开关(2)。开发板还具有nano SIM卡插槽（J5）和eSIM贴片焊盘（U20）或eSIM直插接口（P28）。</p>\n<p>板载正版Jlink OB，除可下载、调试板载的nRF9160外，也可对外调试其他产品。</p>\n<blockquote>\n<p>关于nRF 9160DK的更多信息，可参考：</p>\n<ul>\n<li><p><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN#infotabs\">nRF9160 DK - nordicsemi.com</a></p>\n</li>\n<li><p><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_DK_HW_User_Guide_v1.1.0.pdf\">nRF9160 DK HW User Guide v1.1.0.pdf</a></p>\n</li>\n</ul>\n</blockquote>\n<p>​\tNordic所有的开发板都预留了SoC&#x2F;SiP电流测量的接口。9160DK还预留了SIM卡电流测量的接口。电流的测量可以使用PPK II。下图展示了9160 PSM休眠时的电流（灰色窗口内平均电流为2.8uA）：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311124553236.png\" alt=\"image-20230311124553236\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/PPK2_SideView_Transparent.webp\" alt=\"Online Power Profiler\"></p>\n<p>​\tPower Profile Kit II (PPK II) 是一个方便的功耗测量工具，具有<strong>电流表</strong>和**电源(0.8V ~ 5V)**两种模式，且两种模式都可测量电流，范围从低于1uA到1A。PPK II本身通过USB供电（5V 500mA），如果在电源模式需要输出1A，需要插两个USB。</p>\n<p>​\tPPK II还自带8通道逻辑分析仪，便于分析各个阶段的功耗。下图底部为逻辑分析仪通道3的输出，它连接到9160的一个GPIO，用于测量9160连接MQTT服务器进行证书交换的耗时和功耗。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311123832875.png\" alt=\"image-20230311123832875\"></p>\n<blockquote>\n<p>更多有关PPK II的信息，可参考：<a href=\"https://www.nordicsemi.com/Products/Development-hardware/Power-Profiler-Kit-2\">Power Profiler Kit II - nordicsemi.com</a></p>\n</blockquote>\n<h2 id=\"1-4-nRF-Connect-SDK\"><a href=\"#1-4-nRF-Connect-SDK\" class=\"headerlink\" title=\"1.4. nRF Connect SDK\"></a>1.4. nRF Connect SDK</h2><p>​\tnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>\n<p>​\tNordic所有的新产品都将在NCS上进行开发。</p>\n<p>​\tNCS内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统、库和驱动。利用Device Tree和Kconfig进行项目的硬件、软件配置，自动载入驱动程序，自动初始化硬件。使用CMake和Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便。此外，NCS是跨平台的（Windows&#x2F;Linux&#x2F;OSX），支持命令行编译，可以在服务器上实现CI&#x2F;CD。</p>\n<p>​\tNCS提供VS Code插件，实现强大的项目管理、项目构建、调试等功能（支持条件断点、查看寄存器和</p>\n<p>线程堆栈）。</p>\n<p>​\tNCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。</p>\n<p>​\t更多信息可参考：</p>\n<ul>\n<li><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html\">About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n</li>\n</ul>\n<h1 id=\"2-入门-使用nRF9160-DK连接到nRF-Cloud\"><a href=\"#2-入门-使用nRF9160-DK连接到nRF-Cloud\" class=\"headerlink\" title=\"2. 入门: 使用nRF9160-DK连接到nRF Cloud\"></a>2. 入门: 使用nRF9160-DK连接到nRF Cloud</h1><p>​\t本节将会在nRF9160-DK开发板上，烧录<code>nrf/applications/asset_tracker_v2</code>例程。根据国内的网络进行配置，然后把板子连接到nRF Cloud上。</p>\n<h2 id=\"2-1-前期准备\"><a href=\"#2-1-前期准备\" class=\"headerlink\" title=\"2.1. 前期准备\"></a>2.1. 前期准备</h2><h3 id=\"硬件准备\"><a href=\"#硬件准备\" class=\"headerlink\" title=\"硬件准备\"></a>硬件准备</h3><ul>\n<li><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN\">nRF9160 DK开发板（本示例使用的版本：v1.1.0）</a>：其中nRF9160 SiP<strong>不能</strong>是Revision 1版本，必须是Revision 2或更高版本。<br>（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110534824.png\" alt=\"image-20221124110534824\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>micro USB线缆一根</p>\n</li>\n<li><p>中国移动NB-IoT卡(物联网卡)<br>  <img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122191558453.png\" alt=\"image-20221122191558453\"></p>\n<ul>\n<li>将电源开关拨到on，并确保调试开关处于”nRF91”挡位</li>\n<li>插好nano SIM卡，并通过microUSB线连接到电脑</li>\n</ul>\n<blockquote>\n<p>注：DK包装盒内附赠的iBASIS SIM卡为国外运营商产品，国内无法使用。需要另外购买移动NB-IoT物联网卡。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"非硬件准备\"><a href=\"#非硬件准备\" class=\"headerlink\" title=\"非硬件准备\"></a>非硬件准备</h3><ul>\n<li>一台Windows10或以上版本操作系统的电脑，并<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/779143a4bec8/\"><strong>正确安装了NCS开发环境</strong></a>。本次示例使用的NCS版本是v2.2.0。</li>\n<li>免费注册一个 <a href=\"https://nrfcloud.com/#/\">nRF Cloud</a> 账号</li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205005305505.png\" alt=\"image-20221205005305505\" style=\"zoom:50%;\" />\n\n<ul>\n<li>知道如何打开NCS中的例程，并且知道如何编译、烧写。</li>\n</ul>\n<h2 id=\"2-2-烧录Modem固件\"><a href=\"#2-2-烧录Modem固件\" class=\"headerlink\" title=\"2.2. 烧录Modem固件\"></a>2.2. 烧录Modem固件</h2><p>​\tnRF9160的Modem具有独立的固件，这部分固件是Nordic以zip包的形式提供的。</p>\n<ol>\n<li>在官网<a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK/Download#infotabs\">nRF9160 DK - Downloads - nordicsemi.com</a>界面，选中最新的Modem固件版本并下载（必须大于1.3.0）。</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143324324.png\" alt=\"image-20221123143324324\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"2\">\n<li>打开nRF Connect桌面版，找到Programmer工具并打开</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143424410.png\" alt=\"image-20221123143424410\" style=\"zoom: 67%;\" />\n\n\n\n<ol start=\"3\">\n<li>先选择板卡，然后选择固件文件（.zip），最后烧录</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143649354.png\" alt=\"image-20221123143649354\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"4\">\n<li>烧录完毕</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123144339925.png\" alt=\"image-20221123144339925\"></p>\n<h2 id=\"2-3-配置、编译并烧录Application固件\"><a href=\"#2-3-配置、编译并烧录Application固件\" class=\"headerlink\" title=\"2.3. 配置、编译并烧录Application固件\"></a>2.3. 配置、编译并烧录Application固件</h2><h3 id=\"2-3-1-以asset-tracker-v2为模板，创建新工程\"><a href=\"#2-3-1-以asset-tracker-v2为模板，创建新工程\" class=\"headerlink\" title=\"2.3.1. 以asset_tracker_v2为模板，创建新工程\"></a>2.3.1. 以asset_tracker_v2为模板，创建新工程</h3><blockquote>\n<p>asset_tracker_v2是applications目录下的例程。这个目录下的都是商业级例程，基本改一下就能作为产品使用了。</p>\n</blockquote>\n<p>​\t创建新工程相比于打开例程的好处，在我的另一篇文章《安装nRF-Connect-SDK》中已经描述了。</p>\n<p>​\t通过nrf connect插件界面的”Create a new application”来创建新的工程。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145304528.png\" alt=\"image-20221123145304528\"></p>\n<p>从上到下，选项依次为：</p>\n<ul>\n<li>NCS路径</li>\n<li>Zephyer SDK工具链路径</li>\n<li>本项目的存储位置</li>\n<li>选取作为模板的sample例程（NCS中的例程）</li>\n<li>本项目的名称</li>\n</ul>\n<p>​\t关于asset_tracker_v2例程的更多信息，可以参考官方的例程说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<blockquote>\n<p>建议把为这个新创建的初始化为git仓库，便于你记录自己修改了什么。</p>\n<p>记得添加<code>.gitignore</code>文件，并且忽略你的<code>build/</code>文件夹</p>\n</blockquote>\n<h3 id=\"2-3-2-为新工程创建build配置\"><a href=\"#2-3-2-为新工程创建build配置\" class=\"headerlink\" title=\"2.3.2. 为新工程创建build配置\"></a>2.3.2. 为新工程创建build配置</h3><p>板卡选择<code>nrf9160dk_nrf9160_ns</code>，然后Build Configuration即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145942948.png\" alt=\"image-20221123145942948\"></p>\n<h3 id=\"2-3-3-修改配置\"><a href=\"#2-3-3-修改配置\" class=\"headerlink\" title=\"2.3.3. 修改配置\"></a>2.3.3. 修改配置</h3><p>打开工程根目录下的<code>prj.conf</code>文件，进行修改：</p>\n<ol>\n<li>与运营商有关的修改</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 由于使用移动的NB物联网卡，故需要关闭LET-M，使用NB-IoT</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_LTE_M_GPS=n  <span class=\"comment\"># 由y改为n</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y  <span class=\"comment\"># 新增</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NB-IoT对ePCO支持的不好，故使用传统的PCO</span></span><br><span class=\"line\">CONFIG_PDN=y                         <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_PDN_LEGACY_PCO=y              <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>与nRF Cloud连接、注册有关的修改（后面小节会详细说明）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用JWT和UUID的云端注册方式</span></span><br><span class=\"line\">CONFIG_MODEM_JWT=y                              <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y  <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>【备注】<code>prj.conf</code>文件的作用：</p>\n<p>在Zephyer编译系统中，Kconfig管理编译选项、各类功能选项的开关，而devicetree用来管理硬件。编译时，通过CMake和ninja会调用一系列python辅助脚本，把Kconfig和device tree变成c代码和头文件。然后进行编译。更多资料，可参考：<a href=\"https://docs.zephyrproject.org/latest/build/index.html#build-and-configuration-systems\">Build and Configuration Systems — Zephyr Project Documentation</a></p>\n<p>开发时，只需关注Kconfig与device tree如何修改即可。Kconfig中的选项非常多，大多数情况下保持默认即可。Kconfig的默认配置保存在NCS中。</p>\n<p><code>prj.conf</code>的作用，就是为这个工程单独修改部分Kconfig配置。编译时，构建系统会优先使用prj.conf里的配置来覆盖默认的Kconfig配置。这样每个工程都可以单独配置，不会影响到NCS中的默认配置。</p>\n<p><code>prj.conf</code>中的选项都必须是Kconfig中可以找到的。</p>\n<p>在VS Code中通过图形界面修改完Kconfig时，也可以通过”Save to file”按钮，来把修改的部分单独保存到<code>prj.conf</code>中，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123154242926.png\" alt=\"image-20221123154242926\"></p>\n</blockquote>\n<h3 id=\"2-3-4-编译\"><a href=\"#2-3-4-编译\" class=\"headerlink\" title=\"2.3.4. 编译\"></a>2.3.4. 编译</h3><p>使用nRF Connect插件中的Action菜单中的build即可编译</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221205010029256.png\" alt=\"image-20221205010029256\"></p>\n<p>编译成功的结果：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205010439970.png\" alt=\"image-20221205010439970\" style=\"zoom: 50%;\" />\n\n<h3 id=\"2-3-5-烧录\"><a href=\"#2-3-5-烧录\" class=\"headerlink\" title=\"2.3.5. 烧录\"></a>2.3.5. 烧录</h3><p>​\t先把官方的开发板通过USB连接到电脑上，识别到Jlink之后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221123160139273-1670173336700-36.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n<p>​\t也可以通过命令行的形式进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>备注：\t</p>\n<p>​\t这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160245857-1670173336700-37.png\" alt=\"image-20221123160245857\"></p>\n<p>​\t这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。</p>\n<p>​\t全片擦除然后烧录的方式，点击Flash右边的按钮：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160832598-1670173336700-38.png\" alt=\"image-20221123160832598\"></p>\n<p>​\t或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash --force --erase</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"2-4-联网测试\"><a href=\"#2-4-联网测试\" class=\"headerlink\" title=\"2.4. 联网测试\"></a>2.4. 联网测试</h2><p>​\t在nRF Connect桌面版中，打开LTE Link Monitor工具。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123163321689.png\" alt=\"image-20221123163321689\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t然后左上角选择板卡，然后再打开串口。串口共有三个(都是Jlink提供的虚拟串口，在板子上2个连接到9160，1个连接到52840)，其中9160的串口只有一个用于AT Command。</p>\n<p>需要依次尝试，点击“AT”按钮就会从串口发送一行“AT”命令，如果有回复OK，说明这个串口就是AT指令的串口。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173504262.png\" alt=\"image-20221123173504262\"></p>\n<blockquote>\n<p>在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>\n</blockquote>\n<p>​\t左侧的面板显示了联网状态、IP地址、信号强度等信息：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173600818.png\" alt=\"image-20221123173600818\"></p>\n<p>​\t注意，”<strong>Automatic Request</strong>“需要勾选上。勾选以后，在切换串口或者点击“AT+CFUN?”指令时，此软件会自动发送相关AT指令，查询网络状态信息，面板上的信息才会更新。否则面板可能不更新。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173636098.png\" alt=\"image-20221123173636098\"></p>\n<p>​\t即是说，以下状态灯应当全绿，则说明联网成功。但若不是全绿，也不一定是联网失败，可能只是信息没有刷新，参照上一条勾选“<strong>自动请求</strong>”，然后点击“AT+CFUN?”指令再次查询即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173817830.png\" alt=\"image-20221123173817830\"></p>\n<blockquote>\n<p>含义：</p>\n<ul>\n<li>UART：串口状态</li>\n<li>Modem：调制解调器状态</li>\n<li>UICC：SIM卡状态</li>\n<li>LTE：LTE联网状态</li>\n<li>PDN：Packet Data Domain联网状态</li>\n</ul>\n</blockquote>\n<h2 id=\"2-5-将设备注册到nRF-Cloud云端\"><a href=\"#2-5-将设备注册到nRF-Cloud云端\" class=\"headerlink\" title=\"2.5. 将设备注册到nRF Cloud云端\"></a>2.5. 将设备注册到nRF Cloud云端</h2><p>​\tIoT设备是需要注册到云端的，并且通信都需要加密认证，否则任何人开发的设备都能连接到你的云，就不安全了。</p>\n<p>​\t设备注册到云端的过程称为<strong>Cloud Provisioning</strong></p>\n<p>​\t设备注册的流程是：</p>\n<ol>\n<li>首先，要有一个自签CA证书，以及对应的密钥文件；</li>\n<li>需要用自签CA证书+设备的UUID，给每个设备单独签发CA证书，并安装单独的私钥到设备中。</li>\n<li>云端持有证书（公钥），这样设备和云端就可以加密通信了。</li>\n</ol>\n<blockquote>\n<p>什么是非对称加密和CA证书？</p>\n<p>​\tCA证书具有证书文件（内含公钥）和私钥文件两个部分，公钥和私钥是用来做非对称加密的。公钥加密的数据，只能用私钥解密；用私钥加密的数据，只能用公钥解密。</p>\n<p>私钥是自己持有的，而公钥公开给所有想与自己通信的对象。</p>\n<p>假设A要给B发送一段消息M：</p>\n<ol>\n<li>对于这段消息M，发送者A先利用MD5或SHA256等方式生成一个数字摘要D，再用私钥把消息M加密得到密文C。最后把C+D一起发给接收者B。</li>\n<li>B收到消息后，先用公钥解密C得到M’，再对比M’的数据摘要和D是否一致，若一致，则说明数据确实是<strong>公钥的所有者</strong>发出的。于是确信M’就是要接收的消息M。</li>\n</ol>\n<p>但B可能拿到假的公钥，黑客发出假的公钥，就可以冒充A给B发消息。为了避免这种情况发生，公钥需要被<strong>认证</strong>，这就是CA证书。</p>\n<p>​\t一个CA证书文件<code>ca1</code>包含公钥P、签名S、所有者信息（国家、城市、单位名称、邮箱等）。<code>ca1</code>的签名S，是用另一个证书<code>ca2</code>的私钥，对<code>ca1</code>的公钥P进行加密得到的。</p>\n<p>所以利用公开的<code>ca2</code>的公钥对S进行解密，如果和P一致，则说明<code>ca1</code>是合法的。<code>ca1</code>的合法性由<code>ca2</code>证明。</p>\n<p>​\t一个CA证书的安全性由另一个CA证书来证明，这样层层递归下去，形成证书链。而最初的CA证书就是<strong>根证书</strong>。具有颁发<strong>根证书</strong>的资质的机关就是CA（Certificate Authority），也叫“证书授权中心”。CA具有根证书，然后给他信任的其他公司颁发CA证书，这些颁发的CA证书里的签名S就是用根证书的私钥加密的。</p>\n</blockquote>\n<p>​\t目前nRF Cloud有两种注册方式，一种是通过JITP的方式（Just-in-Time Provisioning）,另一种是<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>。</p>\n<h3 id=\"JITP方式注册\"><a href=\"#JITP方式注册\" class=\"headerlink\" title=\"JITP方式注册\"></a>JITP方式注册</h3><p>​\tJITP（Just-in-Time Provisioning）的方式利用开发板背面贴纸上的IMEI和PIN码，在云端控制台<strong>手动</strong>生成一个CA证书，然后下载到电脑，并通过LTE Link Monitor 工具生成<strong>设备证书</strong>，并把设备证书的私钥安装到9160中。这样设备就可以直接连接到云端并注册。这种方式便于快速开发、验证，但不适合量产，本文不详细介绍。图文步骤可参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/ug_nrf9160_gs.html#connecting-to-nrf-cloud\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/ug_nrf9160_gs.html#connecting-to-nrf-cloud</a></p>\n<p>JITP的文档说明为：<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#just-in-time-provisioning\">Updating The nRF Cloud Certificate</a></p>\n<h3 id=\"预连接方式注册\"><a href=\"#预连接方式注册\" class=\"headerlink\" title=\"预连接方式注册\"></a>预连接方式注册</h3><p>​\t<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>，是利用nRF Cloud提供的云端REST接口（接口文档见<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">Provision Devices</a>），进行批量的设备注册。具体步骤为：</p>\n<ol>\n<li>首先电脑上需要一个CA证书（不一定要CA正规机构颁发，可以自己生成）；</li>\n<li>电脑连接到nRF9160 AT串口，通过nRF Cloud Utils脚本（TypeScript 或 python），执行以下步骤：<ul>\n<li>通过串口AT命令，让设备生成UUID，并通过PC上的<strong>自签CA证书</strong>和<strong>UUID</strong>为每一个设备生成X.509<strong>设备证书</strong>和<strong>私钥</strong>。由于X.509私钥是直接在9160内生成的，PC上看不到，从而确保了安全性。</li>\n<li>通过串口烧写AWS根证书到9160 Modem中，这样可以确保nRF9160连接nRF Cloud时可以对服务器进行验证（nRF Cloud 运行在AWS上）。</li>\n<li>把该设备的UUID、X.509证书等信息记录到一个CSV表格文件中。</li>\n</ul>\n</li>\n<li>步骤2可重复最多1000次，信息存入同一个CSV表格。</li>\n<li>通过nRF Cloud的云端REST接口，把CSV表格上传，把这一批设备一次性注册到云端。</li>\n</ol>\n<p>​\t<strong>nRF Cloud提供了一套工具来帮助你快速完成上述三项工作，可以用TypeScript脚本或Python脚本</strong>，这套工具在github上，地址为： <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#create-device-credentials\">utils&#x2F;README.md at master · nRFCloud&#x2F;utils (github.com)</a>。</p>\n<p>​\t下面通过Python脚本进行示例：</p>\n<h3 id=\"（1）前期准备\"><a href=\"#（1）前期准备\" class=\"headerlink\" title=\"（1）前期准备\"></a>（1）前期准备</h3><ul>\n<li><p>确保9160SiP 为Revision 2或更高版本（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110504562.png\" alt=\"image-20221124110504562\" style=\"zoom: 25%;\" />\n</li>\n<li><p>确保已经按照[2.2](#2.2. 烧录Modem固件)的步骤，烧录了1.3.0或更高版本的Modem固件（这些版本才支持新的安全AT指令，如<code>KEYGEN</code>）</p>\n</li>\n<li><p>确保你已经按照[2.3](#2.3. 配置、编译并烧录Application固件)的步骤，修改了Application固件的配置参数，启用了JWT和UUID；</p>\n</li>\n<li><p>已经按照[2.4](#2.4. 联网测试)的步骤，验证了设备可以成功联网；</p>\n</li>\n<li><p>已经 <a href=\"https://nrfcloud.com/#/\">注册了nRF Cloud账号，并登录</a>。</p>\n</li>\n</ul>\n<h3 id=\"（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\"><a href=\"#（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\" class=\"headerlink\" title=\"（2）获取最新的nRF Cloud Utils工具，并安装好依赖\"></a>（2）获取最新的nRF Cloud Utils工具，并安装好依赖</h3><p>​\t在一个无中文、无空格、无特殊字符的路径下，从github拷贝仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/nRFCloud/utils.git</span><br></pre></td></tr></table></figure>\n\n<p>​\t进入modem firmware 1.3+ 子文件夹，然后安装其python依赖包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> utils/python/modem-firmware-1.3+/</span><br><span class=\"line\">$ pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）生成你的自签CA证书\"><a href=\"#（3）生成你的自签CA证书\" class=\"headerlink\" title=\"（3）生成你的自签CA证书\"></a>（3）生成你的自签CA证书</h3><p>​\t复制下方的命令，并把对应参数改成你自己需要的信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python create_ca_cert.py \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn nordic.cn \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-p ./my_ca \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义（部分参数未使用）：</p>\n<ul>\n<li><code>-c</code> ：2字符的国家代码，<code>CN</code>为中国</li>\n<li><code>-st</code>：州或省</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：公司&#x2F;组织</li>\n<li><code>-ou</code>：组织部门</li>\n<li><code>-cn</code>：Common Name</li>\n<li><code>-dv</code>：有效天数</li>\n<li><code>-e</code>：电子邮箱地址</li>\n<li><code>-p</code>：CA证书生成后存储的位置</li>\n<li><code>-f</code>：给生成的三个证书文件的文件名添加前缀（字符串）</li>\n</ul>\n</blockquote>\n<p>​\t生成后，可以看到自己指定的目录下已经有了三个证书文件：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123223024181.png\" alt=\"image-20221123223024181\" style=\"zoom: 67%;\" />\n\n<p>​\t其中，ca是证书，prv是私钥，pub是公钥。</p>\n<blockquote>\n<p>​\tCA证书是我们自己签发的根证书，能让设备和云端的通信被加密即可。这个CA证书本身并不是CA机构签发的正规证书。</p>\n<p>​\t若想查看CA证书的信息，可以随便找一个<a href=\"https://myssl.com/cert_decode.html\">在线CA查看器</a>，把xxx_ca.pem拖进去就可以看到信息了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123224514523.png\" alt=\"image-20221123224514523\" style=\"zoom:80%;\" />\n</blockquote>\n<h3 id=\"（4）签发并安装设备证书\"><a href=\"#（4）签发并安装设备证书\" class=\"headerlink\" title=\"（4）签发并安装设备证书\"></a>（4）签发并安装设备证书</h3><p>​\t需要使用<code>utils/python/modem-firmware-1.3+/</code>目录下的<code>device_credentials_installer.py</code>脚本。</p>\n<p>如果想查看最新的脚本使用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -h</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t此脚本的功能：</p>\n<ol>\n<li>通过电脑串口，给你的设备发送AT指令，生成一个UUID</li>\n<li>这个脚本会调用同一目录下的<code>create_device_credentials.py</code>，让每个设备单独生成X509设备证书和私钥；</li>\n<li>通过电脑串口，读取到UUID和X.509证书，并保存csv表格文件中</li>\n<li>量产时，这个脚本可以重复执行。只需要在每次串口上换一个设备时，就执行一次这个脚本。这个设备就会生成X.509证书，并且设备的信息会记录到2个表格文件中。<strong>最多允许存1000台设备的信息。</strong></li>\n<li>后续可以把这两个表格文件和证书上传到云端，便于批量注册设备。</li>\n</ol>\n<p>​\t在执行这个脚本之前，确保第（2）步中的CA证书都生成好了。</p>\n<p>​\t脚本使用示例如下（windows环境），你需要根据实际情况改变命令的参数配置。</p>\n<p>​\t注意，示例执行脚本时，并未指定串口。因为脚本在windows下会自动检测哪个串口是AT指令串口。注意不要开着LTE Link Monitor等工具占用着串口导致安装失败。如果在linux下操作，请增加<code>--port /dev/ttyS??</code>来指定串口，详情可参考 <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#device-credentials-installer\">Device Credentials Installer</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -d -t <span class=\"string\">&quot;jayant-DK&quot;</span> --ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem --ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem -a --devinfo_append --csv ./jayant_provision.csv --devinfo ./jayant_devinfo.csv --term CRLF</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-d</code>：安装前先从Modem中删除sectag</li>\n<li><code>-t</code>：用于设备分组管理的标签，是一个字符串</li>\n<li><code>-T</code>：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置</li>\n<li><code>--ca</code>：CA证书文件的路径</li>\n<li><code>--ca_key</code>：CA证书私钥的路径(prv)</li>\n<li><code>-a</code>或<code>--append</code>：保存<strong>设备注册信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--devinfo_append </code>：保存<strong>设备信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--csv</code>：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）</li>\n<li><code>--devinfo</code>：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）</li>\n<li><code>--term</code>：AT指令的结束符（<code>NULL</code>,<code>CRLF</code>,<code> CR</code> 或<code>LF</code>）</li>\n<li><code>--port</code>：指定AT指令串口</li>\n</ul>\n</blockquote>\n<p>​\t我只有一块开发板，所以只执行一次。</p>\n<h3 id=\"（5）把设备信息批量注册到云端\"><a href=\"#（5）把设备信息批量注册到云端\" class=\"headerlink\" title=\"（5）把设备信息批量注册到云端\"></a>（5）把设备信息批量注册到云端</h3><p>​\t批量的在nRFCloud上进行设备注册（Cloud Provisioning）。</p>\n<p>​\t首先，在<a href=\"https://nrfcloud.com/#/\">nRF Cloud Portal</a> 登录你的nRF Cloud账号（前面应该已经注册好了）。然后获取nRF Cloud REST API key。</p>\n<p>​\t在右上角点击进入个人账户页面，然后在下面可以看到API key，复制出来即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123234437620.png\" alt=\"image-20221123234437620\"></p>\n<p>​\t接下来继续执行python脚本，进行云端注册（这个脚本底层就是调用了REST API进行注册）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python ./nrf_cloud_provision.py --apikey 3c967ecbd9fxxxxxxxxxxxxxxxxa73cf37049983 --chk --csv ./jayant_provision.csv --devinfo jayant_devinfo.csv --set_mfwv --name_imei --name_pref <span class=\"string\">&quot;my_dk_&quot;</span> --res prov.log</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>--apikey</code>：刚刚复制的API key</li>\n<li><code>--chk</code>：<strong>单个设备的注册才使用</strong>，注册前先检查设备是否存在</li>\n<li><code>--csv</code> ：上一步生成的，存储着<strong>设备注册信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li><code>--devinfo</code> ：上一步生成的，存储着<strong>设备信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li><code>--set_mfwv</code>：把<code>--devinfo</code>中记录的Modem固件版本存储到云端</li>\n<li><code>--name_imei</code>：把<code>--devinfo</code>中记录的IMEI（芯片ID）作为friendly name</li>\n<li><code>--name_pref</code>：给friendly name添加一个前缀字符串</li>\n<li><code>--res</code>：存储注册结果的日志文件</li>\n</ul>\n</blockquote>\n<p>​\t完成后，可以看到成功注册的结果：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235635167.png\" alt=\"image-20221123235635167\"></p>\n<h3 id=\"（6）在云端查看刚刚注册的设备\"><a href=\"#（6）在云端查看刚刚注册的设备\" class=\"headerlink\" title=\"（6）在云端查看刚刚注册的设备\"></a>（6）在云端查看刚刚注册的设备</h3><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235940868.png\" alt=\"image-20221123235940868\"></p>\n<p>​\t可以在Device界面看到设备已经注册成功，设备的名称是“前缀字符串” + “IMEI”的形式。</p>\n<p>​\t但设备还处于Disconnect的状态。这是因为刚才下载私钥时，把设备设为了离线状态，可以通过LTE Link Monitor输入以下AT指令，也可以简单reset一下设备，或者重新通过LTE Link Monitor查看设备的状态。这样设备应该就会变成已连接了:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">AT%XSYSTEMMODE=0,1,0,0 // 选择NB网络</span><br><span class=\"line\">AT+CEREG=5             // 打开调制解调器</span><br><span class=\"line\">AT+CFUN=1              // 开始联网</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000424393.png\" alt=\"image-20221124000424393\"></p>\n<p>​\t点进设备的详情页面，已经可以看到大量的信息（部分资源在墙外，加载不出属于正常现象，需要代理上网）：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000623033.png\" alt=\"image-20221124000623033\"></p>\n<p>​\t可以通过terminal窗口，发送json消息，与设备进行交互。也可以进行OTA升级。</p>\n<p>​\t在本例程中，板子上的LED指示灯也可以展示状态：详见<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#led-indication\">Led indication</a>。这里只列出DK板的行为。</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>nRF9160 DK solid LEDs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LTE connection search</td>\n<td>LED1 blinking</td>\n</tr>\n<tr>\n<td>GNSS fix search</td>\n<td>LED2 blinking</td>\n</tr>\n<tr>\n<td>Cloud association</td>\n<td>LED3 double pulse blinking</td>\n</tr>\n<tr>\n<td>Connecting to cloud</td>\n<td>LED3 triple pulse blinking</td>\n</tr>\n<tr>\n<td>Publishing data</td>\n<td>LED3 blinking</td>\n</tr>\n<tr>\n<td>Active mode</td>\n<td>LED4 blinking</td>\n</tr>\n<tr>\n<td>Passive mode</td>\n<td>LED3 and LED4 blinking</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>All 4 LEDs blinking</td>\n</tr>\n<tr>\n<td>FOTA update</td>\n<td>LED1 and LED2 blinking</td>\n</tr>\n<tr>\n<td>Completion of FOTA update</td>\n<td>LED1 and LED2 static</td>\n</tr>\n</tbody></table>\n<h3 id=\"（7）从云端删除设备\"><a href=\"#（7）从云端删除设备\" class=\"headerlink\" title=\"（7）从云端删除设备\"></a>（7）从云端删除设备</h3><p>​\t如果你想从云端删除设备，可以直接在网页端操作，从右上角齿轮除点击删除即可。也可以用云对云的REST API进行删除，后续章节讲解。</p>\n<h1 id=\"3-Asset-Tracker-v2-例程分析\"><a href=\"#3-Asset-Tracker-v2-例程分析\" class=\"headerlink\" title=\"3. Asset Tracker v2 例程分析\"></a>3. Asset Tracker v2 例程分析</h1><p>​\t例程的官方说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/asset_tracker_v2_description.html\">Application description — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<h2 id=\"3-1-本例程设计原则\"><a href=\"#3-1-本例程设计原则\" class=\"headerlink\" title=\"3.1. 本例程设计原则\"></a>3.1. 本例程设计原则</h2><ul>\n<li>超低功耗</li>\n<li>离线优先：本例程假设大多数情况下是离线的，连接是不可靠的。因此会有数据重发的机制。</li>\n<li>时间戳机制：多时间源的时间戳机制，离线情况也可以计时</li>\n<li>数据打包：多次数据打包，减少数据发送次数；离线时，数据会被存储，等到下次在线时一起发送</li>\n<li>运行时参数修改：支持在运行时修改部分配置参数（例如加速度计灵敏度，或GNSS超时时间）</li>\n</ul>\n<h2 id=\"3-2-例程实现的功能\"><a href=\"#3-2-例程实现的功能\" class=\"headerlink\" title=\"3.2. 例程实现的功能\"></a>3.2. 例程实现的功能</h2><p>​\t本节概览性的介绍此例程的具体功能：</p>\n<h3 id=\"数据搜集\"><a href=\"#数据搜集\" class=\"headerlink\" title=\"数据搜集\"></a>数据搜集</h3><p>​\t本例程会搜集数据，并上传到云端，下表列出会上传的数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n<th>Identifiers</th>\n<th>String identifier for NOD list</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>位置（Location）</td>\n<td>GNSS坐标</td>\n<td>APP_DATA_GNSS</td>\n<td><code>gnss</code></td>\n</tr>\n<tr>\n<td>环境信息（Environmental）</td>\n<td>温度，湿度</td>\n<td>APP_DATA_ENVIRONMENTAL</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>运动信息（Movement）</td>\n<td>加速度</td>\n<td>APP_DATA_MOVEMENT</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>调制解调器（Modem）</td>\n<td>LTE link data, device data</td>\n<td>APP_DATA_MODEM_DYNAMIC, APP_DATA_MODEM_STATIC</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>电池信息（Battery）</td>\n<td>电压</td>\n<td>APP_DATA_BATTERY</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>Neighbor cells</td>\n<td>Neighbor cell measurements</td>\n<td>APP_DATA_NEIGHBOR_CELLS</td>\n<td><code>ncell</code></td>\n</tr>\n</tbody></table>\n<p>​\t此外，还有一些异步数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>按钮（Button）</td>\n<td>按下的按钮的ID</td>\n</tr>\n<tr>\n<td>冲击（Impact）</td>\n<td>冲击的幅度（单位是重力加速度常数G）</td>\n</tr>\n</tbody></table>\n<h3 id=\"实时配置\"><a href=\"#实时配置\" class=\"headerlink\" title=\"实时配置\"></a>实时配置</h3><p>​\t本例程中的一些选项，支持通过云端进行远程实时配置。</p>\n<table>\n<thead>\n<tr>\n<th>实时配置项</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Device Mode</td>\n<td>主动（Active）或被动（Passive）：Active指一直上报，而Passive只在运动时才上报</td>\n<td>Active</td>\n</tr>\n<tr>\n<td>Active: Wait time</td>\n<td>Active模式下，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement resolution</td>\n<td>Passive模式下，设备在移动时，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement timeout</td>\n<td>Passive模式下，不论设备是否移动，每次把数据传送到云端的时间间隔</td>\n<td>3600秒</td>\n</tr>\n<tr>\n<td>GNSS timeout</td>\n<td>数据采样时，获取GNSS定位的超时时间</td>\n<td>30秒</td>\n</tr>\n<tr>\n<td>Accelerometer activity threshold</td>\n<td>设备被判定为移动的加速度阈值</td>\n<td>10  m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity threshold</td>\n<td>设备被判定为精致动的加速度阈值</td>\n<td>5 m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity timeout</td>\n<td>设备被判定为移动的时间阈值，加速度和时间都超过阈值才被判定为移动</td>\n<td>1秒</td>\n</tr>\n<tr>\n<td>No Data List (NOD)</td>\n<td>禁用列表，列表项是Data Type，字符串形式。可以禁用例程上报某一些Data Type的数据</td>\n<td>空</td>\n</tr>\n</tbody></table>\n<p>​\t这些配置可以另外修改，有以下几种方式：</p>\n<ul>\n<li>每次与云端建立连接时，从云端同步</li>\n<li>设备发送更新数据到云端时</li>\n<li>启动后，从flash中另外加载</li>\n</ul>\n<h3 id=\"工作流程图\"><a href=\"#工作流程图\" class=\"headerlink\" title=\"工作流程图\"></a>工作流程图</h3><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206195856563.png\" alt=\"image-20221206195856563\" style=\"zoom: 67%;\" />\n\n<center>\n 主动模式流程图\n</center>\n\n<p>​\t在<strong>主动模式</strong>下，只要超时，例程就会采样新数据，并发送到云端。</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206200043536.png\" alt=\"image-20221206200043536\" style=\"zoom:80%;\" />\n\n<center>\n    被动模式流程图\n</center>\n\n\n\n<p>​\t在<strong>被动模式</strong>下，只有两种情况会触发数据上报：</p>\n<ul>\n<li>检测到运动，并且Resolution定时器超时，默认120s</li>\n<li>未检测到运动，并且 timeout定时器超时，默认3600s</li>\n</ul>\n<h3 id=\"用户接口\"><a href=\"#用户接口\" class=\"headerlink\" title=\"用户接口\"></a>用户接口</h3><table>\n<thead>\n<tr>\n<th>按钮</th>\n<th>Thingy:91 评估板</th>\n<th>nRF9160 DK 开发板</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>给云端发送数据</td>\n<td>给云端发送数据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-</td>\n<td>给云端发送数据；<br />由于nRF9160 DK没有加速度计，故使用此按钮模拟加速度计有运动的情况</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>工作状态</th>\n<th>Thngy:91 LED</th>\n<th>nRF9160 DK LED</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>搜索LTE网络</td>\n<td>黄色闪烁</td>\n<td>LED1 闪烁</td>\n</tr>\n<tr>\n<td>GNSS定位中</td>\n<td>紫色闪烁</td>\n<td>LED2 闪烁</td>\n</tr>\n<tr>\n<td>Cloud association</td>\n<td>白色双闪</td>\n<td>LED3 双闪</td>\n</tr>\n<tr>\n<td>MQTT连接中</td>\n<td>绿灯三闪</td>\n<td>LED3 三闪</td>\n</tr>\n<tr>\n<td>Publish Data</td>\n<td>绿灯闪烁</td>\n<td>LED3 闪烁</td>\n</tr>\n<tr>\n<td>Active Mode</td>\n<td>浅蓝色闪烁</td>\n<td>LED4 闪烁</td>\n</tr>\n<tr>\n<td>Passive Mode</td>\n<td>深蓝色闪烁</td>\n<td>LED3和LED4闪烁</td>\n</tr>\n<tr>\n<td>故障</td>\n<td>红色常亮</td>\n<td>4个灯闪烁</td>\n</tr>\n<tr>\n<td>FOTA升级</td>\n<td>橙色快闪</td>\n<td>LED1 LED2 闪烁</td>\n</tr>\n<tr>\n<td>升级完成</td>\n<td>橙色常亮</td>\n<td>LED1 LED2 常亮</td>\n</tr>\n</tbody></table>\n<h3 id=\"A-GPS与P-GPS\"><a href=\"#A-GPS与P-GPS\" class=\"headerlink\" title=\"A-GPS与P-GPS\"></a>A-GPS与P-GPS</h3><blockquote>\n<p>GNSS简介：</p>\n<ul>\n<li>GNSS：全球卫星导航系统，通过多颗同步卫星对地球进行广播。地面上的设备只要接收到三个卫星的信号，根据<strong>预先获得的卫星轨道数据</strong>和<strong>接收到广播的时间差</strong>就可以计算出在地球上的定位。</li>\n<li>GPS：美国GNSS，每12.5分钟广播一次。</li>\n<li>A-GPS：辅助GPS，适合室外。设备不用等GPS广播，先从附近蜂窝基站获得大概定位。然后从云服务器的AGPS服务下载这个区域的GPS信息。于是可以缩短设备的GNSS模块首次捕获的时间（2~3分钟缩短到几秒）。</li>\n<li>P-GPS：预测GPS。设备可以下载长达2周的预测卫星星历数据，使设备能够准确的知道卫星的轨道位置，而无需每2小时连接到网络。并且还能随时间变化权衡精度的下降。P-GPS也能缩短设备定位所需的时间。</li>\n</ul>\n</blockquote>\n<p>​\tNCS提供nRFCloud <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_agps.html#lib-nrf-cloud-agps\">A-GPS库</a>和<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_pgps.html#lib-nrf-cloud-pgps\">P-GPS库</a>，让设备能直接从nRF Cloud云端获取这些数据。</p>\n<p>​\t如果云端是其他云，如 <a href=\"https://aws.amazon.com/iot-core/\">AWS IoT Core</a>, <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/\">Azure IoT Hub</a>等。则Location Library也支持从外部输入这些数据（在定位需要用到AGPS&#x2F;PGPS时，产生一个回调事件，应用层把自己从其他云获取到的AGPS、PGPS数据传入Location Library即可）。</p>\n<h2 id=\"3-3-例程的工程结构\"><a href=\"#3-3-例程的工程结构\" class=\"headerlink\" title=\"3.3. 例程的工程结构\"></a>3.3. 例程的工程结构</h2><p>​\tZephyer开发最大的特点是<strong>模块化</strong>。在我的另一篇文章<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/2a39e705bff0/\">《理解Zephyr项目的配置与构建系统》</a>中，我介绍了Zephyr和Nordic提供的库都可以看成是一个模块，每个模块有自己的Kconfig配置。</p>\n<p>​\t如果你自己写一个项目，可以把几个<code>.c</code>源文件和<code>.h</code>头文件丢进<code>CMakeList.txt</code>就行，这样比较简单直接。但如果你想开发好几个独立的复杂模块，并让他们搭配起来工作，就一定要学一下Asset Tracker v2这个例程的写法。</p>\n<p>​\t首先看项目根目录下的<code>Kconfig</code>的包含关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Kconfig</span><br><span class=\"line\">|-- Asset Tracker v2</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modules_common</span><br><span class=\"line\">|   |-- src/modules/Kconfig.app_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.cloud_module</span><br><span class=\"line\">|   |-- src/cloud/Kconfig.lwm2m_integration</span><br><span class=\"line\">|   |-- src/modules/Kconfig.data_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.gnss_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modem_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.sensor_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.ui_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.util_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.led_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.debug_module</span><br><span class=\"line\">|   |</span><br><span class=\"line\">|   |-- src/cloud/cloud_codec/Kconfig</span><br><span class=\"line\">|   |-- src/watchdog/Kconfig</span><br><span class=\"line\">|   |-- src/events/Kconfig</span><br><span class=\"line\">|   </span><br><span class=\"line\">|-- Zephyr Kernel  // 操作系统内核的配置</span><br><span class=\"line\">|    |-- Kconfig.zephyr</span><br><span class=\"line\">|</span><br><span class=\"line\">`-- 日志打印等级配置</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到，除了Zephyr操作系统内核外，还包含了src目录下许多的模组，这些模组<strong>不是官方库</strong>。而是Nordic官方为这个例程开发的应用模组。你也可以照葫芦画瓢开发自己的应用模组。</p>\n<p>​\t直接用图形化界面查看，就可以看到Kconfig中的选项了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129154636314.png\" alt=\"image-20221129154636314\" style=\"zoom: 67%;\" />\n\n<blockquote>\n<p>​\t分模块开发，除了更加简洁直观、解耦以外，还有一个巨大的好处，那就是每个模组的Log可以在Kconfig中单独开关。这个例程的项目实在是太复杂了，如果所有模组的log都打开，不论是串口还是RTT都是打不下的。</p>\n</blockquote>\n<p>​\t每个模组都可以有自己的线程、初始化代码、回调函数等。</p>\n<h2 id=\"3-4-模组间的配合方式\"><a href=\"#3-4-模组间的配合方式\" class=\"headerlink\" title=\"3.4. 模组间的配合方式\"></a>3.4. 模组间的配合方式</h2><h3 id=\"程序的调用方式\"><a href=\"#程序的调用方式\" class=\"headerlink\" title=\"程序的调用方式\"></a>程序的调用方式</h3><p>​\t我们知道，不同代码之间互相调用的方式有同步调用和异步调用：</p>\n<ul>\n<li>同步调用就是，直接调用几个函数，等到它们依次返回后，你才做最后的处理，然后返回；</li>\n<li>异步调用就是，先把最后的处理写进回调函数，然后通过函数指针注册给其他模组。调用其他模组的函数时不用阻塞，立刻就能返回。等到其他模组处理完后，执行这个回调函数，就成功把参数传回本模组了。</li>\n</ul>\n<p>​\t以上两种方式，常常发生在我们使用官方库的过程中。我们直接调用官方库中的函数（同步调用），或者把回调函数注册进官方库中（异步调用）。</p>\n<h3 id=\"Application-Event-Manager\"><a href=\"#Application-Event-Manager\" class=\"headerlink\" title=\"Application Event Manager\"></a>Application Event Manager</h3><p>​\t对于我们自己开发的application模组，如果互相之间通信还要调用对方的函数，还要做线程间通信，还要做互斥锁、信号量，那就失去模块化的意义了。</p>\n<p>​\tNordic提供了一个叫做Application Event Manager的库，Nordic许多产品级的复杂例程都用到了它。它提供了一个不同模组之间的通信机制：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205013810750.png\" alt=\"image-20221205013810750\" style=\"zoom: 67%;\" />\n\n<p>​\t每个模组只负责与自己有关的应用和驱动。每个模组可以发布（SUBMIT）事件，也可以订阅（SUBSCRIB）其他模组的事件。想让其他模组做什么事的时候，发布一个事件就好。而只要订阅了其他模组的事件，那么就可以从Application Event Manager中收到这些事件，之后，只要编写好处理这些事件的回调函数即可。</p>\n<p>​\t所有的事件都是从Applicarion Event Manager来的，回调函数是注册给Applicarion Event Manager的，不是注册给其他模组。此外，每个模组只需一个回调函数就可以处理所有其他模组来的时间，不用定义一堆事件入口。</p>\n<p>​\t由此我们可以体会这个设计的方便之处，每个模组都是独立的，只用关心自己的业务即可。</p>\n<h3 id=\"模组的线程\"><a href=\"#模组的线程\" class=\"headerlink\" title=\"模组的线程\"></a>模组的线程</h3><p>​\t一个模组，根据其业务复杂程度的不同（比如有无状态机），可能自带线程，也可能不带线程。Application Event Manager对这两种模组都兼容。</p>\n<ul>\n<li>对于带线程的模组。所有的事件都变成消息，存入消息队列。模组的线程里循环等待消息队列的数据，并根据具体情况处理到来的事件。</li>\n<li>对于不带线程的模组，只需写好事件的回调函数，注册进Application Event Manager即可。</li>\n</ul>\n<blockquote>\n<p>​\t对于不带线程的模组，必须确保回调函数执行较快，否则将会阻塞Application Event Manager。如果没法确保这一点，就必须给模组写一个单独的线程来处理消息。</p>\n</blockquote>\n<p>如下图：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203957763.png\" alt=\"image-20221206203957763\"></p>\n<blockquote>\n<p>​\t\t对于带线程的模组：<br>​\t把Event变成Message，并放入消息队列的工作，都是每个模组自己维护的。Application Event Manager只是提供一个事件回调的接口，各个模组自己通过事件回调函数，把事件放入消息队列。</p>\n</blockquote>\n<h3 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h3><p>​\t模组大多使用静态分配的内存。但是本例程会有一些内容使用动态内存，依赖的是 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/memory_management/heap.html#heap-v2\">Zephyr的堆内存池</a>。以下内容是使用了动态内存的：</p>\n<ul>\n<li>模组之间传输的Event</li>\n<li>即将被发送到云端的数据</li>\n</ul>\n<p>​\t要发送到云的数据是最耗内存的。所以如果要修改data模组的缓冲区大小，别忘了同时也修改堆的大小。</p>\n<blockquote>\n<p>使用<code>CONFIG_HEAP_MEM_POOL_SIZE</code>来配置堆的大小。</p>\n</blockquote>\n<h2 id=\"3-5-例程模组介绍\"><a href=\"#3-5-例程模组介绍\" class=\"headerlink\" title=\"3.5. 例程模组介绍\"></a>3.5. 例程模组介绍</h2><p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203138376.png\" alt=\"image-20221206203138376\"></p>\n<p>​\t如上图，例程中共实现了9个模组。蓝色的是自带线程的，而橙色的是不带线程的。</p>\n<ul>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/app_module.html#asset-tracker-v2-app-module\">Application module</a>：控制何时采集数据、采集什么数据，并且控制整个例程的其他行为</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html#asset-tracker-v2-data-module\">Data module</a>：根据App模块的设定搜集其他模块的数据，存入环形缓冲。并决定何时发送到云端。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/cloud_module.html#asset-tracker-v2-cloud-module\">Cloud module</a>：负责与云端的连接与数据交互</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/sensor_module.html#asset-tracker-v2-sensor-module\">Sensor module</a>：与 <a href=\"thingy:91productpage\">Thingy:91</a>开发板上的传感器交互并获得数据</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/gnss_module.html#asset-tracker-v2-gnss-module\">GNSS module</a>：控制nRF9160的GNSS功能</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#asset-tracker-v2-ui-module\">User Interface module</a>：利用按键和灯提供简易的用户交互接口</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/util_module.html#asset-tracker-v2-util-module\">Utility module</a>：提供对例程进行管理和监控的工具</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/debug_module.html#asset-tracker-v2-debug-module\">Debug module</a>：此模组订阅了所有事件，方便调试，也支持nCS中的Memfault模组。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/modem_module.html#asset-tracker-v2-modem-module\">Modem module</a>：控制LTE连接</li>\n</ul>\n<blockquote>\n<p>要使用debug模组，需要include <code>../overlay-debug.conf</code></p>\n</blockquote>\n<h2 id=\"3-6-例程代码分析\"><a href=\"#3-6-例程代码分析\" class=\"headerlink\" title=\"3.6. 例程代码分析\"></a>3.6. 例程代码分析</h2><p>​\t今后会编写其他文章详解此例程的代码。\t</p>\n<p>​\t要了解更多关于此项目的实现内容，可以参考例程的官方说明，非常详细：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<div style=”page-break-after: always;”></div>\n\n<h1 id=\"4-nRF-Cloud-API介绍\"><a href=\"#4-nRF-Cloud-API介绍\" class=\"headerlink\" title=\"4. nRF Cloud API介绍\"></a>4. nRF Cloud API介绍</h1><p>nRF Cloud 提供 REST 和 MQTT 两种API。</p>\n<ul>\n<li>REST API 用于<strong>用户到云</strong>、<strong>第三方云到云</strong>的连接；其中少部分API也可被设备调用。</li>\n<li>MQTT API用于<strong>设备和云</strong>的连接</li>\n</ul>\n<h2 id=\"4-1-REST-API\"><a href=\"#4-1-REST-API\" class=\"headerlink\" title=\"4.1. REST API\"></a>4.1. REST API</h2><p>nRF Cloud REST API文档，参考：<a href=\"https://api.nrfcloud.com/v1\">nRF Cloud REST API Documentation</a></p>\n<h3 id=\"REST-API-认证方式\"><a href=\"#REST-API-认证方式\" class=\"headerlink\" title=\"REST API 认证方式\"></a>REST API 认证方式</h3><p>​\t在使用REST API时，不管是用户、设备还是第三方云，在调用API时都需要携带一个Token，来证明消息发出源是可信的。不同的API需要使用不同类型的Token。在API文档中会明确说明此API需要哪种方式认证，例如：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311133314758.png\" alt=\"image-20230311133314758\"></p>\n<blockquote>\n<ul>\n<li><strong>Simple Token</strong>：也就是<strong>API KEY</strong>，在2.5小节中已经见过。它的地位与用户的云账号密码是一样的，不能泄露。通常是用来调用一些与<strong>用户</strong>账户、配置、用户业务有关的API，例如列举设备、注册设备、批量拉取Message等</li>\n<li><strong>JSON Web Token（JWT）</strong>：JWT内包含了设备信息（如UUID）和时间戳等。<strong>设备</strong>可以用自己的X.509私钥生成一个JWT。在调用API时，云端会检查这个JWT是否合法（由于设备已经注册到云端，云端保存了此设备的X.509证书，因此云端可以验证JWT是否合法），如果合法，则允许API的调用。</li>\n<li><strong>Service Evaluation Token</strong>：nRF Cloud提供的服务都是需要JWT认证的，而JWT想要认证成功就必须要注册一个设备到云端。如果一个客户只是单纯想快速评估一下服务的效果，不想搞注册设备、生成JWT那一套麻烦事，那么可以申请服务评估令牌（Service Evaluation Token），使用此Token的效果和JWT相同，可在没有注册设备的情况下直接调用相关API。Servic Evaluation Token本身也是通过REST API获取的，使用<a href=\"https://api.nrfcloud.com/v1#tag/Account/operation/GenerateServiceEvaluationToken\">GenerateServiceEvaluationToken</a>和 <a href=\"https://api.nrfcloud.com/v1#tag/Account/operation/GetServiceEvaluationToken\">GetServiceEvaluationToken</a>两个API即可。要注意这个Token只有30天的试用期限，若想要延长，需要联系Nordic销售。</li>\n</ul>\n</blockquote>\n<h3 id=\"REST-API-调用示例\"><a href=\"#REST-API-调用示例\" class=\"headerlink\" title=\"REST API 调用示例\"></a>REST API 调用示例</h3><p>​\t本小节将使用电脑模拟一台<strong>设备</strong>，通过REST接口注册设备，并使用JWT的认证方式，调用一个REST API。</p>\n<p>整个过程分为三个步骤：</p>\n<ul>\n<li>设备注册（Provision）</li>\n<li>检查设备注册的结果</li>\n<li>获取AGPS数据</li>\n</ul>\n<p>官方文档可参考：<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<blockquote>\n<p>​\t整个注册过程和[2.5小节](#2.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))的流程是一模一样的。但是本小节中展示的注册过程没有使用python脚本，而是使用最基本的HTTP请求来展示REST API调用的过程。</p>\n</blockquote>\n<p>​\t在<strong>开始之前</strong>，找一个<a href=\"https://www.uuidgenerator.net/\">在线UUID生成器</a>，生成一个UUID。本例生成的是：<code>64520de4-e0a0-45cf-bf56-1f43f80a4f37</code>，这个UUID就代表一台设备。</p>\n<p>​\t对于实际的产品，UUID可以是任何字符串。但是Nordic推荐使用9160出厂自带的UUID，你可以在前面加上一些前缀。</p>\n<blockquote>\n<p>nRF Cloud 全球所有的客户的所有设备，都通过UUID来进行区分。所以防止UUID重复是非常必要的。</p>\n</blockquote>\n<p><strong>（1）生成CA证书和设备证书</strong></p>\n<p>​\t在 <a href=\"#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6\">2.5-(3)</a> 小节中，我们已经通过 Nordic 提供的 python 脚本生成了一套 CA证书文件和私钥。这套utils工具中也包含一套TypeScript脚本，和pythone脚本的功能是一样的。你也可以两种都不使用，而只使用OpenSSL进行生成，可参考<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<p>​\t后面在<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">2.5-(4)</a>中，我们通过这个<strong>CA证书</strong>给nRF9160签发了<strong>设备证书</strong>，给设备安装了设备独立的私钥。</p>\n<p>​\t现在，我们要用电脑模拟一台设备，所以，就需要通过刚刚生成的UUID和<strong>CA证书</strong>，来生成一个<strong>新的设备证书</strong>。</p>\n<p>​\t进入 [2.5-(2)](#（2）获取最新的nRF Cloud Utils工具，并安装好依赖) 中安装utils的文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在终端中进入utils文件夹后，再进行后续操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入python工具文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> python/modem-firmware-1.3+/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成设备证书</span></span><br><span class=\"line\">$ python create_device_credentials.py \\</span><br><span class=\"line\">-ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem \\</span><br><span class=\"line\">-ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn 64520de4-e0a0-45cf-bf56-1f43f80a4f37 \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-dv 2000 \\</span><br><span class=\"line\">-p ./dev_credentials \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-Device-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-ca</code>：CA证书文件</li>\n<li><code>-ca_key</code>：CA证书密钥文件</li>\n<li><code>-c</code>：2字符国家代码</li>\n<li><code>-st</code>：美国、加拿大的州或省代码</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：组织</li>\n<li><code>-o</code>u：组织部门</li>\n<li><code>-cn</code>：Common Name。使用nRF CLoud Device ID 或者 MQTT Client ID。这里使用UUID。</li>\n<li><code>-e</code>：e-mail</li>\n<li><code>-dv</code>：证书合法天数</li>\n<li><code>-p</code>：用于生成设备证书的目录</li>\n<li><code>-f</code>：生成的证书文件名前缀</li>\n</ul>\n</blockquote>\n<p><strong>（2）生成设备注册信息表格</strong></p>\n<p>​\t本小节参考 <a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">REST 设备注册API （ProvisionDevices）</a>。</p>\n<p>​\t打开Excel，创建一个新的空表格，并另存为csv格式。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150045752.png\" alt=\"image-20221124150045752\" style=\"zoom: 80%;\" />\n\n<p>​\t在表格中从左往右填入以下内容：</p>\n<ul>\n<li><p>第一列：设备ID，这里是UUID</p>\n</li>\n<li><p>第二列：设备子类型，可以写温湿度传感器之类的文字，可以留空；</p>\n</li>\n<li><p>第三列：用于设备分类的标签，这里填<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">3.5-(4)</a>中nRF9160一样的tag名称就行，也可以留空</p>\n</li>\n<li><p>第四列：固件类型，可以和9160例程填一样的，也可以留空</p>\n</li>\n<li><p>第五列：设备证书。从上一小节的设备证书中，把<code>xxxx_crt.pem</code>中的内容拷贝进去即可</p>\n<p>（注意，excel单元格类型要设置成“文本”，否则可能把等号、加号识别为公式）</p>\n</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150540606.png\" alt=\"image-20221124150540606\"></p>\n<p>​\t保存csv表格，此处给出我的csv文件内容，方便对比格式是否正确：</p>\n<p><code>fake-device.csv</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">64520de4-e0a0-45cf-bf56-1f43f80a4f37,fake-device,jayant-DK,APP|MODEM,&quot;-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">MIICPTCCAeICFHx8JF+NRorZfBQF0sr+jzKSmg9gMAoGCCqGSM49BAMCMIGSMQsw</span><br><span class=\"line\">CQYDVQQGEwJDTjERMA8GA1UEBwwIU2hhbmdoYWkxIjAgBgNVBAoMGU5vcmRpYyBT</span><br><span class=\"line\">ZW1pY29uZHVjdG9yIEsuSy4xDjAMBgNVBAsMBVNhbGVzMRIwEAYDVQQDDAlub3Jk</span><br><span class=\"line\">aWMuY24xKDAmBgkqhkiG9w0BCQEWGWpheWFudC50YW5nQG5vcmRpY3NlbWkubm8w</span><br><span class=\"line\">HhcNMjIxMTI0MDY1MjEwWhcNMjgwNTE2MDY1MjEwWjCBrTELMAkGA1UEBhMCQ04x</span><br><span class=\"line\">ETAPBgNVBAcMCFNoYW5naGFpMSIwIAYDVQQKDBlOb3JkaWMgU2VtaWNvbmR1Y3Rv</span><br><span class=\"line\">ciBLLksuMQ4wDAYDVQQLDAVTYWxlczEtMCsGA1UEAwwkNjQ1MjBkZTQtZTBhMC00</span><br><span class=\"line\">NWNmLWJmNTYtMWY0M2Y4MGE0ZjM3MSgwJgYJKoZIhvcNAQkBFhlqYXlhbnQudGFu</span><br><span class=\"line\">Z0Bub3JkaWNzZW1pLm5vMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6OIeO6C0</span><br><span class=\"line\">/kJzfaWUHt/Xg4J6bdAphzmX5sCLGV+oEeSi1sUQKpBLugda2OwG9FxOCikg8ih7</span><br><span class=\"line\">CvMm7C98+fr+nTAKBggqhkjOPQQDAgNJADBGAiEAuCdq6D1K329hwU9e+4S5//2b</span><br><span class=\"line\">upwtaqT+j6Mckpmj6XUCIQCaAqjWRMXMiOd/pXRkcf7SjKyZifBnxoepRqbNyKUG</span><br><span class=\"line\">OA==</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br><span class=\"line\">&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​\t注意，这个表格是作为REST API的参数传入的，而云端会通过正则表达式来检查内容是否合法，有时多一个少一个回车、空格都不行，正则表达式可参考<a href=\"https://api.nrfcloud.com/v1#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>的API说明：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20230311135339410.png\" alt=\"image-20230311135339410\"></p>\n</blockquote>\n<p><strong>（3）利用REST接口注册设备</strong></p>\n<p>​\t使用<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>接口。这属于<strong>用户到云</strong>的接口调用，需要使用<strong>API key</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向nRF Cloud发送请求，注册设备。</span></span><br><span class=\"line\">$  curl --request POST --url https://api.nrfcloud.com/v1/devices \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbd9f3cxxxxxxxxxxfa73cf37049983&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;content-type: text/csv&#x27;</span> \\</span><br><span class=\"line\">--data-binary @./fake-device.csv</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>把API Key改成你自己的API Key</li>\n<li>用curl发送csv文件时，必须使用二进制流。否则curl可能会丢掉文件末尾的换行符。也可以不用curl，而是通过Postman软件来进行API的调用测试。</li>\n</ul>\n</blockquote>\n<p>​\t云端返回结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;bulkOpsRequestId&quot;:&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t假如这是一次真实的批量注册，这个bulkOpsRequestId需要记录下来，用于调用<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a> API。这个API的作用是用来检查自己批量注册的进度。但是本次是一次模拟，只注册了一个设备，所以很快就能注册完成。</p>\n<blockquote>\n<p>FetchBulkOpsRequest使用方法：</p>\n<p>url的最后是上面获取的bulkOpsRequestId</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/bulk-ops-requests/01GK0NECJPXVNDNKVA4XE98HDE \\</span><br><span class=\"line\">-H <span class=\"string\">&quot;Authorization: Bearer 3c967ecbd9fxxxxxxxxxxxxxx3cf37049983&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bulkOpsRequestId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;status&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;SUCCEEDED&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;PROVISION_DEVICES&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;requestedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:48.054Z&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 这个时间应该是GMT+1的时间</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;completedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:51.365Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;uploadedDataUrl&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;https://bulk-ops-requests.nrfcloud.com/a9d25242-adad-479e-b526-xxxxxxxxxxxx/provision_devices/01GK0NECJPXVNDNKVA4XE98HDE.csv&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\t利用<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>接口来获取新注册的这个设备的信息，其中<code>&#123;device-id&#125;</code>要换成UUID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/devices/&#123;device-id&#125; \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbxxxxxxxxxxxxe81cfa73cf37049983&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tags&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"string\">&quot;jayant-DK&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tenantId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a9d25242-adad-479e-b526-xxxxxxxxxxx&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$meta&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;createdAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:53.127Z&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Generic&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;subType&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;fake-device&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;firmware&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;supports&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;APP&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;MODEM&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;paired&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/d2c&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/+/r&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;metadata&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到里面包含设备的信息，除了之前自己在CSV表格中填写的信息外，还包括MQTT的topic、时间戳等信息。</p>\n<p>​\t设备注册成功后，在网页端也已经可以看到这个模拟的设备：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124154802151.png\" alt=\"image-20221124154802151\"></p>\n<p><strong>（4）生成JWT</strong></p>\n<p><strong>设备到云</strong>（D2C）的API调用需要JWT认证，我们先生成一个JWT：</p>\n<p>打开<a href=\"https://jwt.io/\"> jwt.io</a>，上方选择ES256签名算法，然后PAYLOAD中填入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;sub&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;你的UUID&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下方公钥、私钥区域粘贴上一小节中生成的设备证书的公钥（_pub.pem）和私钥（_prv.pem）的内容。</p>\n<p>（注意，不是CA证书，而是设备证书）</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114051110.png\" alt=\"image-20221129114051110\"></p>\n<p>左下角显示”Signature Verified”，则说明公钥与私钥是成对的。可以把左侧编码好的JWT复制出来，这就是设备与云端通信所需要的 Token：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJFUzI1Nixxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxx78F5NXw</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>（5）测试一个设备API接口</strong></p>\n<p>​\t我们利用<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>来测试接口，在官方API文档页面，我们可以看到：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130102929376.png\" alt=\"image-20221130102929376\"></p>\n<ul>\n<li>展示了URL、参数</li>\n<li>有两种请求方式，Basci Request和 Cuscom Request，后者需要携带更多参数</li>\n<li>提供了<code>curl</code>命令示例，如何携带参数</li>\n<li>展示了认证方式，有 API Key 和 JWT两种，展开有详细说明</li>\n</ul>\n<p>​\t下方是一个Custom Request的调用示例，与API文档中的例子不同，没有使用<code>-d</code>选项，这里是直接把参数写在了URL中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">  --url <span class=\"string\">&#x27;https://api.nrfcloud.com/v1/location/agps?requestType=custom&amp;customTypes=1%2C3%2C4%2C6%2C7%2C8%2C9&amp;mcc=310&amp;mnc=410&amp;tac=36874&amp;eci=84485647&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Accept: application/octet-stream&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Authorization: Bearer eyJhbGciOiJFUzI1Nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxm6Hx78F5NXw&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;range: bytes=0-500&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t请求已经成功返回，但是返回的数据是二进制内容，curl提示我们它不会展示二进制内容，以免打乱终端文字。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114408304.png\" alt=\"image-20221129114408304\"></p>\n<p>​\t也可以用Postman软件进行测试，结果是一样的，返回206，说明数据请求成功：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114544096.png\" alt=\"image-20221129114544096\"></p>\n<p><strong>（6）总结：</strong></p>\n<p>​\t本小节展示了<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a>，<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>这5个REST接口的调用。大多数接口都是云到云的，需要用户的APP key来进行认证。最后一个接口展示了设备到云的REST接口调用，需要使用JWT来进行认证。</p>\n<h2 id=\"4-2-MQTT-API\"><a href=\"#4-2-MQTT-API\" class=\"headerlink\" title=\"4.2. MQTT API\"></a>4.2. MQTT API</h2><p>​\tnRF Cloud是部署在亚马逊AWS上的，并且使用<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/iot-gs.html\">AWS IoT Core</a>的MQTT broker。</p>\n<p>MQTT API的通信，只要订阅topic即可。这里需要有2个topic，<code>d2c</code>和<code>c2d</code>。</p>\n<ul>\n<li><code>d2c</code>：设备发布，云端订阅</li>\n<li><code>c2d</code>：云端发布，设备订阅</li>\n</ul>\n<p>​\t只要每个设备能获得这两个topic，就能与云端进行通信。这个topic可以通过REST API获得，下一小节会介绍。但是实际开发应用的时候，并不需要关心，因为nRF Cloud Library已经帮我们封装好了，我们只需调用<code>connect()</code>，<code>send()</code>之类的就好了。</p>\n<h3 id=\"MQTT-topic前缀的获取\"><a href=\"#MQTT-topic前缀的获取\" class=\"headerlink\" title=\"MQTT topic前缀的获取\"></a>MQTT topic前缀的获取</h3><p>​\t用户可以通过REST API获取topic前缀，接口是 <a href=\"https://api.nrfcloud.com/v1/#operation/FetchAccountInfo\">FetchAccountInfo</a>。需要使用用户的API Key进行认证。接口会返回很多数据，其中就包含：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttEndpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;mqtt.nrfcloud.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttTopicPrefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;prod/a5592ec1-18ae-4d9d-bc44-xxxxxxxxx/&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t不用REST API，也可以在网页端获取。点击右上角下拉菜单-Teams：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130132356346.png\" alt=\"image-20221130132356346\"></p>\n<p>​\t可以看到Team的信息，其中就有team id。<code>mqttTopicPrefix</code>就是<code>prod/&lt;team_id&gt;</code>。</p>\n<h3 id=\"云端的认证\"><a href=\"#云端的认证\" class=\"headerlink\" title=\"云端的认证\"></a>云端的认证</h3><p>​\t所有到AWS IoT MQTT broker的连接都必须使用在8883端口上进行的Mutual TLS。所有用MQTT的设备都必须有一个<a href=\"https://docs.nrfcloud.com/Devices/Security/Security/#authentication\">X.509 device certificate</a>，并且已经<strong>注册到云端（Provisioned）</strong>。这正是我们在[3.5](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))和[6.1](#REST API 调用示例 )中已经介绍过的部分。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>​\tnRF Cloud部署在AWS上，除了<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html\">AWS保留的topic</a>外，还有一些是nRF Cloud自定义的。官方文档请参考：</p>\n<p><a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/\">nRF Cloud MQTT topics | nRF Cloud Docs</a></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>​\t有关nRF Cloud Library底层的细节，官方文档为 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html\">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>\n<p>​\t在[3.5.3](#3.5.3. 数据传输相关代码)中，我们知道9160是通过Cloud Wrapper API包装了nRF Cloud Library相关的接口进行的。其中发送到云端就是<code>cloud_wrap_batch_send()</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">cloud_wrap_batch_send</span><span class=\"params\">(<span class=\"type\">char</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">bool</span> ack, <span class=\"type\">uint32_t</span> id)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> err;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nrf_cloud_tx_data</span> <span class=\"title\">msg</span> =</span> &#123;</span><br><span class=\"line\">        .data.ptr = buf,</span><br><span class=\"line\">        .data.len = len,</span><br><span class=\"line\">        .id = id,</span><br><span class=\"line\">        .qos = ack ? MQTT_QOS_1_AT_LEAST_ONCE : MQTT_QOS_0_AT_MOST_ONCE,</span><br><span class=\"line\">        .topic_type = NRF_CLOUD_TOPIC_BULK,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = nrf_cloud_send(&amp;msg);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;nrf_cloud_send, error: %d&quot;</span>, err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t这里面，准备好要发送的数据<code>msg</code>即可，数据类型是<code>nrf_cloud_tx_data_msg</code>。Topic是<code>NRF_CLOUD_TOPIC_BULK</code>。</p>\n<p>​\t这恰好就是<a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics\">官方MQTT API手册</a>中的topic，作用是发送一组bulk数据。只要仿照wrapper中的格式，就可以写出自己的发送函数。</p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>​\tnRF Cloud是一个物联网云，提供最基本的设备管理和OTA等功能。此外还提供收费的Location Service，含AGPS、PGPS、基站定位、WiFi定位等功能。不局限于Nordic产品，任何产品都可以连。</p>\n<p>​\tnRF9160具有LTE-M和NB-IoT联网能力，支持GPS。支持eDRX和PSM低功耗，休眠时功耗低至2.7uA。除了本身的Cortex M33应用核可开放开发以外，还可作为外挂通讯模组进行开发。SLM扩展的AT指令也支持多种功能。</p>\n<p>​\t</p>\n","categories":["Nordic","LTE"],"tags":["Nordic","nRF91","nRF_Cloud"]},{"title":"利用Wireshark和tcpdump对整个局域网进行实时抓包","url":"/jayant97.github.io/2022/12/dad29a5a49fd/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t有时我们需要对局域网中两个设备之间的通讯进行抓包调试，一种比较方便的方式就是在路由器上通过<code>tcpdump</code>抓包，然后传回电脑上，利用Wireshark查看抓包内容。</p>\n<p>​\t本文将以一个OpenWrt路由器为例，展示抓包过程。</p>\n<p>​\t参考文章：<a href=\"https://thiscute.world/posts/tcpdump-and-wireshark/#%E4%BA%8Ctcpdump--ssh--wireshark-%E8%BF%9C%E7%A8%8B%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85\">使用 tcpdump 和 Wireshark 进行远程实时抓包分析 - This Cute World</a></p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214212711479.png\" alt=\"image-20221214212711479\"></p>\n<h1 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h1><h2 id=\"2-1-PC上安装Wireshark\"><a href=\"#2-1-PC上安装Wireshark\" class=\"headerlink\" title=\"2.1. PC上安装Wireshark\"></a>2.1. PC上安装Wireshark</h2><p>​\t官网下载安装包然后安装即可，安装时，一定要勾选：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/16052569014970022.png\" alt=\"image description\"></p>\n<h2 id=\"2-2-路由器上需要有tcpdump\"><a href=\"#2-2-路由器上需要有tcpdump\" class=\"headerlink\" title=\"2.2. 路由器上需要有tcpdump\"></a>2.2. 路由器上需要有<code>tcpdump</code></h2><p>​\t我是在路由器固件编译时就编译了<code>tcpdump</code>和<code>libcap</code>。选择为<code>&lt;*&gt;</code>号是随固件一起编译，选择为<code>&lt;M&gt;</code>是作为包进行编译。<code>-*-</code>表示强制随固件一起编译，因为有其他包依赖它，所以它必须选中。</p>\n<p>​\tNetwork —&gt; tcpdump</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214214847255.png\" alt=\"image-20221214214847255\"></p>\n<p>​\tLibraries —&gt; libcap：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215049186.png\" alt=\"image-20221214215049186\"></p>\n<p>​\t如果你不是自己编译的固件，也可以网上下载别人编译好的ipk传到OpenWrt上安装即可：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214214611043.png\" alt=\"image-20221214214611043\"></p>\n<p>在路由器上进行测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tcpdump --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215320752.png\" alt=\"image-20221214215320752\"></p>\n<h1 id=\"3-利用Wireshark调用路由器上的tcpdump进行抓包\"><a href=\"#3-利用Wireshark调用路由器上的tcpdump进行抓包\" class=\"headerlink\" title=\"3. 利用Wireshark调用路由器上的tcpdump进行抓包\"></a>3. 利用Wireshark调用路由器上的<code>tcpdump</code>进行抓包</h1><p>（1）打开Wireshark，选择<strong>捕获——选项</strong>：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215528345.png\" alt=\"image-20221214215528345\"></p>\n<p>（2）选择<strong>SSH remote capture</strong>，点击开始</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215620451.png\" alt=\"image-20221214215620451\"></p>\n<p>（3）输入路由器的ip地址和ssh端口号（默认22）</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215737318.png\" alt=\"image-20221214215737318\"></p>\n<p>（4）输入路由器用户名和密码&#x2F;密钥</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214215921550.png\" alt=\"image-20221214215921550\"></p>\n<blockquote>\n<p>我这里用的是密钥而非密码，请参考：<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/693c6a957393/\">最简洁清爽的ssh使用方案 | 一苇万顷 (jayant-tang.github.io)</a>。</p>\n<p>你也可以用密码</p>\n</blockquote>\n<p>（5）tcpdump设置</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214220409559.png\" alt=\"image-20221214220409559\"></p>\n<p>参数设置：</p>\n<ul>\n<li><p>Remote Interface：路由器上要抓包的接口，可以在路由器管理网页上查看，也可以用<code>ifconfig</code>查看，这里是<code>br-lan</code></p>\n<img src=\"/jayant97.github.io/imgs/利用Wireshark和tcpdump对整个局域网进行实时抓包.assets/image-20221214220526046.png\" alt=\"image-20221214220526046\" style=\"zoom:50%;\" />\n</li>\n<li><p>Remote capture command selection：路由器上选择的抓包工具，这里是<code>tcpdump</code></p>\n</li>\n<li><p>Remote capture filter：远程抓包的规则，可以把本机的IP地址填进去过滤，防止Wireshark抓自己和路由器之间的ssh包。比如<code>not (host 192.168.2.2 and port 22)</code>。这里可以用<code>not</code>，<code>or</code>和<code>and</code>逻辑，可以过滤IPv4&#x2F;IPv6地址和端口号。</p>\n<blockquote>\n<p>这个地方是远程过滤器，是抓包时就过滤，后面Wireshark里面还可以再次设置本地过滤器。</p>\n</blockquote>\n</li>\n</ul>\n<p>（6）开始抓包</p>\n<p>最后点击开始，即可在Wireshark中看到路由器br-lan的包了。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%88%A9%E7%94%A8Wireshark%E5%92%8Ctcpdump%E5%AF%B9%E6%95%B4%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E6%8A%93%E5%8C%85.assets/image-20221214221347037.png\" alt=\"image-20221214221347037\"></p>\n<p>​\t与此同时，我们可以去路由器上看看Wireshark是怎么用<code>tcpdump</code>抓的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ root@OpenWrt:~<span class=\"comment\"># ps | grep tcpdump</span></span><br><span class=\"line\"> 2131 root      5676 S    tcpdump -U -i br-lan -w - not (host 192.168.2.2 and port 22)</span><br><span class=\"line\"> 8318 root      1248 S    grep tcpdump</span><br></pre></td></tr></table></figure>\n\n<p>​\t如上，可以看到Wireshark调用的<code>tcpdump</code>命令以及参数。</p>\n","categories":["网络"],"tags":["Wireshark","OpenWrt"]},{"title":"在NCS中使用NRFX外设驱动库——以I2C为例","url":"/jayant97.github.io/2023/11/1349f878e408/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>之前编写了两篇与Zephyr设备树和驱动相关的文章：</p>\n<ul>\n<li><a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">详解Zephyr设备树与驱动模型</a></li>\n<li><a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/\">Zephyr设备树与驱动实战——串口</a></li>\n</ul>\n<p>如果你看完这两篇文章，相信你对Zephyr的驱动模型已经有一定概念了。开发者能够直接使用厂商写好的高效、完善的驱动程序，无需再埋头于寄存器手册、波形时序、引脚配置等底层程序，只需专注于自己的应用即可。</p>\n<p>但是，做嵌入式开发，总还有各种各样的原因，让人不得不陷入底层软件调试之中，包括但不限于：</p>\n<ul>\n<li>厂商提供的外设驱动都只有标准的，但我的应用场景是非标准的</li>\n<li>我需要多个外设在底层进行深入的联动，厂商提供的驱动无法满足我的需求</li>\n<li>我不想学Device Tree和驱动模型，我就喜欢老的nRF5 SDK那种开发方法</li>\n<li>……</li>\n</ul>\n<p>话先说在前面，Nordic的nRF5 SDK从17.10开始就不再更新了。从nRF53系列（也就是nRF5340）、nRF91蜂窝网络、nRF70 Wi-Fi系列以及马上要出的强力的nRF54系列产品，都只能使用NCS了。并且，今后单片机的嵌入式软件开发会越来越复杂：TCP&#x2F;IP、蓝牙、USB、Matter、OTA、文件系统、显示屏……各种复杂的应用和协议栈，如果都从底层寄存器开始做起，那真是不知道要浪费多少时间，关键是还不一定能做成功。Zephyr是一个RTOS，除了基本的多线程、线程间通讯之外，还有功耗管理、线程监控、自定义shell命令、非易失存储、DSP、加密、代码与变量位置重定向、C++支持等等功能。并且，Zephyr是Linux基金会维护的开源项目，底层也是POSIX接口，编译与配置系统是CMake和Kconfig，这意味着Zephyr可以很容易的集成许多第三方开源项目进来。</p>\n<p>不过Zephyr再好，厂商肯定是不会把底层调试的路完全封死的。本文将会以nRF52840DK为例，介绍在NCS中，如何使用NRFX库来使用I2C从机。这个NRFX库和之前nRF5 SDK中的nrfx几乎是一致的。</p>\n<h1 id=\"2-硬件连接\"><a href=\"#2-硬件连接\" class=\"headerlink\" title=\"2. 硬件连接\"></a>2. 硬件连接</h1><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231115221340971.png\" alt=\"image-20231115221340971\"></p>\n<p>I2C主机：SDA(P0.26) SCL(P0.27)</p>\n<p>I2C从机：SDA(P0.30) SCL(P0.31)</p>\n<h1 id=\"3-例程代码\"><a href=\"#3-例程代码\" class=\"headerlink\" title=\"3. 例程代码\"></a>3. 例程代码</h1><h2 id=\"工程结构\"><a href=\"#工程结构\" class=\"headerlink\" title=\"工程结构\"></a>工程结构</h2><p>本文以<code>$&#123;NCS&#125;/zephyr/samples/hello_world</code>为基础。主要文件如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-- boards</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    `-- nrf52840dk_nrf52840.overlay</span><br><span class=\"line\">|</span><br><span class=\"line\">|-- src</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |-- main.c</span><br><span class=\"line\">|    |-- i2c_slave.c</span><br><span class=\"line\">|    `-- message.h</span><br><span class=\"line\">|</span><br><span class=\"line\">|-- CMakeLists.txt</span><br><span class=\"line\">`-- prj.conf</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CMakeLists-txt\"><a href=\"#CMakeLists-txt\" class=\"headerlink\" title=\"CMakeLists.txt\"></a>CMakeLists.txt</h2><figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.20</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Zephyr REQUIRED HINTS $ENV&#123;ZEPHYR_BASE&#125;)</span><br><span class=\"line\"><span class=\"keyword\">project</span>(hello_world)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">target_sources</span>(app PRIVATE </span><br><span class=\"line\">    src/main.c</span><br><span class=\"line\">    src/i2c_slave.c</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">target_include_directories</span>(app PRIVATE </span><br><span class=\"line\">    src)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"prj-conf\"><a href=\"#prj-conf\" class=\"headerlink\" title=\"prj.conf\"></a>prj.conf</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the I2C matser using Zephyr driver</span></span><br><span class=\"line\">CONFIG_I2C=y</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the I2C slave using NRFX driver</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">see: https://github.com/zephyrproject-rtos/zephyr/issues/21445</span></span><br><span class=\"line\">CONFIG_NRFX_TWIS1=y</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li>本例主机采用Zephyr标准I2C驱动，故需要使能</li>\n<li>Zephyr没有标准I2C从机驱动，故此处使用NRFX库</li>\n</ul>\n<blockquote>\n<p>由于版权原因，Nordic的I2C外设叫做TWI（Two-Wire Interface）</p>\n</blockquote>\n<h2 id=\"设备树overlay\"><a href=\"#设备树overlay\" class=\"headerlink\" title=\"设备树overlay\"></a>设备树overlay</h2><p><code>boards/nrf52840dk_nrf52840.overlay</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;i2c0 &#123;</span><br><span class=\"line\">    compatible = <span class=\"string\">&quot;nordic,nrf-twim&quot;</span>;</span><br><span class=\"line\">    status = <span class=\"string\">&quot;okay&quot;</span>;</span><br><span class=\"line\">    clock-frequency = &lt;I2C_BITRATE_STANDARD&gt;;</span><br><span class=\"line\">    pinctrl<span class=\"number\">-0</span> = &lt;&amp;i2c0_default&gt;;</span><br><span class=\"line\">    pinctrl<span class=\"number\">-1</span> = &lt;&amp;i2c0_sleep&gt;;</span><br><span class=\"line\">    pinctrl-names = <span class=\"string\">&quot;default&quot;</span>, <span class=\"string\">&quot;sleep&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this node is here just to meet the requirements of the `CONFIG_NRFX_TWIS1=y`.</span></span><br><span class=\"line\"><span class=\"comment\">// The Zephyr I2C slave driver is not available now.</span></span><br><span class=\"line\"><span class=\"comment\">// So we use NRFX driver instead.</span></span><br><span class=\"line\">&amp;i2c1 &#123;</span><br><span class=\"line\">    compatible = <span class=\"string\">&quot;nordic,nrf-twis&quot;</span>;</span><br><span class=\"line\">    status = <span class=\"string\">&quot;okay&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;pinctrl &#123;</span><br><span class=\"line\">    i2c0_default: i2c0_default &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(TWIM_SDA, <span class=\"number\">0</span>, <span class=\"number\">26</span>)&gt;,</span><br><span class=\"line\">                &lt;NRF_PSEL(TWIM_SCL, <span class=\"number\">0</span>, <span class=\"number\">27</span>)&gt;;</span><br><span class=\"line\">            nordic,drive-mode = &lt;NRF_DRIVE_S0D1&gt;; <span class=\"comment\">// standard 0, disconnect 1</span></span><br><span class=\"line\">            bias-pull-up; <span class=\"comment\">// internal pull-up is too weak, only for 100kHz or lower  </span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c0_sleep: i2c0_sleep &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(TWIM_SDA, <span class=\"number\">0</span>, <span class=\"number\">26</span>)&gt;,</span><br><span class=\"line\">                &lt;NRF_PSEL(TWIM_SCL, <span class=\"number\">0</span>, <span class=\"number\">27</span>)&gt;;</span><br><span class=\"line\">            low-power-enable;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// i2c1 not used for Zephyr driver, it is initialized by nrfx driver.</span></span><br><span class=\"line\">    <span class=\"comment\">// just for Devicetree GUI display</span></span><br><span class=\"line\">    i2c1_default: i2c1_default &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(TWIM_SDA, <span class=\"number\">0</span>, <span class=\"number\">30</span>)&gt;,</span><br><span class=\"line\">                &lt;NRF_PSEL(TWIM_SCL, <span class=\"number\">0</span>, <span class=\"number\">31</span>)&gt;;</span><br><span class=\"line\">                bias-pull-up; </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    i2c1_sleep: i2c1_sleep &#123;</span><br><span class=\"line\">        group1 &#123;</span><br><span class=\"line\">            psels = &lt;NRF_PSEL(TWIM_SDA, <span class=\"number\">0</span>, <span class=\"number\">30</span>)&gt;,</span><br><span class=\"line\">                &lt;NRF_PSEL(TWIM_SCL, <span class=\"number\">0</span>, <span class=\"number\">31</span>)&gt;;</span><br><span class=\"line\">            low-power-enable;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>主机device tree说明：</strong></p>\n<ul>\n<li><code>i2c0</code>为主机，采用pinctrl来配置引脚。</li>\n<li>由于I2C协议要求开漏输出，因此我们这里的i2c0引脚配置为<code>NRF_DRIVE_S0D1</code>，其含义是“输出逻辑0时为标准GND输出，输出逻辑1时内部断开（高阻态）”。</li>\n<li>由于I2C协议要求上拉电阻，而我们是杜邦线跳线没有上拉电阻，因此这里采用内部上拉。</li>\n<li><code>compatible</code>一定要选择<code>&quot;nordic,nrf-twim&quot;</code>而不是<code>&quot;nordic,nrf-twi&quot;</code>，前者是带DMA的驱动程序，后者是不带DMA的驱动程序。</li>\n</ul>\n<blockquote>\n<p>补充：</p>\n<ul>\n<li><p>除了S（Standard）和D（Disconnect）之外，还有H（High-drive）。一些高速接口需要IO有更强的驱动能力，这种情况下可以配置为<code>NRF_DRIVE_H0H1</code>。不过具体还是要看芯片手册里面每个GPIO是否支持高驱（位于手册里的Pin assignment章节）：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116001024624.png\" alt=\"image-20231116001024624\"></p>\n</li>\n<li><p>GPIO内部上&#x2F;下拉电阻比较大，典型值为13千欧。因此如果用内部上拉，速率只能配置为100Kbps。若要更高的速率，外部可以挂更小的电阻，例如5千欧左右可以达到400Kbps.</p>\n</li>\n</ul>\n</blockquote>\n<p><strong>从机device tree说明：</strong></p>\n<p><code>i2c1</code>为从机。从机的代码是用NRFX的，完全没有用到device tree。这里修改i2c1的device tree，完全是Kconfig的要求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config NRFX_TWIS1</span><br><span class=\"line\">    bool &quot;TWIS1 driver instance&quot;</span><br><span class=\"line\">    depends on $(dt_nodelabel_has_compat,i2c1,$(DT_COMPAT_NORDIC_NRF_TWIS))</span><br><span class=\"line\">    select NRFX_TWIS</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，<code>CONFIG_TWIS1</code>的依赖项，要求device tree中的<code>i2c1</code>节点，必须具有<code>compatible=&quot;nordic,nrf-twis&quot;</code>。只有满足这个条件，我们才能写<code>CONFIG_TWIS1=y</code>。并且，此配置项会自动连锁使能<code>CONFIG_NRFX_TWIS=y</code>。</p>\n<p>我们要明确一点，NRFX是不需要device tree的。这里Kconfig的依赖项，我想只是为了能在项目中<strong>明显地指示出</strong>，我们使用了<code>i2c1</code>这个外设。以免在多人开发项目中产生一些误会，导致外设被重复使用。</p>\n<p>同理，从机的pinctrl也是没有实际作用的。写它只是为了能够在Device Tree的GUI中正确显示引脚分配：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116002542051.png\" alt=\"image-20231116002542051\"></p>\n<h2 id=\"message-h\"><a href=\"#message-h\" class=\"headerlink\" title=\"message.h\"></a>message.h</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _MESSAGE_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MASTER_TO_SLAVE <span class=\"string\">&quot;Master to Slave&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SLAVE_TO_MASTER <span class=\"string\">&quot;Slave to Master&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这里面只是主从机共用的测试用数据而已</p>\n<h2 id=\"主机代码\"><a href=\"#主机代码\" class=\"headerlink\" title=\"主机代码\"></a>主机代码</h2><p>main.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Copyright (c) 2012-2014 Wind River Systems, Inc.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/device.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/drivers/i2c.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;message.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">twi_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(i2c0));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_ADDR 0xbeef <span class=\"comment\">// only the lowest 7bit is useful</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> send_data[] = MASTER_TO_SLAVE;</span><br><span class=\"line\">    <span class=\"type\">char</span> read_data[<span class=\"number\">128</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!device_is_ready(twi_dev))&#123;</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;twi device is not ready!\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">3000</span>));</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;\\n[Master] write: \\&quot;%.*s\\&quot;\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(send_data), send_data);</span><br><span class=\"line\">        i2c_write(twi_dev, send_data, <span class=\"keyword\">sizeof</span>(send_data), I2C_ADDR);</span><br><span class=\"line\"></span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">2000</span>));</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;\\n[Master] read\\n&quot;</span>);</span><br><span class=\"line\">        i2c_read(twi_dev, read_data, <span class=\"keyword\">sizeof</span>(SLAVE_TO_MASTER), I2C_ADDR);</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;[Master] received:\\&quot;%.*s\\&quot;\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(SLAVE_TO_MASTER), read_data);</span><br><span class=\"line\"></span><br><span class=\"line\">        k_sleep(K_MSEC(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>主机程序说明：</strong></p>\n<ul>\n<li><p>主机会循环向i2c写入数据、然后读取数据。</p>\n</li>\n<li><p>先slepp，后发数据，是为了开始时要先等从机那边初始化好。</p>\n</li>\n<li><p>Zephyr标准API中，I2C从机地址这个参数是16bit的。但对于Nordic的芯片来说，<strong>只有最低7bit是真实的地址</strong>。硬件上也只支持7bit地址。</p>\n</li>\n<li><p>所有这些I2C读写API都是<strong>阻塞</strong>的。但是，底层是DMA，怎么会阻塞呢？原来，这里的阻塞只是“线程阻塞”而不是“CPU阻塞”。当I2C开始传输后，I2C的驱动实际上是在尝试take一个信号量，这时，<strong>当前线程会被阻塞，但其他线程可以正常执行</strong>。当DMA传输完成后，产生中断，中断内部give这个信号量，于是读&#x2F;写函数就可以返回了。</p>\n<blockquote>\n<p>这也告诉我们，在RTOS中，应该尽量把不同的模块分成不同的线程去开发。这样既使得程序结构清晰，又不会有任务之间互相阻塞的问题。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"从机代码\"><a href=\"#从机代码\" class=\"headerlink\" title=\"从机代码\"></a>从机代码</h2><p>i2c_slave.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/device.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;nrfx_twis.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;message.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACKSIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PRIORITY 7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SLAVE_ADDR 0xef</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TWI_INT_PRIORITY 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SLAVE_SDA_PIN 30 <span class=\"comment\">// P0.30</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SLAVE_SCL_PIN 31 <span class=\"comment\">// P0.31</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TWIS_INST_IDX 1 <span class=\"comment\">// twis1</span></span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">nrfx_twis_t</span> twis_inst = NRFX_TWIS_INSTANCE(TWIS_INST_IDX);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MSG_TO_SEND <span class=\"string\">&quot;Slave-to-Master&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> m_tx_buffer_slave[<span class=\"keyword\">sizeof</span>(MSG_TO_SEND)] = MSG_TO_SEND;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> m_rx_buffer_slave[<span class=\"number\">128</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Function for handling TWIS driver events.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param[in] p_event Event information structure.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">twis_handler</span><span class=\"params\">(<span class=\"type\">nrfx_twis_evt_t</span> <span class=\"type\">const</span> * p_event)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">nrfx_err_t</span> status;</span><br><span class=\"line\">    (<span class=\"type\">void</span>)status;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (p_event-&gt;type)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_WRITE_DONE:&#123;</span><br><span class=\"line\">            <span class=\"type\">uint32_t</span> len = p_event-&gt;data.rx_amount;</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;--&gt; Slave event: received write done.\\n&quot;</span>);</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;[Slave] received:\\&quot;%.*s\\&quot;\\n&quot;</span>, len, m_rx_buffer_slave);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_WRITE_REQ:&#123;</span><br><span class=\"line\">            status = nrfx_twis_rx_prepare(&amp;twis_inst, m_rx_buffer_slave, <span class=\"keyword\">sizeof</span>(m_rx_buffer_slave));</span><br><span class=\"line\">            NRFX_ASSERT(status == NRFX_SUCCESS);</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;--&gt; Slave event: received write request\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_READ_DONE:&#123;</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;--&gt; Slave event: received read done.\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_READ_REQ: &#123;</span><br><span class=\"line\">            status = nrfx_twis_tx_prepare(&amp;twis_inst, m_tx_buffer_slave, <span class=\"keyword\">sizeof</span>(m_tx_buffer_slave));</span><br><span class=\"line\">            NRFX_ASSERT(status == NRFX_SUCCESS);</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;--&gt; Slave event: received read request\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_READ_ERROR:</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;\\nTWIS READ ERROR\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_WRITE_ERROR:</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;\\nTWIS WRITE ERROR\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> NRFX_TWIS_EVT_GENERAL_ERROR:</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;\\nTWIS GENERAL ERROR\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            printk(<span class=\"string\">&quot;--&gt; SLAVE event: %d.&quot;</span>, p_event-&gt;type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">i2c_slave_entry</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">nrfx_err_t</span> status;</span><br><span class=\"line\">    (<span class=\"type\">void</span>)status;</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">&quot;Starting nrfx_twim_twis non-blocking example.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// connect handler to Zephyr interrupt</span></span><br><span class=\"line\">    IRQ_CONNECT(DT_IRQN(DT_NODELABEL(i2c1)),</span><br><span class=\"line\">        DT_IRQ(DT_NODELABEL(i2c1), priority),</span><br><span class=\"line\">        nrfx_isr, twis_handler, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">nrfx_twis_config_t</span> twis_config = &#123;</span><br><span class=\"line\">        .addr[<span class=\"number\">0</span>]            = SLAVE_ADDR, <span class=\"comment\">// first address</span></span><br><span class=\"line\">        .addr[<span class=\"number\">1</span>]            = <span class=\"number\">0</span>,          <span class=\"comment\">// second address</span></span><br><span class=\"line\">        .scl                = SLAVE_SCL_PIN,                              </span><br><span class=\"line\">        .sda                = SLAVE_SDA_PIN,                              </span><br><span class=\"line\">        .scl_pull           = NRF_GPIO_PIN_PULLUP,                   </span><br><span class=\"line\">        .sda_pull           = NRF_GPIO_PIN_PULLUP,                   </span><br><span class=\"line\">        .interrupt_priority = TWI_INT_PRIORITY,</span><br><span class=\"line\">        .skip_gpio_cfg = <span class=\"literal\">false</span>,</span><br><span class=\"line\">        .skip_psel_cfg = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    printk(<span class=\"string\">&quot;\\nI2C Slave: ADDR: 0x%x, SCL: %d, SDA: %d, int_pri: %d&quot;</span>,</span><br><span class=\"line\">      twis_config.addr[<span class=\"number\">0</span>],</span><br><span class=\"line\">      twis_config.scl,</span><br><span class=\"line\">      twis_config.sda,</span><br><span class=\"line\">      twis_config.interrupt_priority);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nrfx_twis_init(&amp;twis_inst, &amp;twis_config, twis_handler) == NRFX_SUCCESS)&#123;</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;\\nnrfx twis initialized.\\n\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        printk(<span class=\"string\">&quot;\\nERROR: nrfx_twis_init()\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IRQ_DIRECT_CONNECT(NRFX_IRQ_NUMBER_GET(NRF_TWIS_INST_GET(TWIS_INST_IDX)), IRQ_PRIO_LOWEST,</span><br><span class=\"line\">                       NRFX_TWIS_INST_HANDLER_GET(TWIS_INST_IDX), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    nrfx_twis_enable(&amp;twis_inst);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        k_sleep(K_FOREVER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">K_THREAD_DEFINE(i2c_slave_id, STACKSIZE, i2c_slave_entry, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, PRIORITY, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>从机程序说明：</strong></p>\n<p>从机用nrfx库初始化、注册中断服务函数、并使能TWIS。这部分代码，和nrf5 SDK中nrfx库的用法是一样的。</p>\n<p>与nRF5 SDK中略有不同的是，中断服务函数需要用Zephyr的机制去连接一下。这是因为Zephyr默认把所有中断向量全占了，用于整个驱动模型。这部分请参考<a href=\"https://docs.zephyrproject.org/latest/kernel/services/interrupts.html#interrupts\">Zephyr内核文档——中断</a>。今后我也会写一篇博客来介绍Zephyr的中断。</p>\n<p>从机的程序也是一个线程，用<code>K_THREAD_DEFINE</code>来定义线程。线程中初始化完TWIS后，就进入了永久睡眠。</p>\n<p>对于I2C WRITE操作，在主机发送完7bit地址，之后的那一个比特为0（写）时，这一瞬间立即产生<code>NRFX_TWIS_EVT_WRITE_REQ</code>事件，这时要准备好接收数据的缓存。写完后，产生<code>NRFX_TWIS_EVT_WRITE_DONE</code>事件。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116004555046.png\" alt=\"image-20231116004555046\"></p>\n<p>对于I2C READ操作也是同理。<code>NRFX_TWIS_EVT_READ_REQ</code>时，准备好即将要发送的缓存。<code>NRFX_TWIS_EVT_READ_DONE</code>说明发送完毕。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116004445733.png\" alt=\"image-20231116004445733\"></p>\n<blockquote>\n<p>注意，不一定要在<code>NRFX_TWIS_EVT_READ_REQ</code>时，才开始准备要发送的数据。可以提前调用<code>nrfx_twis_tx_prepare()</code>来准备要发送的数据。接收也是同理。</p>\n</blockquote>\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116013311689.png\" alt=\"image-20231116013311689\"></p>\n<h1 id=\"4-应用开发\"><a href=\"#4-应用开发\" class=\"headerlink\" title=\"4. 应用开发\"></a>4. 应用开发</h1><h2 id=\"其他NRFX例程\"><a href=\"#其他NRFX例程\" class=\"headerlink\" title=\"其他NRFX例程\"></a>其他NRFX例程</h2><p>位于<code>$&#123;NCS&#125;/modules/hal/nordic/nrfx/samples/src</code></p>\n<h2 id=\"与其他Zephyr标准驱动的共存\"><a href=\"#与其他Zephyr标准驱动的共存\" class=\"headerlink\" title=\"与其他Zephyr标准驱动的共存\"></a>与其他Zephyr标准驱动的共存</h2><p>通过前面的讲解，相信多数人都能理解，NRFX的驱动程序和Zephry的标准驱动是可以共存的，只要用到的<strong>外设资源</strong>不冲突、<strong>GPIO不冲突</strong>即可。</p>\n<p>这里还有另外两个要注意的点：</p>\n<h3 id=\"外设地址冲突\"><a href=\"#外设地址冲突\" class=\"headerlink\" title=\"外设地址冲突\"></a>外设地址冲突</h3><p>Nordic的串行外设（串口、SPI、SPIM、SPIS、TWI、TWIM、TWIS），并不是都能同时使用的。有些外设其实是同样的外设地址，内部共用了一部分串行和DMA电路。这样就造成了有很多外设可用的假象。实际上只是同一个芯片内部电路的不同使用方法。</p>\n<p>我们可以在芯片手册 Memory 章节的 Instantiation 小节看到所有外设实例的地址：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8NCS%E4%B8%AD%E4%BD%BF%E7%94%A8NRFX%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8%E5%BA%93%E2%80%94%E2%80%94%E4%BB%A5I2C%E4%B8%BA%E4%BE%8B.assets/image-20231116011218081.png\" alt=\"image-20231116011218081\"></p>\n<p>可以看到，对于52840来说，串口0是独立的，SPI0和TWI0是二选一，SPI1和TWI1是二选一。</p>\n<p>不仅是NRFX，对于Zephyr标准驱动来说，也是一样的。我们可以从DeviceTree中看到，冲突的外设，它们的地址是相等的。</p>\n<p>此外，从右边我们可以看到，不带DMA的外设目前基本是不用的。</p>\n<h3 id=\"资源型外设的自动分配\"><a href=\"#资源型外设的自动分配\" class=\"headerlink\" title=\"资源型外设的自动分配\"></a>资源型外设的自动分配</h3><p>在Nordic的单片机中，有很多“资源型”外设。我把它叫做资源型，是因为这些外设之间没有任何区别，用谁都一样，比如：</p>\n<ul>\n<li><strong>GPIOTE</strong>：GPIOTE有8个独立的通道，每个通道可以连一个GPIO，使其获得TASK和EVENT寄存器，用来产生中断、连接PPI通道等。</li>\n<li><strong>PPI</strong>：可以连接一个外设的EVENT寄存器，和两个其他外设的TASK寄存器，使得EVENT自动触发TASK。nRF52840有20个自由的PPI通道（还有12个固定的）。</li>\n</ul>\n<p>理论上讲，当你用这些个通道时，随便用哪个都没区别。但是，<strong>你怎么知道目前Zephyr系统内的什么驱动已经用掉了哪个通道呢？</strong>如何防止自己选的通道和Zephyr内目前已经用的通道冲突？</p>\n<p>答案就是，别自己选。这些外设之所以叫资源型，就是因为它和内存等资源一样，可以集中管理，动态的分配和释放。<strong>而Nordic提供的所有Zephyr驱动，凡是用到了这些外设的，都是使用其对应的allocate函数，而不是直接指定一个具体的资源</strong>。</p>\n<p>例如，对于GPIOTE通道，可以用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">nrfx_err_t</span> <span class=\"title function_\">nrfx_gpiote_channel_alloc</span><span class=\"params\">(<span class=\"type\">uint8_t</span> * p_channel)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于PPI通道，可以用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">nrfx_err_t</span> <span class=\"title function_\">nrfx_gppi_channel_alloc</span><span class=\"params\">(<span class=\"type\">uint8_t</span> * p_channel)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Nordic不同芯片，有的是PPI，有的是分布式PPI（DPPI）。NCS中统一用gppi，这是一个wrapper，会自动根据芯片平台选择调用PPI或DPPI的API。</p>\n</blockquote>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr","NRFX"]},{"title":"在Windows上使用Wireshark和Npcap进行WiFi嗅探","url":"/jayant97.github.io/2022/12/66c35f484401/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t我们知道，无线网卡有四种工作模式：</p>\n<ul>\n<li>Managed：电脑网卡最常用的模式，用于连接到无线AP进行上网，被AP管理通信过程。</li>\n<li>Master：AP模式，提供无线接入和路由的功能。Master能管理与Managed模式的网卡的通信过程。</li>\n<li>Ad-hoc：点对点通讯模式，通信双方地位对等，共同承担AP的任务</li>\n<li>Monitor：监听模式</li>\n</ul>\n<p>​\t本文讲解如何在<strong>Windows</strong>电脑上，把无线网卡变为<strong>Monitor</strong>模式，对空中的wifi进行抓包，并用<strong>Wireshark</strong>进行包的分析。</p>\n<p>​\t本文参考了：<a href=\"https://zhiliao.h3c.com/theme/details/183006\">在Windows电脑上通过wireshark直接无线抓包的方式 - 知了社区 (h3c.com)</a></p>\n<h1 id=\"2-安装Npcap\"><a href=\"#2-安装Npcap\" class=\"headerlink\" title=\"2. 安装Npcap\"></a>2. 安装Npcap</h1><p>在Windows上安装Wireshark时，会问你是否要同时安装Npcap，这里要勾选：</p>\n<p>​\t<img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225008728.png\" alt=\"image-20221214225008728\"></p>\n<p>安装Npacp时，<strong>不勾选</strong>管理员模式，<strong>勾选</strong>802.11流量抓包支持：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225059444.png\" alt=\"image-20221214225059444\"></p>\n<blockquote>\n<p>注！</p>\n<p>​\t经过亲自测试，发现Npcap 1.71&#x2F;1.70版本在Windows 11 上均存在bug，明明勾选了<code>Support raw 802.11 traffic</code>，但是实际使用时却提示没有勾选。</p>\n<p>​\t后来安装Npcap 1.60版本才成功，老版本下载地址：<a href=\"https://npcap.com/dist/\">Npcap release archive</a></p>\n</blockquote>\n<p>安装完毕，重启电脑后，任意打开一个终端，输入<code>WlanHelper --help</code>，应该有输出：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225257642.png\" alt=\"image-20221214225257642\"></p>\n<blockquote>\n<p>WlanHelper.exe的位置在<code>C:\\Windows\\System32\\Npcap</code></p>\n</blockquote>\n<h1 id=\"3-WlanHelper的使用\"><a href=\"#3-WlanHelper的使用\" class=\"headerlink\" title=\"3. WlanHelper的使用\"></a>3. WlanHelper的使用</h1><h2 id=\"3-1-查看无线网卡的名称\"><a href=\"#3-1-查看无线网卡的名称\" class=\"headerlink\" title=\"3.1. 查看无线网卡的名称\"></a>3.1. 查看无线网卡的名称</h2><p>查看自己电脑上无线网卡的名称：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ipconfig</span><br></pre></td></tr></table></figure>\n\n<p>如下图，名称是WLAN：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225720426.png\" alt=\"image-20221214225720426\"></p>\n<p>​\t也可以在新版Windows设置中查看：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225852951.png\" alt=\"image-20221214225852951\"></p>\n<p>​\t也可以在旧版Windows网络适配器中查看：</p>\n<img src=\"/jayant97.github.io/imgs/在Windows上使用Wireshark和Npcap进行WiFi嗅探.assets/image-20221214225813048.png\" alt=\"image-20221214225813048\" style=\"zoom:50%;\" />\n\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221214225931713.png\" alt=\"image-20221214225931713\"></p>\n<p>​\t 可以看到，我这张网卡的名称是WLAN，有的网卡名称可能叫Wi-Fi，这与电脑品牌有关。</p>\n<h2 id=\"3-2-把网卡切换为monitor模式\"><a href=\"#3-2-把网卡切换为monitor模式\" class=\"headerlink\" title=\"3.2. 把网卡切换为monitor模式\"></a>3.2. 把网卡切换为monitor模式</h2><p>​\t使用一个支持抓包的USB网卡，插到电脑上：</p>\n<img src=\"/jayant97.github.io/imgs/在Windows上使用Wireshark和Npcap进行WiFi嗅探.assets/image-20221215075234594.png\" alt=\"image-20221215075234594\" style=\"zoom:50%;\" />\n\n<p>​\t可以看到有两张无线网卡：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075413896.png\" alt=\"image-20221215075413896\"></p>\n<p>​\t查看网卡当前工作模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper <span class=\"string\">&quot;Wi-Fi 2&quot;</span> mode</span><br><span class=\"line\">managed</span><br></pre></td></tr></table></figure>\n\n<p>​\t查看网卡支持的所有模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper.exe <span class=\"string\">&quot;Wi-Fi 2&quot;</span> modes</span><br><span class=\"line\">master, managed, monitor</span><br></pre></td></tr></table></figure>\n\n<p>​\t修改网卡的模式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ WlanHelper.exe <span class=\"string\">&quot;Wi-Fi 2&quot;</span> mode monitor</span><br><span class=\"line\">Success</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>也可以直接<code>WlanHelper -i</code>，进入交互模式，然后根据其提示输入数字，来进行配置</p>\n</blockquote>\n<h1 id=\"4-使用Wireshark进行抓包\"><a href=\"#4-使用Wireshark进行抓包\" class=\"headerlink\" title=\"4. 使用Wireshark进行抓包\"></a>4. 使用Wireshark进行抓包</h1><p>​\t选择“捕获”——“选项”：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075810915.png\" alt=\"image-20221215075810915\"></p>\n<p>​\t发现监控模式已经可以打勾，可以进行抓包：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Wireshark%E5%92%8CNpcap%E8%BF%9B%E8%A1%8CWiFi%E5%97%85%E6%8E%A2.assets/image-20221215075830448.png\" alt=\"image-20221215075830448\"></p>\n","categories":["网络","WiFi"],"tags":["Wireshark","WiFi"]},{"title":"在nRF7002开发板上运行MQTT例程","url":"/jayant97.github.io/2023/08/045cdc9c9b10/","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>本文面向零基础读者，将一步一步介绍如何通过nRF7002DK开发板来运行MQTT例程，并分析此例程的框架、代码，以及用到的库。</p>\n<p>本文包含以下内容：</p>\n<ul>\n<li>MQTT协议简介</li>\n<li>手把手教你运行MQTT over WiFi例程</li>\n<li>MQTT例程解析<ul>\n<li>线程间通信框架：ZBus</li>\n<li>Zephyr状态机框架：SMF (State Machine Framework)</li>\n<li>NCS中的Wi-Fi连接方法</li>\n<li>NCS中的MQTT连接方法</li>\n<li>MQTT加密连接配置（TLS配置）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-1-nRF7002DK\"><a href=\"#1-1-nRF7002DK\" class=\"headerlink\" title=\"1.1. nRF7002DK\"></a>1.1. nRF7002DK</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/nRF7002-DK-1.0.0_perspective_prod_page.webp\" alt=\"nRF7002-DK-1.0.0_perspective\"></p>\n<p>nRF7002DK是Nordic的WiFi6开发板，上面有nRF7002和nRF5340两颗芯片。其中nRF7002是Wi-Fi6双频IC，nRF5340是双核蓝牙主控MCU，二者通过QSPI连接。此开发板提供了5GHz和2.4GHz双频WiFi和蓝牙共存的功能。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908164659947.png\" alt=\"image-20230908164659947\"></p>\n<p>此外如果你在今年的Nordic Tech Tour上获得了免费的Clever Connect Kit（CCK），也可以使用。它和7002DK的主要电路都相同（7002, 5340，Jlink和外挂Flash），只是缺少一些外围保护电路和IO口切换用的电子开关。你可以在<a href=\"https://devzone.nordicsemi.com/cfs-file/__key/communityserver-discussions-components-files/4/INTERNAL-CCK-Quick-Guide-v1.pdf\">这里</a>下载到它的说明文档。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115736114.png\" alt=\"image-20230823115736114\"></p>\n<h2 id=\"1-2-MQTT协议简介\"><a href=\"#1-2-MQTT协议简介\" class=\"headerlink\" title=\"1.2. MQTT协议简介\"></a>1.2. MQTT协议简介</h2><h3 id=\"什么是MQTT协议？\"><a href=\"#什么是MQTT协议？\" class=\"headerlink\" title=\"什么是MQTT协议？\"></a>什么是MQTT协议？</h3><p>MQTT是物联网领域常用的通讯协议，它轻量、高效，适合需要联网的嵌入式应用。要快速了解MQTT协议，可以从以下几个角度看。</p>\n<h3 id=\"设备之间如何建立连接？\"><a href=\"#设备之间如何建立连接？\" class=\"headerlink\" title=\"设备之间如何建立连接？\"></a>设备之间如何建立连接？</h3><p>许多设备通过TCP连接到一个服务器上，这个服务器是MQTT Broker，它代理了设备之间的通信。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115755610.png\" alt=\"image-20230823115755610\"></p>\n<p>这种方式优势很多。由于<strong>设备之间</strong>不需要建立<strong>直接</strong>连接，因此当一个设备要与另一个设备通信时，既不需要知道对方的地址，也不需要等待对方的唤醒，甚至不需要知道对方的存在。设备只需要把消息交给服务器，并且从服务器取回自己所需的数据即可，然后就能继续休眠。</p>\n<h3 id=\"MQTT消息如何传输？\"><a href=\"#MQTT消息如何传输？\" class=\"headerlink\" title=\"MQTT消息如何传输？\"></a>MQTT消息如何传输？</h3><p>消息被发布到主题上，然后就能被订阅此主题的设备接收到。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908165648117.png\" alt=\"image-20230908165648117\"></p>\n<p>MQTT是基于发布&#x2F;订阅模型的消息传输协议。任何一个设备都可以向某个主题（Topic）发布（Publish）消息，也可以订阅（Subscribe）某个主题从而接收消息。当某个客户端向一个主题发布数据时，所有订阅了这个主题的客户端都可以收到这个消息。</p>\n<blockquote>\n<p>消息：可以是任何数据。如json字符串或纯二进制数据；</p>\n<p>客户端：既可以是IoT设备，也可以是PC、手机或服务器；</p>\n<p>主题：一串符合格式要求的字符串。其格式不是本文的重点，此处不详细叙述。</p>\n</blockquote>\n<h3 id=\"MQTT协议安全吗？\"><a href=\"#MQTT协议安全吗？\" class=\"headerlink\" title=\"MQTT协议安全吗？\"></a>MQTT协议安全吗？</h3><p>从最简单的角度考虑，安全分为两个方面，一个是设备身份的认证，一个是传输本身的加密。</p>\n<p>每一个MQTT客户端都有一个Client ID，用于标识设备的身份。在一些仅供测试学习的MQTT broker上，只需要自己随便填写一个个Client ID就可以登录了。而商用的MQTT broker可能还需要密码、密钥、证书等凭据才可以允许设备登录。</p>\n<p>此外，MQTT是基于TCP&#x2F;IP的协议，这意味着MQTT也可以通过TLS加密通讯。在这种情况下：</p>\n<ul>\n<li>如果客户端需要验证服务端的身份，则客户端内需要安装CA证书，用于验证TLS握手时服务器出示的证书是否合法；</li>\n<li>如果服务端要验证客户端的身份，那么除了前面讲的通过<strong>密码</strong>进行登陆的方式外，还可以通过<strong>设备证书</strong>的方式进行验证。这种情况下，客户端需要持有<strong>设备证书</strong>（包含公钥）及其<strong>私钥</strong>。并且设备的证书和Client  ID要提前被注册到云端。</li>\n</ul>\n<h1 id=\"2-环境准备\"><a href=\"#2-环境准备\" class=\"headerlink\" title=\"2. 环境准备\"></a>2. 环境准备</h1><ol>\n<li>nRF7002DK或CCK</li>\n<li>一台安装了nRF Connect SDK v2.4.0的开发环境的PC (Windows&#x2F;Linux&#x2F;MacOS)</li>\n<li>PC上安装一个MQTT客户端，例如：<a href=\"https://mqttx.app/zh\">MQTTX</a></li>\n<li>联网的WiFi环境（目前仅支持PSK，也就是输入密码的类型；不支持企业级Wi-Fi）</li>\n</ol>\n<h1 id=\"3-运行例程\"><a href=\"#3-运行例程\" class=\"headerlink\" title=\"3. 运行例程\"></a>3. 运行例程</h1><h2 id=\"3-1-通过例程模板创建新工程\"><a href=\"#3-1-通过例程模板创建新工程\" class=\"headerlink\" title=\"3.1. 通过例程模板创建新工程\"></a>3.1. 通过例程模板创建新工程</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002150634368.png\" alt=\"image-20231002150634368\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002150727465.png\" alt=\"image-20231002150727465\"></p>\n<ol>\n<li>打开一个VS Code新窗口，进入nRF Connect插件界面，选择Create a new application，创建一个新工程</li>\n<li>选择copy a sample，复制一个例程</li>\n<li>在搜索框输入mqtt，选择<code>nrf/samples/net/mqtt</code></li>\n<li>输入工程存放的路径，回车</li>\n<li>输入新工程的名称，回车创建</li>\n</ol>\n<blockquote>\n<p>通过这种方式创建的新工程会自动创建单独的git仓库，方便我们后续追踪文件的变动。</p>\n</blockquote>\n<h2 id=\"3-2-修改工程配置文件\"><a href=\"#3-2-修改工程配置文件\" class=\"headerlink\" title=\"3.2. 修改工程配置文件\"></a>3.2. 修改工程配置文件</h2><p>在<code>boards/nrf7002dk_nrf5340_cpuapp.conf</code>中，添加WiFi SSID和密码的配置，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># WIFI SSID与密码</span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_SSID=<span class=\"string\">&quot;Nordicsh-5G&quot;</span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_PASSWORD=<span class=\"string\">&quot;xxxxxxxx&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加密方式，根据AP的情况四选一</span></span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_OPEN=y </span></span><br><span class=\"line\">CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_PSK=y</span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_PSK_SHA256=y</span></span><br><span class=\"line\"><span class=\"comment\">#CONFIG_WIFI_CREDENTIALS_STATIC_TYPE_SAE=y</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提示：</p>\n<ol>\n<li><p>本例程的<code>src/modules/network_wifi.c</code>中要求必须静态配置WiFi SSID和密码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">BUILD_ASSERT(IS_ENABLED(CONFIG_WIFI_CREDENTIALS_STATIC), <span class=\"string\">&quot;Static Wi-Fi config must be used&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因此，若不在编译前就设置好WiFi SSID与密码，则Assert无法通过。<br>不过在实际的产品开发中，肯定是希望在程序运行后再动态配置，具体方法请参考后续章节。</p>\n</li>\n<li><p>由于<code>mqtt</code>例程除了可以用7002wifi开发板运行外，也可用9160蜂窝网开发板运行，因此Wi-Fi的相关配置最好放在<code>boards</code>目录下与WiFi板子相关的配置文件中，而不是放在<code>prj.conf</code>这个通用的配置文件中。这是一种更合理的做法。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"3-3-创建编译目标\"><a href=\"#3-3-创建编译目标\" class=\"headerlink\" title=\"3.3. 创建编译目标\"></a>3.3. 创建编译目标</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115834345.png\" alt=\"image-20230823115834345\"></p>\n<ol>\n<li>选择nRF Connect 插件</li>\n<li>在mqtt工程下新建一个编译目标</li>\n<li>选择板子<code>nrf7002dk_nrf5340_cpuapp</code> （含义：7002DK开发板——5340MCU——应用核）</li>\n<li>追加的配置文件选择<code>overlay-tls-nrf7002.conf</code>。（也可以把这个追加配置文件的内容复制到prj.conf中）</li>\n<li>编译</li>\n</ol>\n<blockquote>\n<p>提示：</p>\n<ol>\n<li><p>通过按<code>CTRL + ` </code> 可以呼出命令行界面，查看编译进度</p>\n</li>\n<li><p>编译时，命令行中会显示运行的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/sh -c west build --build-dir /home/jayant/project/ncs-project/wifi/mqtt/build /home/jayant/project/ncs-project/wifi/mqtt --pristine --board nrf7002dk_nrf5340_cpuapp --no-sysbuild -- -DNCS_TOOLCHAIN_VERSION:STRING=<span class=\"string\">&quot;NONE&quot;</span> -DBOARD_ROOT:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt&quot;</span> -DCONF_FILE:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt/prj.conf;/home/jayant/project/ncs-project/wifi/mqtt/boards/nrf7002dk_nrf5340_cpuapp.conf&quot;</span> -DOVERLAY_CONFIG:STRING=<span class=\"string\">&quot;/home/jayant/project/ncs-project/wifi/mqtt/overlay-tls-nrf7002.conf&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过阅读这个命令携带的冗长的参数，我们可以知道，编译系统采用了以下三个配置文件：</p>\n<ul>\n<li><code>prj.conf</code></li>\n<li><code>boards/nrf7002dk_nrf5340_cpuapp.conf</code></li>\n<li><code>overlay-tls-nrf7002.conf</code></li>\n</ul>\n<p>第一个是zephyr系统默认的配置文件，第二个是系统根据所选的板子自动选择的配置文件，第三个是我们创建编译目标时手动选择的附加的配置文件。三者的内容最终是合并在一起，然后才采用的。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"3-4-程序下载与运行\"><a href=\"#3-4-程序下载与运行\" class=\"headerlink\" title=\"3.4. 程序下载与运行\"></a>3.4. 程序下载与运行</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115845564.png\" alt=\"image-20230823115845564\"></p>\n<ol>\n<li>连接好开发板，确认VS Code中可以识别到已连接的Jlink</li>\n<li>点击“Flash”按钮，下载编译好的程序（如果是点击图中红色框内按钮，则是擦除并下载）</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823121558235.png\" alt=\"image-20230823121558235\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824102839317.png\" alt=\"image-20230824102839317\"></p>\n<ol start=\"3\">\n<li>打开编号较大的串口（这是应用核的串口，另一个串口是5340网络核的默认串口），并点击开发板上的reset 按钮让程序重新运行<br><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823122202243.png\" alt=\"image-20230823122202243\"></li>\n<li>等待一段时间，就能看到板子已经依次成功连上WiFi、互联网、MQTT broker、并订阅了topic。由于我们之前设置编译目标时选择了TLS的overlay配置文件，所以可以看到这里连接的是MQTTS默认的8883端口，并且启用了TLS协议。<br><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824103416044.png\" alt=\"image-20230824103416044\"></li>\n</ol>\n<h2 id=\"3-5-MQTT通信测试\"><a href=\"#3-5-MQTT通信测试\" class=\"headerlink\" title=\"3.5. MQTT通信测试\"></a>3.5. MQTT通信测试</h2><p>例程默认连接的是<code>test.mosquitto.org</code>这个免费的公共MQTT broker，它仅供测试使用。</p>\n<p>我们在PC上使用一个MQTT客户端，也连上这个broker，与板子进行通讯测试。这里以MQTTX为例：</p>\n<h3 id=\"连接到MQTT-broker\"><a href=\"#连接到MQTT-broker\" class=\"headerlink\" title=\"连接到MQTT broker\"></a>连接到MQTT broker</h3><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824104643996.png\" alt=\"image-20230824104643996\"></p>\n<p>首先打开MQTTX，在连接的右侧点击“+”，选择新建连接。在右侧填入基本信息：</p>\n<ul>\n<li>名称：此链接在客户端软件里显示的名称，与MQTT协议本身无关；</li>\n<li>Client ID：此客户端在MQTT broker上被识别的身份。由于这是个免费公共broker，因此可以随意填写，不要填写容易与其他人重复的ID即可；</li>\n<li>服务器地址：协议选择MQTT，地址填写<code>test.mosquitto.org</code>。</li>\n<li>SSL&#x2F;TLS：无需启用。此Broker既支持TLS连接也支持非加密连接。虽然开发板是通过TLS方式连接的，但PC客户端即使通过不同方式连接，最终只要连接到同一个broker上，也是可以通讯的。</li>\n</ul>\n<p>其余参数保持默认即可，然后点击右上角的“连接”。</p>\n<h3 id=\"订阅主题并接收数据\"><a href=\"#订阅主题并接收数据\" class=\"headerlink\" title=\"订阅主题并接收数据\"></a>订阅主题并接收数据</h3><p>通过串口日志我们可以看出:</p>\n<ul>\n<li>开发板订阅的topic为：<code>F4CE36000384/my/subscribe/topic</code></li>\n<li>开发板发布数据的topic为：<code>F4CE36000384/my/publish/topic</code></li>\n</ul>\n<blockquote>\n<p>这里的Client ID是硬件ID生成的，你需要查看你的板子的ID是多少。</p>\n</blockquote>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105539237.png\" alt=\"image-20230824105539237\"></p>\n<p>因此在MQTTX中，我们要订阅<code>F4CE36000384/my/publish/topic</code>，从而接收开发板上发送的数据：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105703966.png\" alt=\"image-20230824105703966\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824105745173.png\" alt=\"image-20230824105745173\"></p>\n<ul>\n<li>点击“添加订阅”</li>\n<li>填写Topic，并将服务质量（QoS）设置为1（确保对方收到至少一次，也就是有重传确认机制）。</li>\n</ul>\n<p>此例程是定时发送数据的，但也可以通过按下开发板上的Button1或Button2来立即发送数据。</p>\n<h3 id=\"发送数据到开发板\"><a href=\"#发送数据到开发板\" class=\"headerlink\" title=\"发送数据到开发板\"></a>发送数据到开发板</h3><p>同理，我们可以发送数据到<code>F4CE36000384/my/subscribe/topic</code>，从而让开发板可以接收到：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824110521147.png\" alt=\"image-20230824110521147\"></p>\n<ul>\n<li>Paylod：选择字符串（Plaintext）。由于MQTT传输的底层就是二进制传输。因此，我们在Playload选项中，选择的其实是客户端如何编码，如何进行格式检查。MQTT协议本身并不会有什么字段来描述自己携带的数据类型。</li>\n<li>QoS：选择1，确保Broker会收到至少一次。</li>\n<li>Topic：填入开发板订阅的Topic，这里是<code>F4CE36000384/my/subscribe/topic</code></li>\n<li>下方填入要发送的内容，并发送数据</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824111005271.png\" alt=\"image-20230824111005271\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824111020710-1692846622507-1.png\" alt=\"image-20230824111020710\"></p>\n<p>可以看到开发板成功收到数据。</p>\n<h1 id=\"4-代码解析\"><a href=\"#4-代码解析\" class=\"headerlink\" title=\"4. 代码解析\"></a>4. 代码解析</h1><h2 id=\"4-1-编译与配置系统\"><a href=\"#4-1-编译与配置系统\" class=\"headerlink\" title=\"4.1. 编译与配置系统\"></a>4.1. 编译与配置系统</h2><h3 id=\"源码的组织\"><a href=\"#源码的组织\" class=\"headerlink\" title=\"源码的组织\"></a>源码的组织</h3><p>源码都位于<code>src</code>目录下，分成了<code>common</code>和几个模块：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824113012286.png\" alt=\"image-20230824113012286\"></p>\n<p>我们可以注意到，代码是没有<code>main()</code>函数的。因为Zephyr支持静态定义线程，系统上电reset后，各个模块的线程就直接运行起来了，无需<code>main()</code>函数。</p>\n<p>源码使用CMake进行管理，我们可以看到项目顶层<code>CMakeLists.txt</code>使用<code>add_subdirectory()</code>引用了各个模块的<code>CMakeLists.txt</code>，从而把所有源码组织在一起。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824114611064.png\" alt=\"image-20230824114611064\"></p>\n<h3 id=\"Kconfig配置系统\"><a href=\"#Kconfig配置系统\" class=\"headerlink\" title=\"Kconfig配置系统\"></a>Kconfig配置系统</h3><p>各个模块以及Zephyr系统有大量的配置项可以修改，这些配置项是以预编译宏的形式存在的。由于配置项很多，Zephyr采用了Kconfig进行配置项的管理。</p>\n<p>例程目录下的顶层Kconfig文件定义了本工程的一个配置项菜单，它包含本工程所需的全部配置：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230823115854511.png\" alt=\"image-20230823115854511\"></p>\n<p>和CMake的逻辑类似。顶层Kconfig也是可以通过引用各个模块的菜单，从而形成一个整个项目的大型菜单。菜单的前一部分是引用了<code>src/modules/</code>目录下各个子模块的Kconfig菜单，后一部分是引用了Zephyr的Kconfig菜单。我们可以通过点击Kconfig按钮来查看这个完整的菜单：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824115336388.png\" alt=\"image-20230824115336388\"></p>\n<p>在完整的菜单中，我们可以看到，顶层的两级目录就分别是例程本身的各个模块的菜单，以及Zephyr系统的配置菜单。</p>\n<h3 id=\"设置配置项的值\"><a href=\"#设置配置项的值\" class=\"headerlink\" title=\"设置配置项的值\"></a>设置配置项的值</h3><p>Kconfig是一个<strong>菜单</strong>，真正发挥作用的是菜单中各个<strong>配置项的值</strong>。其中的配置项的值会有很多个来源：</p>\n<ul>\n<li>在Kconfig文件定义菜单时，某些配置项会有默认值</li>\n<li>在创建编译目标，选择板子时，这个板子自带的一些配置项。见<code>$&#123;NCS&#125;/nrf/boards/arm/</code>或<code>$&#123;NCS&#125;/zephyr/boards/arm/</code>下各个板子的目录中的<code>.conf</code>文件</li>\n<li>工程目录下，<code>boards/</code>目录下与板子对应的<code>.conf</code>配置文件</li>\n<li>工程目录下默认的<code>prj.conf</code>配置文件，这也是最常用的</li>\n<li>创建编译目标时，选择附加的Kconfig片段，例如<code>overlay-tls-7002.conf</code></li>\n</ul>\n<blockquote>\n<p>配置项的来源还有很多，例如使用CMake编译时指定<code>CONFIG_</code>开头的变量，还有一些隐含的配置项，无法直接修改，只会被其他配置项联动修改等等。要了解更多关于配置项的问题，可参考：<a href=\"https://docs.zephyrproject.org/latest/build/kconfig/setting.html#the-initial-configuration\">https://docs.zephyrproject.org/latest/build/kconfig/setting.html#the-initial-configuration</a></p>\n</blockquote>\n<p>所有的配置项最终在编译时都会合并到<code>build/zephyr/.config</code>临时文件中，要想知道自己的配置有没有成功适用，查看这个文件即可。</p>\n<p>在Kconfig菜单界面修改后，如果只点击”Apply”，那么此修改只会保存到<code>.config</code>临时文件中。下次Build时可以生效。但是如果修改了其他config文件、CMake文件，或者执行了重新编译的情况下，这些修改就会随着<code>.config</code>文件一起消失。如果想让自己的修改永久保存，需要点击Save to file，然后选择一个合适的文件保存。通常，与特定板子有关的，可以保存到<code>boards</code>目录下的配置文件中；如果是这个项目通用的配置，可以保存到<code>prj.conf</code>中。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824122017814.png\" alt=\"image-20230824122017814\"></p>\n<p>举例来说：</p>\n<ol>\n<li>MQTT服务器地址是在哪里配置的？<br>在<code>src/modules/transport/Kconfig.transport</code>中，定义菜单时，<code>MQTT_SAMPLE_TRANSPORT_BROKER_HOSTNAME</code>的默认值是<code>test.mosquitto.org</code></li>\n<li>Wi-Fi密码在哪里配置的？<br>可以像第3节中一样，在板子的<code>conf</code>文件中配置，也可以直接写在项目的<code>prj.conf</code>中。</li>\n</ol>\n<h2 id=\"4-2-代码框架\"><a href=\"#4-2-代码框架\" class=\"headerlink\" title=\"4.2. 代码框架\"></a>4.2. 代码框架</h2><p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824141934689.png\" alt=\"image-20230824141934689\"></p>\n<p>此例程有6个模块，分别是：</p>\n<ul>\n<li>Trigger：定时触发，让其他模块向MQTT broker发布消息，同时在检测到按钮按下时也触发；</li>\n<li>Sampler：当其他模块发出请求时，采样数据，并发送给其他模块。此例程中，采样的数据用一串字符串代替；</li>\n<li>Transport：负责处理MQTT连接；</li>\n<li>Network：负责网络连接；</li>\n<li>LED：负责根据其他模块发出的消息，控制不同的LED状态；</li>\n<li>Error：监控其他模块发出的报错信息，若出现报错，则执行重启。</li>\n</ul>\n<h3 id=\"Zbus与模块化编程\"><a href=\"#Zbus与模块化编程\" class=\"headerlink\" title=\"Zbus与模块化编程\"></a>Zbus与模块化编程</h3><p>在模块化的编程中，除了模块本身的实现以外，模块间的通信也是非常重要的一环，往往牵扯到大量的队列、信号量和锁的交互。</p>\n<p>为了减轻这部分的工作量，Zephyr提供了Zbus通信框架，相当于对上述操作进行了一个封装。Zbus有点像“本地的MQTT”，每个模块可以在不同的通道（Channel）上发布&#x2F;订阅消息。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230824143949656.png\" alt=\"image-20230824143949656\"></p>\n<p>Zbus可以使模块间实现解耦，因为每个模块实际上只和Zbus交互，并不知道其他模块的存在。</p>\n<p>我们在<code>src/common/message_channel.h</code>中可以看到总共<strong>声明</strong>了4个Zbus通道：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZBUS_CHAN_DECLARE(TRIGGER_CHAN, PAYLOAD_CHAN, NETWORK_CHAN, FATAL_ERROR_CHAN);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>src/common/message_channel.c</code>中可以看到每个通道的<strong>定义</strong>，这里以<code>NETWORK_CHAN</code>通道为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZBUS_CHAN_DEFINE(NETWORK_CHAN,</span><br><span class=\"line\">         <span class=\"keyword\">enum</span> network_status,</span><br><span class=\"line\">         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">         <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">         ZBUS_OBSERVERS(transport IF_ENABLED(CONFIG_MQTT_SAMPLE_LED, (, led)), sampler),</span><br><span class=\"line\">         ZBUS_MSG_INIT(<span class=\"number\">0</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到定义了通道的名称，payload的数据类型以及通道数据的接收者（Observers）。这里的Observers就是能从这个Channel接收消息的模块，可以填写多个。这里可以看到一个条件预编译：如果定义了<code>CONFIG_MQTT_SAMPLE_LED=y</code>，则此处就会插入一个“<code>, led</code>”字符串。</p>\n<p>Zbus支持多对多通信，支持同步、异步通信。</p>\n<h3 id=\"Zbus同步接收\"><a href=\"#Zbus同步接收\" class=\"headerlink\" title=\"Zbus同步接收\"></a>Zbus同步接收</h3><p>同步通信的例子是<code>led</code>模块，我们可以看到<code>src/modules/led/led.c</code>中并没有定义线程，而是只定义了一个Zbus Listener和LED的回调函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处仅定义了listener，没有定义其要监听哪个channel，因为在前面Zbus定义channel时就已经确定好observer的名称了</span></span><br><span class=\"line\">ZBUS_LISTENER_DEFINE(led, led_callback);</span><br></pre></td></tr></table></figure>\n\n<p>这就是同步通信的例子，每当Channel上有消息产生时，这个回调函数都会<strong>在发送端的发送函数内被执行一次</strong>。所以，同步接收的回调函数应该尽量快速执行，以免阻塞发送端的线程。</p>\n<h3 id=\"Zbus异步接收\"><a href=\"#Zbus异步接收\" class=\"headerlink\" title=\"Zbus异步接收\"></a>Zbus异步接收</h3><p>异步通信的例子是<code>sampler</code>模块，我们可以看到<code>src/modules/sample/sampler.c</code>中分别定义了Zbus Subscriber和一个线程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于在src/common/message_channel.c中，定义Zbus channel时就已经确定好observer的名称了</span></span><br><span class=\"line\"><span class=\"comment\">// 因此此处只需定义自身的observer的名称即可</span></span><br><span class=\"line\">ZBUS_SUBSCRIBER_DEFINE(sampler, CONFIG_MQTT_SAMPLE_SAMPLER_MESSAGE_QUEUE_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">sampler_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zbus_channel</span> *<span class=\"title\">chan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!zbus_sub_wait(&amp;sampler, &amp;chan, K_FOREVER)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (&amp;TRIGGER_CHAN == chan) &#123;</span><br><span class=\"line\">            sample();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">K_THREAD_DEFINE(sampler_task_id,</span><br><span class=\"line\">        CONFIG_MQTT_SAMPLE_SAMPLER_THREAD_STACK_SIZE,</span><br><span class=\"line\">        sampler_task, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在线程中，通过<code>zbus_sub_wait()</code>函数来监听通道上是否有消息。由于此消息只是用来触发采样的，消息内的payload并无任何作用，因此此处没有使用<code>zbus_chan_read()</code>函数。</p>\n<blockquote>\n<p>Zbus接收的本质：</p>\n<ol>\n<li>每定义一个subscriber，就会同时为它定义一个<code>k_msgq</code>队列；</li>\n<li>每次数据发送到某个channel时，实际上是给这个channel下的每个obsever的队列都填充了相同的消息；</li>\n<li><code>zbus_sub_wait()</code>的作用是阻塞等待，并从队列中取出消息；</li>\n<li><code>zbus_chane_read()</code>的作用是从已经出队的消息中提取真正的数据；</li>\n</ol>\n</blockquote>\n<h3 id=\"Zbus数据发送\"><a href=\"#Zbus数据发送\" class=\"headerlink\" title=\"Zbus数据发送\"></a>Zbus数据发送</h3><p>在<code>src/modules/trigger/trigger.c</code>中可以看到，发送的行为不需要定义类似publisher的东西。直接向channel发布数据即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">err = zbus_chan_pub(&amp;TRIGGER_CHAN, &amp;not_used, K_SECONDS(<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于Zbus的总结：</p>\n<ul>\n<li>每次数据发送到某个channel时，实际上是给这个channel下的每个observer的消息队列都push了相同的消息；并且如果有注册的同步接收的回调函数的话，还要执行这个回调函数</li>\n<li>由于发布、接收都是对锁操作的封装，因此它们都不能在中断服务函数中使用；并且都可以设置超时时间以避免一直阻塞</li>\n<li>不必担心线程阻塞造成功耗问题，因为在Zephyr中，进入IDLE线程时会自动进入低功耗模式</li>\n<li>发送数据是拷贝的，因此，消息数据用局部变量即可。此外，有多少个observer就会把数据拷贝多少份，如果需要做大量数据的传输，注意CPU的开销。</li>\n<li>ZBUS其实并没有真正把消息存入k_msgq队列，真正存储消息的位置只有Channel结构体的一个成员，长度为1个payload。每次新消息发布到channel上时，这个用于存储消息的位置就会被立即覆盖。消息队列中存储的是一个指向该位置的指针。因此，当发送速度太快，接收端来不及消费时，会出现前面的数据被后面的数据覆盖掉的情况。但是消息的总个数还是不会变的。因此，ZBUS只适合用来传输一些“状态值”。如果真要传输大量数据，推荐用k_msgq。</li>\n<li>更多资料，参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/zbus/index.html#zbus\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/zbus/index.html#zbus</a></li>\n</ul>\n</blockquote>\n<h2 id=\"4-3-Wi-Fi连接过程\"><a href=\"#4-3-Wi-Fi连接过程\" class=\"headerlink\" title=\"4.3. Wi-Fi连接过程\"></a>4.3. Wi-Fi连接过程</h2><p>网络连接由network模块控制，在<code>src/modules/network/CMLakeists.txt</code>中，我们可以看到，根据不同的板子选择，实际参与编译的是不同的源代码。由于我们选择的是7002开发板，因此这里只会编译<code>network_wifi.c</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">connect</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_if</span> *<span class=\"title\">iface</span> =</span> net_if_get_default();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iface == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Returned network interface is NULL&quot;</span>);</span><br><span class=\"line\">        SEND_FATAL_ERROR();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> err = net_mgmt(NET_REQUEST_WIFI_CONNECT_STORED, iface, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Connecting to Wi-Fi failed. error: %d&quot;</span>, err);</span><br><span class=\"line\">        SEND_FATAL_ERROR();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">network_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    net_mgmt_init_event_callback(&amp;net_mgmt_callback, wifi_mgmt_event_handler, MGMT_EVENTS);</span><br><span class=\"line\">    net_mgmt_add_event_callback(&amp;net_mgmt_callback);</span><br><span class=\"line\">    net_mgmt_init_event_callback(&amp;net_mgmt_ipv4_callback, ipv4_mgmt_event_handler,</span><br><span class=\"line\">                     NET_EVENT_IPV4_ADDR_ADD | NET_EVENT_IPV4_ADDR_DEL);</span><br><span class=\"line\">    net_mgmt_add_event_callback(&amp;net_mgmt_ipv4_callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Add temporary fix to prevent using Wi-Fi before WPA supplicant is ready. */</span></span><br><span class=\"line\">    k_sleep(K_SECONDS(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    connect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码非常直观，先是分别给WiFi和IPv4注册了不同的回调函数，然后再执行连接。这里的网络回调函数和连接分别用到了两个模块，<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/net_if.html#net-if-interface\">Network Interface</a>和<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/net_mgmt.html#net-mgmt-interface\">Network Management</a>。</p>\n<h3 id=\"Network-Interface\"><a href=\"#Network-Interface\" class=\"headerlink\" title=\"Network Interface\"></a>Network Interface</h3><p>所有与网络相关的处理都与网络接口有关。网络接口是在编译时就确定的。我们可以看到<code>connect()</code>函数中获得了默认的网络接口：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_if</span> *<span class=\"title\">iface</span> =</span> net_if_get_default();</span><br></pre></td></tr></table></figure>\n\n<p>由于Zephyr将nRF7002抽象成了网卡，并且在NCS中已经有了7002的驱动代码，所以我们不必太关心底层细节，就能实现网络通信。</p>\n<p>有关7002驱动的架构，可以查看：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/wifi/nrf700x/nrf700x.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/wifi/nrf700x/nrf700x.html</a></p>\n<h3 id=\"Network-Management库\"><a href=\"#Network-Management库\" class=\"headerlink\" title=\"Network Management库\"></a>Network Management库</h3><p>Network Management可以让应用层与网络层之间、或者网络层的内部进行方便的函数调用。我们通过查看<code>net_mgmt</code>的定义可以知道，实际上<code>net_mgmt()</code>并不是一个单独的函数，而是把第一个参数放入函数名的多个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> net_mgmt(_mgmt_request, _iface, _data, _len)            \\</span></span><br><span class=\"line\"><span class=\"meta\">    net_mgmt_##_mgmt_request(_mgmt_request, _iface, _data, _len)</span></span><br></pre></td></tr></table></figure>\n\n<p>这也意味着每个调用<code>net_mgmt(ABC)</code>的地方，都会在SDK的某个地方对应一个函数的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NET_MGMT_DEFINE_REQUEST_HANDLER(_mgmt_request)            \\</span></span><br><span class=\"line\"><span class=\"meta\">    extern int net_mgmt_##_mgmt_request(uint32_t mgmt_request,\t\\</span></span><br><span class=\"line\"><span class=\"meta\">                        struct net_if *iface,\t\\</span></span><br><span class=\"line\"><span class=\"meta\">                        void *data, size_t len)</span></span><br></pre></td></tr></table></figure>\n\n<p>这种实现方式可以让整个网络API有更强的扩展性，同时，让用不到的函数在编译时就被消除，从而减少代码的大小。</p>\n<p>因此，当我们想查看某个<code>net_mgmt(request,...)</code>函数做了什么的时候，可以去整个SDK中搜索这个函数的参数，从而找到这个函数注册的地方，从而查看它的具体的实现。</p>\n<blockquote>\n<p>此Network Management的实现方式是实验性的，今后可能会更新。</p>\n</blockquote>\n<h3 id=\"Wi-Fi的自动连接\"><a href=\"#Wi-Fi的自动连接\" class=\"headerlink\" title=\"Wi-Fi的自动连接\"></a>Wi-Fi的自动连接</h3><p>我们在整个SDK中全局搜索<code>NET_REQUEST_WIFI_CONNECT_STORED</code>就可以查到前述网络API被注册的地方，其实际的代码位于<code>$&#123;NCS&#125;/nrf/subsys/net/lib/wifi_mgmt_ext/wifi_mgmt_ext.c</code>。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20230908172441366.png\" alt=\"image-20230908172441366\"></p>\n<p>由此我们可以看出Network Management API的扩展性很强。Nordic直接在Zephyr的Network Management API里，注册了一个新的API，扩展出了通过config文件配置Wi-Fi凭据的功能，方便了例程的配置。这就是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_mgmt_ext.html\">Wi-Fi management extension</a>库，它能让例程上电自动连接预设Wi-Fi。</p>\n<p>从代码中可以看出，它的具体步骤是：先把config中静态配置的Wi-Fi凭据保存到Flash中，然后自动执行Wi-Fi连接。大家可以打开这个代码文件，去查看具体的代码。</p>\n<h3 id=\"Wi-Fi凭据的管理\"><a href=\"#Wi-Fi凭据的管理\" class=\"headerlink\" title=\"Wi-Fi凭据的管理\"></a>Wi-Fi凭据的管理</h3><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#wi-fi-credentials\">Wi-Fi credentials</a>这个库用于管理Wi-Fi凭据。它可以让Wi-Fi凭据存储在MCU内部。</p>\n<p>Wi-Fi凭据，对于Personal模式（PSK, Pre-Shared Key）来说，就是密码。对于Enterprise模式来说，就是各类证书和密钥。我们可以从<code>$&#123;NCS&#125;/nrf/include/net/wifi_credentials.h</code>中看出，这两种凭据是通过不同的两种结构体来存储的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">wifi_security_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ssid[WIFI_SSID_MAX_LEN];</span><br><span class=\"line\">    <span class=\"type\">size_t</span> ssid_len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> bssid[WIFI_MAC_ADDR_LEN];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> flags;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Personal凭据只存储header和密码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_personal</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> password[WIFI_CREDENTIALS_MAX_PASSWORD_LEN];</span><br><span class=\"line\">    <span class=\"type\">size_t</span> password_len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Enterprise凭据会存储Header和各类身份信息，可能包含密码、密钥、证书等</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：Enterprise凭据目前只有定义，其功能并未实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_enterprise</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wifi_credentials_header</span> <span class=\"title\">header</span>;</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> identity_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> anonymous_identity_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> password_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> ca_cert_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> client_cert_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> private_key_len;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> private_key_pw_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Wi-Fi凭据的写和读都很简单，分别提供了两种API。一种是直接传递参数，另一种是通过结构体来传递参数。由于篇幅原因，这里只列出较短的，也就是通过结构体传参数的形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_get_by_ssid_personal_struct</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"keyword\">struct</span> wifi_credentials_personal *buf)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_get_by_ssid_personal_struct</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"keyword\">struct</span> wifi_credentials_personal *buf)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wifi_credentials_delete_by_ssid</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *ssid, <span class=\"type\">size_t</span> ssid_len)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">wifi_credentials_for_each_ssid</span><span class=\"params\">(wifi_credentials_ssid_cb cb, <span class=\"type\">void</span> *cb_arg)</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：</p>\n<ul>\n<li>Enterprise模式的相关API目前并未实现，因此无法连接。</li>\n<li>用于凭据永久存储的后端（Backend）有两种。一种是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/services/settings/index.html\">Zephyr Settings存储服务</a>，另一种是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/samples/tfm_integration/psa_protected_storage/README.html\">PSA安全存储</a>。前者只是对Flash读写进行封装的库，使得整个Zephyr系统中的各个模组都可以方便地存储自己的非易失数据；而后者是ARM PSA (Platform Security Archtecture)中提出的一种安全存储服务，这种方式可以让自己的应用程序运行在“非安全（Non-Secure）”空间的同时，把凭据存储在“安全（Secure）空间”中，它需要TF-M才能工作。具体内容不在本文中阐述。修改后端的配置可以参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#configuration\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/wifi_credentials.html#configuration</a></li>\n</ul>\n</blockquote>\n<h3 id=\"Wi-Fi连接的管理\"><a href=\"#Wi-Fi连接的管理\" class=\"headerlink\" title=\"Wi-Fi连接的管理\"></a>Wi-Fi连接的管理</h3><p>前面提到，在<code>$&#123;NCS&#125;/nrf/subsys/net/lib/wifi_mgmt_ext/wifi_mgmt_ext.c</code>中，对存储中的每一个SSID遍历执行了<code>add_stored_network</code>函数。如果我们追踪下去，就会发现最终执行的连接函数，内部都是<code>wpa_cli</code>的命令，也就是我们在Linux上常见的一个Wi-Fi管理工具。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231002155758866.png\" alt=\"image-20231002155758866\"></p>\n<p>不过，当我们开发实际的产品时，肯定还是要通过蓝牙、USB、串口等其他方式把Wi-Fi凭据传入的。而且，实际上非专业的客户也不可能真的去写这些<code>wpa_cli</code>命令。</p>\n<p>Nordic当然也提供了通过BLE配置Wi-Fi凭据的方案，例程是<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples/wifi/provisioning/README.html#wi-fi-provisioning-service\">Wi-Fi: Provisioning Service</a>，位于<code>$&#123;NCS&#125;/nrf/samples/wifi/provisioning</code>。这是一个完整的BLE服务，可以通过手机APP（<a href=\"https://play.google.com/store/apps/details?id=no.nordicsemi.android.wifi.provisioning\">安卓版本</a>和<a href=\"https://apps.apple.com/cn/app/nrf-wi-fi-provisioner/id1638948698\">iOS版本</a>都有）对nRF7002DK进行配网。手机App和BLE Service之间数据的格式使用<a href=\"https://protobuf.dev/\">Protocol Buffers</a>来管理。当然手机App的源码也是开放的，客户可以把它们集成到自己的手机App中：</p>\n<ul>\n<li><a href=\"https://github.com/NordicSemiconductor/Android-nRF-Wi-Fi-Provisioner\">https://github.com/NordicSemiconductor/Android-nRF-Wi-Fi-Provisioner</a></li>\n<li><a href=\"https://github.com/NordicSemiconductor/IOS-nRF-Wi-Fi-Provisioner\">https://github.com/NordicSemiconductor/IOS-nRF-Wi-Fi-Provisioner</a></li>\n</ul>\n<p>如果你愿意阅读这个BLE Service的源码，会发现这个Service中，它通过BLE获得Wi-Fi密码后，也是用前面说的 Wi-Fi credentials 库对凭据进行存储。此外，它连接Wi-Fi所使用的方法是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">rc = net_mgmt(NET_REQUEST_WIFI_CONNECT, iface,</span><br><span class=\"line\">             &amp;cnx_params, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> wifi_connect_req_params));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这段代码位于<code>$&#123;NCS&#125;/nrf/subsys/bluetooth/services/wifi_prov/wifi_prov_handler.c</code></p>\n</blockquote>\n<p>这又是一个Network Management API。其注册的位置在<code>$&#123;NCS&#125;/zephyr/subsys/net/l2/wifi/wifi_mgmt.c</code>。它需要的参数除了基本的wifi连接所需的信息以外，还需要的就是一个Interface。而这个Interface已经由nRF7002的驱动提供好了，就像前文所述，直接用<code>net_if_get_default()</code>就能获得这个Interface。</p>\n<p>如果你想用其他方式配置Wi-Fi凭据，也推荐参考这个BLE Service中连接Wi-Fi的方式。</p>\n<h2 id=\"4-4-MQTT连接过程\"><a href=\"#4-4-MQTT连接过程\" class=\"headerlink\" title=\"4.4. MQTT连接过程\"></a>4.4. MQTT连接过程</h2><h3 id=\"MQTT-Helper-库\"><a href=\"#MQTT-Helper-库\" class=\"headerlink\" title=\"MQTT Helper 库\"></a>MQTT Helper 库</h3><p>Zephyr有一个很基础的<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/mqtt.html#mqtt\">MQTT库</a>，支持MQTT 3.1.0和3.1.1。它是基于Socket编写的，简单直接，但是不太好用。由于它只提供API，也就是连接、发布、订阅这些，还要开发者自己处理一些文件描述符（fd）。在之前版本的NCS中有个例程叫<code>mqtt_simple</code>，MQTT的心跳包甚至要在main.c里单独用一个定时任务来发送，目前这个例程已经被删除了。</p>\n<p>Nordic提供了<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/libraries/networking/mqtt_helper.html#api-documentation\">MQTT Helper库</a>，对Zephyr的MQTT接口进行了封装，使其更加易用。一方面，它单独建立了一个线程，用来发送MQTT心跳包；另一方面，它把大部分重要的MQTT参数都变成了Kconfig菜单中的参数，便于你做配置。</p>\n<p>通过阅读例程<code>src/modules/transport/transport.c</code>，可知MQTT Helper的用法：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231005225532340.png\" alt=\"image-20231005225532340\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231005230011226.png\" alt=\"image-20231005230011226\"></p>\n<p>基本上，就是配好回调函数和各种参数，初始化一下再连接服务器即可。当然，实际的例程代码写的不是这么直接。</p>\n<h3 id=\"Zephyr状态机框架-SMF-State-Machine-Framework\"><a href=\"#Zephyr状态机框架-SMF-State-Machine-Framework\" class=\"headerlink\" title=\"Zephyr状态机框架 (SMF, State Machine Framework)\"></a>Zephyr状态机框架 (SMF, State Machine Framework)</h3><p>由于<code>transport.c</code>代码中的MQTT连接并不是像前文说的直来直去进行的，而是分散在各处。因此，在继续分析MQTT代码之前，有必要先分析一下SMF的代码，以方便不熟悉的读者。</p>\n<p>我们知道状态机是开发中常用的一种框架，只要<strong>明确</strong>规定好一个模块被允许存在的所有状态、规定好每个状态下被允许的行为，以及各个状态之间切换的条件，就能写出较为完善、逻辑清晰、健壮性强、易于调试的代码。</p>\n<p>最常见的状态机代码是用<code>switch...case</code>语句编写的，通过一个<code>state</code>变量来判断当前处于哪个<code>case</code>，执行完不同的处理代码后，根据其他变量、事件等等不同的因素，来决定是否要切换到其他<code>state</code>值。常见的例子是写一个自定义二进制协议的解包代码，“状态”就是当前正在处理的是包头、数据、包尾还是转义字符，而“切换条件”就是输入的二进制流。</p>\n<p>Zephyr SMF和<code>switch...case</code>也没什么区别，只不过它把各个步骤进行了拆分，让你把“状态机的结构”和“各个状态的处理代码”分开，然后通过回调函数注册。比如，它把每个状态内的处理函数分为了<code>entry</code>、<code>run</code>、<code>exit</code>三部分，分别对应“进入此状态时要执行的一次性代码”、“在此状态循环处理时运行的代码”、“退出此状态时要执行的一次性代码”，让你不用写一堆标志位来判断状态的切换、也不用在<code>switch...case</code>语句中嵌套一堆<code>if...else</code>语句。另一方面，SMF也做好了状态机的嵌套处理，每个状态的内部还可以有一堆子状态，每个子状态也可以有<code>entry</code>、<code>run</code>、<code>exit</code>三个处理函数。通过把这些内容拆开，让我们可以先定义好一个状态机的结构，再给每个状态和子状态注册回调函数，从而使得代码更加清晰。</p>\n<p>要使用SMF，首先需要定义上下文(context)结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">s_object</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* This must be first */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">smf_ctx</span> <span class=\"title\">ctx</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Last channel type that a message was received on */</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zbus_channel</span> *<span class=\"title\">chan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Network status */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">network_status</span> <span class=\"title\">status</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Payload */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">payload</span> <span class=\"title\">payload</span>;</span></span><br><span class=\"line\">&#125; s_obj;</span><br></pre></td></tr></table></figure>\n\n<p>所谓的上下文，就是你在处理这个状态机时所需要的全部信息，例如标志位等，把他们全填入这个自定义结构体。</p>\n<p>然后，定义好所有的状态枚举，注册好每个状态的<code>entry</code>、<code>run</code>和<code>exit</code>函数即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Internal states */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">module_state</span> &#123;</span> MQTT_CONNECTED, MQTT_DISCONNECTED &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Construct state table */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">smf_state</span> <span class=\"title\">state</span>[] =</span> &#123;</span><br><span class=\"line\">    [MQTT_DISCONNECTED] = SMF_CREATE_STATE(disconnected_entry, disconnected_run, <span class=\"literal\">NULL</span>),</span><br><span class=\"line\">    [MQTT_CONNECTED] = SMF_CREATE_STATE(connected_entry, connected_run, connected_exit),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>关于状态切换，可以用<code>smf_set_state</code>函数，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">smf_set_state(SMF_CTX(&amp;s_obj), &amp;state[MQTT_CONNECTED]);</span><br></pre></td></tr></table></figure>\n\n<p>状态切换时，就会执行前一个状态的<code>exit</code>函数，以及后一个状态的<code>entry</code>函数。</p>\n<p>在本模块的线程函数中，每次通过ZBus接收到新的消息后，都会通过<code>smf_run_state(SMF_CTX(&amp;s_obj))</code>来处理这个消息携带的数据。这个函数底层执行的就是当前状态的<code>run</code>函数。</p>\n<p>由此可见SMF也是比较简单易用的，步骤就是先定义状态，然后注册回调函数，最后执行。</p>\n<p>MQTT的连接就发生在状态机执行初始状态的这一步：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Set initial state */</span></span><br><span class=\"line\">    smf_set_initial(SMF_CTX(&amp;s_obj), &amp;state[MQTT_DISCONNECTED]);</span><br></pre></td></tr></table></figure>\n\n<p>这时就会执行初始状态的<code>entry</code>函数，进行MQTT的连接。</p>\n<blockquote>\n<p>其他补充：</p>\n<ol>\n<li>本例程没有展示出状态机嵌套的功能，要想了解这部分，可以参考<a href=\"https://docs.zephyrproject.org/latest/services/smf/index.html\">SMF文档</a>。</li>\n<li>SMF的<code>run</code>函数和<code>set_state</code>函数何时执行，完全由开发者决定，如果你想要事件驱动型的状态机框架（阻塞等待某个事件，然后再执行run函数），可以参考SMF文档中的写法。。</li>\n<li>在<code>exit</code>函数内部进行<code>set_state</code>这种行为是有歧义的，因为<code>set_state</code>本身就是要进入一个新的状态，而<code>set_state</code>内部同时也会调用前一个状态的<code>exit</code>函数，因此SMF底层会拒绝这种操作，会报错。</li>\n<li>SMF框架没有限制<code>set_state</code>函数必须和状态机本身的<code>run</code>函数处于同一个线程（本例程中，<code>set_state</code>就在MQTT的回调函数中，与状态机不在一个线程）。因此完全有可能出现<code>run</code>函数还没执行完，<code>exit</code>函数就在另一个线程被执行了的情况。开发者自己要控制好这一情况。</li>\n<li>为了防止<strong>4</strong>的情况出现，我们的回调函数，不论是MQTT回调函数，还是状态机的回调函数，都要<strong>快进快出</strong>，而且要保证在状态机层面上是<strong>原子操作</strong>。因此，我们可以发现代码中，这些回调函数实际都没做什么工作，而是把具体的代码提交到<a href=\"https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html\">work queue</a>去执行，然后就马上返回了。work queue是个单独的线程，从work queue的层面上讲，每个work都是“原子”的，就不用担心<strong>4</strong>中的情况了。</li>\n</ol>\n</blockquote>\n<h3 id=\"TLS-Credentials-库与证书管理\"><a href=\"#TLS-Credentials-库与证书管理\" class=\"headerlink\" title=\"TLS Credentials 库与证书管理\"></a>TLS Credentials 库与证书管理</h3><p>我们知道，SSL加密通信，其核心不仅仅在于加密，还在于身份的认证，需要确保对方真的是你想要连接的那个对象，这里就分为三种情况：</p>\n<ul>\n<li><p>如果只是设备验证服务器，单向验证，则设备中需要存储服务器对应的<strong>CA证书</strong>，用CA证书校验服务器出示的证书是否合法。这也是我们电脑访问各大网站的常见方式。</p>\n</li>\n<li><p>如果只是服务器验证设备，单向验证，则设备中需要存储<strong>客户端证书</strong>，用于出示给服务器。服务器中预先注册了设备的证书信息，因此可以检查设备是否是冒充的。当然，设备也需要存储此证书对应的<strong>私钥</strong>；</p>\n</li>\n<li><p>若双向都要验证，则三样都需要。这也是目前物联网行业常见的方式。</p>\n</li>\n</ul>\n<p>在MQTTX客户端软件中，我们就可以看到这三个文件的配置项：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006004212156.png\" alt=\"image-20231006004212156\"></p>\n<p>如果我们的开发板要想通过MQTTS连接到MQTT Broker，当然也需要存储这些凭据信息。</p>\n<p>我们使用的电脑已经预安装了世界上各大CA机构的证书，因此我们访问世界上绝大多数服务器，都可以用已经安装的CA证书去检查该服务器是否是冒充的。但是嵌入式设备不可能存这么多证书，最好是按需存储，要通过TLS连哪个服务器，就只存哪个服务器对应的CA证书。</p>\n<p>Zephyr提供了<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/connectivity/networking/api/sockets.html#tls-credentials-subsystem\">TLS Credentials</a>库来管理各类证书、私钥。简而言之，它管理了一个TLS连接所需的<strong>CA证书</strong>、<strong>设备证书</strong>、<strong>设备私钥</strong>，并且通过一个编号来索引。每次要进行TLS连接时，只需要指定一个编号即可，这个编号叫做<code>SEC_TAG</code>。</p>\n<p>直观地说，就是要先存储证书和私钥：</p>\n<img src=\"/jayant97.github.io/imgs/在nRF7002开发板上运行MQTT例程.assets/image-20231006010250433.png\" alt=\"image-20231006010250433\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>同一个TLS连接所需的CA证书、设备证书、设备私钥都存储在同一个<code>SEC_TAG</code>下。</p>\n</blockquote>\n<p>然后，在底层建立Socket连接时，通过传参传入<code>SEC_TAG</code>，就可以使用这些证书了：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006010436194.png\" alt=\"image-20231006010436194\"></p>\n<p>这个库的设计逻辑在于<strong>“存储”与“使用”分离</strong>。存储后端可以自由切换，它既可以是单纯的Flash存储，也可以是ARM平台安全架构（PSA）提供的安全存储服务（Protected Storage Service）。</p>\n<p>一个实例就是nRF9160，我们知道9160的证书是通过python脚本或者nRF Connect for Desktop软件烧录到Modem中的（底层都是AT指令），烧录时其实就指定了Security Tag号（例如，nRF Cloud默认用的就是<code>16842753</code>）。在应用层建立TLS连接时（例如连接到nRF Cloud时），都是通过<code>SEC_TAG</code>号来访问私钥的。这样既能完成握手，又能让应用层无法读取到证书、私钥的内容，从而确保了信息安全。</p>\n<blockquote>\n<p>实际上，9160的证书和私钥可以不烧进去，而是直接在Modem内部生成。然后生产线上只取出证书，上传到服务器即可，从而确保私钥绝对不会泄漏。</p>\n</blockquote>\n<h3 id=\"MQTT证书文件配置流程\"><a href=\"#MQTT证书文件配置流程\" class=\"headerlink\" title=\"MQTT证书文件配置流程\"></a>MQTT证书文件配置流程</h3><p>回到例程中来，我们的证书究竟是如何配置进去的？</p>\n<p>首先，例程默认连接的服务器是<code>mqtt://test.mosquitto.org:1883</code>。我们可以用HTTP协议，也就是直接用浏览器访问<a href=\"https://test.mosquitto.org/%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%8B%E7%BB%8D%EF%BC%9A\">https://test.mosquitto.org/，查看介绍：</a></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006012304338.png\" alt=\"image-20231006012304338\"></p>\n<p>我们可以得知，这个服务器有许多端口，每个不同的端口上运行的是不同的协议。其中8883端口运行的是MQTT over TLS，并且只需单向验证服务器，服务器不需要验证客户端。 </p>\n<p>我们先看看之前添加的<code>overlay-tls-nrf7002.conf</code>里有哪些与SSL有关的config：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006004756724.png\" alt=\"image-20231006004756724\"></p>\n<p>首先要使能TLS，然后是目标服务器的端口号要改为8883。然后选择载入默认的SSL证书，启用加密库，最后Socket也要启用TLS的支持。</p>\n<p>MQTT Helper有默认的证书文件名，我们可以看到在<code>$&#123;NCS&#125;/nrf/subsys/net/lib/mqtt_helper/cert/mqtt-certs.h</code>中，默认包含的CA证书文件名为<code>ca-cert.pem</code>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E5%9C%A8nRF7002%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E8%BF%90%E8%A1%8CMQTT%E4%BE%8B%E7%A8%8B.assets/image-20231006013111085.png\" alt=\"image-20231006013111085\"></p>\n<p>而<code>CONFIG_MQTT_HELPER_PROVISION_CERTIFICATES</code>配置决定了MQTT Helper会不会在编译时自动包含这个证书，并且在MQTT连接前自动载入这个证书。具体代码位于<code>$&#123;NCS&#125;/nrf/subsys/net/lib/mqtt_helper/mqtt_helper.c</code></p>\n<blockquote>\n<p>读者可以尝试把服务器改成<code>broker.emqx.io</code>，这是另一个免费的测试用MQTT broker，文档地址是<a href=\"https://www.emqx.com/zh/mqtt/public-mqtt5-broker\">https://www.emqx.com/zh/mqtt/public-mqtt5-broker</a></p>\n<p>在网页上下载到CA证书后，把代码中的<code>ca-cert.pem</code>改成下载好的证书即可。注意不能直接改文件名，因为这个文件是在C语言中被当成字符串包含的，所以下载好的证书要编辑一下，把里面的内容都用引号括起来，并添加好<code>\\n</code>。</p>\n</blockquote>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><ol>\n<li>MQTT是轻量高效的网络协议，适合物联网，实现了设备间解耦通信。</li>\n<li>由于是例程，Wi-Fi的凭据和TLS的凭据都是静态配置，被编译进固件的。编译前注意检查配置。</li>\n<li>例程是无main架构，各个模块通过ZBUS进行线程间通信。</li>\n<li>程序先连上MQTT broker，然后订阅主题，再然后定时发布消息。</li>\n<li>Zephyr提供了状态机框架SMF</li>\n<li>Wi-Fi 连接的底层是 WPA Supplicant 软件，也有Network Management API可用。Wi-Fi凭据的存储用的是 Wi-Fi Credential 库。 Wi-Fi Credential 使用 SSID 来索引。</li>\n<li>MQTTS连接使用MQTT Helper库。MQTTS的连接需要SSL，SSL证书的存储用的是 TLS Credential库。它使用SEC_TAG来索引。</li>\n</ol>\n","categories":["Nordic","Wi-Fi"],"tags":["Nordic","nRF_Cloud","nRF70"]},{"title":"安装nRF-Connect-SDK","url":"/jayant97.github.io/2022/12/779143a4bec8/","content":"<blockquote>\n<p>2025.7.27更新：</p>\n<ul>\n<li>增加了nRF Connect详细安装说明，和国内软件源</li>\n<li>增加了nrfutil详细安装说明，以及命令行自动补全</li>\n<li>新增了强制用国内服务器加速安装NCS的方法</li>\n</ul>\n<p>2025.5.12更新：</p>\n<ul>\n<li>NCS v3.0.0支持打包下载，无需科学的上网从GitHub拉取</li>\n<li>新增workspace插件清理内容，解决VS Code弹窗问题</li>\n<li>新增对Windows目录名长度限制的提醒</li>\n</ul>\n</blockquote>\n<p>nRF Connect SDK，简称NCS，是Nordic最新的SDK平台。该平台支持Nordic的三大产品线：</p>\n<ol>\n<li><strong>短距离 2.4G MCU</strong>：<ul>\n<li>Bluetooth LE（主机、从机、主从一体、多主多从、BLE MESH、AoA&#x2F;AoD蓝牙测向、LE Audio、 PAwR、Channel Sounding）</li>\n<li>基于802.15.4的OpenThread和Zigbee</li>\n<li>2.4G私有协议（ESB）</li>\n</ul>\n</li>\n<li><strong>中距离 Wi-Fi</strong> 收发器：<ul>\n<li>nRF700x系列的Wi-Fi收发器，低功耗双频Wi-Fi6，QSPI&#x2F;SPI接口。NCS提供700x系列的Zephyr驱动和例程。</li>\n</ul>\n</li>\n<li><strong>长距离 蜂窝 模组</strong>：<ul>\n<li>nRF91系列，是支持CAT-NB1(NB-IoT)和CAT-M1的<strong>系统级封装（SiP）</strong>，全球运营商认证。<strong>超低功耗，小尺寸</strong>，支持Open CPU和 AT Commands方式开发。</li>\n</ul>\n</li>\n</ol>\n<p>软件上，还支持Matter，HomeKit，Apple FindMy，Google FindMy，Amazon Sidewalk，ANT+等物联网协议；硬件上，还支持Nordic的2.4G无线功率放大器（PA）和电源管理芯片（PMIC）。</p>\n<p>NCS基于Zephyr系统。Zephyr系统是一个<strong>开源嵌入式实时操作系统</strong>项目，由<a href=\"https://zephyrproject.org/project-members/\">Linux基金会和众多厂商</a>维护。Zephyr系统除了基本的ROTS之外，还有很多中间件，软件库，硬件驱动等等。</p>\n<blockquote>\n<p>Zephyr的强大特性</p>\n<ol>\n<li>全面的内核服务<ul>\n<li>多线程，支持协程和基于优先级的抢占。兼容POSIX pthreads API。</li>\n<li>多种动态内存分配工具，支持固定大小或可变大小的内存块</li>\n<li>支持多种信号量同步机制；支持多种线程间通讯机制（消息队列、字节流等）</li>\n<li>CPU电源管理和外设电源管理</li>\n</ul>\n</li>\n<li>多种调度策略可选</li>\n<li>高度可定制性、模块化开发</li>\n<li>支持许多架构（x86, ARM, RSIC-V）</li>\n<li>堆栈、内核、驱动、线程间内存保护</li>\n<li>允许编译时静态定义资源（线程、内存池、队列等），提高性能</li>\n<li>提供具有一致性的设备驱动模型，并且支持DeviceTree</li>\n<li>全功能网络协议栈（包括LwM2M和BSD Sockets），OpenThread，BLE</li>\n<li>跨平台开发（Windows&#x2F;Linux&#x2F;MacOS）</li>\n<li>支持多种文件系统（ext2, LittleFS, FatFS…），还支持FCB(Flash Circular Buffer)</li>\n<li>强大的模块化日志框架，支持多种后端（串口、RTT、BLE、network、filesystem…）</li>\n<li>易于开发的Shell</li>\n<li>在非易失存储器上保存配置，掉电不丢失</li>\n<li>支持在Linux上运行Zephyr模拟器</li>\n<li>远程资源管理（通过串口、USB、BLE、network管理固件升级与版本回滚，文件系统资源等）</li>\n</ol>\n</blockquote>\n<p>NCS在Zephyr的基础上提供了更多的脚本工具、协议栈、驱动、功能库等等。</p>\n<p>NCS中有许多例程。其中有Zephyr自带的一些基础例程，如线程、LED&#x2F;Button、TCP&#x2F;UDP等；也有Nordic提供的高级例程，如BLE键鼠、蓝牙多连接、Matter例程等。NCS官网针对每个例程都提供了文档。</p>\n<p>更多信息可参考：</p>\n<ul>\n<li><a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/installation/install_ncs.html\">NCS官网（英文） - 安装教程</a></li>\n<li><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></li>\n</ul>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>本节将会详细介绍如何在一台<strong>Windows</strong> 11的电脑上安装NCS开发环境（Windows 10也适用），包含NCS、编译器以及其他工具。其他平台的安装也是类似的，参考好官网英文教程即可。</p>\n<p>需要安装的内容列表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">软件</th>\n<th>分类</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></td>\n<td>编辑器</td>\n<td>代码文本编辑器，并且通过安装插件的方式为其他开发调试工具提供可视化界面</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-command-line-tools\">nRF Command Line Tools</a></td>\n<td>命令行工具</td>\n<td>nrfjprog命令行烧录工具（后续将被nRF Util取代）</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nRF-Util\">nRF Util</a></td>\n<td>命令行工具</td>\n<td>更高级的命令行工具，类似于包管理器，可以安装各种子命令。包括烧录、管理toolchain&#x2F;SDK、DFU、BLE抓包、蜂窝ModemTrace</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><a href=\"https://github.com/NordicSemiconductor/nrf-udev\">nrf-udev</a></td>\n<td>配置文件</td>\n<td>【Linux专用】配置USB设备权限，可识别Nordic USB设备</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop\">nRF Connect for Desktop</a></td>\n<td>桌面工具</td>\n<td>Nordic桌面工具集合</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\"><a href=\"https://www.segger.com/downloads/jlink\">Jlink驱动</a></td>\n<td>驱动</td>\n<td>JLink驱动需要单独安装。</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">NCS Toolchain</td>\n<td>编译工具链</td>\n<td>一个独立的工具链文件夹，含Git、CMake、Python、Ninja、GCC等工具，与你电脑上已经安装的环境不冲突</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\"><a href=\"https://github.com/nrfconnect/sdk-nrf\">NCS</a></td>\n<td>SDK源码包</td>\n<td>SDK本体，含内核、驱动、模块、协议栈等等的源码</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-安装开发工具\"><a href=\"#2-安装开发工具\" class=\"headerlink\" title=\"2. 安装开发工具\"></a>2. 安装开发工具</h1><h2 id=\"VS-Code\"><a href=\"#VS-Code\" class=\"headerlink\" title=\"VS Code\"></a>VS Code</h2><p>在官网安装：<a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></p>\n<h2 id=\"JLink驱动\"><a href=\"#JLink驱动\" class=\"headerlink\" title=\"JLink驱动\"></a>JLink驱动</h2><p>在<a href=\"https://www.segger.com/downloads/jlink\">SEGGER - JLink官网</a>下载JLINK驱动。其中JLink的版本参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/installation/recommended_versions.html#j-link_software_and_documentation_pack\">NCS依赖</a>：</p>\n<p>打开文档后，先把文档版本对齐为你要安装的NCS版本：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205021043601.webp\" alt=\"image-20250205021043601\"></p>\n<p>然后查看JLink需要的版本：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205021126347.webp\" alt=\"image-20250205021126347\"></p>\n<blockquote>\n<p>也可以用<code>nrfutil device --version</code>对照查看nrfutil device需要的JLink版本。注意，<strong>下表对应的不是NCS的版本</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>SEGGER J-Link version</th>\n<th>Tested with…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v8.10f</td>\n<td><code>device</code> v2.7.11 and newer</td>\n</tr>\n<tr>\n<td>v7.94i</td>\n<td><code>device</code> v2.5.4 to v2.7.10, <code>ble-sniffer</code> v0.9.0 and newer, <code>trace</code> v3.0.0 and newer, <code>91</code> v0.5.0.</td>\n</tr>\n<tr>\n<td>v7.94e</td>\n<td><code>device</code> v2.1.1 to v2.5.3.</td>\n</tr>\n<tr>\n<td>v7.88j</td>\n<td><code>device</code> v2.0.2 to v2.0.3.</td>\n</tr>\n</tbody></table>\n</blockquote>\n<p><strong>安装JLink驱动时，一定要带上JLink USB驱动</strong>：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># For windows</span></span><br><span class=\"line\">.\\JLink_Windows_V794i_x86_64.exe <span class=\"literal\">-InstUSBDriver</span>=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>或者在安装时勾选USB driver：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/57c7c7a3c1b24a4013e61a438ba92626.png\" alt=\"image-20250727155420764\"></p>\n<p>其他依赖： <a href=\"https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022\">Microsoft Visual C++ Redistributable</a></p>\n<h2 id=\"nRF-Connect-For-Desktop\"><a href=\"#nRF-Connect-For-Desktop\" class=\"headerlink\" title=\"nRF Connect For Desktop\"></a>nRF Connect For Desktop</h2><p>访问下载页面：<a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop\">https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop</a></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221122214235111-1731044874926-19.webp\" alt=\"image-20221122214235111\"></p>\n<p>下载并安装最新版本，进入设置，打开中国大陆服务器软件源：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ce1553838de4b8562ca01f8e9dfda59a.png\" alt=\"image-20250727155823079\"></p>\n<p>然后安装自己需要的软件即可，可以先安装这三个最常用的：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/125b92f2904349a6b2e02b0faee82ede.png\" alt=\"image-20250727155935022\"></p>\n<blockquote>\n<p>如果你的电脑不能联网，可以先在可以联网的电脑上安装nRF Connect for Desktop。然后导出离线文件，再导入到不能联网的电脑上。见：</p>\n<p><a href=\"https://www.cnblogs.com/jayant97/p/17821601.html\">nRF Connect for Desktop离线安装方法</a></p>\n</blockquote>\n<h2 id=\"nrfutil\"><a href=\"#nrfutil\" class=\"headerlink\" title=\"nrfutil\"></a>nrfutil</h2><p>ntfutil是一个命令行工具集。可以联网安装各种工具，比如程序烧录，SDK管理，工具链环境等等。</p>\n<p>在官网下载可执行文件：<a href=\"https://www.nordicsemi.com/Products/Development-tools/nRF-Util\">nRF Util</a>。</p>\n<p>然后把nrfutil所在目录添加到PATH环境变量：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/374227a1ab74d3ff010f5f8cbd22289f.png\" alt=\"image-20250727160809557\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/66eba8f83e53eed553bda73f46e9858c.png\" alt=\"image-20250727160716550\"></p>\n<p>在命令行中执行子程序的下载：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 联网查找软件包</span></span><br><span class=\"line\">nrfutil search</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自我更新</span></span><br><span class=\"line\">nrfutil self<span class=\"literal\">-upgrade</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装常用软件</span></span><br><span class=\"line\">nrfutil install device toolchain<span class=\"literal\">-manager</span> sdk<span class=\"literal\">-manager</span> completion</span><br></pre></td></tr></table></figure>\n\n<p>nrfutil支持在powershell, bash和zsh下的<strong>命令自动补全</strong>，以power shell为例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">PS</span> C:\\Users\\Jayant&gt; nrfutil completion install powershell</span><br><span class=\"line\"></span><br><span class=\"line\">Add the following to your <span class=\"variable\">$PROFILE</span> file:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># From nrfutil completion install</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING: nrfutil tab-completion may become slow because of Windows Defender</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"built_in\">Test-Path</span> <span class=\"literal\">-Path</span> <span class=\"variable\">$</span>&#123;env:USERPROFILE&#125;\\.nrfutil\\share\\nrfutil<span class=\"literal\">-completion</span>\\scripts\\powershell\\setup.ps1 ) &#123;</span><br><span class=\"line\">    . <span class=\"variable\">$</span>&#123;env:USERPROFILE&#125;\\.nrfutil\\share\\nrfutil<span class=\"literal\">-completion</span>\\scripts\\powershell\\setup.ps1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把命令行输出的内容粘贴到&#96;&#96;$PROFILE<code>文件中，也就是</code>~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1&#96;。</p>\n<p>安装了VS Code的情况下，可以这样打开此文件：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">code <span class=\"variable\">$PROFILE</span></span><br></pre></td></tr></table></figure>\n\n<p>需要管理员权限。另外如果你是首次设置windows powershell脚本，需要修改注册表使其允许执行脚本：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在管理员终端中执行</span></span><br><span class=\"line\"><span class=\"built_in\">set-executionpolicy</span> remotesigned</span><br></pre></td></tr></table></figure>\n\n<p>在那之后，重新打开命令行。随意输入nrfutil的命令，只输入一半按TAB键，就可以看到自动补全候选项了：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/cf0c001fc9315b8e08579d979b4023dc.png\" alt=\"image-20250727162035911\"></p>\n<blockquote>\n<ul>\n<li>在NCS v3.0.0之后，NCS内的程序下载全部使用nrfutil。nRF Command Line Tools(nrfjprog)不再使用</li>\n<li>如果你的电脑不能联网，可以先在有网络的电脑安装，然后导出到不能联网的电脑，见：<a href=\"https://www.cnblogs.com/jayant97/p/17819404.html\">nrfutil离线安装方法</a></li>\n</ul>\n</blockquote>\n<h2 id=\"VS-Code插件\"><a href=\"#VS-Code插件\" class=\"headerlink\" title=\"VS Code插件\"></a>VS Code插件</h2><p>VS Code的安装这里不做介绍。VS Code的插件可以在VS Code插件市场搜索<strong>nRF Connect for VS Code Extension pack</strong>来一次性安装所有需要的插件。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250204233110265.webp\" alt=\"image-20250204233110265\"></p>\n<blockquote>\n<p>如果你的电脑不能联网，需要离线安装。先在有网络的电脑上下载VSIX离线插件文件：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a51c1f6d2f3fd4c6fa027cb35fb90145.png\" alt=\"image-20250727162402886\"></p>\n<p>注意这个插件包只是个封装。封装里的每一个插件都要单独下载VSIX，并选择平台：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/461ecd55f552d8599ac52893b91c0894.png\" alt=\"image-20250727162619019\"></p>\n<p>然后，拷贝到不能联网的电脑上导入即可：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a323fc91f942a982240fb8f3e5c856c7.png\" alt=\"image-20250727162713479\"></p>\n</blockquote>\n<h2 id=\"Linux-USB规则\"><a href=\"#Linux-USB规则\" class=\"headerlink\" title=\"Linux USB规则\"></a>Linux USB规则</h2><p>对于LinuxPC，需要安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install libusb-1.0-0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 先从https://github.com/NordicSemiconductor/nrf-udev/releases下载deb包</span></span><br><span class=\"line\">sudo dpkg -i nrf-udev_1.0.1-all.deb</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"3-安装编译工具链和SDK\"><a href=\"#3-安装编译工具链和SDK\" class=\"headerlink\" title=\"3. 安装编译工具链和SDK\"></a>3. 安装编译工具链和SDK</h1><p>Toolchain和SDK是两个独立的文件夹。Toolchain包含python, cmake, ninja, gcc等工具，与你电脑上本身的环境变量不冲突。SDK包含源码、脚本、库等。</p>\n<p><strong>简化后</strong>的目录树：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncs</span><br><span class=\"line\">├─── toolchains</span><br><span class=\"line\">│      ├─── 648da874d</span><br><span class=\"line\">|      ├─── bc5b4cb7c</span><br><span class=\"line\">│      └─── toolchains.json</span><br><span class=\"line\">├───  v2.9.0</span><br><span class=\"line\">└───  v3.0.0</span><br></pre></td></tr></table></figure>\n\n<p>toolchain的目录名是某种哈希值，而不是版本号。<code>toolchains.json</code>中记录了每个toolchain和SDK版本的对应关系。实际的目录树，还会有一些临时文件，和解压前的文件：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512163349985.png\" alt=\"image-20250512163349985\"></p>\n<p>默认路径（<code>C:\\ncs</code>或者<code>~/ncs</code>）下存放各个版本的SDK。此外，还有一个Toolchain文件夹，其中存放各个版本的toolchain。</p>\n<p>Toolchain是在Nordic服务器上的压缩包，直接按照后面步骤自动下载自动安装即可。</p>\n<p>SDK是放在<strong>GitHub</strong>上的许多仓库的合集，主仓库是<a href=\"https://github.com/nrfconnect/sdk-nrf\">sdk-nrf</a>。当你能稳定科学地上网，才能从GitHub方便地安装。不过<strong>目前Nordic也提供了压缩包形式的SDK</strong>，有全球CDN加速，无需科学的上网就能直连下载。</p>\n<h2 id=\"3-1-方式一：预打包方式安装\"><a href=\"#3-1-方式一：预打包方式安装\" class=\"headerlink\" title=\"3.1. 方式一：预打包方式安装\"></a>3.1. 方式一：预打包方式安装</h2><h3 id=\"（1）强制设置中国大陆服务器源\"><a href=\"#（1）强制设置中国大陆服务器源\" class=\"headerlink\" title=\"（1）强制设置中国大陆服务器源\"></a>（1）强制设置中国大陆服务器源</h3><blockquote>\n<p>注意，此方式只支持NCS v3.0.0以上的pre-packaged SDKs安装加速。不能加速从Github拉取的方式。</p>\n<p>后续nrfutil可能会更新更方便的用法，我会更新到本文。</p>\n</blockquote>\n<p>在环境变量中新建以下内容：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/bf9d21cebb6648bdeb34f03f72563ce1.png\" alt=\"image-20250727162858814\"></p>\n<p>以上方式为全局设置，对命令行nrfutil toolchain-manager和VS Code插件都生效。</p>\n<p>PowerShell临时环境变量：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$Env:NRFUTIL_SDK_REMOTE_CONFIG_URL</span> = <span class=\"string\">&quot;https://files.nordicsemi.cn/artifactory/ncs-src-mirror/external/sdk-manager/config-cn.json&quot;</span></span><br><span class=\"line\"><span class=\"variable\">$Env:NRFUTIL_TOOLCHAIN_REMOTE_CONFIG_URL</span> = <span class=\"string\">&quot;https://files.nordicsemi.cn/artifactory/NCS/external/bundles/config-cn.json&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>Linux命令行临时环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NRFUTIL_SDK_REMOTE_CONFIG_URL=<span class=\"string\">&quot;https://files.nordicsemi.cn/artifactory/ncs-src-mirror/external/sdk-manager/config-cn.json&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> NRFUTIL_TOOLCHAIN_REMOTE_CONFIG_URL=<span class=\"string\">&quot;https://files.nordicsemi.cn/artifactory/NCS/external/bundles/config-cn.json&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）安装Toolchain\"><a href=\"#（2）安装Toolchain\" class=\"headerlink\" title=\"（2）安装Toolchain\"></a>（2）安装Toolchain</h3><p>在插件的Welcome界面，选择安装新的Toolchain</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250204234236367.webp\" alt=\"image-20250204234236367\"></p>\n<p><strong>先设置安装路径（也可以不设置），然后点击选择要安装的NCS版本。</strong></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ee8db1f55717e3ca087c9ce4c6db89b5.png\" alt=\"image-20250727163923939\"></p>\n<blockquote>\n<p>这里设置的是所有toolchain的父目录。Windows默认安装路径是<code>C:\\\\ncs\\</code>，Linux下是<code>$&#123;HOME&#125;/ncs/</code>，MacOS下设置无效。例如：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250204235145339.webp\" alt=\"image-20250204235145339\"></p>\n<p>后续安装SDK时也可以设置同样的路径，这样最后电脑上的NCS都会装在一起。</p>\n</blockquote>\n<p>Toolchain会自动下载并解压，里面的工具<strong>不会</strong>被添加PATH环境变量中，也<strong>不需要添加到PATH</strong>。防止工具链中的软件和你电脑上已经安装的同名软件产生冲突（如Python)。</p>\n<p>可以看到国内镜像的下载速度是非常快的：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/13ed66722868a56e25daf2f03453698b.png\" alt=\"image-20250727164049235\"></p>\n<h3 id=\"（3）安装SDK\"><a href=\"#（3）安装SDK\" class=\"headerlink\" title=\"（3）安装SDK\"></a>（3）安装SDK</h3><p>安装SDK的方式也类似：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205003637807.webp\" alt=\"image-20250205003637807\"></p>\n<p>这里可以选择从哪里下载。<strong>Pre-packaged SDKs</strong>是从Nordic服务器下载压缩包，<strong>GitHub</strong>是从GitHub拉取SDK的所有仓库。<strong>只有前者才能享受国内镜像源加速</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512164417437.png\" alt=\"image-20250512164417437\"></p>\n<p>这里的安装路径，<strong>最好与toolchain使用相同的父目录</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205003730244.webp\" alt=\"image-20250205003730244\"></p>\n<p>然后回车安装。安装完毕会自动解压。</p>\n<h3 id=\"（4）清理git状态\"><a href=\"#（4）清理git状态\" class=\"headerlink\" title=\"（4）清理git状态\"></a>（4）清理git状态</h3><p>目前，预打包（Pre-packaged）方式有个bug。那就是SDK在linux环境下打包好的，在Windows下解压，会出现部分文件的权限从755强制转换为644，导致git状态不是clean：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8671cc395bf5de759f4ef80b0cbc20a4.png\" alt=\"image-20250727164656643\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/7957c29ba730bca0d3a49a98b30a3a98.png\" alt=\"image-20250727164717632\"></p>\n<p>并且，我实测在git全局配置忽略文件权限的变化也没用。必须在每个git子仓库都忽略文件权限的变化：</p>\n<p>打开nRF Connect命令行：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8f02cfc623694bbb710701a565fb9a6a.webp\" alt=\"image-20250205000107113\"></p>\n<p>进入SDK根目录，执行以下内容：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># set for all repo:</span></span><br><span class=\"line\">west forall <span class=\"literal\">-c</span> <span class=\"string\">&#x27;git config core.filemode false&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set for all sub modules:</span></span><br><span class=\"line\">west forall <span class=\"literal\">-c</span> <span class=\"string\">&#x27;git submodule foreach --recursive git config core.filemode false&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是给NCS的每个代码仓库，以及每个仓库的子仓库都递归执行<code>git config core.filemode false</code>，从而忽略文件的变化。</p>\n<p>处理完毕后，Git状态变干净了：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/95f8f2ee93ed55a849d0f6a5e269d961.png\" alt=\"image-20250727170510324\"></p>\n<h2 id=\"3-2-命令行环境\"><a href=\"#3-2-命令行环境\" class=\"headerlink\" title=\"3.2. 命令行环境\"></a>3.2. 命令行环境</h2><p>如果是服务器等命令行编译环境，可以参考本节内容。另外，手动从GitHub拉取SDK，也需要此命令行环境。</p>\n<h3 id=\"通过VS-Code打开NCS命令行环境\"><a href=\"#通过VS-Code打开NCS命令行环境\" class=\"headerlink\" title=\"通过VS Code打开NCS命令行环境\"></a>通过VS Code打开NCS命令行环境</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205000107113.webp\" alt=\"image-20250205000107113\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205000139731.webp\" alt=\"image-20250205000139731\"></p>\n<h3 id=\"直接从命令行切换到NCS环境\"><a href=\"#直接从命令行切换到NCS环境\" class=\"headerlink\" title=\"直接从命令行切换到NCS环境\"></a>直接从命令行切换到NCS环境</h3><p>对于没有显示器的服务器环境，或者脚本中需要使用工具链的情况，可以用nrfutil实现。</p>\n<p>准备nrfutil：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 确保已经安装nrfutil，并添加到环境变量。</span></span><br><span class=\"line\"><span class=\"comment\">## 并且已经安装了nrfutil toolchain-manager</span></span><br><span class=\"line\"><span class=\"comment\">#  nrfutil search</span></span><br><span class=\"line\"><span class=\"comment\">#  nrfutil install toolchain-manager</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 首先，如果前面安装toolchain时，没有安装到默认路径，此处需要设置你的安装路径</span></span><br><span class=\"line\">nrfutil toolchain<span class=\"literal\">-manager</span> config <span class=\"literal\">--set</span> <span class=\"built_in\">install-dir</span>=D:\\Project\\ncs</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 检查nrfutil是否找到工具链</span></span><br><span class=\"line\"> nrfutil toolchain<span class=\"literal\">-manager</span> list</span><br><span class=\"line\"> </span><br><span class=\"line\">Version  Toolchain</span><br><span class=\"line\"> * v2.<span class=\"number\">9.0</span>   D:\\Project\\ncs\\toolchains\\b620d30767</span><br></pre></td></tr></table></figure>\n\n<p> 直接进入一个带有toolchain作为path的shell环境<br> <figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># Windows PowerShell</span></span><br><span class=\"line\">nrfutil toolchain<span class=\"literal\">-manager</span> launch <span class=\"literal\">--ncs-version</span> v2.<span class=\"number\">9.0</span> <span class=\"literal\">--</span> powershell</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\"># Windows CMD</span></span><br><span class=\"line\"> nrfutil toolchain<span class=\"literal\">-manager</span> launch <span class=\"literal\">--ncs-version</span> v2.<span class=\"number\">9.0</span> <span class=\"literal\">--</span> cmd</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\"># 进入后，可用env命令检查环境变量</span></span><br><span class=\"line\"> env</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/7c5b1ac9ca1f813380f58a6bfdb4a396.png\" alt=\"image-20250727170711908\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Linux下必须使用--shell参数</span></span><br><span class=\"line\">nrfutil toolchain-manager launch --ncs-version v2.9.0 --shell</span><br></pre></td></tr></table></figure>\n\n<p>进入环境后，我们执行<code>west --help</code>，会发现是没有烧录、编译这些命令的。</p>\n<p>需要再手动设置<code>ZEPHYR_BASE</code>临时环境变量，使其指向“NCS目录下的zephyr目录”。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$Env:ZEPHYR_BASE</span>=<span class=\"string\">&quot;D:\\ncs\\v3.0.2\\zephyr&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后就可以使用SDK中的扩展命令了：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ebe988e38f4afe0a8d6214a61b154162.png\" alt=\"image-20250727171046110\"></p>\n<h2 id=\"3-3-方式二：手动拉取或者更新SDK\"><a href=\"#3-3-方式二：手动拉取或者更新SDK\" class=\"headerlink\" title=\"3.3. 方式二：手动拉取或者更新SDK\"></a>3.3. 方式二：手动拉取或者更新SDK</h2><p>手动拉取是从GitHub拉取。无法受到国内镜像源加速。确保你能稳定访问GitHub。</p>\n<p>此外，如果需要在NCS中添加一些私有仓库（如FindMy，ANT+这些需要相关授权才能使用的私有仓库），则必须要手动拉取。</p>\n<p>在刚刚打开的<strong>nRF Connect命令行</strong>中，找到想要安装SDK的位置，执行以下步骤：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205005413929.webp\" alt=\"image-20250205005413929\"></p>\n<h3 id=\"（1）拉取主仓库\"><a href=\"#（1）拉取主仓库\" class=\"headerlink\" title=\"（1）拉取主仓库\"></a>（1）拉取主仓库</h3><p>新安装SDK才需要执行这一步。如果是更新版本，跳过此步骤。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入到toolchain安装的父目录，默认C:\\ncs，或者$&#123;HOME&#125;/ncs/</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\Project\\ncs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并进入SDK文件夹</span></span><br><span class=\"line\">mkdir v2.<span class=\"number\">9.0</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> v2.<span class=\"number\">9.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化仓库（从github拉取对应Tag的主仓库）</span></span><br><span class=\"line\">west init <span class=\"literal\">-m</span> https://github.com/nrfconnect/sdk<span class=\"literal\">-nrf</span> <span class=\"literal\">--mr</span> v2.<span class=\"number\">9.0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>这一步如果下载失败想重新下载，<strong>需要把创建的v2.9.0文件夹下的所有内容删除干净</strong>，尤其是<code>.west</code>隐藏文件夹。然后再次执行前面的<code>west init ...</code>即可；</li>\n<li>如果网络实在差，可以从百度网盘下载，见<a href=\"https://www.cnblogs.com/iini/p/14174427.html\">《开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序》 - iini - 博客园 (cnblogs.com)</a></li>\n</ul>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205005309635.webp\" alt=\"image-20250205005309635\"></p>\n<h3 id=\"（2）拉取其他子仓库\"><a href=\"#（2）拉取其他子仓库\" class=\"headerlink\" title=\"（2）拉取其他子仓库\"></a>（2）拉取其他子仓库</h3><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主仓库已经拉取完毕，拉取其他子仓库，直接在当前目录下执行</span></span><br><span class=\"line\">west update</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于国内网络DNS污染的原因，这一步也经常失败，但是没关系，每次<code>west update</code>都能下载一点点，如果失败了，就重复<code>west update</code>就行了。不需要像<code>west init</code>失败一样删除干净重新下载。</p>\n<p>可以用个脚本循环执行，直到west update无报错。</p>\n</blockquote>\n<h3 id=\"（3）导出Zephyr-CMake-package\"><a href=\"#（3）导出Zephyr-CMake-package\" class=\"headerlink\" title=\"（3）导出Zephyr CMake package\"></a>（3）导出Zephyr CMake package</h3><figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">west zephyr<span class=\"literal\">-export</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（4）后续更新和切换SDK版本\"><a href=\"#（4）后续更新和切换SDK版本\" class=\"headerlink\" title=\"（4）后续更新和切换SDK版本\"></a>（4）后续更新和切换SDK版本</h3><p>SDK通过git管理的好处是，你可以方便地切到新版本或者老版本。注意此方法<strong>只能切换SDK，各个版本的toolchain还是需要单独安装</strong>。当然，如果你硬盘够大，把所有要用的SDK都分别安装也可以。</p>\n<p>按照以下步骤操作：</p>\n<ol>\n<li>确保SDK中的git仓库状态均为Clean</li>\n</ol>\n<p>这意味着，<strong>开发者平时不要随便去改SDK中的任何代码</strong>。但是编译例程是没问题的，因为例程的默认编译目录<code>build/</code>是被<code>.gitignore</code>忽略掉的。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此命令可查看当前git仓库的状态</span></span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>但是NCS中的仓库很多。也可以用VS Code打开整个NCS，用git界面图形化查看是否每个仓库均为clean。</p>\n<ol start=\"2\">\n<li>检查manifest有无新版本</li>\n</ol>\n<p>NCS中，nrf为主仓库，nrf的版本即为整个SDK的版本</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看nfr仓库下有多少版本</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nrf</span><br><span class=\"line\">git pull</span><br><span class=\"line\">git tag  <span class=\"comment\"># 按键盘上下键翻阅，按q退出</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切换到自己想要的版本</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 检出想要的主仓库nrf版本</span></span><br><span class=\"line\">git checkout v2.<span class=\"number\">6.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新nrf之外的整个NCS仓库</span></span><br><span class=\"line\">west update</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-打开一个例程\"><a href=\"#4-打开一个例程\" class=\"headerlink\" title=\"4. 打开一个例程\"></a>4. 打开一个例程</h1><p>从VS Code 的一个全新窗口，选择<strong>打开文件夹</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209103137554-1731044874928-20.webp\" alt=\"image-20221209103137554\"></p>\n<center>或者：</center>\n\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209103240455-1731044874929-21.webp\" alt=\"image-20221209103240455\"></p>\n<p>打开整个SDK目录，这样做是为了<strong>看代码跳转时，SDK中的代码也能跳转到</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012245435.webp\" alt=\"image-20250205012245435\"></p>\n<p>然后在VS Code中再打开一个例程：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012416141.webp\" alt=\"image-20250205012416141\"></p>\n<p>我们选择<code>v2.9.0\\nrf\\samples\\bluetooth\\peripheral_uart</code></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012602448.webp\" alt=\"image-20250205012602448\"></p>\n<p>编译例程参考后续章节。</p>\n<blockquote>\n<p>NCS中所有例程的位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NCS </span><br><span class=\"line\">|-- nrf                      </span><br><span class=\"line\">|   |-- applications/      # Nordic商业级例程</span><br><span class=\"line\">|   |-- samples/           # Nordic外设、蓝牙、LTE等例程</span><br><span class=\"line\">|   |-- tests/             # 组件API测试例程</span><br><span class=\"line\">`-- zephyr</span><br><span class=\"line\">    |-- samples            # Zephyr Kernel、各类板子、各类传感器芯片例程</span><br><span class=\"line\">    `-- tests              # 组件API测试例程</span><br></pre></td></tr></table></figure>\n\n<p><code>zephyr/samples/</code>中有RTOS的组件例程、Zephyr支持的各类厂商的板卡例程、各类传感器的例程等，其中也有蓝牙例程。</p>\n<p><code>zephyr/tests/</code>中有<strong>全部的</strong>API测试例程。</p>\n<p><code>nrf</code>仓库的目录结构仿造<code>zephyr</code>仓库，也有<code>samples/</code>和<code>tests/</code>目录。<code>samples/</code>中有Nordic提供的软件库例程、Zephyr未收录的例程（如 nRF9160的LTE）等。</p>\n</blockquote>\n<h1 id=\"5-以例程为模板创建新工程\"><a href=\"#5-以例程为模板创建新工程\" class=\"headerlink\" title=\"5. 以例程为模板创建新工程\"></a>5. 以例程为模板创建新工程</h1><p>上一节讲解了如何<strong>打开</strong>一个例程。</p>\n<p>如果我们只是打开例程，例程的文件夹还是在ncs仓库内部，受到ncs的git仓库的管理。如果想自己开发项目，用git管理自己项目的版本，就需要<strong>创建</strong>新工程。</p>\n<p>NCS支持把例程当作模板，复制到NCS外部，并创建新工程。</p>\n<blockquote>\n<p>新建工程还有一个用处：<strong>Windows上有目录名长度限制</strong>。在一些路径比较深的例程里进行编译时，会出现长度不足导致编译系统报错找不到某个SDK文件的情况。因此，把例程作为模板拷贝到比较浅的目录中进行开发，可以避免此问题。</p>\n<p>Linux，MacOS则没有这个问题。</p>\n</blockquote>\n<h2 id=\"5-1-创建新工程\"><a href=\"#5-1-创建新工程\" class=\"headerlink\" title=\"5.1. 创建新工程\"></a>5.1. 创建新工程</h2><p>NCS支持以例程作为模板，复制并创建新的工程。这也是Nordic非常推荐的方式。</p>\n<p>首先在VS Code中打开一个新窗口</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027154653607-1731044874929-24.webp\" alt=\"image-20231027154653607\"></p>\n<p>在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，先检查toolchain和SDK是否已经检测到。</p>\n<p>然后点击<code>Create a new application</code>创建新工程。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012805758.webp\" alt=\"image-20250205012805758\"></p>\n<p>选择“Copy a sample”</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012842271.webp\" alt=\"image-20250205012842271\"></p>\n<p>选择自己想要拷贝的例程，支持文字搜索：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205012920701.webp\" alt=\"image-20250205012920701\"></p>\n<blockquote>\n<p>这里的例程列表，和第4节中提到的目录结构是一致的。同时也和NCS官网的例程说明文档是保持一致的，下图位置打开官网文档：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013013188.webp\" alt=\"image-20250205013013188\"></p>\n<p>Nordic商业级应用：<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/applications.html\">https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/applications.html</a></p>\n<p>Nordic例程：<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/samples.html\">https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/samples.html</a></p>\n<p>Zephyr例程：<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/zephyr/samples/index.html\">https://docs.nordicsemi.com/bundle/ncs-latest/page/zephyr/samples/index.html</a></p>\n<p>此外，还有一些模块的例程不会出现在这个界面，但是可供参考：</p>\n<ul>\n<li><code>$&#123;NCS&#125;/modules/hal/nordic/nrfx/samples/src/</code>： NRFX外设驱动库例程。如果用户不想用、或者Zephyr没有提供某些外设的标准驱动，则可以使用NRFX驱动，其用法和老的nRF5 SDK基本一致。</li>\n<li><code>$&#123;NCS&#125;/zephyr/tests</code>：zephyr所有的API的测试用例。如果你不知道某个Zephyr API怎么用，可以从这里面找。</li>\n</ul>\n</blockquote>\n<p>选择自己新建工程的位置，注意<strong>Windows上，新建工程必须和SDK在同一个磁盘</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013142630.webp\" alt=\"image-20250205013142630\"></p>\n<p>然后就可以打开新的工程。</p>\n<h2 id=\"5-2-添加Workspace\"><a href=\"#5-2-添加Workspace\" class=\"headerlink\" title=\"5.2. 添加Workspace\"></a>5.2. 添加Workspace</h2><p>这样的独立工程是可以编译的，但是后续编译完，看代码时，按Ctr+鼠标左键跳转的代码在SDK内部，就无法跳过去了。所以，需要把SDK和当前工程添加到同一个VS Code Workspace中。</p>\n<p>选择添加文件夹到Workspace</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013547421.webp\" alt=\"image-20250205013547421\"></p>\n<p>直接把整个NCS和当前工程添加到同一个Workspace中：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013658240.webp\" alt=\"image-20250205013658240\"></p>\n<p>保存当前workspace：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013723666.webp\" alt=\"image-20250205013723666\"></p>\n<p>下次打开时，只需双击workspace文件，就能直接打开当前workspace（含工程目录+SDK）</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013906343.webp\" alt=\"image-20250205013906343\"></p>\n<p>最后记得修改<code>.gitignore</code>文件，避免污染git记录：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205013949727.webp\" alt=\"image-20250205013949727\"></p>\n<h2 id=\"5-3-清理Workspace插件\"><a href=\"#5-3-清理Workspace插件\" class=\"headerlink\" title=\"5.3. 清理Workspace插件\"></a>5.3. 清理Workspace插件</h2><p>可能你的VS Code里还安装了其他厂商的插件，以及一些通用插件。开发NCS时，这些插件不断弹窗报错，非常烦人。</p>\n<p>这时你可以用VS Code的workspace定制功能来关闭这个插件。</p>\n<p>目前版本NCS的插件包只需要这六个插件：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512170309135.png\" alt=\"image-20250512170309135\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512170323334.png\" alt=\"image-20250512170323334\"></p>\n<p>因此你在workspace里可以关掉其他的插件。举例来说，微软的<code>CMake Tools</code>会一直弹窗询问CMake根目录文件在哪里：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512170510620.png\" alt=\"image-20250512170510620\"></p>\n<p>我们不需要它来帮助解析CMake。直接在插件页面单独关掉它：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512170600781.png\" alt=\"image-20250512170600781\"></p>\n<p>这样，在当前workspace，这个插件就被关闭了。同理其他厂商的插件也可以这样关闭。如此一来，在当前workspace开发NCS，你不再会受到这些插件打扰。同时，在其他workspace，你也可以继续正常使用那些插件。</p>\n<h2 id=\"5-4-使用git跟踪你的代码修改\"><a href=\"#5-4-使用git跟踪你的代码修改\" class=\"headerlink\" title=\"5.4. 使用git跟踪你的代码修改\"></a>5.4. 使用git跟踪你的代码修改</h2><details>\n    <summary>展开查看</summary>\n\n<blockquote>\n<p>如果你从没用过git，需要先配置用户名和邮箱。这个用户名和邮箱不是登陆什么网站用的，而是一个签名，在提交代码时用于标记这段代码是谁提交的。这个配置存在你电脑的本地，并且是<strong>全局</strong>的，对所有git仓库都有效。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;Jayant.Tang&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;jayant.tang@nordicsemi.no&quot;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>新建的工程都会自动初始化git仓库，我们可以看到.gitignore文件：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027155922698-1731044874930-31.webp\" alt=\"image-20231027155922698\"></p>\n<p>你可以把<code>.vscode/</code>添加到其中</p>\n<p>如果你不熟悉Git以及Git在VS Code中的使用，强烈建议去学习一下，它极大的方便了代码的管理。</p>\n<p>例如：如果安装了git history插件，就可以查看提交历史：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221122235338251-1731044874930-32.webp\" alt=\"image-20221122235338251\"></p>\n<p>Git History提供了很方便的视图，可以看到每次commit都改动了哪些代码和配置（左侧是旧的，右侧是新的）：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221122235416865-1731044874930-33.webp\" alt=\"image-20221122235416865\"></p>\n<p>​\t更多Git的使用，可以去网上了解其他教程。本文不再赘述。</p>\n</details>\n\n<h1 id=\"6-编译工程\"><a href=\"#6-编译工程\" class=\"headerlink\" title=\"6. 编译工程\"></a>6. 编译工程</h1><h2 id=\"6-1-创建一个编译目标（Build-Target）\"><a href=\"#6-1-创建一个编译目标（Build-Target）\" class=\"headerlink\" title=\"6.1. 创建一个编译目标（Build Target）\"></a>6.1. 创建一个编译目标（Build Target）</h2><p>所谓编译目标就是在同一套代码下，可能有不同的配置项（Debug&#x2F;Release，不同的优化级别等等），编译出不同的可执行文件。一个项目下可以创建多个编译目标。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205014115409.webp\" alt=\"image-20250205014115409\"></p>\n<h3 id=\"Toolchain和SDK版本\"><a href=\"#Toolchain和SDK版本\" class=\"headerlink\" title=\"Toolchain和SDK版本\"></a>Toolchain和SDK版本</h3><p>在build界面设置Toolchain和SDK版本：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205022811532.webp\" alt=\"image-20250205022811532\"></p>\n<blockquote>\n<p>目前在Build界面设置，可以让同一个工程用不同的环境进行编译，测试区别。之前的VS Code版本，是在Welcome界面全局设置Toolchain和SDK版本。注意这个改动比较大。</p>\n</blockquote>\n<h3 id=\"Board-Target\"><a href=\"#Board-Target\" class=\"headerlink\" title=\"Board Target\"></a>Board Target</h3><p>创建Build时，需要选择自己使用的板子，Zephyr自带许多厂商的开发板配置。</p>\n<p>下图中，Board target下拉框是用来选板子的，下方还有三个<strong>过滤器</strong>，来过滤可选的板子：</p>\n<ul>\n<li><p>Compatible boards：本例程适配的板子，如果选择这些板子，<strong>不需要任何修改就可以烧录进去使用</strong></p>\n</li>\n<li><p>Nordic SoC：使用了Nordic SoC的板子，可能是一些demo板或第三方板子</p>\n</li>\n<li><p>Nordic Kits：Nordic 出品的官方开发板</p>\n</li>\n<li><p>All boards：Zephyr中所有的板子</p>\n</li>\n</ul>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205023002380.webp\" alt=\"image-20250205023002380\"></p>\n<blockquote>\n<p>Zephyr Board target 配置的命名规则：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205023618902.webp\" alt=\"image-20250205023618902\"></p>\n<p>例如：<code>nrf52840dk/nrf52840</code>，是说这个target是为 nRF52840DK 这块开发板上的 nrf52840 这颗 MCU 创建的。Board Target的配置文件会记录这个MCU的外设地址，以及此MCU连接的外部硬件的信息（如SPI Flash）。</p>\n<p>例如：<code>nrf9160dk/nrf9160</code>和<code>nrf9160dk/nrf52840</code>，都是nRF9160DK这块开发板的配置。但是这块开发板上有两颗MCU&#x2F;SoC，一颗是9160 SiP，另一颗是52840。所以有两个配置可选，分别为这两颗MCU&#x2F;SoC编译固件。</p>\n<p>例如：<code>nrf5340dk/nrf5340/cpuapp</code>和<code>nrf5340dk/nrf5340/cpunet</code>，都是nrf5340dk这块板子的配置，并且这块板子上只有nRF5340这一颗主控。但是nRF5340是一颗双核MCU，所以，可以有两种配置来区分两个核。这两个核的固件是分开运行的，因此编译时也是分别编译的。</p>\n<p>例如：<code>nrf5340dk/nrf5340/cpuapp</code>和<code>nrf5340dk/nrf5340/cpuapp/ns</code>，都是nrf5340dk开发板上，nrf5340芯片的应用核的配置。但是，这颗应用核使用的CPU是Cortex-M33，基于Arm V8架构，提供了TrustZone的安全保护技术，同样的一个外设寄存器，可以有安全（Secure）和非安全（Non-Secure）两个地址，这样可以把安全应用和非安全应用隔离开来。因此，这两个board配置的不同之处，就是从安全地址还是非安全地址去访问芯片上的外设资源。</p>\n<p>例如：<code>nrf52833dk/nrf52820</code>。这块开发板上只有nrf52833这一块主控。但是由于nRF52833和nRF52820同属nRF52系列，52820上的资源是52833的子集，并且Nordic并未单独为52820制作开发板，因此可以用52833来模拟52820。此配置文件限制了52833上的硬件资源，使其表现和52820相同。</p>\n<p>更详细的信息牵扯到DeviceTree，可参考：<a href=\"https://www.cnblogs.com/jayant97/articles/17794813.html\">《理解Zephyr编译与配置系统》</a>有关Boards的章节。</p>\n<p>NCS v2.6.x之前，采用的是根据SoC架构来分类板子的方式，那时候板子名称都是独立的，用下划线连接：如<code>nrf52840dk_nrf52840</code>。</p>\n<p>NCS v2.7.0开始，采用了Zephyr Hardware Model v2，才产生这个区别。</p>\n<p>在CMake中，有以下变量可以获取板子信息：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;<span class=\"comment\"># Board name,如nrf52840dk</span></span><br><span class=\"line\">&gt;<span class=\"variable\">$&#123;BOARDS&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;<span class=\"comment\"># Board qualifiers，如/nrf5340/cpuapp</span></span><br><span class=\"line\">&gt;<span class=\"variable\">$&#123;BOARD_QUALIFIERS&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;<span class=\"comment\"># 完整的Board target，如nrf5340dk/nrf5340/cpuapp</span></span><br><span class=\"line\">&gt;<span class=\"variable\">$&#123;BOARDS&#125;</span><span class=\"variable\">$&#123;BOARD_QUALIFIERS&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;<span class=\"comment\"># 转换为下划线的格式，如nrf5340dk_nrf5340_cpuapp</span></span><br><span class=\"line\">&gt;<span class=\"variable\">$&#123;NORMALIZED_BOARD_TARGET&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>各种配置文件、追加配置文件，可参考<a href=\"https://www.cnblogs.com/jayant97/articles/17794813.html\">《理解Zephyr编译与配置系统》</a>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205025318126.webp\" alt=\"image-20250205025318126\"></p>\n<h3 id=\"编译选项\"><a href=\"#编译选项\" class=\"headerlink\" title=\"编译选项\"></a>编译选项</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205025414518.webp\" alt=\"image-20250205025414518\"></p>\n<p>可以设置Build目录，优化等级等等。Sysbuild可参考<a href=\"https://www.cnblogs.com/jayant97/articles/17794813.html\">《理解Zephyr编译与配置系统》</a>，v2.7.0后默认使用sysbuild。</p>\n<h2 id=\"6-2-进行编译\"><a href=\"#6-2-进行编译\" class=\"headerlink\" title=\"6.2. 进行编译\"></a>6.2. 进行编译</h2><blockquote>\n<p>【注意】NCS v2.9.x在<strong>中文Windows系统</strong>上有个编码Bug，v3.0.0之后已经修复。编译会报错：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CMake Error at C:/ncs/v2.<span class=\"number\">9.0</span>/zephyr/cmake/modules/boards.cmake:<span class=\"number\">196</span> (message):</span><br><span class=\"line\">  Error finding board: nrf52840dk</span><br><span class=\"line\"></span><br><span class=\"line\">  Error message: Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">    File <span class=\"string\">&quot;C:\\ncs\\v2.9.0\\zephyr\\scripts\\list_boards.py&quot;</span>, line <span class=\"number\">469</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">      dump_v2_boards(args)</span><br><span class=\"line\">    File <span class=\"string\">&quot;C:\\ncs\\v2.9.0\\zephyr\\scripts\\list_boards.py&quot;</span>, line <span class=\"number\">416</span>, <span class=\"keyword\">in</span> dump_v2_boards</span><br><span class=\"line\">      boards = find_v2_boards(args)</span><br><span class=\"line\">               ^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">    File <span class=\"string\">&quot;C:\\ncs\\v2.9.0\\zephyr\\scripts\\list_boards.py&quot;</span>, line <span class=\"number\">341</span>, <span class=\"keyword\">in</span> find_v2_boards</span><br><span class=\"line\">      b, e = load_v2_boards(args.board, board_yml, systems)</span><br><span class=\"line\">             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class=\"line\">    File <span class=\"string\">&quot;C:\\ncs\\v2.9.0\\zephyr\\scripts\\list_boards.py&quot;</span>, line <span class=\"number\">230</span>, <span class=\"keyword\">in</span> load_v2_boards</span><br><span class=\"line\">      b = yaml.load(f.read(), Loader=SafeLoader)</span><br><span class=\"line\">                    ^^^^^^^^</span><br><span class=\"line\"></span><br><span class=\"line\">  UnicodeDecodeError: <span class=\"string\">&#x27;gbk&#x27;</span> codec can<span class=\"string\">&#x27;t decode byte 0xa2 in position 46:</span></span><br><span class=\"line\"><span class=\"string\">  illegal multibyte sequence</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Call Stack (most recent call first):</span></span><br><span class=\"line\"><span class=\"string\">  cmake/modules/sysbuild_default.cmake:15 (include)</span></span><br><span class=\"line\"><span class=\"string\">  C:/ncs/v2.9.0/zephyr/share/zephyr-package/cmake/ZephyrConfig.cmake:75 (include)</span></span><br><span class=\"line\"><span class=\"string\">  C:/ncs/v2.9.0/zephyr/share/zephyr-package/cmake/ZephyrConfig.cmake:92 (include_boilerplate)</span></span><br><span class=\"line\"><span class=\"string\">  C:/ncs/v2.9.0/zephyr/share/sysbuild-packag</span></span><br></pre></td></tr></table></figure>\n\n<p>需要修改<code>v2.9.0\\zephyr\\scripts\\list_boards.py</code>。否则无法编译。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> board_yml.<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br></pre></td></tr></table></figure>\n\n<p>改为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> board_yml.<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>新建完build target后，点击Build Configuration进行编译。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205031140383.webp\" alt=\"image-20250205031140383\"></p>\n<p>如果后续要再次编译这个target，可以在APPLICATIONS栏选中自己要构建的工程和target。然后在ACTIONS栏通过build<strong>按钮</strong>进行项目的构建。</p>\n<blockquote>\n<p>按Build旁的圆圈箭头按钮，可以全部重新编译。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205031114268.webp\" alt=\"image-20250205031114268\"></p>\n<h2 id=\"6-3-命令行编译\"><a href=\"#6-3-命令行编译\" class=\"headerlink\" title=\"6.3. 命令行编译\"></a>6.3. 命令行编译</h2><p>补充：命令行编译</p>\n<p>按 “ CTRL + &#96; “，可以呼出终端。点击“+”号右边的下拉箭头，选择nRF Connect：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027161338719-1731044874931-36.webp\" alt=\"image-20231027161338719\"></p>\n<p>这样打开的终端，其环境变量指向前面安装的toolchain。</p>\n<p>编译命令示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -b nrf52840dk/nrf52840 -d build -p -- -DCONF_FILE=<span class=\"string\">&quot;prj.conf&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># -d 指定编译目录为./build</span></span><br><span class=\"line\"><span class=\"comment\"># -b 板子为nrf52840dk/nrf52840</span></span><br><span class=\"line\"><span class=\"comment\"># -p 表示pristine build,全部重新编译。</span></span><br><span class=\"line\"><span class=\"comment\"># 在--之后可以添加CMake选项。如-D表示设置CMake变量。</span></span><br><span class=\"line\"><span class=\"comment\">#   -DCONF_FILE等价于在CMakeLists.txt中写 set(CONF_FILE prj.conf)</span></span><br><span class=\"line\"><span class=\"comment\">#   更多CMake配置文件选项，参考https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/cmake/index.html#providing_cmake_options</span></span><br></pre></td></tr></table></figure>\n\n<p>更多用法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -h</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-4-编译输出文件\"><a href=\"#6-4-编译输出文件\" class=\"headerlink\" title=\"6.4. 编译输出文件\"></a>6.4. 编译输出文件</h2><p>一个工程可能有多个固件，这里以Matter窗帘举例。有Bootloader和application。</p>\n<p>这里选中哪个子工程，看的就是哪个子工程的输出。如window_covering就是appilcation子工程。然后下方output files就可以看到输出文件。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512172148831.png\" alt=\"image-20250512172148831\"></p>\n<p>其中比较重要的：</p>\n<ul>\n<li><code>.config</code>是所有配置项合并后的最终配置列表。当你想确认某个配置是否真的打开&#x2F;关闭了，可以查看这个文件</li>\n<li><code>zephyr.dts</code>是所有设备树文件合并后的最终设备树。当你想确认某个节点最终配置是什么，可以查看这个文件</li>\n<li><code>merged.hex</code>：application + bootloader的合并固件。</li>\n<li><code>zephyr.elf</code>：单独application的固件，并含有调试信息。在它同一目录下，有<code>zephyr.hex</code>是纯固件。</li>\n</ul>\n<h2 id=\"6-5-内核一览\"><a href=\"#6-5-内核一览\" class=\"headerlink\" title=\"6.5. 内核一览\"></a>6.5. 内核一览</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512172921895.png\" alt=\"image-20250512172921895\"></p>\n<p>目前Core overview可以看到初始化级别和已经使能的中断。</p>\n<h3 id=\"Initialization-levels\"><a href=\"#Initialization-levels\" class=\"headerlink\" title=\"Initialization levels\"></a>Initialization levels</h3><p>Zephyr系统中，在main函数之前，会有5个级别的初始化等级。在这些不同的初始化等级时，会执行不同的函数，例如各种外设驱动的初始化、内核服务的初始化等。在这里可以看到这些函数的执行顺序，以及它们被定义的位置。</p>\n<h3 id=\"Enabled-Interrupts\"><a href=\"#Enabled-Interrupts\" class=\"headerlink\" title=\"Enabled Interrupts\"></a>Enabled Interrupts</h3><p>可以看到哪些硬件中断被打开了。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250512173232076.png\" alt=\"image-20250512173232076\"></p>\n<h1 id=\"7-连接设备\"><a href=\"#7-连接设备\" class=\"headerlink\" title=\"7. 连接设备\"></a>7. 连接设备</h1><p>nrf-connect插件，底层调用的是<code>nrfjprog</code>或<code>nrfutil</code>命令来连接开发板上的JLink。因此，需要通过USB线连接到JLink口。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209144123203-1731044874931-37.webp\" alt=\"image-20221209144123203\"></p>\n<p>以nRF52840DK为例，中间最大的带有贴纸的芯片为JLink主控（官方称其为Interface MCU），左侧为JLink USB口，此接口可以用来给整块板供电。</p>\n<p>需确保左下角电源开关打开。左侧中间位置的开关置于VDD挡位，右上角开关置于DEFAULT挡位（如上图）。</p>\n<p>对于一些有多颗MCU的开发板，注意要使用拨码开关选择自己要调试的MCU，例如nRF9160DK可选择9160和52840：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209153801993-1731044874931-38.webp\" alt=\"image-20221209153801993\"></p>\n<p>​\t然后就可以在VS Code中识别到设备了：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209144833292-1731044874931-39.webp\" alt=\"image-20221209144833292\"></p>\n<h1 id=\"8-烧录固件\"><a href=\"#8-烧录固件\" class=\"headerlink\" title=\"8. 烧录固件\"></a>8. 烧录固件</h1><p>连接并成功识别到Jlink后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221123160139273-1731044874934-42.webp\" alt=\"image-20221123160139273\"></p>\n<p>​\t也可以通过命令行进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west flash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：\t</p>\n<p>这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221123160245857-1731044874934-43.png\" alt=\"image-20221123160245857\"></p>\n<p>这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。相关资料，可以参考Nordic芯片数据手册的UICR章节。</p>\n<p>这种情况下只能全片擦除然后再烧录，点击Flash右边的按钮：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221123160832598-1731044874935-44.webp\" alt=\"image-20221123160832598\"></p>\n<p>或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west flash --force --erase</span><br></pre></td></tr></table></figure>\n\n<p>此外，还有一种可能是，调试接口启用了保护，需要recover这颗芯片来解除保护。</p>\n<p>通常，右下角会有弹窗来问你是否要recover，就选择Yes就好。</p>\n<p>如果没有效果，也可以用命令行来recover</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrfutil device recover</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">nrfjprog --recover</span><br></pre></td></tr></table></figure>\n\n<p>如果是nRF5340这种双核芯片，那么网络核也要recover</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrfutil device recover --core Application</span><br><span class=\"line\">nrfutil device recover --core Network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">nrfjprog --recover --coprocessor CP_APPLICATION,</span><br><span class=\"line\">nrfjprog --recover --coprocessor CP_NETWORK</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"9-运行并测试\"><a href=\"#9-运行并测试\" class=\"headerlink\" title=\"9. 运行并测试\"></a>9. 运行并测试</h1><p>连接的设备，可以看到Jlink上的主控芯片、串口以及RTT。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028103135931-1731044874935-45.webp\" alt=\"image-20231028103135931\"></p>\n<p>这里的串口是MCU上真实的物理串口，在开发板上通过PCB走线连接到Jlink，然后Jlink把这个串口转化为USB虚拟串口。</p>\n<blockquote>\n<p>新款开发板，板载的Jlink是拿5340做的，这种新款开发板有两个USB虚拟串口：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027164658632-1731044874935-46.webp\" alt=\"image-20231027164658632\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027163914699-1731044874935-47.webp\" alt=\"image-20231027163914699\"></p>\n<p>但是对于52840DK来说，开发板上只连了一个串口，另一个是空的。具体是哪个？要试一下，因为可能USB枚举的顺序不一样。</p>\n<p>对于5340DK, 7002DK来说，两个串口分别对应Application Core和Network Core的日志输出。</p>\n</blockquote>\n<h2 id=\"9-2-连接串口\"><a href=\"#9-2-连接串口\" class=\"headerlink\" title=\"9.2. 连接串口\"></a>9.2. 连接串口</h2><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209154745021-1731044874935-48.webp\" alt=\"image-20221209154745021\"></p>\n<p>​\t点击串口，选择波特率，即可打开串口。串口<strong>接收</strong>的信息在Terminal展示：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231027162835862-1731044874935-49.webp\" alt=\"image-20231027162835862\"></p>\n<blockquote>\n<p>这个串口工具类似于Putty，按下键盘的按键就立即发送出去一个字符，不会显示自己发出了什么。便于在这个串口上运行命令行终端之类的，这也是Zephyr所支持的。</p>\n</blockquote>\n<h2 id=\"9-3-连接RTT\"><a href=\"#9-3-连接RTT\" class=\"headerlink\" title=\"9.3. 连接RTT\"></a>9.3. 连接RTT</h2><p>RTT是Segger提供的日志调试手段，全称Real Time Transmit。MCU将日志打印到内部缓存中，然后利用Jlink的高速通道，把日志打印到电脑上。这个方法不需要占用串口外设，而且速度极快，对CPU运行影响小。</p>\n<blockquote>\n<p><strong>大多数例程的默认日志输出是串口</strong>。但本例程是蓝牙串口透传，串口需要传输用户数据，因此在本例程中日志的默认输出就已经是RTT了，无需再配置RTT。</p>\n<p>要查看RTT日志输出的相关配置，打开工程根目录下的<code>.prj</code>文件：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209161912543-1731044874935-50.webp\" alt=\"image-20221209161912543\"></p>\n<p>可以看到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_LOG=y                 <span class=\"comment\"># 启用日志系统</span></span><br><span class=\"line\">CONFIG_USE_SEGGER_RTT=y      <span class=\"comment\"># 启用RTT驱动</span></span><br><span class=\"line\">CONFIG_LOG_BACKEND_RTT=y     <span class=\"comment\"># 日志后端选用RTT</span></span><br><span class=\"line\">CONFIG_LOG_BACKEND_UART=n    <span class=\"comment\"># 日志后端不选用串口</span></span><br><span class=\"line\">CONFIG_LOG_PRINTK=n          <span class=\"comment\"># PRINTK不从LOG输出（而是从console输出）</span></span><br></pre></td></tr></table></figure>\n\n</blockquote>\n<p>如下图连接RTT：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20221209170245563-1731044874935-51.webp\" alt=\"image-20221209170245563\"></p>\n<h2 id=\"9-4-测试peripheral-uart例程\"><a href=\"#9-4-测试peripheral-uart例程\" class=\"headerlink\" title=\"9.4. 测试peripheral_uart例程\"></a>9.4. 测试peripheral_uart例程</h2><p>一般来说，需要两块开发板，一块烧<code>peripheral_uart</code>，一块烧<code>central_uart</code>。两块开发板上电后会自动连接。从一个开发板串口输入的数据，会从另一个开发板输出。</p>\n<p>但是这里我们只有一块开发板，那么BLE central我们就用手机。iOS应用商店可以下载<code>nRF Connect</code>，安卓可以在谷歌商店下载，或者直接去Github下载<a href=\"https://github.com/NordicSemiconductor/Android-nRF-Connect/releases\">APK</a>。</p>\n<h3 id=\"通过BLE连接设备\"><a href=\"#通过BLE连接设备\" class=\"headerlink\" title=\"通过BLE连接设备\"></a>通过BLE连接设备</h3><p>在nRF Connect APP中，先scan搜索附近蓝牙。scan按钮一开始是三角形，点击开始扫描后，变成方形。<br>扫到设备后，再连接：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028104626601-1731044874935-52.webp\" alt=\"image-20231028104626601\"></p>\n<h3 id=\"开发板接收数据\"><a href=\"#开发板接收数据\" class=\"headerlink\" title=\"开发板接收数据\"></a>开发板接收数据</h3><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028104717740-1731044874936-53.webp\" alt=\"image-20231028104717740\"></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028104734696-1731044874936-54.webp\" alt=\"image-20231028104734696\"></p>\n<p>可以在串口看到数据：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028104845188-1731044874936-55.webp\" alt=\"image-20231028104845188\"></p>\n<h3 id=\"开发板发送数据\"><a href=\"#开发板发送数据\" class=\"headerlink\" title=\"开发板发送数据\"></a>开发板发送数据</h3><p>BLE协议是Client-Server架构。BLE协议规定，从机作为Server，只能被Client读、写上面的属性。默认情况下不能主动发消息到Client。除非Client使能了Notify的功能，Server才能Nortify到Client。更多信息，大家可以搜索CCCD(Client Characteristic Configuration Descriptor)。这里，就需要点亮TX属性的CCCD：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028105348055-1731044874936-56.webp\" alt=\"image-20231028105348055\"></p>\n<p>然后在串口中通过键盘输入内容：hello+回车。屏幕上不会显示东西，但是按键确实会发送出去。</p>\n<blockquote>\n<p>这个串口工具类似于Putty，按下键盘的按键就立即发送出去一个字符，不会在屏幕上显示自己发出了什么。</p>\n<p>这里之所以要加回车，是因为例程代码就是这么写的。在串口回调函数内，检测到回车，才会把串口数据打包从蓝牙发出。</p>\n</blockquote>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028105643833-1731044874936-57.webp\" alt=\"image-20231028105643833\"></p>\n<p>至此，我们完成了在nRF52840DK上的<code>peripheral_uart</code>例程的编译、烧录与运行测试。</p>\n<h1 id=\"10-阅读代码、跳转与搜索\"><a href=\"#10-阅读代码、跳转与搜索\" class=\"headerlink\" title=\"10. 阅读代码、跳转与搜索\"></a>10. 阅读代码、跳转与搜索</h1><p>当一个工程编译完毕后，工程中的函数与变量、Kconfig配置、设备树都是可以ctrl+鼠标左键点击跳转到定义的。为了能够跳转和搜索到SDK中的代码，记得按照前面第5.2小节的方法，把NCS和当前工程添加到同一个Workspace中。</p>\n<p>然后，就可以在nRF插件中进行浏览了：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20241029123918141-1203491295.webp\" alt=\"image\"></p>\n<p>Source File中是所有参与编译的源码。其中Application下的是当前工程中的源码；nRF Connect SDK下的是NCS中参与编译的源码（不参与编译的不会在里面）；Generated下是工具链自动生成的一些代码（中断向量表、Kconfig转换成宏等等)。</p>\n<p>由于我们前面已经把SDK放进了VS Code workspace，所以可以直接搜索代码：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20241029124509412-1982218675.webp\" alt=\"image\"></p>\n<p>点击上面的搜索按钮后，会自动跳转到VS Code搜索界面，并且已经自动填充好文件搜索范围：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20241029124636177-436976402.webp\" alt=\"image\"></p>\n<p>在浏览和搜索的过程中，时刻注意自己选中的是整个工程的Build Target还是子工程的Build Target</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205032032135.webp\" alt=\"image-20250205032032135\"></p>\n<p>以免影响后续的编译情况。</p>\n<h1 id=\"11-官方资料\"><a href=\"#11-官方资料\" class=\"headerlink\" title=\"11. 官方资料\"></a>11. 官方资料</h1><h2 id=\"Nordic-TechDocs资料中心\"><a href=\"#Nordic-TechDocs资料中心\" class=\"headerlink\" title=\"Nordic TechDocs资料中心\"></a>Nordic TechDocs资料中心</h2><p><a href=\"https://docs.nordicsemi.com/\">https://docs.nordicsemi.com/</a></p>\n<p>目前最新的资料中心，可以通过技术或产品系列进行分类，查找想要的资料。芯片数据手册（Specification）、开发板说明都可以在这里查看。<br><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20240618103459443-1837528620.webp\" alt=\"image\"></p>\n<p><strong>记得进入NCS文档后，第一步先选择文档的版本与自己使用的NCS版本一致：</strong><br><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3028998-20241029114423094-1941812085.webp\" alt=\"image\"></p>\n<p>从2024.6.18开始，NCS官网和Infocenter都会下线。所有开发资料都会集中在TechDocs。上图中我们可以看到，除了各个产品系列的介绍之外，下方有nRF Connect SDK和老的nRF5 SDK的资料，点击跳转进去即可。</p>\n<p>关于文档的结构，可以展开下面章节中被折叠的信息来了解。</p>\n<h2 id=\"NCS官网\"><a href=\"#NCS官网\" class=\"headerlink\" title=\"NCS官网\"></a>NCS官网</h2><p><strong>此网站已于2024.6.18被Nordic资料中心替代</strong></p>\n<details>\n    <summary>展开查看</summary>\n\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html\">https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html</a></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028162512499-1731044874936-58.webp\" alt=\"image-20231028162512499\"></p>\n<p>进入官网，首先看到右上角可以选择文档的版本，需要与SDK的版本对应。</p>\n<p>然后可以看到中间的一排标签页：</p>\n<ul>\n<li><p><strong>Zephyr Project</strong>：是<a href=\"https://docs.zephyrproject.org/latest/index.html\">Zephyr官方文档</a>的一个镜像，包含Zephyr RTOS内核服务、操作系统API、各种驱动、协议支持以及它们的例程文档。一些比较通用的功能的如日志、Flash存储、线程间通信等功能的文档都在这里面。它对应的是NCS中的<code>zephyr</code>文件夹。</p>\n</li>\n<li><p><strong>nRF Connect SDK:</strong> 是Nordic在Zephyr系统上扩展的各种Nordic独有的库、驱动和例程的文档。里面大多数是一些Nordic独有的技术，对应的是NCS中的<code>nrf</code>文件夹。</p>\n</li>\n<li><p><strong>nrfx与nrfxlib</strong>：Nordic的外设驱动库，是最接近寄存器操作的一层，和目前已经停止维护的的nRF5 SDK中的nrfx几乎是一样的。在Zephyr中，通常应用层只需调用Zephyr的标准API，Nordic提供的底层驱动会把nrfxlib和一些寄存器操作封装成Zephyr的标准API。通常，只有客户在对MCU外设功能进行较为深入的开发时，会参考到这一块的文档。</p>\n</li>\n<li><p><strong>MCUboot</strong>：MCUboot是一个开源的第三方安全bootloader，支持很多系统和平台，Zephyr只是其中之一。很多支持OTA的例程基本都是使用MCUboot</p>\n</li>\n<li><p><strong>Trust Firmware-M</strong>：ARM提出了<strong>平台安全架构（Platform Security Architecture, PSA）</strong>，意思就是说，客户自己开发软件容易有安全漏洞，因此运行环境应分为<strong>安全环境（SPE）</strong>和<strong>非安全环境（NSPE）</strong>。客户开发的程序，属于非安全环境。安全环境的程序，由厂商提供，主要提供一些安全存储、安全启动之类的API给客户的非安全环境来调用。Trust Firmware-M(TFM)是安全环境的一个样板固件。 如果你使用了nRF5340或者nRF9160这种带有ARM v8架构的主控平台，则在编译选板子时，都可以看到<code>_s</code>或<code>_ns</code>后缀。<code>_s</code>的意思是说，客户直接在安全环境开发程序，安全性全由客户自己掌控。<code>_ns</code>的意思是说，客户在非安全环境开发程序，编译时，Zephyr会自动把TFM一起编译进去，和客户的应用程序一起工作。对于9160来说，由于要和蜂窝modem进行交互，因此，牵扯到蜂窝网络操作的例程，都必须选择<code>nrf9160dk_nrf9160_ns</code>。</p>\n</li>\n<li><p><strong>Matter</strong>：Matter是智能家居的新标准，目的是打破厂商之间的壁垒，实现生态融合。从连接方式上讲，Matter是基于局域网IPv6的，因此，Wi-Fi和Thread都是可以作为Matter的底层的。从配网方式上讲，Matter通过BLE来传输认证信息，此外可以通过NFC或者二维码的方式，让手机快速的找到要配网的这个设备的BLE广播。此页面主要是Matter SDK的文档，并不局限于在Nordic MCU上进行开发。如果要找Matter在Nordic产品上运行的例程，还是要去nRF Connect SDK页面的Samples目录下去寻找。</p>\n</li>\n<li><p><strong>Kconfig</strong>：Zephyr系统中有大量的Kconfig配置，Nordic扩展的库、驱动中也有大量Kconfig配置。如果你不知道一个Kconfig配置是干什么的，可以在这个页面进行搜索。</p>\n</li>\n</ul>\n<p>总之，NCS官网里面有大量的技术细节，在运行一个例程之前，一定要参照网站中该例程的说明进行操作。</p>\n</details>\n\n<h2 id=\"Nordic旧版资料中心-Info-Center\"><a href=\"#Nordic旧版资料中心-Info-Center\" class=\"headerlink\" title=\"Nordic旧版资料中心(Info Center)\"></a>Nordic旧版资料中心(Info Center)</h2><p><strong>此网站已于2024.6.18被Nordic资料中心替代</strong><br>如果要查询老的nRF5 SDK资料，看：<a href=\"https://docs.nordicsemi.com/bundle/sdk_nrf5_v17.1.0/page/index.html\">https://docs.nordicsemi.com/bundle/sdk_nrf5_v17.1.0/page/index.html</a></p>\n<details>\n    <summary>展开查看</summary>\nhttps://infocenter.nordicsemi.com/index.jsp\n![](https://img2024.cnblogs.com/blog/3028998/202406/3028998-20240618103019099-1297214744.png)\n也可以下载到芯片数据手册（Specification）、开发板说明、技术白皮书等。这里也有目前已停止维护的nRF5 SDK的文档。\n</details>\n\n\n\n<h2 id=\"Nordic官网\"><a href=\"#Nordic官网\" class=\"headerlink\" title=\"Nordic官网\"></a>Nordic官网</h2><p><a href=\"https://www.nordicsemi.com/\">https://www.nordicsemi.com/</a></p>\n<p>一些商业新闻和产品介绍。但是最重要的是一些<strong>工具软件</strong>、<strong>开发板原理图&#x2F;PCB&#x2F;BOM</strong>之类，需要在这里下载。</p>\n<p>例如：</p>\n<p><strong>nRF52840DK开发板默认例程、Jlink固件、原理图等</strong>：<a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF52840-DK/Download?lang=en#infotabs\">https://www.nordicsemi.com/Products/Development-hardware/nRF52840-DK/Download?lang=en#infotabs</a></p>\n<h2 id=\"DevZone开发者论坛\"><a href=\"#DevZone开发者论坛\" class=\"headerlink\" title=\"DevZone开发者论坛\"></a>DevZone开发者论坛</h2><p><a href=\"https://devzone.nordicsemi.com/\">https://devzone.nordicsemi.com/</a></p>\n<p>有问题可以在上面搜索，也可以用英文提问。每天都有原厂support team查看问题并回复。Nordic注册客户，还可以提交private ticket，解决一些与代码、板子有关的问题，也可以审核PCB。</p>\n<h2 id=\"Nordic-AI\"><a href=\"#Nordic-AI\" class=\"headerlink\" title=\"Nordic AI\"></a>Nordic AI</h2><p>TechDoc和DevZone网站右下角都有Ask AI按钮：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205032231322.webp\" alt=\"image-20250205032231322\"></p>\n<p>AI训练了所有的Nordic官网资料，以及DevZone论坛中的帖子。可以用中文问他：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250205032554493.webp\" alt=\"image-20250205032554493\"></p>\n<h2 id=\"Nordic-DevAcademy官方课程\"><a href=\"#Nordic-DevAcademy官方课程\" class=\"headerlink\" title=\"Nordic DevAcademy官方课程\"></a>Nordic DevAcademy官方课程</h2><p><a href=\"https://academy.nordicsemi.com/\">https://academy.nordicsemi.com/</a></p>\n<p>类似于慕课的网站，目前有NCS，BLE、Wi-Fi、Cellular等课程。有视频结合题目，适合英文好的读者去学习，是非常适合入门的课程。</p>\n<h1 id=\"12-其他推荐阅读\"><a href=\"#12-其他推荐阅读\" class=\"headerlink\" title=\"12. 其他推荐阅读\"></a>12. 其他推荐阅读</h1><ul>\n<li><a href=\"https://www.cnblogs.com/jayant97/articles/17794813.html\">理解Zephyr编译与配置系统</a></li>\n<li><a href=\"https://www.cnblogs.com/jayant97/articles/17209392.html\">详解Zephyr设备树（DeviceTree）与驱动模型</a></li>\n<li><a href=\"https://www.cnblogs.com/jayant97/articles/17828907.html\">Zephyr设备树与驱动应用实战——串口</a></li>\n<li><a href=\"https://www.cnblogs.com/jayant97/articles/17835258.html\">不想用Zephyr DeviceTree？试试nrfx API</a></li>\n</ul>\n","categories":["Nordic","NCS"],"tags":["Nordic","NCS"]},{"title":"搭建自己的静态博客并自动部署","url":"/jayant97.github.io/2022/12/b42baba50896/","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>本文讲解本博客的搭建方式</p>\n<table>\n<thead>\n<tr>\n<th>部件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://hexo.io/zh-cn/\">Hexo</a></td>\n<td>把.md文章转换为页面，并且快速部署到平台</td>\n</tr>\n<tr>\n<td>GitHub Pages</td>\n<td>提供从GitHub仓库创建网站的服务</td>\n</tr>\n<tr>\n<td>GitHub Actions</td>\n<td>GitHub提供的免费持续集成服务</td>\n</tr>\n</tbody></table>\n<h2 id=\"Hexo-Github-Pages\"><a href=\"#Hexo-Github-Pages\" class=\"headerlink\" title=\"Hexo + Github Pages\"></a>Hexo + Github Pages</h2><p>先从简单的讲起，看图：</p>\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202224730111.png\" alt=\"image-20221202224730111\" style=\"zoom: 50%;\" />\n\n<p>简而言之：</p>\n<ul>\n<li>Hexo是一个博客框架，存放在你的电脑上，能把你的markdown文章转换成网站源码，并存入一个git仓库</li>\n<li>Github Pages是GitHub提供的免费静态网站服务，能让你展示文档。你只需要把网站源码存入一个repository，并且启用这个服务，GitHub就会帮你建一个静态网站，分配一个网址。别人从这个网址就能看到你的博客了。</li>\n<li>Hexo能一键把本地的网站源码推送到GitHub，让GitHub自动将其部署为Pages</li>\n</ul>\n<h2 id=\"GitHub-Actions\"><a href=\"#GitHub-Actions\" class=\"headerlink\" title=\"GitHub Actions\"></a>GitHub Actions</h2><p>​    前面的方法，网站所有的资源都存在本地，除了markdown文章和图片这种<strong>资源文件</strong>以外，网站的<strong>美化主题</strong>、<strong>配置</strong>等也存在本地。</p>\n<p>​    这会产生几个问题：</p>\n<ul>\n<li><p>数据容易丢失，一旦硬盘损坏，你的博客就灰飞烟灭了</p>\n</li>\n<li><p>只能在一台电脑上写文章，多台电脑之间hexo文件夹不好同步</p>\n</li>\n<li><p>网站的配置文件修改，没有历史记录追踪</p>\n</li>\n<li><p>由于网站的美化主题本身就是Github上的项目，每次要手动更新，很麻烦</p>\n</li>\n<li><p>每次写完文章，都要用hexo命令生成网站，还要用hexo命令部署网站，重复操作</p>\n</li>\n</ul>\n<p>​    所以，<strong>最好把hexo文件夹本身也当作Git项目，并放在GitHub托管</strong>。并且，还要把hexo部署的操作给自动化，让我们每次写完markdown文章，一 Push 就能自动部署页面。</p>\n<p>​    这就要用到GitHub Actions，它是GitHub提供的<strong>持续集成</strong>（Continuous integration， CI）服务。这里不详述CI&#x2F;CD的概念，你只需要知道，GitHub提供的这个服务，可以让你的仓库在特定条件下（例如push时），触发对应的<strong>动作（Actions）</strong>。</p>\n<p>​    所谓的Actions，可以认为就是一条一条的Linux命令（也可以是Windows CMD命令）或者脚本，并且GitHub给你一个虚拟服务器去自动执行这一条一条的命令，这个虚拟服务器具有2核CPU，7GB内存，14GB硬盘。</p>\n<p>​    你可以写自己的Actions，也可以用别人的Actions。Github提供了一个Action商店。</p>\n<p>​    最终的效果应该如下图：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221203224217145.png\" alt=\"image-20221203224217145.png\" style=\"zoom: 50%;\" />\n\n<p>配置完成后的效果：</p>\n<ul>\n<li>写完文章后，直接本地hexo仓库<code>commit</code>，然后<code>push</code></li>\n<li>GitHub上的hexo仓库由<code>push</code>触发Actions，自动在虚拟服务器中生成网站源码，然后部署到网站仓库中</li>\n<li>网站仓库（xxxx.github.io）更新时，自动更新Github Pages</li>\n<li>hexo的美化主题，作为hexo的git submodule，每次push时自动checkout最新分支</li>\n</ul>\n<h1 id=\"2-搭建步骤\"><a href=\"#2-搭建步骤\" class=\"headerlink\" title=\"2. 搭建步骤\"></a>2. 搭建步骤</h1><p>一些简单的步骤就只简略提一下。</p>\n<h2 id=\"2-1-在GitHub创建仓库并启用Pages\"><a href=\"#2-1-在GitHub创建仓库并启用Pages\" class=\"headerlink\" title=\"2.1. 在GitHub创建仓库并启用Pages\"></a>2.1. 在GitHub创建仓库并启用Pages</h2><ol>\n<li>注册一个GitHub账号</li>\n<li>在GitHub创建两个仓库<code>&lt;site_name&gt;.github.io</code>和<code>my-hexo</code><br> 前者是GitHub Pages仓库，命名必须以<code>github.io</code>结尾，后者是hexo仓库，可随意取名。<br> 两个仓库都留空，不创建任何文件。</li>\n<li>然后设置Pages，在<code>&lt;site_name&gt;.github.io</code>仓库中：</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202233043747.png\" alt=\"image-20221202233043747\"></p>\n<p>在仓库的Settings中，选择Pages，下方选择哪个分支的哪个目录被识别为网站的根目录。</p>\n<blockquote>\n<p>GitHub现在的主分支是<code>main</code>而不是<code>master</code>了，我是自己创建了一个<code>master</code>分支，因为我本地的git默认主分支还是master。</p>\n</blockquote>\n<h2 id=\"2-2-本地部署hexo\"><a href=\"#2-2-本地部署hexo\" class=\"headerlink\" title=\"2.2. 本地部署hexo\"></a>2.2. 本地部署hexo</h2><h3 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h3><p>首先安装依赖，需要安装的软件：</p>\n<ul>\n<li><a href=\"https://git-scm.com/\">Git (git-scm.com)</a>：版本管理</li>\n<li><a href=\"https://nodejs.org/en/download/\">Node.js</a>：hexo所需的平台</li>\n</ul>\n<blockquote>\n<p>Windows用户安装时，一定要勾选<code>Add to PATH </code>选项</p>\n</blockquote>\n<p>然后安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm  install -g hexo-cli <span class=\"comment\"># 全局安装</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于Node.js和hexo的版本依赖关系，请参考：<a href=\"https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6\">文档 | Hexo</a></p>\n</blockquote>\n<h3 id=\"初始化hexo\"><a href=\"#初始化hexo\" class=\"headerlink\" title=\"初始化hexo\"></a>初始化hexo</h3><p>找个喜欢的地方创建一个文件夹用于存放hexo项目，例如<code>my-hexo</code>。</p>\n<p>进入这个仓库，然后进行hexo初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> my-hexo &amp;&amp; <span class=\"built_in\">cd</span> my-hexo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化hexo，执行这步之前，需确保文件夹是空的</span></span><br><span class=\"line\">$ hexo init ./</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖的node.js插件</span></span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>hexo初始化要求文件夹为空，因此必须先初始化hexo，再初始化git。否则<code>.git/</code>的存在将导致hexo无法初始化</li>\n<li><code>hexo init</code>时，产生了文件<code>package.json</code>，里面记录了hexo所依赖的npm包的具体来源和版本号</li>\n<li><code>npm install</code>时，就根据<code>package.json</code>记录的内容进行了包的安装。包的具体安装情况记录在<code>package-lock.json</code>中</li>\n</ul>\n</blockquote>\n<p>安装完毕后，目录结构应该如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- _config.landscape.yml  # landscape主题配置文件</span><br><span class=\"line\">|-- _config.yml            # 网站配置文件</span><br><span class=\"line\">|-- node_modules           # node.js插件包</span><br><span class=\"line\">|-- package-lock.json      # node.js插件包记录</span><br><span class=\"line\">|-- package.json           # node.js插件包记录</span><br><span class=\"line\">|-- scaffolds/             # 文章、页面模板文件夹</span><br><span class=\"line\">|-- source/                # 网站静态资源（文章、图片等）</span><br><span class=\"line\">`-- themes/                # 网站美化主题文件夹</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"初始化git并传到远程仓库\"><a href=\"#初始化git并传到远程仓库\" class=\"headerlink\" title=\"初始化git并传到远程仓库\"></a>初始化git并传到远程仓库</h3><blockquote>\n<p>如果你从没用过git，需要配置本地的git用户和邮箱：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;$ git config --global user.name &lt;用户名&gt;</span><br><span class=\"line\">&gt;$ git config --global user.email &lt;邮箱&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个用户名和邮箱只是本地提交代码时记录修改人是谁，并非是要登录什么网站</p>\n</blockquote>\n<p>​    还是在这个目录，进行Git仓库初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本文不解释git及其相关概念，后续使用git命令时，即使是复制，也务必明白你在做什么</p>\n<p>另外，记得确认仓库中的<code>.gitignore</code>文件，它是<code>hexo init &lt;文件夹&gt;</code>时生成的，其内容包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/         # 安装的npm包</span><br><span class=\"line\">public/               # 生成的静态网站源码目录</span><br><span class=\"line\">.deploy*/             # xxxx.github.io仓库</span><br><span class=\"line\">_multiconfig.yml</span><br></pre></td></tr></table></figure>\n\n<p>​    这是让git不要去追踪一些自动生成的内容，这些内容与文章、站点配置无关。</p>\n</blockquote>\n<p>​    然后再<code>commit</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;init&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​    还记得前面在GitHub创建的<code>my-hexo</code>仓库还是空的吗，现在需要把本地<code>my-hexo</code>仓库绑定到GitHub仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin https://github.com/&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br><span class=\"line\">$ git branch -M master  <span class=\"comment\"># 默认主分支我改名为master</span></span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地预览hexo网站页面\"><a href=\"#本地预览hexo网站页面\" class=\"headerlink\" title=\"本地预览hexo网站页面\"></a>本地预览hexo网站页面</h3><p>依次输入以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean      <span class=\"comment\"># 清理hexo缓存</span></span><br><span class=\"line\">$ hexo g          <span class=\"comment\"># 生成hexo网站源码</span></span><br><span class=\"line\">$ hexo s --debug  <span class=\"comment\"># 在本地开启网站的访问端口</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">16:49:54.435 DEBUG Generator: tag</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: category</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: index</span><br><span class=\"line\">16:49:54.445 INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>终端中会打印本地网站的地址，Ctrl+鼠标左键点击访问即可：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203005355143.png\" alt=\"image-20221203005355143\"></p>\n<p>可以看到默认页面即为成功，首页的唯一一篇文章是hexo自带的<code>source/_post/hello-world.md</code>.</p>\n<blockquote>\n<p>终端按Ctrl + C停止本地服务器</p>\n</blockquote>\n<h2 id=\"2-3-配置hexo\"><a href=\"#2-3-配置hexo\" class=\"headerlink\" title=\"2.3.  配置hexo\"></a>2.3.  配置hexo</h2><h3 id=\"安装主题\"><a href=\"#安装主题\" class=\"headerlink\" title=\"安装主题\"></a>安装主题</h3><p>​    hexo有很多美化主题，可以在<a href=\"https://hexo.io/themes/\">Themes | Hexo</a>找到喜欢的主题，也可以在GitHub上搜索其他主题。我选择的主题是<a href=\"https://butterfly.js.org/\">Butterfly - A Simple and Card UI Design theme for Hexo</a>。主题除了美化外，往往还提供许多其他功能的配置。</p>\n<p>​    主题放在themes文件夹下。<strong>不论安装什么主题，一定要注意</strong>：</p>\n<ul>\n<li>虽然主题的官方教程一般都是让用<code>git clone</code>到themes文件夹下，但是我们的hexo文件夹已经是一个git仓库了，所以要以<code>git submodule</code>的形式安装；</li>\n<li><code>themes</code>下的主题文件夹必须以<code>&lt;主题名&gt;</code>来命名，而不是GitHub仓库的名称，如<code>hexo-theme-&lt;主题名&gt;</code>。</li>\n<li>很多主题的官方说明会要求安装其他的npm包。使用<code>npm</code>安装这些包时，一定要带<code>--save</code>选项。这样这些包才会被记录到<code>package.json</code>中，这样我们以后push时，GitHub Actions上面的虚拟服务器才会帮我们完整的安装这些依赖。</li>\n<li>主题本身的配置文件在<code>themes/&lt;主题名&gt;/_config.yml</code>中，但这个文件是被主题仓库管理的，不会被hexo仓库管理，无法推送到GitHub。而且主题仓库更新后我们修改的配置也会丢失。所以我们应当在hexo根目录下创建<code>_config.&lt;主题名&gt;.yml</code>文件，并把主题中的配置文件拷贝进去。这样配置文件就会被hexo仓库管理。（但是原来主题文件夹里的_config.yml也不要删除）</li>\n</ul>\n<p>下面是我安装butterfly的步骤:</p>\n<ol>\n<li>把butterfly作为git submodule安装到hexo中</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git submodule add -b master https://github.com/jerryc127/hexo-theme-butterfly.git ./themes/butterfly</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：<code>git submodule add</code>时，一定要指定主题的文件夹名称，将其命名为主题的名称，此处为<code>themes/butterfly</code>。若不这样做，将会变成其GitHub仓库的名称，如<code>hexo-theme-butterfly</code>，这样是不行的。</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装渲染器</li>\n</ol>\n<p>根据butterfly的官方文档，需要安装渲染器。其他主题可能需要其他渲染器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一定要带<code>--save</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>拷贝<strong>主题配置</strong>文件</li>\n</ol>\n<p>把<code>themes/&lt;主题名&gt;/_config.yml</code>配置拷到hexo根目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>应用主题</li>\n</ol>\n<p>修改<strong>hexo配置文件</strong>，<code>my-hexo</code>根目录下的<code>_config.yml</code>，找到<code>theme</code>项并修改：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">butterfly</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>yml格式的<code>:</code>后面一定要有一个空格</p>\n</blockquote>\n<ol start=\"5\">\n<li>查看效果</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203191314829.png\" alt=\"image-20221203191314829\"></p>\n<ol start=\"6\">\n<li>其他修改</li>\n</ol>\n<p>根据主题的官方说明，进行其他的自定义配置。所有的修改都在my-hexo根目录下<code>_config.&lt;主题名&gt;.yml</code>中修改。 </p>\n<blockquote>\n<p><code>themes/&lt;主题名&gt;/_config.yml</code>虽然不生效，但是也不能删除。</p>\n</blockquote>\n<h3 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h3><p>​    hexo本身的配置，需要修改<code>my-hexo</code>根目录下的<code>_config.yml</code>文件。可以修改站点名称、作者等，具体可以参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a>。</p>\n<p>​    这里提一些与Github Pages还有markdown文章插入相关的配置。</p>\n<h4 id=\"网站url与root\"><a href=\"#网站url与root\" class=\"headerlink\" title=\"网站url与root\"></a>网站url与root</h4><p>目前，GitHub Pages提供的网站url为：</p>\n<p><code>https://&lt;用户名&gt;.github.io/&lt;仓库名&gt;/</code></p>\n<p>例如：</p>\n<p><code>https://jayant-tang.github.io/jayant97.github.io/</code></p>\n<p>所以，要配置hexo的目录：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://jayant-tang.github.io/jayant97.github.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/jayant97.github.io/</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​    不同环境，访问资源的根目录是不同的。hexo的所有资源文件都应该放在<code>&lt;hexo文件夹&gt;/source</code>下，生成网页时，会自动拷贝到网页的根目录下。</p>\n<p>​    例如，有一张图片资源的路径是：<code>&lt;hexo文件夹&gt;/source/foo/bar/image.png</code>：</p>\n<ul>\n<li>对于你的markdown文章，可以设置根目录为<code>&lt;hexo文件夹&gt;/source</code></li>\n<li>对于网站，刚才已经配置了根目录为<code>/jayant97.github.io/</code></li>\n</ul>\n<p>只要设置好根目录，markdown和网页就可以使用<strong>相同的路径</strong>来访问到<strong>相同的资源</strong>了，如<code>/foo/bar/image.png</code>。</p>\n</blockquote>\n<h4 id=\"hexo的部署方式介绍\"><a href=\"#hexo的部署方式介绍\" class=\"headerlink\" title=\"hexo的部署方式介绍\"></a>hexo的部署方式介绍</h4><p>通常情况下，hexo的部署流程是这样的：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203195710806.png\" alt=\"image-20221203195710806\"></p>\n<ol>\n<li><code>hexo g</code>，生成网页源码，并存储在<code>/public</code>文件夹中</li>\n<li><code>hexo d</code>，把public同步到本地git仓库，然后推送到github仓库。</li>\n</ol>\n<p>先安装git部署的插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后需要给hexo配置github仓库的路径和权限，打开<strong>hexo配置文件</strong>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">    <span class=\"comment\">#repo: https://github.com/Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td>部署类型，可以设置多个要部署的目标</td>\n</tr>\n<tr>\n<td>branch</td>\n<td>分支名称</td>\n</tr>\n<tr>\n<td>repo</td>\n<td>仓库名称，这里有ssh和https两种方式。使用ssh方式。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>GitHub认证方式：</p>\n<ul>\n<li>https方式，任何人可以随便clone，但是push时需要在弹窗中输入账号密码，认证身份；</li>\n<li>ssh方式，需要ssh key，公钥放在GitGub，私钥自己持有。只要持有私钥就可以用ssh访问GitHub仓库，纯命令行操作，不会弹窗。</li>\n</ul>\n<p>因为后面要用GitHub Actions在虚拟服务器里自动部署，所以需要用ssh的方式。</p>\n</blockquote>\n<h4 id=\"ssh密钥对的生成\"><a href=\"#ssh密钥对的生成\" class=\"headerlink\" title=\"ssh密钥对的生成\"></a>ssh密钥对的生成</h4><p>​     然后需要生成两对ssh  key，第一对用于<strong>电脑</strong>和<strong>GitHub</strong>之间的认证，第二对用于<strong>GitHub my-hexo仓库</strong> 和<strong>GitHub xxxx.github.io仓库</strong>之间的认证。</p>\n<p>​    生成key：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/github_ed25519</span><br><span class=\"line\"><span class=\"comment\"># 输入后一直回车</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>-t</code>：选择加密算法，ed25519比较安全</p>\n<p><code>-C</code>:  密钥的备注说明文字。Github要求这里要填上git config时配置的邮箱，同时也必须是GitHub中已经配置的认证邮箱。</p>\n<p><code>-f</code>：生成的私钥文件名</p>\n</blockquote>\n<p>执行完毕后，<code>~/.ssh</code>下应该有4个新文件，其中带有<code>.pub</code>后缀的是公钥，不带的是私钥:</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"code\"><pre><span class=\"line\">~/.ssh</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519.pub</span><br><span class=\"line\">|-hexo<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">`-hexo<span class=\"built_in\">_</span>ed25519.pub</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"GitHub-ssh-key设置\"><a href=\"#GitHub-ssh-key设置\" class=\"headerlink\" title=\"GitHub ssh key设置\"></a>GitHub ssh key设置</h4><p>配置你的电脑ssh访问GitHub的权限。GitHub点击右上角头像-Settings，然后点击New SSH key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203202950352.png\" alt=\"image-20221203202950352\"></p>\n<p>然后，把<code>github_ed25519.pub</code>的内容粘贴进去，其他都不用填，确认即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203203135033.png\" alt=\"image-20221203203135033\" style=\"zoom: 50%;\" />\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\"><span class=\"comment\"># Attempts to ssh to GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; The authenticity of host <span class=\"string\">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class=\"string\">&#x27;t be established.</span></span><br><span class=\"line\"><span class=\"string\">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class=\"line\"><span class=\"string\">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br><span class=\"line\"><span class=\"string\"># 这里输入yes然后回车</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; Hi USERNAME! You&#x27;</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>有以上输出说明权限配置成功。</p>\n<h3 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h3><p>根据你所使用的主题的官方文档来配置。建议把后面的其他部署都完成后，再研究主题的配置。</p>\n<h2 id=\"2-4-从电脑部署hexo\"><a href=\"#2-4-从电脑部署hexo\" class=\"headerlink\" title=\"2.4. 从电脑部署hexo\"></a>2.4. 从电脑部署hexo</h2><p>前面的步骤都完成后，可以执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>这时，hexo应该已经可以把网站配置到<code>xxxx.github.io</code>上了，过一会从网页端就可以看到网站页面了。</p>\n<p><strong>网页端的入口：</strong></p>\n<p>​\tPages仓库右边：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104114033850.png\" alt=\"image-20230104114033850\"></p>\n<p>然后点击View deployment</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104114222770.png\" alt=\"image-20230104114222770\"></p>\n<h2 id=\"2-5-GitHub-Actions自动部署\"><a href=\"#2-5-GitHub-Actions自动部署\" class=\"headerlink\" title=\"2.5. GitHub Actions自动部署\"></a>2.5. GitHub Actions自动部署</h2><h4 id=\"pages仓库添加公钥\"><a href=\"#pages仓库添加公钥\" class=\"headerlink\" title=\"pages仓库添加公钥\"></a>pages仓库添加公钥</h4><p>​     我们需要设置<code>my-hexo</code>仓库访问<code>xxxx.github.io</code>仓库的权限，前者持有私钥，后者持有公钥。然后才能在push完<code>my-hexo</code>仓库之后，让<code>my-hexo</code>仓库的Actions自动部署博客到Pages仓库。</p>\n<p>​    首先进入<code>xxxx.github.io</code>仓库页面，找到Settings - Deploy Keys，然后点击Add deploy key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204246535.png\" alt=\"image-20221203204246535\"></p>\n<p>把<code>hexo_ed25519.pub</code>的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204425639.png\" alt=\"image-20221203204425639.png\" style=\"zoom:50%;\" />\n\n<p>Title填写<code>HEXO_DEPLOY_PUB</code></p>\n<h4 id=\"hexo仓库添加私钥\"><a href=\"#hexo仓库添加私钥\" class=\"headerlink\" title=\"hexo仓库添加私钥\"></a>hexo仓库添加私钥</h4><p>​    然后进入<code>my-hexo</code>仓库，找到Settings - Secrets - Actions，然后点击New repository secret.</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204626463.png\" alt=\"image-20221203204626463\"></p>\n<p>把私钥<code>hexo_ed25519</code>中的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204859957.png\" alt=\"image-20221203204859957.png\"></p>\n<p><strong>注意，Name要记住，后面需要用到</strong>。我这里配置的是<code>HEXO_DEPLOY_PRI</code>.</p>\n<h4 id=\"编写Actions\"><a href=\"#编写Actions\" class=\"headerlink\" title=\"编写Actions\"></a>编写Actions</h4><p>在本地my-hexo文件夹中，创建一个文件<code>.github/workflows/deploy.yml</code>，填入以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在master分支上收到push时，开始执行流程</span></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">      - master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">env</span>:</span><br><span class=\"line\">  GIT_USER: Jayant.Tang</span><br><span class=\"line\">  GIT_EMAIL: jayant.tang@nordicsemi.no</span><br><span class=\"line\">  DEPLOY_REPO: Jayant-Tang/jayant97.github.io</span><br><span class=\"line\">  DEPLOY_BRANCH: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 具体步骤</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span>:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    name: Build on node <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125; and <span class=\"variable\">$&#123;&#123; matrix.os &#125;</span>&#125;</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    strategy:</span><br><span class=\"line\">      matrix:</span><br><span class=\"line\">        os: [ubuntu-latest]</span><br><span class=\"line\">        node_version: [18.12.1] <span class=\"comment\"># 修改好node js版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Checkout</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          submodules: recursive</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Checkout deploy repo</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          repository: <span class=\"variable\">$&#123;&#123; env.DEPLOY_REPO &#125;</span>&#125;</span><br><span class=\"line\">          ref: <span class=\"variable\">$&#123;&#123; env.DEPLOY_BRANCH &#125;</span>&#125;</span><br><span class=\"line\">          path: .deploy_git</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Use Node.js <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\">        uses: actions/setup-node@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          node-version: <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Configuration environment</span><br><span class=\"line\">        <span class=\"built_in\">env</span>:</span><br><span class=\"line\">          HEXO_DEPLOY_PRI: <span class=\"variable\">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          sudo timedatectl set-timezone <span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br><span class=\"line\">          <span class=\"built_in\">mkdir</span> -p ~/.ssh/</span><br><span class=\"line\">          <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_ed25519</span><br><span class=\"line\">          <span class=\"built_in\">chmod</span> 600 ~/.ssh/id_ed25519</span><br><span class=\"line\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">          git config --global user.name <span class=\"variable\">$GIT_USER</span></span><br><span class=\"line\">          git config --global user.email <span class=\"variable\">$GIT_EMAIL</span></span><br><span class=\"line\">          <span class=\"comment\">#cp _config.theme.yml themes/concise/_config.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Install dependencies</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm install</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Deploy hexo</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm run deploy</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>内容修改：</p>\n<ol>\n<li><p>修改环境变量，改成你自己的用户名(GIT_USER)、邮箱(GIT_EMAIL)、pages仓库、pages分支</p>\n</li>\n<li><p>修改node_version: [xxxx]，填上你电脑本地安装的Nodejs的版本</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看本地Node.js版本</span></span><br><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改时区，如果在中国就不用改了</p>\n</li>\n</ol>\n<p>内容解释：</p>\n<ol>\n<li>在hexo仓库的master分支收到push时，触发job</li>\n<li>在Ubuntu环境中，checkout本仓库的最新内容，并且同时自动获取各个submodle的仓库。这里的<code>actions/checkout@v3</code>是Actions商店提供的，我们只需要用<code>with</code>传参数进去就行了。商店页面<a href=\"https://github.com/marketplace/actions/checkout\">Checkout · Actions · GitHub Marketplace</a>。</li>\n<li>checkout pages仓库，并把它放到.deploy_git路径中</li>\n<li>安装指定版本的Node.js</li>\n<li>配置环境变量：添加私钥、配置git用户和邮箱。注意，这里的私钥的名称就是<code>$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</code>，与前面配置的<code>HEXO_DEPLOY_PRI</code>一致。</li>\n<li>根据package.json的内容安装npm包</li>\n<li>部署hexo博客</li>\n</ol>\n<p>其他说明：</p>\n<ul>\n<li>我没有使用商店中别人写的自动部署hexo的Actions，因为他们很久没更新了，使用的Node.js版本比较低，也没法通过传参的方式修改其内部使用的Node.js版本。</li>\n</ul>\n</blockquote>\n<h4 id=\"提交修改\"><a href=\"#提交修改\" class=\"headerlink\" title=\"提交修改\"></a>提交修改</h4><p>从一开始到现在，已经修改了不少内容了，将其commit然后push</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;add config&quot;</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>add之前一定要注意检查.gitignore，是否已经让git忽略了<code>db.json</code>，<code>node_modules/</code>，<code>public/</code>。</p>\n</blockquote>\n<p>push之后，在Github Actions页面应该已经可以看到流程了：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212530721.png\" alt=\"image-20221203212530721\"></p>\n<p>你的每次push，都会触发actions。绿色勾说明整个流程没有出现错误（指Ubuntu linux命令没有出现执行错误的）。如果执行失败，会出现红色叉，你可以点进去看详细的执行记录。</p>\n<p>Actions执行完毕后，应该已经部署到Pages仓库了，这里也可以看到网站部署的记录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212852929.png\" alt=\"image-20221203212852929\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203213623303.png\" alt=\"image-20221203213623303\"></p>\n<p>绿色说明部署成功，网站已经可以访问了。</p>\n<h1 id=\"3-编写并发布文章\"><a href=\"#3-编写并发布文章\" class=\"headerlink\" title=\"3. 编写并发布文章\"></a>3. 编写并发布文章</h1><h2 id=\"3-1-文章的存储与格式\"><a href=\"#3-1-文章的存储与格式\" class=\"headerlink\" title=\"3.1. 文章的存储与格式\"></a>3.1. 文章的存储与格式</h2><p>​    所有要显示的markdown文章都存放在<code>source/_posts/</code>目录下，不展示的文章（草稿）都放在<code>source/_drafts</code>目录下。</p>\n<p>​    新建文章：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>layout: markdown的布局（或者说模板），布局存放在<code>scaffolds/</code>目录下，默认有三种布局：</p>\n<ul>\n<li>post.md: 文章模板</li>\n<li>draft.md：草稿模板</li>\n<li>page.md：页面模板</li>\n</ul>\n<p>title：文章的标题，直接写标题即可，不需要写.md。<em><strong>但是最好不要有空格等特殊字符！！！</strong></em></p>\n</blockquote>\n<p>​\t以上命令，会在<code>source/_posts/</code>目录下自动创建一个新的<code>&lt;title&gt;.md</code>文件，并且把模板内容拷贝过去。由于模板中有<code>date</code>参数，这时会自动记录当前的电脑本地时间作为这篇文章的创建时间，记录在Front-Matter中。</p>\n<h2 id=\"3-2-Front-Matter\"><a href=\"#3-2-Front-Matter\" class=\"headerlink\" title=\"3.2. Front-Matter\"></a>3.2. Front-Matter</h2><p>Front-Matter是markdown文件最上方以两行<code>---</code>分隔的区域，里面需要填写yml格式的文章配置，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Hello World</span><br><span class=\"line\">date: 2013/7/13 20:46:25</span><br><span class=\"line\">tags: </span><br><span class=\"line\"><span class=\"bullet\"> -</span> 嵌入式</span><br><span class=\"line\"><span class=\"section\"> - MCU</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>在Typora编辑器中，直接在文章开头输入<code>---</code>并回车，就可以创建这个区域：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203224247035.png\" alt=\"image-20221203224247035\"></p>\n<p>​\t对于某些主题来说，有些选项是必选的，具体要看对应主题的说明文档。比如，我使用的butterfly主题，就可以配置：</p>\n<ul>\n<li><p>title：文章标题</p>\n</li>\n<li><p>date：文章创建日期</p>\n</li>\n<li><p>cover：文章封面图</p>\n</li>\n<li><p>tags：文章标签</p>\n</li>\n<li><p>categories：文章目录</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<blockquote>\n<p>tags和categories的区别：</p>\n<p>​    tags是无顺序的，categories是一个递归层级。设计好的tags和categories能让读者很方便的从主页索引到对应的文章。</p>\n</blockquote>\n<p>​    这里，我们也可以体会到前面模板的意义：可以在模板里填好Front Matter，这样每次hexo就会自动帮我们生成了。</p>\n<h2 id=\"3-3-Typora在文章中插图的问题\"><a href=\"#3-3-Typora在文章中插图的问题\" class=\"headerlink\" title=\"3.3. Typora在文章中插图的问题\"></a>3.3. Typora在文章中插图的问题</h2><h3 id=\"方案一：云端图床\"><a href=\"#方案一：云端图床\" class=\"headerlink\" title=\"方案一：云端图床\"></a>方案一：云端图床</h3><p>图片全部放在云端图床，markdown和Pages都通过URL查看图片。具体的方式，本文不介绍，可以去网上查阅。</p>\n<h3 id=\"方案二：图片放在本地\"><a href=\"#方案二：图片放在本地\" class=\"headerlink\" title=\"方案二：图片放在本地\"></a>方案二：图片放在本地</h3><p>假设我们在markdown中展示一张图片，其路径为<code>source/imgs/foo/bar/image.png</code>。</p>\n<p>hexo生成网站后，网页会根据 <code>$&#123;root&#125;/imgs/foo/bar/image.png</code>来找这张图片，即是说，source文件夹放的内容，在网页端就是根目录下的内容。</p>\n<blockquote>\n<p>在<a href=\"#%E9%85%8D%E7%BD%AEhexo\">2.3 配置hexo</a>中，我们已经配置了root为<code>&lt;仓库名&gt;</code>了。</p>\n</blockquote>\n<p>​    下面要解决的是，如何在markdown文章和网页中，能用<strong>同样的路径</strong>来访问图片资源。这样本地写文章时和网页端就都可以预览了，而且从markdown转换成html时，路径也是可用的。</p>\n<p>​     解决方式就是根目录，由于hexo的根目录前面已经设置过了，我们只需要设置markdown编辑器的根目录就好。设置完毕后，而这就都可以通过<code>/imgs/foo/bar/image.png</code>来访问同一张图片了。</p>\n<p><strong>（1）设置markdown文章访问图片时的根目录</strong></p>\n<p>​    我使用的Markdown编辑器是Typora，Typora支持<strong>针对每一篇文章单独设置</strong>根目录。</p>\n<p>直接在Front-Matter中填入以下内容即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-root-url:</span> <span class=\"string\">./..</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于文章的路径是<code>source/_post</code>，所以<code>./..</code>就是<code>source</code>了。</p>\n</blockquote>\n<p>你可以把这一行配置直接写进<code>scaffolds/post.md</code>中，这样下次模板就自动帮你填了。</p>\n<p>以上设置，直接从菜单栏设置是一样的，Typora会自动帮你写这一行：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221125176.png\" alt=\"image-20221203221125176\"></p>\n<p><strong>（2）设置Typora粘贴图片时的行为</strong></p>\n<p>直接在Front-Matter中写入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-copy-images-to:</span> <span class=\"string\">../../source/imgs/$&#123;filename&#125;.assets/</span></span><br></pre></td></tr></table></figure>\n\n<p>这个效果和下图中的偏好设置是一样的，<strong>但是不要去偏好设置里去配置，因为那是全局的配置</strong>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222104681.png\" alt=\"image-20221203222104681\"></p>\n<blockquote>\n<p>只需要在  Front-Matter 中写就行，不要去偏好设置里设置成上图的样子！！！</p>\n</blockquote>\n<p><strong>（3）检查效果</strong></p>\n<p>​    在Front-Matter中填入以上配置之后，每次粘贴图片到typora时，就会自动帮你把图片拷贝到<code>source/imgs/&lt;文章名&gt;.assets/</code>文件夹中。</p>\n<p>​    我们可以粘贴一张图片到typora中，检查图片位置：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221924602.png\" alt=\"image-20221203221924602\"></p>\n<p>然后，检查markdown访问图片的路径，查看markdown源码：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222001274.png\" alt=\"image-20221203222001274\"></p>\n<p>可以看到，路径名直接是从<code>/imgs</code>开始的，这说明根目录已经是<code>source</code>了。</p>\n<blockquote>\n<p>以上配置全部写在Front-Matter中，把这两行配置写入<code>scaffolds/post.md</code>的Front-Matter中，这样模板就创建好了。这些配置就只对hexo中的markdown有影响，对你平时用typora写其他文章没有任何影响。</p>\n<p>参考资料：<a href=\"https://support.typoraio.cn/YAML/\">YAML Front Matter - Typora Support (typoraio.cn)</a></p>\n</blockquote>\n<h2 id=\"3-4-Typora中的html标签插图\"><a href=\"#3-4-Typora中的html标签插图\" class=\"headerlink\" title=\"3.4. Typora中的html标签插图\"></a>3.4. Typora中的html标签插图</h2><p>​    如果你在Typora中右键点击一张图片，然后进行缩放，它就会从Markdown语法的图片:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片名称</span>](<span class=\"link\">图片路径</span>)</span><br></pre></td></tr></table></figure>\n\n<p>​    变成html格式的img标签，比如缩小到50%：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;图片路径&quot;</span> alt=<span class=\"string\">&quot;图片名称&quot;</span> style=<span class=\"string\">&quot;zoom: 50%;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​\thexo在把<code>.md</code>文章转换成html的时候，会自动根据我们设置的根目录来替换markdown格式图片的路径。</p>\n<p>​\t以本博客为例，<code>![测试图片](/imgs/image.png)</code>会被转换成<code>/jayant97.github.io/imgs/image.png</code>。</p>\n<p>​\t但是，如果<code>.md</code>文章里的图片本来就是html格式的标签，<strong>hexo不会对其进行任何转换</strong>。这就导致，在网站上，图片的路径还是<code>/imgs/image.png</code>，所以网站上就找不到图片了。</p>\n<p>​\t为了解决这个问题，网上解法很多。但我想了想，还是用Linux的sed命令来对文本进行替换，毕竟我并不懂JavaScripts。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br></pre></td></tr></table></figure>\n\n<p>​\t以上三个命令会把<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code> 和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>都替换成 <code>&lt;img src=&quot;/&lt;仓库名&gt;/imgs/</code>。</p>\n<blockquote>\n<p>默认情况下,html标签中的写法：</p>\n<ul>\n<li><p><code>./imgs</code>和<code>imgs</code>是一样的，在网页端会被当作<code>/&lt;文章名&gt;/imgs</code>。</p>\n</li>\n<li><p><code>/imgs</code>不会被转换，在网页端还是<code>/imgs</code></p>\n</li>\n</ul>\n<p>在网页上，以上两种方式都访问不到图片，只有<code>/jayant97.github.io/imgs</code>才能访问到图片。因为所有静态资源都在<code>source</code>文件夹下，而<code>source</code>中的内容会被拷贝到<code>&lt;site_name&gt;/xxxx.github.io/</code>中。</p>\n</blockquote>\n<p>​    把这些命令加到GitHub Actions中，这样我们本地用typora的时候还是能看到图片，push到远程的时候网页也能看到图片。</p>\n<p>​    首先在GitHub Actions的.yml文件中增加一个环境变量，方便后面更改：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221204210311635.png\" alt=\"image-20221204210311635\" style=\"zoom: 67%;\" />\n\n<p>​\t然后，在hexo部署的步骤之前，加入sed命令：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Sed</span> <span class=\"string\">img</span> <span class=\"string\">label</span></span><br><span class=\"line\">  <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样云端部署的时候就会自动帮你替换路径了。</p>\n<blockquote>\n<p>​\t但是，本地<code>hexo s --debug</code>去查看网页的时候，由于没有Actions帮你转换，图片还是看不了的。这个问题倒没什么影响。</p>\n</blockquote>\n<h2 id=\"3-5-Typora云端和本地图片互转\"><a href=\"#3-5-Typora云端和本地图片互转\" class=\"headerlink\" title=\"3.5. Typora云端和本地图片互转\"></a>3.5. Typora云端和本地图片互转</h2><p>如果你有一篇文章，以前所有的图片是放在云端的，现在想放在本地。可以批量操作：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222340559.png\" alt=\"image-20221203222340559.png\"></p>\n<p>​\t只要文章已经写好了Front-Matter，那么整个复制过程会从你设置的图片根目录，来自动设置图片的路径。</p>\n<p>​\t同理，也可以批量把本地图片上传到云端（需要提前设置好上传方式），<strong>文章内所有的图片路径都会自动更新</strong>。</p>\n<h2 id=\"3-6-文章的发布\"><a href=\"#3-6-文章的发布\" class=\"headerlink\" title=\"3.6. 文章的发布\"></a>3.6. 文章的发布</h2><p>​\t文章写好以后，可以<code>hexo s --debug</code>在本地查看一下。也可以<code>hexo d</code>直接从本地发布。但是既然我们已经搭建好CI系统，可以直接add，commit然后push，后面的事情就交给GitHub Actions完成了。</p>\n<p>​\tGithub Actions会在虚拟服务器上，根据我们写好的yml，自动执行<code>hexo g</code>然后<code>hexo d</code>，这样网站就重新部署好了。</p>\n<p>​\t但是这又会产生新问题：<strong>我们每次发布新文章，所有旧的文章都会被重新部署一遍</strong>，导致整个网站所有文章的更新日期都变成一样的了：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20230104121209837.png\" alt=\"image-20230104121209837\"></p>\n<p>​\t</p>\n<h1 id=\"4-网站的其他设置\"><a href=\"#4-网站的其他设置\" class=\"headerlink\" title=\"4. 网站的其他设置\"></a>4. 网站的其他设置</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>​    博客除了<strong>文章</strong>外，还有<strong>页面</strong>。页面的模板就是<code>scaffolds/post.md</code>。可以有时间线、标签、目录等页面，页面也存放在<code>source</code>目录下。</p>\n<p>​    在<code>_config.yml</code>中，配置了这些页面的目录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203225905257.png\" alt=\"image-20221203225905257\"></p>\n<p>​    基本上所有的配置你都可以在<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a> 和你所用的主题的官方文档中找到。</p>\n<h2 id=\"文章的永久链接（Permalinks）\"><a href=\"#文章的永久链接（Permalinks）\" class=\"headerlink\" title=\"文章的永久链接（Permalinks）\"></a>文章的永久链接（Permalinks）</h2><p>​\thexo默认的文章URL格式是<code>/年/月/日/文章标题</code>，如果你的文章标题有中文，这个URL就会巨长无比：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204210811289.png\" alt=\"image-20221204210811289\"></p>\n<p>​\t我的方案是改成用文章标题+日期的hash值去命名url，这样更简洁。</p>\n<p>​\t打开<strong>站点配置</strong><code>_config.yml</code>，修改：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:hash/</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样，文章的URL就会变成：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204211202297.png\" alt=\"image-20221204211202297\"></p>\n<p>​\t这样URL就比较短了。</p>\n<h2 id=\"文章的更新日期\"><a href=\"#文章的更新日期\" class=\"headerlink\" title=\"文章的更新日期\"></a>文章的更新日期</h2><p>​\t文章具有<strong>创建日期（date）</strong>和<strong>更新日期（updated）</strong>。默认情况下，更新日期使用的是操作系统中记录的文件最后修改日期。</p>\n<p>​\t但是我们利用Github Actions部署时，</p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><ul>\n<li>所有文章标题、文件名、目录名都不要有空格等特殊字符！！！（可以有减号<code>-</code>）</li>\n<li>本博客使用了Gitalk作为评论系统，把页面仓库的Github Issue变成一个评论区。会有一些API key之类的东西，明文配置在hexo仓库中，所以我把hexo仓库的权限设为私有了</li>\n<li>Front-Matter是yml格式，冒号<code>:</code>后面一定要加一个空格，不然识别不了。</li>\n</ul>\n","categories":["其他"],"tags":["hexo","GitHub Pages","GitHub Actions","Typora","博客搭建"]},{"title":"最简洁清爽的ssh使用方案","url":"/jayant97.github.io/2022/12/693c6a957393/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\t已经2022年了，看到很多朋友还在使用Putty、MobaXTerm之类的软件，ssh连接到自己的各种linux开发板、服务器等。每次都要回忆IP地址、用户名、密码。如果要传输文件，scp又要又要输一遍IP地址、用户名、密码。整个搞下来，精神聚焦不了，烦躁程度直线上升。</p>\n<p>​\t今天把最方便的ssh使用方式分享给大家。先放一个<strong>演示效果</strong>如下：</p>\n<p>（1）在Linux shell终端，或者Windows Git Bash中，直接输入<code>ssh &lt;主机名&gt;</code>，就可<code>ssh</code>连接到指定主机，无需输入密码.</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193456382.png\" alt=\"image-20221214193456382\"></p>\n<center>上图为Windows11 Terminal中打开的Git Bash</center>\n\n\n<p>（2）<code>scp</code>远程拷贝，也只需主机名，无需用户名、密码：</p>\n<p>​\t<img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193918641.png\" alt=\"image-20221214193918641\"></p>\n<blockquote>\n<p>注：我的远程主机是OpenWrt，没安装sftp，所以这里<code>scp</code>要加<code>-O</code>参数。一般支持sftp的可以不加<code>-O</code>参数。</p>\n</blockquote>\n<p>（3）VS Code Remote，直接选择远程主机，无需密码</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194243898.png\" alt=\"image-20221214194243898\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194211714.png\" alt=\"image-20221214194211714\"></p>\n<blockquote>\n<p>注：VS Code Remote要求对方主机要有<code>glibc</code>和<code>libstdc++</code>，实际上OpenWrt的C运行库是musl，是不能用VS Code Remote连的，我这里只是展示一下。</p>\n<p>​\t大部分开发板的Linux系统都是可以使用VS Code Remote的</p>\n</blockquote>\n<h1 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h1><h2 id=\"2-1-创建密钥对\"><a href=\"#2-1-创建密钥对\" class=\"headerlink\" title=\"2.1. 创建密钥对\"></a>2.1. 创建密钥对</h2><p>​\t使用密钥对而非账户密码来进行<code>ssh</code>连接。这里先生成密钥对</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C <span class=\"string\">&quot;xxxx@xxx.com&quot;</span> -f ~/.ssh/my_ed25519</span><br><span class=\"line\"><span class=\"comment\"># 一路回车即可，不要输入任何内容</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t参数说明：</p>\n<ul>\n<li><code>-t</code>：加密算法，目前推荐ed25519，rsa已经不够安全</li>\n<li><code>-C</code>：备注信息，写一些明文备注，可以写任何东西，让你记得这是个啥。如果是GitHub的密钥，则需要输入本地git邮箱。</li>\n<li><code>-f</code>：存放私钥的文件，会新建一个文件，建议放在<code>~/.ssh/</code>下</li>\n</ul>\n<p>​\t创建完毕后，会发现<code>.ssh</code>目录下有公钥和私钥文件，其中带<code>.pub</code>后缀的是公钥：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214195611976.png\" alt=\"image-20221214195611976\"></p>\n<h2 id=\"2-2-安装公钥到远程主机\"><a href=\"#2-2-安装公钥到远程主机\" class=\"headerlink\" title=\"2.2. 安装公钥到远程主机\"></a>2.2. 安装公钥到远程主机</h2><p>​\t把公钥安装到远程主机，输入以下命令，最后填入你自己的填入远程主机用户名和IP地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/my_ed25519.pub root@192.168.2.1</span><br></pre></td></tr></table></figure>\n\n<p>参数说明:</p>\n<ul>\n<li><code>-i</code>：公钥文件</li>\n</ul>\n<p>第一次安装会要求你输入密码，输入密码后即为安装成功</p>\n<h2 id=\"2-3-配置ssh\"><a href=\"#2-3-配置ssh\" class=\"headerlink\" title=\"2.3. 配置ssh\"></a>2.3. 配置ssh</h2><p>​\t修改<code>~/.ssh/config</code>，如果没有就创建一个新的，内容示例如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host aliyun</span><br><span class=\"line\">    HostName xxx.xxx.xxx.xxx</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_ed25519_aliyun</span><br><span class=\"line\">Host google</span><br><span class=\"line\">    HostName xxx.xxx.xxx.xxx</span><br><span class=\"line\">    User ubuntu</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/ds.txt</span><br><span class=\"line\">Host r5s</span><br><span class=\"line\">    HostName 192.168.2.1</span><br><span class=\"line\">    User root</span><br><span class=\"line\">    Port 22</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Host</code>：命名，可以随便取名英文字母+数字+下划线</li>\n<li><code>HostName</code>：主机名，可填IP地址或域名</li>\n<li><code>User</code>：用户名</li>\n<li><code>Port</code>：端口号，如果不配置，默认是22</li>\n<li><code>IndentityFile</code>：私钥文件，必须是与前一步安装的公钥成对的私钥文件</li>\n</ul>\n<h2 id=\"2-4-测试\"><a href=\"#2-4-测试\" class=\"headerlink\" title=\"2.4. 测试\"></a>2.4. 测试</h2><p>直接使用<code>config</code>中命名的别名就可以进行ssh连接，无需输入密码，例如：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214193456382.png\" alt=\"image-20221214193456382\"></p>\n<h1 id=\"3-其他相关话题\"><a href=\"#3-其他相关话题\" class=\"headerlink\" title=\"3. 其他相关话题\"></a>3. 其他相关话题</h1><h2 id=\"3-1-VS-Code-Remote\"><a href=\"#3-1-VS-Code-Remote\" class=\"headerlink\" title=\"3.1. VS Code Remote\"></a>3.1. VS Code Remote</h2><p>​\t直接在插件商店搜索remote，安装remote开发合集即可，会自动安装remote ssh等：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214200636992.png\" alt=\"image-20221214200636992\"></p>\n<p>​\t然后点击左下角即可开始选择远程主机：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214200752517.png\" alt=\"image-20221214200752517\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214194211714.png\" alt=\"image-20221214194211714\"></p>\n<p>​\t第一次连接，需要选择是Linux&#x2F;Windows&#x2F;Mac OS，然后VS Code会自动在对方主机上编译安装服务端，需要对方主机上有C++环境。需要等待一段时间：<br><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214201022079.png\" alt=\"image-20221214201022079\"></p>\n<p>​\t安装完毕后，在VS Code中打开文件夹，就像在本地一样操作，左侧文件栏是可以拖放文件的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214210243472.png\" alt=\"image-20221214210243472\"></p>\n<h2 id=\"3-2-固定IP地址\"><a href=\"#3-2-固定IP地址\" class=\"headerlink\" title=\"3.2. 固定IP地址\"></a>3.2. 固定IP地址</h2><p>​\t现在家用网络很少用静态IP了，而是路由器通过DHCP服务自动给设备分配IP地址。但是我们希望：</p>\n<ul>\n<li>自己在家调试时，开发板不要每次上电IP地址就变化</li>\n<li>不要在开发板上配置静态IP，不然把板子带到其他地方去联网就又要重新配置动态获取IP了</li>\n</ul>\n<p>​\t解决方法是，DHCP客户端（板子）仍然申请IP，但是DHCP服务器（路由器）只会分配固定的IP地址给它。</p>\n<blockquote>\n<p>DHCP静态分配与“静态IP”不是一个概念，但可以达到我们希望IP地址不变的效果</p>\n</blockquote>\n<p>​\t路由器管理页面种类很多，但是原理都是相通的，这里以OpenWrt为例：</p>\n<p>（1）选择 “网络”——“DHCP&#x2F;DNS”</p>\n<img src=\"/jayant97.github.io/imgs/最简洁清爽的ssh使用方案.assets/image-20221214202240725.png\" alt=\"image-20221214202240725\" style=\"zoom:50%;\" />\n\n<p>（2）可以看到已分配的IP地址，找到你的开发板，记住MAC地址：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202411249.png\" alt=\"image-20221214202411249\"></p>\n<p>（3）在下方，“静态地址分配”中，选择“添加”，然后给MAC地址绑定一个固定的IP地址即可，主机名可以随便取个名，也可以不填：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202548591.png\" alt=\"image-20221214202548591\"></p>\n<p>（4）页面中选择“保存&amp;应用”即可：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214202711815.png\" alt=\"image-20221214202711815\"></p>\n<blockquote>\n<p>注意：</p>\n<p>​\tDHCP静态绑定，并不是说这个IP地址就不会被其它设备动态获取到了。只要这个IP在动态IP池子里，就有可能在被绑定的设备不在线时，动态分配给其他设备。</p>\n<p>​\t为了避免这种情况，我们做DHCP静态分配时，最好把静态分配的地址放在动态分配地址池之外。</p>\n<p>​\t以我的OpenWrt为例：</p>\n<p>​\t在“网络”——“接口”——“LAN接口配置修改”中，可以看到DHCP服务器的设置：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%9C%80%E7%AE%80%E6%B4%81%E6%B8%85%E7%88%BD%E7%9A%84ssh%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88.assets/image-20221214205402842.png\" alt=\"image-20221214205402842\"></p>\n<p>​\t可以看到基址是100，范围是150.由于我的LAN网段是 192.168.2.0&#x2F;24，所以动态地址池的分配范围就是192.168.2.100 ~ 192.168.2.250. </p>\n<p>​\t所以前面做DHCP静态绑定时，IP地址设在这个范围之外即可。</p>\n</blockquote>\n","categories":["Linux","ssh"],"tags":["Linux","ssh"]},{"title":"树莓派串口终端与网口直连终端","url":"/jayant97.github.io/2025/03/dd490e6182dc/","content":"<h1 id=\"1-概览\"><a href=\"#1-概览\" class=\"headerlink\" title=\"1. 概览\"></a>1. 概览</h1><p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250331132936987.webp\" alt=\"image-20250331132936987\"></p>\n<p>本文满足以下树莓派使用场景：</p>\n<ol>\n<li>无显示器，无键盘鼠标，无小型路由器。</li>\n<li>有Wi-Fi网络，但无Wi-Fi网络管理员权限（校园网&#x2F;企业网），树莓派需要连接到互联网。</li>\n<li>有USB转TTL串口模块。电脑通过串口登陆树莓派终端。</li>\n<li>有一根网线。电脑可以通过网口直连树莓派。</li>\n<li>整套设备携带到没有网络的地方也可用。</li>\n<li>不影响笔记本网口正常功能。</li>\n</ol>\n<h1 id=\"2-配置串口终端\"><a href=\"#2-配置串口终端\" class=\"headerlink\" title=\"2. 配置串口终端\"></a>2. 配置串口终端</h1><ul>\n<li>硬件：树莓派5</li>\n<li>系统：Raspbian或Ubuntu Server 24.04</li>\n</ul>\n<p>使用树莓派的Imager软件烧录完SD卡后，打开SD卡，boot盘，找到<code>config.txt</code>文件，在尾部添加:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enable_uart=1</span><br><span class=\"line\">dtoverlay=uart0</span><br><span class=\"line\">dtparam=uart0_console</span><br></pre></td></tr></table></figure>\n\n<p>前两行开启串口Shell终端，可以登录控制台。第三行开启串口内核日志。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/7_5_5c4a976d-c917-4049-ba8f-85bb33d52568_1024x1024.webp\" alt=\"img\"></p>\n<p>引脚为上图中的 GPIO14, GPIO15，电平为3.3V。接好USB转串口（TXD接RXD，RXD接TXD，GND接GND），插入SD卡。上电，等待一段时间就可以从串口看到内核启动日志。并且可以输入用户名、密码登录终端。</p>\n<h1 id=\"3-配置网线直连终端\"><a href=\"#3-配置网线直连终端\" class=\"headerlink\" title=\"3. 配置网线直连终端\"></a>3. 配置网线直连终端</h1><p>网上有很多教程是在电脑上把Wi-Fi网络共享给网口，这样电脑就变成一个路由器，树莓派网口接到电脑上就可以访问互联网。</p>\n<p>但是本文将采用相反的方案。不修改电脑的网口配置，而是在树莓派的网口启动一个DHCP server，把树莓派变成路由器。</p>\n<h2 id=\"1-给树莓派网口配置静态IP\"><a href=\"#1-给树莓派网口配置静态IP\" class=\"headerlink\" title=\"(1) 给树莓派网口配置静态IP\"></a>(1) 给树莓派网口配置静态IP</h2><p>不同操作系统的配置不同。例如Ubuntu桌面版有Network Manager，而Server版没有。这里只展示Ubuntu Server版的配置。Ubuntu Server 24.04通过<code>netplan</code>配置网口。</p>\n<p>首先查看网口名称：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ip a</span><br></pre></td></tr></table></figure>\n\n<p>以太网口名通常为<code>eth0</code></p>\n<p>检查现有的Netplan配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cat /etc/netplan/*.yaml</span><br></pre></td></tr></table></figure>\n\n<p>我这里的文件名是<code>50-cloud-init.yaml</code></p>\n<p>给网口配置静态ip：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/netplan/50-cloud-init.yaml</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">network:</span><br><span class=\"line\">  version: 2</span><br><span class=\"line\">  wifis:</span><br><span class=\"line\">    wlan0:</span><br><span class=\"line\">      optional: true</span><br><span class=\"line\">      dhcp4: true</span><br><span class=\"line\">      access-points:</span><br><span class=\"line\">        &quot;Wi-Fi SSID&quot;:</span><br><span class=\"line\">          auth:</span><br><span class=\"line\">            key-management: &quot;psk&quot;</span><br><span class=\"line\">            password: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ethernets:</span><br><span class=\"line\">    eth0:</span><br><span class=\"line\">      addresses: [192.168.10.1/24]</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">       - to: 192.168.10.0/24</span><br><span class=\"line\">         via: 192.168.10.1</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>wifis</code>的部分可能在SD卡烧录完毕，配置镜像的时候就已经输入好密码了，这部分不用动。</p>\n<p>增加一个和<code>wifis</code>同级别的<code>ethernets</code>部分。配置静态IP地址为<code>192.168.10.1/24</code>，<strong>注意不要和你的校园网&#x2F;企业网的网段冲突</strong>。如果冲突可以换成其他网段。</p>\n<p>应用配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo netplan apply</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-在树莓派网口启动DHCP服务器\"><a href=\"#2-在树莓派网口启动DHCP服务器\" class=\"headerlink\" title=\"(2) 在树莓派网口启动DHCP服务器\"></a>(2) 在树莓派网口启动DHCP服务器</h2><p>安装dnsmasq</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install dnsmasq</span><br></pre></td></tr></table></figure>\n\n<p>配置dnsmasq</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">mv</span> /etc/dnsmasq.conf /etc/dnsmasq.conf.bak</span><br><span class=\"line\"></span><br><span class=\"line\">sudo nano /etc/dnsmasq.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">port=0                  # 禁用 DNS 服务</span><br><span class=\"line\">interface=eth0          # 仅监听 eth0</span><br><span class=\"line\">dhcp-range=192.168.10.100,192.168.10.200,255.255.255.0,24h</span><br><span class=\"line\">dhcp-option=option:router,192.168.10.1</span><br><span class=\"line\">dhcp-option=option:dns-server,114.114.114.114  # 指定外部 DNS</span><br></pre></td></tr></table></figure>\n\n<p>这里我们只希望dnsmasq启动DHCP server，而不需要它帮我们代理DNS。因此这里需要<code>port=0</code>。</p>\n<p>重启dnsmasq</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart dnsmasq</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-通过网口ssh直连\"><a href=\"#3-通过网口ssh直连\" class=\"headerlink\" title=\"(3) 通过网口ssh直连\"></a>(3) 通过网口ssh直连</h2><p>重启树莓派</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo reboot</span><br></pre></td></tr></table></figure>\n\n<p>重启后，用电脑的网口应该就可以访问树莓派了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优先通过密码来登录</span></span><br><span class=\"line\">ssh -o PreferredAuthentications=password pi@192.168.10.1</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-笔记本电脑网络接口优先级\"><a href=\"#4-笔记本电脑网络接口优先级\" class=\"headerlink\" title=\"4. 笔记本电脑网络接口优先级\"></a>4. 笔记本电脑网络接口优先级</h1><p>以上配置完成后，可能有些笔记本连上网口后会无法连接互联网。这是因为以太网口的默认路由优先级比Wi-Fi网卡高，访问互联网的请求都走到树莓派去了。</p>\n<p>我们可以修改笔记本的路由表，使得流量优先路由到Wi-Fi网卡。最终效果：</p>\n<ol>\n<li><strong>网线</strong> → 树莓派（<code>eth0</code>，IP: <code>192.168.10.1</code>），用于 SSH。</li>\n<li><strong>Wi-Fi</strong> → 路由器（互联网），用于上网。</li>\n<li>不连接树莓派时，网口仍然保持正常的功能。</li>\n</ol>\n<p>这里只展示Ubuntu笔记本电脑的配置方式：</p>\n<h2 id=\"1-查看当前路由\"><a href=\"#1-查看当前路由\" class=\"headerlink\" title=\"(1) 查看当前路由\"></a>(1) 查看当前路由</h2><p>以下内容在Ubuntu笔记本电脑，本地执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ip route</span><br></pre></td></tr></table></figure>\n\n<p>可能会看到以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">default via 192.168.10.1 dev enp0s31f6 proto dhcp metric 20500 </span><br><span class=\"line\">default via 192.168.2.1 dev wlp0s20f3 proto dhcp metric 20600 </span><br><span class=\"line\">169.254.0.0/16 dev enp0s31f6 scope link metric 1000 </span><br><span class=\"line\">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown</span><br></pre></td></tr></table></figure>\n\n<p>其中Wi-Fi网卡是<code>wlp0s20f3</code>，以太网口是<code>enp0s31f6</code>。Wi-Fi网口优先级比以太网口低。</p>\n<h2 id=\"2-修改默认路由\"><a href=\"#2-修改默认路由\" class=\"headerlink\" title=\"(2) 修改默认路由\"></a>(2) 修改默认路由</h2><p>Ubuntu桌面版有Network Manager，可以比较方便修改优先级。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ip a               <span class=\"comment\"># 确认接口名称（如 wlan0、eth0）</span></span><br><span class=\"line\">ip route           <span class=\"comment\"># 查看当前路由表（注意默认路由的 metric）</span></span><br></pre></td></tr></table></figure>\n\n<p>检查Network Manager连接名称：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nmcli connection show</span><br></pre></td></tr></table></figure>\n\n<p><strong>降低 Wi-Fi 的 metric（数值越小优先级越高）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo nmcli connection modify <span class=\"string\">&quot;MyWiFi&quot;</span> ipv4.route-metric 100   <span class=\"comment\"># Wi-Fi 优先级更高</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>提高有线连接的 metric（数值越大优先级越低）</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo nmcli connection modify <span class=\"string\">&quot;有线连接名称&quot;</span> ipv4.route-metric 200</span><br></pre></td></tr></table></figure>\n\n<p>重新激活连接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo nmcli connection up <span class=\"string\">&quot;MyWiFi&quot;</span></span><br><span class=\"line\">sudo nmcli connection up <span class=\"string\">&quot;有线连接名称&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>验证优先级</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ip route</span><br><span class=\"line\">default via 192.168.2.1 dev wlp0s20f3 proto dhcp metric 20100 </span><br><span class=\"line\">default via 192.168.10.1 dev enp0s31f6 proto dhcp metric 20200 </span><br><span class=\"line\">169.254.0.0/16 dev enp0s31f6 scope link metric 1000 </span><br><span class=\"line\">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>关键点</strong>：Wi-Fi 的 <code>metric</code>（20100）比有线（20200）更小，因此优先级更高。</li>\n</ul>\n<p>如此便可实现网线ssh直连树莓派，同时笔记本通过Wi-Fi访问互联网不受影响。</p>\n"},{"title":"理解Zephyr项目的配置与构建系统","url":"/jayant97.github.io/2022/12/2a39e705bff0/","content":"<blockquote>\n<p>本文更新于2025.01.06，增加了对NCS2.7.0新引入的Sysbuild的介绍。补充了一些说明，使本文更详尽。</p>\n</blockquote>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>Zephyr Project是Linux基金会推出的一个Apache2.0开源项目，版权非常友好，适合用于商业项目开发。包含RTOS、编译系统、各类第三方库。NCS中的例程基本都跑在<a href=\"https://docs.zephyrproject.org/latest/kernel/index.html\">Zephyr RTOS</a>上。</p>\n<p>对于之前只接触过IDE+外设驱动库这种开发方式的开发者来说，Zephyr的配置和编译系统可能比较令人费解，但是一旦你能掌握，就会发现它的方便之处。</p>\n<p>本文重点介绍了NCS中的配置和编译工具。其中包含一些其他开发环境中常见的CMake，Kconfig，DeviceTree等的简单介绍，和Zephyr中特有的<strong>Sysbuild</strong>、<strong>Boards</strong>，以及Nordic提供的<strong>Partition Manager存储器分区</strong>等介绍。</p>\n<h1 id=\"2-通过CMake管理源码\"><a href=\"#2-通过CMake管理源码\" class=\"headerlink\" title=\"2. 通过CMake管理源码\"></a>2. 通过CMake管理源码</h1><p>本节只简要介绍NCS中常见的CMake使用方法，篇幅有限不可能完整的介绍CMake。希望完整学习CMake的话可以参考<a href=\"https://cmake.org/cmake/help/latest/guide/tutorial/index.html#guide:CMake%20Tutorial\">CMake官方文档</a>.</p>\n<h2 id=\"CMake基本写法\"><a href=\"#CMake基本写法\" class=\"headerlink\" title=\"CMake基本写法\"></a>CMake基本写法</h2><p>通过<code>zephyr/samples/hello_world</code>例程的<code>CMakeLists.txt</code>，我们可以看到：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定CMake版本</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.20</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从系统环境变量$&#123;ZEPHYR_BASE&#125;找到NCS中的Zephyr安装目录</span></span><br><span class=\"line\"><span class=\"comment\"># 并把整个Zephyr系统当作包来导入</span></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Zephyr REQUIRED HINTS $ENV&#123;ZEPHYR_BASE&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设定项目名称</span></span><br><span class=\"line\"><span class=\"keyword\">project</span>(hello_world)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把main.c添加为app目标的源码</span></span><br><span class=\"line\"><span class=\"keyword\">target_sources</span>(app PRIVATE src/main.c)</span><br></pre></td></tr></table></figure>\n\n<p>这里的编译目标是<code>app</code>，最终会编译为<code>libapp.a</code>，也就是把用户自己的应用层代码编译成库的形式。最后再链接进Zephyr系统。</p>\n<p>这里的<code>PRIVATE</code>控制的是编译的行为：</p>\n<ul>\n<li><code>PRIVATE</code>：main.c修改后，只会重新编译app目标</li>\n<li><code>PUBLIC</code>：main.c修改后，app目标要重新编译，且所有与APP目标链接的其他目标也要重新编译</li>\n</ul>\n<h2 id=\"条件添加源码\"><a href=\"#条件添加源码\" class=\"headerlink\" title=\"条件添加源码\"></a>条件添加源码</h2><p>条件添加也很好理解，就是某个CMake变量值为true时，才把源码添加到目标中去。例如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Include UART ASYNC API adapter</span></span><br><span class=\"line\">target_sources_ifdef(CONFIG_BT_NUS_UART_ASYNC_ADAPTER app PRIVATE</span><br><span class=\"line\">  src/uart_async_adapter.c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>这里就是<code>CONFIG_BT_NUS_UART_ASYNC_ADAPTER</code>为<code>y</code>时，才添加<code>src/uart_async_adapter.c</code>到源码中。</p>\n<h2 id=\"把整个目录添加源码\"><a href=\"#把整个目录添加源码\" class=\"headerlink\" title=\"把整个目录添加源码\"></a>把整个目录添加源码</h2><p>有时目录层级很多，我们没必要在一个CMakeLists.txt里把所有源码都添加完。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-CMakeLists.txt</span><br><span class=\"line\">|-aaa</span><br><span class=\"line\">|  |-CMakeLists.txt</span><br><span class=\"line\">|  `-main.c</span><br><span class=\"line\">`-bbb</span><br><span class=\"line\">   |-CMakeLists.txt</span><br><span class=\"line\">   `-hello.c</span><br></pre></td></tr></table></figure>\n\n<p>这时，就可以在项目根目录的CMakeLists.txt中写：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(aaa)</span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(bbb)</span><br></pre></td></tr></table></figure>\n\n<p>然后在两个子目录的CMakeLists.txt中添加对应的源码。</p>\n<p>当然，目录也是可以条件添加的，最典型的就是在<code>$&#123;NCS&#125;/zephyr/driver/CMakeLists.txt</code>中：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_subdirectory_ifdef(CONFIG_ADC adc)</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，只有启用了<code>CONFIG_ADC=y</code>，Zephyr才会去编译<code>$&#123;NCS&#125;/zephyr/driver/adc/</code>目录下的驱动。</p>\n<p>此外，如果再去看<code>$&#123;NCS&#125;/zephyr/driver/adc/CMakeLists.txt</code>：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_MCUX_LPADC    adc_mcux_lpadc.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_SAM_AFEC    adc_sam_afec.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_NRFX_ADC    adc_nrfx_adc.c)</span><br><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_ADC_NRFX_SAADC    adc_nrfx_saadc.c)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>就可以看到，这里又根据不同的MCU平台，来添加对应的adc驱动代码。</p>\n<h2 id=\"添加include目录\"><a href=\"#添加include目录\" class=\"headerlink\" title=\"添加include目录\"></a>添加include目录</h2><p>也就是存放头文件的目录，如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加CMakeLists.txt所在目录下的inc/目录到app目标</span></span><br><span class=\"line\"><span class=\"keyword\">target_include_directories</span>(app PRIVATE inc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也是可以条件添加的</span></span><br><span class=\"line\">zephyr_include_directories_ifdef(CONFIG_MEMFAULT configuration/memfault)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置变量\"><a href=\"#设置变量\" class=\"headerlink\" title=\"设置变量\"></a>设置变量</h2><p>和宏定义类似，把A定义成B。主要是用来定义一些编译系统会用到的东西，例如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定自己项目的device tree overlay文件</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>(DTC_OVERLAY_FILE app.oerlay)</span><br></pre></td></tr></table></figure>\n\n<p>除了上述直接把变量定义写在CMakeLists.txt内，还可以在命令行编译时，通过<code>-D</code>选项传入的参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -b nrf52840dk/nrf52840 -d build --sysbuild -- -D DTC_OVERLAY_FILE app.overlay</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，CMake参数的传递在<code>--</code>之后，再用多个<code>-D</code>分别传入。</p>\n</blockquote>\n<p>上述通过编译命令添加的CMake变量，也可以在nRF Connect for VS Code的界面中编译时输入：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250106223923162.webp\" alt=\"image-20250106223923162\"></p>\n<p>在CMakeLists.txt中用<code>set()</code>函数，或者在命令行编译时用<code>-D</code>参数，都可以设置你<strong>自定义</strong>的变量。但是更多时候，还是用来设置Zephyr编译系统的一些选项，这里给出一个表格，方便查找：</p>\n<details>\n    <summary>Zephyr系统自带选项[点击展开]</summary>\n\n<h3 id=\"CMake中直接修改Kconfig配置项\"><a href=\"#CMake中直接修改Kconfig配置项\" class=\"headerlink\" title=\"CMake中直接修改Kconfig配置项\"></a>CMake中直接修改Kconfig配置项</h3><p>直接在CMake中指定某个Kconfig选项的值。</p>\n<p>命令行参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-D&lt;name_of_Kconfig_option&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CONF-FILE\"><a href=\"#CONF-FILE\" class=\"headerlink\" title=\"CONF_FILE\"></a>CONF_FILE</h3><p>设置当前工程的Kconfig基本配置文件。通常是prj.conf。</p>\n<p>命令行参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置默认的配置文件</span></span><br><span class=\"line\">-DCONF_FILE=&lt;file_name&gt;.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置特定Build Type下的配置文件</span></span><br><span class=\"line\">-DCONF_FILE=prj_&lt;build_type_name&gt;.conf`</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SHIELD\"><a href=\"#SHIELD\" class=\"headerlink\" title=\"SHIELD\"></a>SHIELD</h3><p>很多开发板都是支持Arduino接口的，因此很多器件厂商&#x2F;分销商会制作Ardiono接口的扩展板：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028214708544.webp\" alt=\"image-20231028214708544\"></p>\n<p>Zephyr中，也会有这些扩展板的配置（包含device tree和Kconfig）。如果要在工程中启用扩展板，则需要设置CMake变量：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(SHIELD nrf21540_ek)</span><br></pre></td></tr></table></figure>\n\n<p>或者在编译目标的配置中添加CMake参数：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028215131762.webp\" alt=\"image-20231028215131762\"></p>\n<p>编译时，会自动合并原始板子和扩展板的Kconfig和Devicetree。</p>\n<h3 id=\"更多CMake配置项，请参考Providing-CMake-Options\"><a href=\"#更多CMake配置项，请参考Providing-CMake-Options\" class=\"headerlink\" title=\"更多CMake配置项，请参考Providing CMake Options\"></a>更多CMake配置项，请参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/cmake/index.html#providing_cmake_options\"><u>Providing CMake Options</u></a></h3></details>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>项目通过CMake管理源码和include目录。项目本身会把应用代码编译成<code>build/app/libapp.a</code>，最后和Zephyr系统一起链接成可执行文件。</p>\n<p>Zephyr系统本身的内核、库、驱动等源码也都是用CMake来管理的。</p>\n<h1 id=\"3-通过Kconfig管理配置\"><a href=\"#3-通过Kconfig管理配置\" class=\"headerlink\" title=\"3. 通过Kconfig管理配置\"></a>3. 通过Kconfig管理配置</h1><p>一个编译系统中，肯定有很多配置项的需求，如：</p>\n<ul>\n<li>布尔类型：开关某些功能，决定一些库和内核功能代码是否参与编译</li>\n<li>枚举类型：配置某些预设好的功能，比如日志打印级别(ERR&#x2F;WRN&#x2F;INF&#x2F;OFF)等</li>\n<li>数值类型：设置具体参数，如线程栈大小、蓝牙MTU Size大小等</li>\n</ul>\n<p>以上功能当然可以通过宏定义来实现。但是宏的作用比较有限，且所有的宏都是平等的，无法结构化地管理。</p>\n<p>Kconfig就是用来结构化地管理整个项目以及SDK中所有的配置项的。</p>\n<p>在Zephyr系统中，RTOS内核、各个功能模块都会有自己的配置项；并且，开发者自己的项目也会有很多配置项。这些配置项之间可能还有依赖关系。</p>\n<p>Kconfig就是把一个模块的<strong>所有配置项组成一个菜单</strong>。所有模块的菜单，通过层级关系拼接在一起，形成一个大菜单。菜单有默认配置项，开发者可以随意修改配置项。只需把自己和默认配置项有差异的部分写到一个<em><em>配置文件（</em>.conf）</em>*中，就可以方便地进行配置项的管理了。</p>\n<p>在管理配置项时，Kconfig相比于宏定义有许多优势：</p>\n<ol>\n<li>Kconfig不止适用于源码。编译系统（CMake）也可以用到其中的配置来决定源码是否参与编译。</li>\n<li>Kconfig是结构化的，可以规定配置项之间的依赖关系；支持提前枚举好允许的配置范围。</li>\n<li>Kconfig菜单方便互相引用。一个功能库在提供源码和API之外，还会提供一个Kconfig菜单，方便开发者使用。</li>\n<li>配置项可以保存到配置文件中。多个配置文件可以合并、覆盖。</li>\n</ol>\n<h2 id=\"Kconfig交互式菜单\"><a href=\"#Kconfig交互式菜单\" class=\"headerlink\" title=\"Kconfig交互式菜单\"></a>Kconfig交互式菜单</h2><p>我们知道，Kconfig实际上是定义了一个菜单，在哪里能看到这个菜单呢？</p>\n<p>我们可以在VS Code中点击nRF Kconfig GUI:</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028192036882.webp\" alt=\"image-20231028192036882\"></p>\n<p>也可以把鼠标悬浮在这个按钮上，点右边的三个点，然后用Guiconfig（弹窗）或Menuconfig（命令行）的方式进行配置。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028192059493.webp\" alt=\"image-20231028192059493\"></p>\n<p>这里就只介绍nRF Kconfig GUI：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20231028192424706.webp\" alt=\"image-20231028192424706\"></p>\n<h2 id=\"修改并保存配置项\"><a href=\"#修改并保存配置项\" class=\"headerlink\" title=\"修改并保存配置项\"></a>修改并保存配置项</h2><p>如果我们只是单纯点击界面右上角的”Apply”，那么这些配置是保存在<code>.config</code>中的。这是编译过程中生成的一个<strong>临时文件</strong>，是把各种配置项来源整合到一起，得到的最终配置文件。</p>\n<p>如果我们进行pristine build，那么<code>.config</code>文件就会重新生成，我们之前的修改就消失了。</p>\n<p><strong>要想永久保存，应该点击“save to file”。然后保存到配置文件（如<code>prj.conf</code>）中。</strong></p>\n<p>当你熟练后，就不需要再去这个菜单中找选项了，直接修改配置文件（如<code>prj.conf</code>）即可。</p>\n<h2 id=\"构建时配置项的合并\"><a href=\"#构建时配置项的合并\" class=\"headerlink\" title=\"构建时配置项的合并\"></a>构建时配置项的合并</h2><p>配置项有许多来源。在构建可执行文件时，会在configure阶段，compile之前，对所有来源的配置项按顺序进行合并，合并后的文件就是前面说的临时配置文件<code>.config</code>，路径为：</p>\n<p><code>&lt;build_dir&gt;/&lt;application_name&gt;/zephyr/.config</code></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250106233645472.webp\" alt=\"image-20250106233645472\"></p>\n<blockquote>\n<p>注：在NCS v2.7.0之前，未采用Sysbuild。不使用Sysbuild时，合并后的配置文件位于<code>build/zephyr/.config</code></p>\n</blockquote>\n<p>那么，配置项总共有哪些来源呢？</p>\n<ol>\n<li>Kconfig菜单中的默认值</li>\n<li>选择板子后，板子自带的一些config。可以在<code>zephyr/boards</code>或者<code>nrf/boards</code>中查看。</li>\n<li>CMake变量<code>CONF_FILE</code>指定的配置文件内的配置项，<strong>这也是最常用的</strong>。默认情况下是以下两个文件：<ul>\n<li>项目的<code>prj.conf</code>，它可以覆盖默认值；</li>\n<li>项目的<code>boards/&lt;board_name&gt;.conf</code>，当编译目标中选择的板子和这里的board_name一致时，可以覆盖默认值。此配置和前一项会合并。</li>\n</ul>\n</li>\n<li>CMake变量<code>EXTRA_CONF_FILE</code>指定的额外配置文件，也就是在VS Code中创建新的build target时，可以选择的”Extra Kconfig fragments”</li>\n</ol>\n<h2 id=\"了解Kconfig菜单基本写法\"><a href=\"#了解Kconfig菜单基本写法\" class=\"headerlink\" title=\"了解Kconfig菜单基本写法\"></a>了解Kconfig菜单基本写法</h2><details>\n    <summary>[点击展开]</summary>\n\n<p>可以先从一个简单的例子<code>$&#123;NCS&#125;/nrf/samples/bluetooth/peripheral_uart</code>来参考：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 引用Zephyr的Kconfig菜单</span><br><span class=\"line\">source &quot;Kconfig.zephyr&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义本项目的菜单</span><br><span class=\"line\">menu &quot;Nordic UART BLE GATT service sample&quot;</span><br><span class=\"line\">   ... 此处省略...</span><br><span class=\"line\">endmenu</span><br></pre></td></tr></table></figure>\n\n<p>菜单中的选项，可以配置它的类型、说明，和<strong>默认值</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 此选项用来设置Nordic UART Service线程的栈大小</span><br><span class=\"line\"># 并且具有默认值</span><br><span class=\"line\">config BT_NUS_THREAD_STACK_SIZE</span><br><span class=\"line\">    int &quot;Thread stack size&quot;</span><br><span class=\"line\">    default 1024</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Stack size used in each of the two threads</span><br></pre></td></tr></table></figure>\n\n<p>菜单中的选项可以<strong>连锁使能</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 当本选项被设置成y时，通过select，同时把CONFIG_BT_SMP的值设置成y</span><br><span class=\"line\">config BT_NUS_SECURITY_ENABLED</span><br><span class=\"line\">    bool &quot;Enable security&quot;</span><br><span class=\"line\">    default y</span><br><span class=\"line\">    select BT_SMP</span><br><span class=\"line\">    help</span><br><span class=\"line\">      &quot;Enable BLE security for the UART service&quot;</span><br></pre></td></tr></table></figure>\n\n<p>此外，一个选项也可以指定一个<strong>依赖项</strong>。如果本选项被启用，但依赖项未被启用，则编译前的配置过程就会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 配置是否在系统启动时，自动初始化USB ACM设备 （用于输出日志）</span><br><span class=\"line\"># 此配置依赖于CONFIG_USB_CDC_ACM=y，也就是说，起码要把USB_CDC_ACM的代码编译进来</span><br><span class=\"line\">config USB_DEVICE_INITIALIZE_AT_BOOT</span><br><span class=\"line\">    bool &quot;Initialize USB device support at boot&quot;</span><br><span class=\"line\">    depends on USB_CDC_ACM</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Use CDC ACM UART as backend for console, shell, or logging.</span><br></pre></td></tr></table></figure>\n\n<p>当然，Kconfig也不是说要写的非常大，把整个项目的配置都写进去。你也可以每个子文件夹下单独写Kconfig，然后在项目的Kconfig中进行包含：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 通过绝对路径进行包含</span><br><span class=\"line\">source &quot;xxx.Kconfig&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 通过相对路径进行包含</span><br><span class=\"line\">rsource &quot;src/xxx.Kconfig&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>某些简单例程，例如<code>zephyr/samples/hello_world</code>，没有什么配置项，所以是可以没有自己的Kconfig的。这种情况下，相当于直接用了Zephyr的Kconfig菜单，也就是相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</details>\n\n<h2 id=\"显性与隐性配置项\"><a href=\"#显性与隐性配置项\" class=\"headerlink\" title=\"显性与隐性配置项\"></a>显性与隐性配置项</h2><details>\n    <summary>[点击展开]</summary>\n\n<p>在Kconfig中定义菜单选项时，我们会发现，大多数选项，在变量类型后面会有一个**说明字符串(prompt)**。</p>\n<p>如<code>bool</code>后面的<code>&quot;Support floating point operations&quot;</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config FPU</span><br><span class=\"line\">   bool &quot;Support floating point operations&quot;</span><br><span class=\"line\">   depends on HAS_FPU</span><br></pre></td></tr></table></figure>\n\n<p>这意味着，这个配置项会出现在Kconfig交互式菜单中，我们可以在交互式菜单中修改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ ] Support floating point operations</span><br></pre></td></tr></table></figure>\n\n<p>也可以用<code>prj.conf</code>之类的配置文件来直接改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_FPU=y</span><br></pre></td></tr></table></figure>\n\n<p>但是，也有一些<strong>隐性配置项</strong>，它们的变量类型后面不带说明字符串，我们无法直接修改它的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config CPU_HAS_FPU</span><br><span class=\"line\">   bool</span><br><span class=\"line\">   help</span><br><span class=\"line\">     This symbol is y if the CPU has a hardware floating point unit.</span><br></pre></td></tr></table></figure>\n\n<p>一个CPU到底带不带FPU，肯定不由开发者的配置决定，因此不能直接修改是很合理的。</p>\n<p>这种配置，通常是通过<strong>连锁使能select</strong>的方式，被其他配置项使能的，例如<code>zephyr/soc/arm/nordic_nrf/nrf52/Kconfig.soc</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 隐性配置项</span><br><span class=\"line\">config SOC_NRF52840</span><br><span class=\"line\">    bool</span><br><span class=\"line\">    select CPU_CORTEX_M_HAS_DWT</span><br><span class=\"line\">    select CPU_HAS_FPU</span><br><span class=\"line\">    </span><br><span class=\"line\"> ... </span><br><span class=\"line\"> </span><br><span class=\"line\"> # 显性配置项</span><br><span class=\"line\"> config SOC_NRF52840_QIAA</span><br><span class=\"line\">    bool &quot;NRF52840_QIAA&quot;</span><br><span class=\"line\">    select SOC_NRF52840</span><br></pre></td></tr></table></figure>\n\n<p>而这个<code>SOC_NRF52840_QIAA</code>，是我们选择板子时，52840DK的板子自带的默认配置，来自于<code>zephyr/samples/application_development/out_of_tree_board/boards/arm/nrf52840dk_nrf52840/nrf52840dk_nrf52840_defconfig</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_SOC_NRF52840_QIAA=y</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Zephyr的配置系统是Kconfig定义的菜单。可以用<code>prj.conf</code>之类的文件来修改配置项的值。</p>\n<p>Kconfig中的配置项，可以影响CMake中的条件，选择是否添加哪些源码，从而剪裁内核。</p>\n<p>Kconfig中的配置项，最终会生成到<code>build/&lt;project_name&gt;/zephyr/include/generated/autoconf.h</code>中，成为源代码中也可以用到的宏。</p>\n<p>不要去尝试修改隐性的Kconfig配置项。</p>\n<h1 id=\"4-DeviceTree和Zephyr驱动模型\"><a href=\"#4-DeviceTree和Zephyr驱动模型\" class=\"headerlink\" title=\"4. DeviceTree和Zephyr驱动模型\"></a>4. DeviceTree和Zephyr驱动模型</h1><p>device tree比较复杂，具体的语法、使用方法可以参考我的另一篇文章：<a href=\"https://www.cnblogs.com/jayant97/articles/17209392.html\">《详解Zephyr设备树（DeviceTree）与驱动模型》</a>。</p>\n<p>本文中尽量简洁地说明device tree的用途。</p>\n<h2 id=\"设备树文件\"><a href=\"#设备树文件\" class=\"headerlink\" title=\"设备树文件\"></a>设备树文件</h2><p>device tree的文件是Device Tree Source (DTS)。这里用最简洁的语言描述一下dts文件的产生：</p>\n<ol>\n<li>芯片级的dts文件，定义了芯片上的各种外设资源及其地址；</li>\n<li>板级的dts文件，可以包含芯片级的dts文件。除了芯片之外，也会包含板子上的资源，如按键、LED、i2c等总线上挂的外设等等；</li>\n<li>在工程中选板子时，实际上就是选择了板级的dts文件。在工程中，如果想修改默认的dts，是通过<code>*.overlay</code>文件进行覆盖；例如开发板默认的dts（SDK中的文件）默认没有打开串口1，那么就可以在Overlay文件（你的工程中的文件）中打开串口1；</li>\n<li>build target时，所有这些dts会在编译目录下合并成<code>zephyr.dts</code>。这就是最终的dts。</li>\n</ol>\n<blockquote>\n<h4 id=\"合并dts的位置\"><a href=\"#合并dts的位置\" class=\"headerlink\" title=\"合并dts的位置\"></a>合并dts的位置</h4><p>NCS v2.7.0引入了sysbuild，zephyr.dts的路径为<code>build/&lt;application_name&gt;/zephyr/zephyr.dts</code>;</p>\n<p>在NCS v2.6.x之前，zephyr.dts的路径为：<code>build/zephyr/zephyr.dts</code>;</p>\n<h4 id=\"overlay文件\"><a href=\"#overlay文件\" class=\"headerlink\" title=\"overlay文件\"></a>overlay文件</h4><p>如果说<code>*.conf</code>文件是你当前工程的软件配置，那么<code>*.overlay</code>文件就是你的当前工程的<strong>硬件配置</strong>。</p>\n<ul>\n<li><code>app.overlay</code>是整个项目的overlay，如果CMake不设置<code>DTC_OVERLAY_FILE</code>,则默认使用app.overlay</li>\n<li><code>boards/&lt;board_name&gt;.overlay</code>是板子对应的overlay</li>\n</ul>\n</blockquote>\n<p>外设的使能与关闭，引脚的分配等与硬件相关的内容，都在dts overlay文件中编写。修改时，注意不要修改SDK里的dts，因为这会影响其他的工程。只在自己的工程内用Overlay修改就好。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 例如，在overlay中使能串口1. uart1是label，可以直接引用</span><br><span class=\"line\">&amp;uart1 &#123;</span><br><span class=\"line\">    compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 另一种写法，不用label，而用绝对路径</span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">    soc&#123;</span><br><span class=\"line\">        uart@40028000&#123;</span><br><span class=\"line\">            compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class=\"line\">            status = &quot;okay&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Zephyr驱动程序\"><a href=\"#Zephyr驱动程序\" class=\"headerlink\" title=\"Zephyr驱动程序\"></a>Zephyr驱动程序</h2><p>在<code>main()</code>函数运行起来之前，zephyr设备驱动的初始化程序就已经先运行了。设备的驱动程序根据device tree中的配置，自动把外设进行相应的初始化，配置寄存器。然后driver还会提供一个<code>struct device</code>结构体，方便应用层操作这个外设。</p>\n<p>程序的application层起来之后，开发者就可以用driver初始化好的device结构体，用标准的Zephyr API进行操作。</p>\n<p>有以下5个阶段可以用来初始化外设驱动：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20230312215847338.webp\" alt=\"image-20230312215847338\"></p>\n<p>Zephyr外设驱动的整个流程：</p>\n<p>【编译阶段】</p>\n<ol>\n<li><p>开发者在Kconfig中，使能了某个外设驱动，如<code>CONFIG_SERIAL=y</code></p>\n</li>\n<li><p><code>zephyr/driver/</code>下的CMakeLists.txt，根据<code>CONFIG_SERIAL=y</code>，把<code>zephyr/driver/serial/</code>添加到工程中</p>\n</li>\n<li><p><code>zephyr/driver/serial/</code>下有各个半导体厂商向Zephyr提交的串口驱动代码。此目录下的CMakeLists.txt根据你的当前Kconfig配置，来选择哪个驱动文件编译进来：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">zephyr_library_sources_ifdef(CONFIG_UART_NRFX_UART uart_nrfx_uart.c)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (CONFIG_UART_NRFX_UARTE)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (CONFIG_UART_NRFX_UARTE_LEGACY_SHIM)</span><br><span class=\"line\">    zephyr_library_sources(uart_nrfx_uarte.c)</span><br><span class=\"line\">  <span class=\"keyword\">else</span>()</span><br><span class=\"line\">    zephyr_library_sources(uart_nrfx_uarte2.c)</span><br><span class=\"line\">  <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>驱动代码中，会通过宏来匹配<code>zephyr.dts</code>中的所有串口节点，也就是匹配哪些节点的<code>compatible</code>与当前驱动是一致的。然后，再匹配这些节点的<code>status=&quot;okay&quot;</code>，就说明这个外设被使能了，于时就定义一个<code>device</code>结构体实例。</p>\n</li>\n</ol>\n<blockquote>\n<p>device结构体的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\"> <span class=\"type\">const</span> <span class=\"type\">char</span> *name;           <span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\"> <span class=\"type\">const</span> <span class=\"type\">void</span> *config;         <span class=\"comment\">// 设备的初始配置</span></span><br><span class=\"line\"> <span class=\"type\">const</span> <span class=\"type\">void</span> *api;            <span class=\"comment\">// 设备的api函数集合</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_state</span> *<span class=\"title\">state</span>;</span> <span class=\"comment\">// 设备的工作状态</span></span><br><span class=\"line\"> <span class=\"type\">void</span> *data;                 <span class=\"comment\">// 设备的运行数据</span></span><br><span class=\"line\"> <span class=\"comment\">/* ... */</span>                   <span class=\"comment\">// 其他参数，例如电源管理</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>【运行阶段】</p>\n<ol>\n<li>系统启动后，在设备驱动程序预设好的阶段（上图5个阶段之一），进行外设的初始化和配置。配置的值就来自于dts overlay中节点的配置。<br>如果是外挂芯片的驱动，则会在这个阶段完成外挂芯片的配置（如SPI总线的液晶屏、I2C总线的RTC时钟等）。<br>以上只是两个示例，具体的行为，要看根据驱动程序的代码。</li>\n<li>程序进入到应用层之后，所有需要的外设就已经被初始化好了。在应用层代码中，开发者只需先获得这个device结构体的指针，后续调用Zephyr标准外设API时，把这个指针作为参数传入即可。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如，获取串口1的device结构体指针</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">uart1_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(uart1));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用串口1发送数据</span></span><br><span class=\"line\">uart_tx(uart1_dev, buf, len, timeout);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Zephyr驱动模型的优劣\"><a href=\"#Zephyr驱动模型的优劣\" class=\"headerlink\" title=\"Zephyr驱动模型的优劣\"></a>Zephyr驱动模型的优劣</h2><p>优点：</p>\n<ul>\n<li>代码里调用的都是Zephyr标准API，与硬件细节无关。如果后需要更换MCU平台，几乎没有什么移植成本，只需要更换所选的board即可。</li>\n<li>通用性强，无论是普通的串口，还是USB串口，抑或是<a href=\"\">LPUART</a>，它们的应用层代码均是Zephyr标准API，只需要更换底层驱动即可。</li>\n<li>开发者无需花精力在标准、通用的基本功能上，如串口、SPI、网络、按钮等。因为这些驱动都是厂商提供的，在性能、健壮性、功能性上往往都强于开发者自己用寄存器或外设驱动库开发的代码。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><p>上手难度稍高，需要花精力去学习语法，并且要简单了解驱动代码</p>\n</li>\n<li><p>功能不完全。Zephyr只提供最标准的用法，当用到串口、spi、i2c等协议时，就是最标准的协议。一旦有不符合标准的，或者Zephyr标准库未提供的功能，就无法在Zephyr驱动模型的框架下实现了。</p>\n<blockquote>\n<p>例如，nordic的芯片有PPI的功能，可以让一个外设的event触发另一个外设的task。这个功能Zephyr是没有标准驱动的。</p>\n<p>Nordic可以在提交给Zephyr的驱动代码中用PPI。例如，在串口驱动中，通过uart外设和timer外设，加上PPI，实现异步流控串口（Timer的作用是记录发送&#x2F;接收了多少字节，然后用PPI控制GPIO CTS&#x2F;RTS），<strong>Nordic提供的驱动代码，把他们整体封装成串口</strong>，也就是说，Zephyr标准驱动操作的串口，实际并不是单独对应uart这一个外设，而是UART+GPIOTE+TIMER+PPI的复合外设。</p>\n<p>如果用户想自己用PPI实现一些自定义功能，只能直接调用nrfx api。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Nordic-NRFX外设驱动库\"><a href=\"#Nordic-NRFX外设驱动库\" class=\"headerlink\" title=\"Nordic NRFX外设驱动库\"></a>Nordic NRFX外设驱动库</h2><p>如果你的需求比较特殊，想要绕过Zephyr驱动层，直接在底层驱动甚至寄存器和中断的级别来进行开发，NCS也是支持的。</p>\n<p>请参考<a href=\"https://www.cnblogs.com/jayant97/articles/17835258.html\">《在NCS中使用NRFX外设驱动库》</a>。</p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>dts怎么写，本质上取决于驱动代码里怎么读取dts。dts的本质就是保存硬件细节相关的信息，使自己的应用代码与硬件细节解耦。</p>\n<p>要更详细地了解Device Tree，请参考<a href=\"https://jayant-tang.github.io/jayant97.github.io/2023/03/4b274a50e575/\">《详解Zephyr设备树（DeviceTree）与驱动模型》</a>。</p>\n<h1 id=\"5-Sysbuild-System-build\"><a href=\"#5-Sysbuild-System-build\" class=\"headerlink\" title=\"5. Sysbuild (System build)\"></a>5. Sysbuild (System build)</h1><p>前面介绍的CMake, Kconfig, DeviceTree都是其他领域（如Linux内核）已经在广泛使用的配置工具。但是Sysbuild是Zephyr的新引入的构建机制，它是一个High-Level的配置工具，解决的是MCU多镜像编译的问题。</p>\n<p>前面介绍的那些工具，都是为了1个镜像编译时用的。当我们要编译一个多镜像的固件时，这些不同的镜像之间可能会有一些配置项的差别。</p>\n<p>例如，我希望我的串口用于打印日志，但是在bootloader镜像中，同一个串口用于固件升级。</p>\n<p>又比如，我选型了一款QSPI外挂Flash，与Nordic官方开发板上的Flash不同，于时我修改了我的工程中的overlay文件。但是，我也需要在某个地方修改bootloader工程的overlay文件，从而让bootloader也识别我的flash。</p>\n<p>以上说的是运行在同一个CPU上，不同镜像之间的<strong>差异配置</strong>。除此之外，还有运行在不同CPU上，不同镜像之间的<strong>相同配置</strong>，例如双核MCU上的App Core和Net Core，我希望同时配置为debug模式或release模式，而不是单独去调。</p>\n<h2 id=\"Sysbuild的开关\"><a href=\"#Sysbuild的开关\" class=\"headerlink\" title=\"Sysbuild的开关\"></a>Sysbuild的开关</h2><p>编译时可以决定是否使用Sysbuild</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build --sysbuild</span><br><span class=\"line\"></span><br><span class=\"line\">west build --no-sysbuild</span><br></pre></td></tr></table></figure>\n\n<p>在NCS v2.7.0之后，<code>west build</code>命令默认就是开启<code>--sysbuild</code>的。在NCS v2.6.x之前，则默认不开启。</p>\n<h2 id=\"命名空间（Namespace）\"><a href=\"#命名空间（Namespace）\" class=\"headerlink\" title=\"命名空间（Namespace）\"></a>命名空间（Namespace）</h2><p>在多镜像编译的场景下，我们用<code>west build</code>进行命令行编译时，如果要添加一些配置项，则可能需要指定，这个配置项是属于哪个子工程的，或者是属于整体的（Sysbuild）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 带有Namespace的Kconfig</span></span><br><span class=\"line\">-D&lt;namespace&gt;_CONFIG_&lt;var&gt;=&lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 带有Namespace的CMake选项</span></span><br><span class=\"line\">-D&lt;namespace&gt;_&lt;var&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -b reel_board --sysbuild samples/hello_world \\</span><br><span class=\"line\">    -- \\</span><br><span class=\"line\">        -DSB_CONFIG_BOOTLOADER_MCUBOOT=y \\</span><br><span class=\"line\">        -DCONFIG_DEBUG_OPTIMIZATIONS=y \\</span><br><span class=\"line\">        -Dmcuboot_CONFIG_DEBUG_OPTIMIZATIONS=y</span><br><span class=\"line\"><span class=\"comment\"># 给Sysbuild（全局）传递CONFIG_BOOTLOADER_MCUBOOT=y，表示使用bootloader作为MCUBOOT，命名空间为SB</span></span><br><span class=\"line\"><span class=\"comment\"># 给当前默认Application工程传递CONFIG_DEBUG_OPTIMIZATIONS=y，命名空间为空</span></span><br><span class=\"line\"><span class=\"comment\"># 给mcuboot工程传递CONFIG_DEBUG_OPTIMIZATIONS=y，命名空间为mcuboot，也就是子工程的名称</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Sysbuild配置文件\"><a href=\"#Sysbuild配置文件\" class=\"headerlink\" title=\"Sysbuild配置文件\"></a>Sysbuild配置文件</h2><p>除了上述在编译时传递编译选项的方法，也可以保存Sysbuild级别的配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">application/</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── CMakeLists.txt <span class=\"comment\"># application的CMake</span></span><br><span class=\"line\">├── prj.conf       <span class=\"comment\"># application的配置项</span></span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── Kconfig.sysbuild <span class=\"comment\"># Sysbuild全局级别的Kconfig菜单定义。可以不定义，不定义时使用SDK内的默认菜单</span></span><br><span class=\"line\">├── sysbuild.conf    <span class=\"comment\"># Sysbuild全局配置项</span></span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── sysbuild.cmake   <span class=\"comment\"># Sysbuild全局级别的CMake。可以用来管理有哪些工程镜像参与总镜像的编译</span></span><br><span class=\"line\">├── ...</span><br><span class=\"line\">└── sysbuild/         <span class=\"comment\"># Sysbuild目录下，可以分别给每个子工程单独进行配置</span></span><br><span class=\"line\">    └── mcuboot           </span><br><span class=\"line\">        ├── prj.conf</span><br><span class=\"line\">        ├── app.overlay</span><br><span class=\"line\">        └── boards</span><br><span class=\"line\">            ├── &lt;board_A&gt;.conf</span><br><span class=\"line\">            ├── &lt;board_A&gt;.overlay</span><br><span class=\"line\">            ├── &lt;board_B&gt;.conf</span><br><span class=\"line\">            └── &lt;board_B&gt;.overlay</span><br></pre></td></tr></table></figure>\n\n<p>关于sysbuild的例程，可以参考<code>zephyr/samples/sysbuild/</code>下的几个例程。</p>\n<h2 id=\"给Sysbuild添加子工程\"><a href=\"#给Sysbuild添加子工程\" class=\"headerlink\" title=\"给Sysbuild添加子工程\"></a>给Sysbuild添加子工程</h2><p>参考<code>zephyr/samples/sysbuild/hello_world</code>，这个工程是给双核MCU运行使用的。App核运行一个Hello World，然后同时再添加一个Hello World工程给另一个核使用。最后编译出双镜像固件。</p>\n<p>要给当前工程添加子工程，其实就是修改<code>sysbuild.cmake</code>。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">ExternalZephyrProject_Add(</span><br><span class=\"line\">  APPLICATION my_sample                 <span class=\"comment\"># 要添加的工程名</span></span><br><span class=\"line\">  SOURCE_DIR &lt;path-to&gt;/my_sample        <span class=\"comment\"># 要添加的工程路径</span></span><br><span class=\"line\">  BOARD mps2_an521_remote               <span class=\"comment\"># 如有必要，单独指定要添加的工程使用的board</span></span><br><span class=\"line\">  BUILD_ONLY <span class=\"keyword\">TRUE</span>                       <span class=\"comment\"># 如有必要，可以只编译不烧录</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 要先编译my_sample,再编译当前默认application工程</span></span><br><span class=\"line\">sysbuild_add_dependencies(CONFIGURE <span class=\"variable\">$&#123;DEFAULT_IMAGE&#125;</span> my_sample)</span><br><span class=\"line\"><span class=\"comment\"># 等价于以下CMake标准函数</span></span><br><span class=\"line\"><span class=\"keyword\">add_dependencies</span>(<span class=\"variable\">$&#123;DEFAULT_IMAGE&#125;</span> my_sample)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 要先烧录my_sample,再烧录当前application工程</span></span><br><span class=\"line\">sysbuild_add_dependencies(FLASH <span class=\"variable\">$&#123;DEFAULT_IMAGE&#125;</span> my_sample)</span><br><span class=\"line\"><span class=\"comment\"># 如果my_sample配置为BUILD_ONLY=TRUE，则会报错</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别地，如果要添加的工程就是MCUBOOT，则只需在<code>sysbuid.conf</code>中添加下列配置即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">SB_CONFIG_BOOTLOADER_MCUBOOT=y</span><br></pre></td></tr></table></figure>\n\n<p>因为SDK中已经把MCUBOOT相关的sysbuild写好了，这里直接使能即可。</p>\n</blockquote>\n<h1 id=\"6-【已抛弃】parent-child-image\"><a href=\"#6-【已抛弃】parent-child-image\" class=\"headerlink\" title=\"6. 【已抛弃】parent-child image\"></a>6. 【已抛弃】parent-child image</h1><details>\n    <summary>[点击展开]</summary>\n\n<p>在NCS v2.6.x及之前的版本中，多镜像的管理靠的是parent-child image。这个工具不是Zephyr的，而是Nordic的。它也能在一个子文件夹里分别管理子镜像的配置。但它和Sysbuild的区别在于：它没有单独的High-Level的全局配置。这导致一些实际上应该属于全局的配置，直接放在了Application层的配置中（例如选择哪个Bootloader），因此偶尔会产生混淆。</p>\n<p>如使用老版本的NCS，建议参考老版本NCS关于这方面的文档：<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.7.0/page/nrf/config_and_build/multi_image.html\">https://docs.nordicsemi.com/bundle/ncs-2.7.0/page/nrf/config_and_build/multi_image.html</a></p>\n</details>\n\n<h1 id=\"7-存储器分区文件（Partition-Manager）\"><a href=\"#7-存储器分区文件（Partition-Manager）\" class=\"headerlink\" title=\"7. 存储器分区文件（Partition Manager）\"></a>7. 存储器分区文件（Partition Manager）</h1><p>管理一个MCU的存储器分区是很常见的需求。不仅在多镜像、OTA的场景下要管理，在内部和外部flash上挂载文件系统、用单独的分区存储生产信息等等场景下都要管理。</p>\n<p>存储器分区文件，尤其是带有外部flash的，可以参考Matter例程，例如<code>nrf/samples/matter/lock</code>。你可以看到很多<code>pm_static_xxx.yml</code>:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mcuboot:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x0</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0x7000</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">flash_primary</span></span><br><span class=\"line\"><span class=\"attr\">mcuboot_pad:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x7000</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0x200</span></span><br><span class=\"line\"><span class=\"attr\">app:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x7200</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0xefe00</span></span><br><span class=\"line\"><span class=\"attr\">mcuboot_primary:</span></span><br><span class=\"line\">  <span class=\"attr\">orig_span:</span> <span class=\"meta\">&amp;id001</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">mcuboot_pad</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">app</span></span><br><span class=\"line\">  <span class=\"attr\">span:</span> <span class=\"meta\">*id001</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x7000</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0xf0000</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">flash_primary</span></span><br><span class=\"line\"><span class=\"attr\">mcuboot_primary_app:</span></span><br><span class=\"line\">  <span class=\"attr\">orig_span:</span> <span class=\"meta\">&amp;id002</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">app</span></span><br><span class=\"line\">  <span class=\"attr\">span:</span> <span class=\"meta\">*id002</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x7200</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0xefe00</span></span><br><span class=\"line\"><span class=\"attr\">factory_data:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0xf7000</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0x1000</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">flash_primary</span></span><br><span class=\"line\"><span class=\"attr\">settings_storage:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0xf8000</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0x8000</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">flash_primary</span></span><br><span class=\"line\"><span class=\"attr\">mcuboot_secondary:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0x0</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0xf0000</span></span><br><span class=\"line\">  <span class=\"attr\">device:</span> <span class=\"string\">MX25R64</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">external_flash</span></span><br><span class=\"line\"><span class=\"attr\">external_flash:</span></span><br><span class=\"line\">  <span class=\"attr\">address:</span> <span class=\"number\">0xf0000</span></span><br><span class=\"line\">  <span class=\"attr\">size:</span> <span class=\"number\">0x710000</span></span><br><span class=\"line\">  <span class=\"attr\">device:</span> <span class=\"string\">MX25R64</span></span><br><span class=\"line\">  <span class=\"attr\">region:</span> <span class=\"string\">external_flash</span></span><br></pre></td></tr></table></figure>\n\n<p>详细的语法无需在意，不同工程基本都是大同小异的。</p>\n<blockquote>\n<p>【注意】配置Partition Manager时，一定要注意对齐Flash的Page！！！</p>\n</blockquote>\n<h2 id=\"静态分区文件说明\"><a href=\"#静态分区文件说明\" class=\"headerlink\" title=\"静态分区文件说明\"></a>静态分区文件说明</h2><h3 id=\"mcuboot相关\"><a href=\"#mcuboot相关\" class=\"headerlink\" title=\"mcuboot相关\"></a>mcuboot相关</h3><p>mcuboot相关照抄即可，只需修改地址和大小。</p>\n<ul>\n<li><code>mcuboot</code>，也就是mcuboot的固件大小。Matter的MCUBOOT配置是SDK中专门优化过的，因此只需要0x7000字节。一般来说自己添加一个需要0xc000的空间</li>\n<li><code>mcuboot_pad</code>：DFU期间，存储一些固件升级情况的标志位和校验信息</li>\n<li><code>mcuboot_primary</code>：也就是app所在的slot，同时也有mcuboot_pad。</li>\n<li><code>mcuboot_secondary</code>：也就是升级时新固件存放的slot。通常app负责接收新固件，然后跳转到mcuboot，mcuboot进行分区固件交换后，升级完成。secondary slot也可以放到外部flash</li>\n</ul>\n<h3 id=\"app相关\"><a href=\"#app相关\" class=\"headerlink\" title=\"app相关\"></a>app相关</h3><p>app相关照抄即可，只需修改地址和大小。</p>\n<ul>\n<li><code>app</code>与<code>mcuboot_primary_app</code>：都是app分区</li>\n</ul>\n<h3 id=\"settings-storage\"><a href=\"#settings-storage\" class=\"headerlink\" title=\"settings_storage\"></a>settings_storage</h3><p>settings_storage是Zephyr系统中一个存储配置项的分区，是一个简易的文件系统。可以用“字符串”（通常是文件路径，例如<code>id/serial</code>）作为句柄来存取数据（提供首地址、长度）。</p>\n<p>Zephyr中许多的Librarys都依赖Settings来存储持久化数据，例如蓝牙的绑定密钥。因此这个分区非常常见。考虑到用到Settings的组件非常多，最好不要把Settings放到外部flash，不然做外部flash低功耗时，如果外部flash休眠了，而某个组件要用到Settings，就会报错，非常麻烦。</p>\n<p>由于Settings是文件系统，因此它不是把数据单一的存在一个地址，而是像硬盘一样一直向后写，直到分区flash写满了，才把前面的page全部擦掉做垃圾回收。因此最好给settings_storage准备至少2个page的flash空间（上面的例子是0x8000，为两个4kB的page）。如果在特定极端峰值情况下，flash读写非常快且数量多，则需要3个page或以上。例如HomeKit认证时的循环蓝牙绑定16次测试，需要3个page。</p>\n<h3 id=\"其他分区\"><a href=\"#其他分区\" class=\"headerlink\" title=\"其他分区\"></a>其他分区</h3><p>其他分区没有什么特别的，就是用一个label定义一个分区名称。</p>\n<ul>\n<li><code>factory_data</code>：在Matter工程中，用于存储证书等数据的分区。</li>\n<li><code>external_flash</code>：外部flash空余的位置，随意进行了一个命名。</li>\n</ul>\n<p>其实Partition Manager只是一套脚本，最终还是要落实到C代码。在代码中，可以通过label来访问这些分区。例如Matter的SDK中就会通过<code>factory_data</code>来访问认证证书等数据。</p>\n<p>你也可以充分利用这个未使用的分区。用<code>nrf/include/flash_map_pm.h</code>中定义的宏函数，来吧这些label转化成Zephyr可以使用的Flash Device句柄和分区句柄。例如把这个<code>external_flash</code>分区拿来建立NVS文件系统。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/storage/flash_map.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NVS_PARTITION        external_storage</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NVS_PARTITION_DEVICE    FIXED_PARTITION_DEVICE(NVS_PARTITION)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NVS_PARTITION_OFFSET    FIXED_PARTITION_OFFSET(NVS_PARTITION)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/fs/nvs.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nvs_fs</span> <span class=\"title\">fs</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">app_nvs_entry</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> key[<span class=\"number\">8</span>], longarray[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> reboot_counter = <span class=\"number\">0U</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">flash_pages_info</span> <span class=\"title\">info</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* define the nvs file system by settings with:</span></span><br><span class=\"line\"><span class=\"comment\">     *\tsector_size equal to the pagesize,</span></span><br><span class=\"line\"><span class=\"comment\">     *\t3 sectors</span></span><br><span class=\"line\"><span class=\"comment\">     *\tstarting at NVS_PARTITION_OFFSET</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    fs.flash_device = NVS_PARTITION_DEVICE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!device_is_ready(fs.flash_device)) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Flash device %s is not ready&quot;</span>, fs.flash_device-&gt;name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fs.offset = NVS_PARTITION_OFFSET;</span><br><span class=\"line\">    rc = flash_get_page_info_by_offs(fs.flash_device, fs.offset, &amp;info);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rc) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Unable to get page info&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fs.sector_size = info.size;</span><br><span class=\"line\">    fs.sector_count = PAGE_COUNT;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_INF(<span class=\"string\">&quot;NVS sector size: %d, sector count: %d&quot;</span>, fs.sector_size, fs.sector_count);</span><br><span class=\"line\"></span><br><span class=\"line\">    rc = nvs_mount(&amp;fs);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rc) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Flash Init failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>值的一提的是，根据<code>nrf/include/flash_map_pm.h</code>中的定义，当使用以下三种文件系统时，最好就使用那个名字作为label</p>\n<ul>\n<li><code>settings_storage</code></li>\n<li><code>littlefs_storage</code></li>\n<li><code>nvs_storage</code></li>\n</ul>\n</blockquote>\n<h2 id=\"外部Flash分区\"><a href=\"#外部Flash分区\" class=\"headerlink\" title=\"外部Flash分区\"></a>外部Flash分区</h2><p>当某个分区位于外部Flash时，这个分区需要配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">region:</span> <span class=\"string\">external_flash</span></span><br><span class=\"line\"><span class=\"attr\">device:</span> <span class=\"string\">MX25R64</span></span><br></pre></td></tr></table></figure>\n\n<p>其中device是需要在设备树中配置的，要让partition manager知道外部flash是哪个设备，比如这里是<code>mx25r64</code>这个节点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ &#123;</span><br><span class=\"line\">    chosen &#123;</span><br><span class=\"line\">        nordic,pm-ext-flash = &amp;mx25r64;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果Bootloader也需要访问外部flash，不要忘记在mcuboot中也添加以上配置。</p>\n<blockquote>\n<p>除此之外，还要注意。如果不得已要把文件系统放在外部flash，一定要使能对应的配置，例如：</p>\n<ul>\n<li><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/kconfig/index.html#CONFIG_PM_PARTITION_REGION_LITTLEFS_EXTERNAL\"><code>CONFIG_PM_PARTITION_REGION_LITTLEFS_EXTERNAL</code></a></li>\n<li><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/kconfig/index.html#CONFIG_PM_PARTITION_REGION_SETTINGS_STORAGE_EXTERNAL\"><code>CONFIG_PM_PARTITION_REGION_SETTINGS_STORAGE_EXTERNAL</code></a></li>\n<li><a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/kconfig/index.html#CONFIG_PM_PARTITION_REGION_NVS_STORAGE_EXTERNAL\"><code>CONFIG_PM_PARTITION_REGION_NVS_STORAGE_EXTERNAL</code></a></li>\n</ul>\n<p>并且这些配置是，只有当你用Nordic的QSPI Flash驱动时（<code>compatible = &quot;nordic,qspi-nor&quot;</code>）才有作用的。</p>\n</blockquote>\n<p>更多使用外部flash的细节，见<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/app_dev/bootloaders_dfu/mcuboot_nsib/bootloader_partitioning.html#ug-bootloader-external-flash\">文档</a>.</p>\n<h2 id=\"动态分区\"><a href=\"#动态分区\" class=\"headerlink\" title=\"动态分区\"></a>动态分区</h2><p>实际上Partition Manager还支持根据不同子工程编译的大小动态分区。但是动态分区对于实际的项目来说没有任何意义，实际项目一定都需要静态分区，才能确保固件升级（DFU）的正确性。</p>\n<p>如需了解更多，参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/scripts/partition_manager/partition_manager.html\">Partition Manager文档</a>。</p>\n<h2 id=\"检查Partition-Manager是否开启\"><a href=\"#检查Partition-Manager是否开启\" class=\"headerlink\" title=\"检查Partition Manager是否开启\"></a>检查Partition Manager是否开启</h2><p>要检查自己是否开启了Partition Manager，检查编译后的<code>.config</code>中有无：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_PARTITION_MANAGER_ENABLED=y</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不要主动去设置它，一般来说开启多镜像编译后，它就会自动使能。</p>\n</blockquote>\n<h2 id=\"用CMake变量指定分区文件\"><a href=\"#用CMake变量指定分区文件\" class=\"headerlink\" title=\"用CMake变量指定分区文件\"></a>用CMake变量指定分区文件</h2><p>通常来说，编译时会自动选择项目根目录下的<code>pm_static_&lt;board_name&gt;.yaml</code>文件。</p>\n<p>但是如果你的项目比较复杂，希望用CMake变量来指定Partition Manager文件，类似于指定<code>CONF_FILE</code>配置文件那种方式，则需要在Sysbuild级别的配置<code>sysbuild.cmake</code>中进行设置，变量为<code>PM_STATIC_FILE</code>。</p>\n<p><code>sysbuild.cmake</code></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(PM_STATIC_YML_FILE <span class=\"variable\">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/foo/bar/pm_static.yml CACHE INTERNAL <span class=\"string\">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8-Zephyr中的“Boards”\"><a href=\"#8-Zephyr中的“Boards”\" class=\"headerlink\" title=\"8. Zephyr中的“Boards”\"></a>8. Zephyr中的“Boards”</h1><p>在Zephyr中，Boards是非常重要的一个概念。直观地理解，它指的就是你开发的项目的PCB板子。Zephyr中有很多可选择的Boards，都是各个厂商或提交给Zephyr的。在编译时必须选择一个Boards。</p>\n<p>但看完前面的介绍，我们就可以更深入地理解Boards：它其实就是一堆默认的Kconfig，DeviceTree配置文件的集合。</p>\n<h2 id=\"Boards默认配置文件\"><a href=\"#Boards默认配置文件\" class=\"headerlink\" title=\"Boards默认配置文件\"></a>Boards默认配置文件</h2><p>当我们选择<code>nrf52840dk/nrf52840</code>时，就会导入SDK中<code>$&#123;NCS&#125;/zephyr/boards/nordic/nrf52840dk/</code>目录下的各种配置文件。这其中，<code>nrf52840dk</code>是板子的名称，<code>nrf52840</code>是SoC的名称。</p>\n<p>其中，Kconfig配置文件是<code>nrf52840dk_nrf52840_defconfig</code>；DeviceTree文件是<code>nrf52840dk_nrf52840.dts</code>。其余<code>.dts</code>或<code>.dtsi</code>文件是被它include的。例如，引脚分配文件<code>nrf52840dk_nrf52840-pinctrl.dtsi</code>。</p>\n<p>当编译时，选择<code>nrf52840dk/nrf52811</code>时，它是用<code>nrf52840</code>这颗芯片来模拟<code>nrf52811</code>的资源，让你也可以用nRF52840DK这个开发板来进行nRF52811的开发。</p>\n<h2 id=\"Board-Name\"><a href=\"#Board-Name\" class=\"headerlink\" title=\"Board Name\"></a>Board Name</h2><p>Boards是为了编译固件而服务的。因此board name中一定包含编译目标所需要的信息。</p>\n<p>示例：</p>\n<ul>\n<li><code>nrf52840dk/nrf52840</code>：为nRF52840DK开发板上的nRF52840这颗SoC芯片编译固件</li>\n<li><code>nrf5340dk/nrf5340/cpuapp</code>：为nRF5340DK开发板上的nRF5340这颗<strong>双核</strong>芯片的<strong>App核</strong>编译固件</li>\n<li><code>nrf54l15/cpuapp/ns</code>：为nRF554L15DK开发板上的nRF54L15这颗<strong>双核</strong>芯片的<strong>App核</strong>编译固件，并且选择非安全（non-secure）地址空间进行编译。</li>\n</ul>\n<p>完整示例：</p>\n<p><img src=\"https://docs-be.nordicsemi.com/bundle/ncs-latest/page/zephyr/_images/board-terminology.svg?_LANG=enus\" alt=\"Board terminology diagram\"></p>\n<p><code>nrf54l15dk@1.0.0/nrf54l15/cpuapp/ns</code>：</p>\n<table>\n<thead>\n<tr>\n<th>nrf54l15dk</th>\n<th>@1.0.0</th>\n<th>&#x2F;nrf54l15</th>\n<th>&#x2F;cpuapp</th>\n<th>&#x2F;ns</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>板子名称</td>\n<td>板子版本（常见于工程样片版本）</td>\n<td><strong>Board qualifier</strong> for SoC</td>\n<td><strong>Board qualifier</strong> for CPU cluster</td>\n<td><strong>Board qualifier</strong> for variant</td>\n</tr>\n</tbody></table>\n<h3 id=\"老版本板子名称\"><a href=\"#老版本板子名称\" class=\"headerlink\" title=\"老版本板子名称\"></a>老版本板子名称</h3><details>\n    <summary>[点击展开]</summary>\n\n<p>前面介绍的都是Zephyr的Hardware Model v2。在板子、SoC、CPU之间有层级关系。</p>\n<p>在NCS v2.6.x之前，用的是没有层级关系的板子名称。例如<code>nrf52840dk_nrf52840</code>和<code>nrf52840dk_nrf52811</code>被认为是两块不同的板子。</p>\n<p>当然你也可以简单理解为，Hardware Model v2就是简单把下划线<code>_</code>换成了斜杠<code>/</code>。</p>\n</details>\n\n<h2 id=\"CMake中使用Boards变量\"><a href=\"#CMake中使用Boards变量\" class=\"headerlink\" title=\"CMake中使用Boards变量\"></a>CMake中使用Boards变量</h2><p>可能你需要在CMake中根据Board来配置不同的文件。Zephyr的boards CMake扩展已经提供了以下变量供使用：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The following variables will be defined when this CMake module completes:</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD:                       Board, without revision field.</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD_REVISION:              Board revision</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD_QUALIFIERS:            Board qualifiers</span></span><br><span class=\"line\"><span class=\"comment\"># - NORMALIZED_BOARD_QUALIFIERS: Board qualifiers in lower-case format where slashes have been</span></span><br><span class=\"line\"><span class=\"comment\">#                                replaced with underscores</span></span><br><span class=\"line\"><span class=\"comment\"># - NORMALIZED_BOARD_TARGET:     Board target in lower-case format where slashes have been</span></span><br><span class=\"line\"><span class=\"comment\">#                                replaced with underscores</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD_DIR:                   Board directory with the implementation for selected board</span></span><br><span class=\"line\"><span class=\"comment\"># - ARCH_DIR:                    Arch dir for extracted from selected board</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD_ROOT:                  BOARD_ROOT with ZEPHYR_BASE appended</span></span><br><span class=\"line\"><span class=\"comment\"># - BOARD_EXTENSION_DIRS:        List of board extension directories (If</span></span><br><span class=\"line\"><span class=\"comment\">#                                BOARD_EXTENSIONS is not explicitly disabled)</span></span><br></pre></td></tr></table></figure>\n\n<p>例如，选择板子<code>nrf52840dk/nrf52840</code>，在CMakeLixts.txt中加入以下消息打印：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;BOARD:$&#123;BOARD&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;BOARD_REVISION:$&#123;BOARD_REVISION&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;BOARD_QUALIFIERS:$&#123;BOARD_QUALIFIERS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;NORMALIZED_BOARD_QUALIFIERS:$&#123;NORMALIZED_BOARD_QUALIFIERS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;NORMALIZED_BOARD_TARGET:$&#123;NORMALIZED_BOARD_TARGET&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;BOARD_DIR:$&#123;BOARD_DIR&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;ARCH_DIR:$&#123;ARCH_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>编译时cmake打印：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- BOARD:                        nrf52840dk</span><br><span class=\"line\"></span><br><span class=\"line\">-- BOARD_REVISION:</span><br><span class=\"line\"></span><br><span class=\"line\">-- BOARD_QUALIFIERS:             /nrf52840</span><br><span class=\"line\"></span><br><span class=\"line\">-- NORMALIZED_BOARD_QUALIFIERS:  _nrf52840</span><br><span class=\"line\"></span><br><span class=\"line\">-- NORMALIZED_BOARD_TARGET:      nrf52840dk_nrf52840</span><br><span class=\"line\"></span><br><span class=\"line\">-- BOARD_DIR:      /home/jayant/project/ncs/v2.8.0/zephyr/boards/nordic/nrf52840dk</span><br><span class=\"line\"></span><br><span class=\"line\">-- ARCH_DIR:</span><br></pre></td></tr></table></figure>\n\n<p>其中比较有用的是<code>$&#123;NORMALIZED_BOARD_TARGET&#125;</code>，你可以在<code>CMakeLists.txt</code>或者<code>sysbuild.cmake</code>中用这个变量来匹配设置一些配置文件，例如：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在sysbuild.cmake中使用，把分区设置同时应用到Application和Bootloader</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Partition manager</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">EXISTS</span> <span class=\"string\">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/partitions/pm_static_$&#123;NORMALIZED_BOARD_TARGET&#125;.yml&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span>(PM_STATIC_YML_FILE <span class=\"string\">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/partitions/pm_static_$&#123;NORMALIZED_BOARD_TARGET&#125;.yml&quot;</span> CACHE INTERNAL <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;Using Partition Manager file: $&#123;CMAKE_CURRENT_LIST_DIR&#125;/partitions/pm_static_$&#123;NORMALIZED_BOARD_TARGET&#125;.yml&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>()</span><br><span class=\"line\">    <span class=\"keyword\">message</span>(FATAL_ERROR <span class=\"string\">&quot;Can&#x27;t find Partition Manager scripts ($&#123;CMAKE_CURRENT_LIST_DIR&#125;/partitions/pm_static_$&#123;NORMALIZED_BOARD_TARGET&#125;.yml)&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上配置会在<code>partitions/</code>目录下自动查找板子对应的<code>pm_static_xxx.yml</code>配置文件：</p>\n<h2 id=\"自定义板子\"><a href=\"#自定义板子\" class=\"headerlink\" title=\"自定义板子\"></a>自定义板子</h2><p>如果你的项目比较简单，可以不用自定义板子。直接选择Nordic开发板作为基础的Board。然后用device tree overlay文件和Kconfig配置文件，来增、删、改配置。</p>\n<p>但是定义自己的板子会有许多好处，比如：</p>\n<ul>\n<li>让一个工程同时支持自己的Borad和开发板。debug时，可以对比开发板和自己的板子的表现。在排查硬件问题，进行功耗优化时非常有用。</li>\n<li>用同一块板子开发不同工程时，移植非常方便。</li>\n<li>你选择的芯片封装和开发板上的封装并不相同，引脚数量有区别，需要自定义board。</li>\n</ul>\n<h3 id=\"自定义板子的步骤\"><a href=\"#自定义板子的步骤\" class=\"headerlink\" title=\"自定义板子的步骤\"></a>自定义板子的步骤</h3><details>\n    <summary>[点击展开]</summary>\n\n<p>也可以参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/board_support/defining_custom_board.html\">官方文档</a></p>\n<h4 id=\"创建Board\"><a href=\"#创建Board\" class=\"headerlink\" title=\"创建Board\"></a>创建Board</h4><p>可以在VS Code中图形化操作，定义板子：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145312936.webp\" alt=\"image-20250107145312936\"></p>\n<p>输入板子名称，是给人阅读的字符串，可以带空格：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145418793.webp\" alt=\"image-20250107145418793\"></p>\n<p>输入板子名称，是编译时使用的名称，不能带空格：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145508177.webp\" alt=\"image-20250107145508177\"></p>\n<p>选择使用的NCS版本：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145532264.webp\" alt=\"image-20250107145532264\"></p>\n<p>选择SoC芯片：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145557369.webp\" alt=\"image-20250107145557369\"></p>\n<p>选择自己的boards相关文件存放的位置，通常就是当前project根目录即可。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107145720987.webp\" alt=\"image-20250107145720987\"></p>\n<p>输入公司名称，作为vendor字段：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108145721828.webp\" alt=\"image-20250108145721828\"></p>\n<p>创建完毕后，就存放在当前工程的boards目录下：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108145954333.webp\" alt=\"image-20250108145954333\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 目录结构，你可以添加自己的doc</span><br><span class=\"line\">application_dir/</span><br><span class=\"line\">├── boards/</span><br><span class=\"line\">│   └── vendor/</span><br><span class=\"line\">│       └── my_custom_board/</span><br><span class=\"line\">│           ├── doc/</span><br><span class=\"line\">│           │   └── img</span><br><span class=\"line\">│           └── support/</span><br><span class=\"line\">└── src/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"添加默认Kconfig\"><a href=\"#添加默认Kconfig\" class=\"headerlink\" title=\"添加默认Kconfig\"></a>添加默认Kconfig</h4><p>默认的config就是你的<code>&lt;board_name&gt;_defconfig</code>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108154144637.webp\" alt=\"image-20250108154144637\"></p>\n<p>可以按需求拷贝开发板的默认配置，参考<code>$&#123;NCS-2.8.0&#125;/zephyr/boards/arm/nrf52840dk_nrf52840/nrf52840dk_nrf52840_defconfig</code></p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108154101849.webp\" alt=\"image-20250108154101849\"></p>\n<p>以上是添加默认的配置值。如果你想增加这个板子的菜单可选项，可以在<code>Konfig.&lt;board_name&gt;</code>中添加你的菜单项。</p>\n<blockquote>\n<p>值得一提的是，如果你的板子上没有32.768kHz晶振，则需要使用内部RC震荡器。可以把内部晶振相关配置写到这个defconfg中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC=y</span><br><span class=\"line\">CONFIG_CLOCK_CONTROL_NRF_K32SRC_XTAL=n</span><br><span class=\"line\">CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION=y</span><br></pre></td></tr></table></figure>\n\n<p>但是，在成本允许的情况下，还是非常推荐使用外部32k晶振的。外部晶体相比于内部RC震荡器具有更高的温度稳定性。此外，内部RC震荡器需要经常用高频时钟进行校准，因此功耗也会更高。</p>\n</blockquote>\n<h4 id=\"添加默认设备树配置\"><a href=\"#添加默认设备树配置\" class=\"headerlink\" title=\"添加默认设备树配置\"></a>添加默认设备树配置</h4><p>在<code>&lt;board_name&gt;.dts</code>中增加你的默认设备树配置。你也可以按需求拷贝对应芯片的开发板文件。例如：<code>/$&#123;NCS-v2.8.0&#125;/zephyr/boards/nordic/nrf52840dk/nrf52840dk_nrf52840.dts</code></p>\n<p>这里着重介绍一些要用到的：</p>\n<h5 id=\"特殊引脚配置（in-UICR）\"><a href=\"#特殊引脚配置（in-UICR）\" class=\"headerlink\" title=\"特殊引脚配置（in UICR）\"></a>特殊引脚配置（in UICR）</h5><p>当你的GPIO不够用时，可能需要把一些特殊引脚当作GPIO使用。这些需要写芯片的UICR寄存器（类似于Flash的一个区域，存储用户配置）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;uicr &#123;</span><br><span class=\"line\">    // bool类型属性，有则为true，没有则为false</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Reset pin 当作 reset 而不是GPIO使用</span><br><span class=\"line\">    gpio-as-nreset;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 删除属性，就是把bool类型设为false</span><br><span class=\"line\">    </span><br><span class=\"line\">    // NFC引脚不当作GPIO使用</span><br><span class=\"line\">    /delete-property/ nfct-pins-as-gpios；</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在较老的NCS版本，v2.4.x及之前，不是在DeviceTree中设置，而是在Kconfig中设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_GPIO_AS_PINRESET=y</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_NFCT_PINS_AS_GPIOS=n</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"电源regulator配置\"><a href=\"#电源regulator配置\" class=\"headerlink\" title=\"电源regulator配置\"></a>电源regulator配置</h5><p>板子外部通过VDD引脚对芯片进行供电，Nordic芯片内部还有一级电源Regulator给内核供电。这个Regulator可以配置成DC&#x2F;DC或者LDO。如果是DC&#x2F;DC的话，板子外部需要添加对应的电感电容。</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108163305341.webp\" alt=\"image-20250108163305341\"></p>\n<center>\n    nRF52832内部供电-DCDC模式\n</center>\n\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108163523995.webp\" alt=\"image-20250108163523995\"></p>\n<center>\n    nRF52840内部两级供电-双DC/DC模式\n</center>\n\n<p>nRF52840有高电压模式，可以用VDDH引脚输入2.5～5.5V电压。</p>\n<p>你也可以不使用VDDH。直接把VDDH和VDD短路，这种情况下会跳过Regulator0，供电范围是1.7~3.6V：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108163945669.webp\" alt=\"image-20250108163945669\"></p>\n<center>\n    nRF52840一级供电 - LDO模式\n</center>\n\n<p>大多数应用，采用一级供电即可。此外，像是nRF52840-QFAA这种封装（QFN48）内部已经把VDDH和VDD进行了短路操作，这时regulator0已经被屏蔽。直接配置reg1即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 使用DC/DC</span><br><span class=\"line\">&amp;reg1 &#123;</span><br><span class=\"line\">    regulator-initial-mode = &lt;NRF5X_REG_MODE_DCDC&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 使用LDO</span><br><span class=\"line\">&amp;reg1 &#123;</span><br><span class=\"line\">    regulator-initial-mode = &lt;NRF5X_REG_MODE_LDO&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果你用的是带有VDDH供电的封装，则用以下设备树开启REG0的DC&#x2F;DC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// reg0 只在nrf52840-qiaa.dtsi中有定义</span><br><span class=\"line\">&amp;reg0 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在较老的NCS版本中，不是在设备树中配置，而是用Kconfig配置DC&#x2F;DC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CONFIG_SOC_DCDC_NRF52X=y</span><br><span class=\"line\">CONFIG_SOC_DCDC_NRF52X_HV=y</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"gpio-reserve\"><a href=\"#gpio-reserve\" class=\"headerlink\" title=\"gpio reserve\"></a>gpio reserve</h5><p>在开发板的设备树中，我们可能会看到gpio port的节点下有一些配置。我们需要知道它的意思。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;gpio0 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    gpio-reserved-ranges = &lt;0 2&gt;, &lt;6 1&gt;, &lt;8 3&gt;, &lt;17 7&gt;;</span><br><span class=\"line\">    gpio-line-names = &quot;XL1&quot;, &quot;XL2&quot;, &quot;AREF&quot;, &quot;A0&quot;, &quot;A1&quot;, &quot;RTS&quot;, &quot;TXD&quot;,</span><br><span class=\"line\">        &quot;CTS&quot;, &quot;RXD&quot;, &quot;NFC1&quot;, &quot;NFC2&quot;, &quot;BUTTON1&quot;, &quot;BUTTON2&quot;, &quot;LED1&quot;,</span><br><span class=\"line\">        &quot;LED2&quot;, &quot;LED3&quot;, &quot;LED4&quot;, &quot;QSPI CS&quot;, &quot;RESET&quot;, &quot;QSPI CLK&quot;,</span><br><span class=\"line\">        &quot;QSPI DIO0&quot;, &quot;QSPI DIO1&quot;, &quot;QSPI DIO2&quot;, &quot;QSPI DIO3&quot;,&quot;BUTTON3&quot;,</span><br><span class=\"line\">        &quot;BUTTON4&quot;, &quot;SDA&quot;, &quot;SCL&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里<code>gpio-reserved-ranges</code>的意思是：从软件层面上限制gpio0的某些引脚不能当作普通GPIO使用，因为它们在开发板上已经接了一些元器件。这可以防止出一些引脚分配问题。</p>\n<p><code>&lt;0 2&gt;</code>的意思是P0.00及其之后一共2个引脚，也就是P0.00和P0.01，因为它们是32.768kHz低频晶振所使用的引脚；同理，<code>&lt;17 7&gt;</code>的意思是P0.17及其之后一共7个引脚不能当普通GPIO使用，因为它们是板子上外部QSPI flash采用的引脚，还有P0.18是 reset引脚。</p>\n<p>这个只是限制引脚不能当作普通GPIO使用，运行时会报错。但是并不限制这些引脚用pinctrl来分配给外设（毕竟QSPI引脚就是这么分配的）。</p>\n<p>我们在拷贝开发板的dts到我们自定义的board时，注意不要完全拷贝这部分，要根据需求来。</p>\n<h5 id=\"Zephyr软件依赖的设备树节点\"><a href=\"#Zephyr软件依赖的设备树节点\" class=\"headerlink\" title=\"Zephyr软件依赖的设备树节点\"></a>Zephyr软件依赖的设备树节点</h5><p>Zephyr中有许多现成的软件模块，它们与硬件有关。比如命令行终端shell，又比如LED和button的驱动。当你使能这些软件模块时，它们会去device tree中寻找自己应该操作哪些硬件。</p>\n<p>比如，许多Zephyr Kernel功能用的是<code>/chosen</code>节点下的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    chosen &#123;</span><br><span class=\"line\">        zephyr,console = &amp;uart0;</span><br><span class=\"line\">        zephyr,shell-uart = &amp;uart0;</span><br><span class=\"line\">        zephyr,uart-mcumgr = &amp;uart0;</span><br><span class=\"line\">        zephyr,bt-mon-uart = &amp;uart0;</span><br><span class=\"line\">        zephyr,bt-c2h-uart = &amp;uart0;</span><br><span class=\"line\">        zephyr,ieee802154 = &amp;ieee802154;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果用到OpenThread, Zigbee协议，则需要开启802.15.4</span><br><span class=\"line\">&amp;ieee802154 &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>而其他一些library和例程用的是<code>/aliases</code>节点下的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    aliases &#123;</span><br><span class=\"line\">        led0 = &amp;led0;</span><br><span class=\"line\">        led1 = &amp;led1;</span><br><span class=\"line\">        led2 = &amp;led2;</span><br><span class=\"line\">        led3 = &amp;led3;</span><br><span class=\"line\">        pwm-led0 = &amp;pwm_led0;</span><br><span class=\"line\">        sw0 = &amp;button0;</span><br><span class=\"line\">        sw1 = &amp;button1;</span><br><span class=\"line\">        sw2 = &amp;button2;</span><br><span class=\"line\">        sw3 = &amp;button3;</span><br><span class=\"line\">        bootloader-led0 = &amp;led0;</span><br><span class=\"line\">        mcuboot-button0 = &amp;button0;</span><br><span class=\"line\">        mcuboot-led0 = &amp;led0;</span><br><span class=\"line\">        watchdog0 = &amp;wdt0;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很多例程会用到LED和Button。当你在自己的板子上运行例程，而你的板子上又没有定义led或button时，记得删除例程中LED和Button相关代码。</p>\n<p>例程led和button相关的CONFIG是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Remove support for LEDs and buttons on Nordic development kits</span><br><span class=\"line\">CONFIG_DK_LIBRARY=n</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"外部Flash\"><a href=\"#外部Flash\" class=\"headerlink\" title=\"外部Flash\"></a>外部Flash</h5><p>nRF52840DK开发板上默认的QSPI flash为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;qspi &#123;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    pinctrl-0 = &lt;&amp;qspi_default&gt;;</span><br><span class=\"line\">    pinctrl-1 = &lt;&amp;qspi_sleep&gt;;</span><br><span class=\"line\">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class=\"line\">    mx25r64: mx25r6435f@0 &#123;</span><br><span class=\"line\">        compatible = &quot;nordic,qspi-nor&quot;;</span><br><span class=\"line\">        reg = &lt;0&gt;;</span><br><span class=\"line\">        /* MX25R64 supports only pp and pp4io */</span><br><span class=\"line\">        writeoc = &quot;pp4io&quot;;</span><br><span class=\"line\">        /* MX25R64 supports all readoc options */</span><br><span class=\"line\">        readoc = &quot;read4io&quot;;</span><br><span class=\"line\">        sck-frequency = &lt;8000000&gt;;</span><br><span class=\"line\">        jedec-id = [c2 28 17];</span><br><span class=\"line\">        sfdp-bfp = [</span><br><span class=\"line\">            e5 20 f1 ff  ff ff ff 03  44 eb 08 6b  08 3b 04 bb</span><br><span class=\"line\">            ee ff ff ff  ff ff 00 ff  ff ff 00 ff  0c 20 0f 52</span><br><span class=\"line\">            10 d8 00 ff  23 72 f5 00  82 ed 04 cc  44 83 68 44</span><br><span class=\"line\">            30 b0 30 b0  f7 c4 d5 5c  00 be 29 ff  f0 d0 ff ff</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        size = &lt;67108864&gt;;</span><br><span class=\"line\">        has-dpd;</span><br><span class=\"line\">        t-enter-dpd = &lt;10000&gt;;</span><br><span class=\"line\">        t-exit-dpd = &lt;35000&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在nRF7002DK中，也有SPI Flash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;spi4 &#123;</span><br><span class=\"line\">    compatible = &quot;nordic,nrf-spim&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    pinctrl-0 = &lt;&amp;spi4_default&gt;;</span><br><span class=\"line\">    pinctrl-1 = &lt;&amp;spi4_sleep&gt;;</span><br><span class=\"line\">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class=\"line\">    cs-gpios = &lt;&amp;gpio0 11 GPIO_ACTIVE_LOW&gt;;</span><br><span class=\"line\">    mx25r64: mx25r6435f@0 &#123;</span><br><span class=\"line\">        compatible = &quot;jedec,spi-nor&quot;;</span><br><span class=\"line\">        reg = &lt;0&gt;;</span><br><span class=\"line\">        spi-max-frequency = &lt;33000000&gt;;</span><br><span class=\"line\">        jedec-id = [c2 28 17];</span><br><span class=\"line\">        sfdp-bfp = [</span><br><span class=\"line\">            e5 20 f1 ff ff ff ff 03 44 eb 08 6b 08 3b 04 bb</span><br><span class=\"line\">            ee ff ff ff ff ff 00 ff ff ff 00 ff 0c 20 0f 52</span><br><span class=\"line\">            10 d8 00 ff 23 72 f5 00 82 ed 04 cc 44 83 68 44</span><br><span class=\"line\">            30 b0 30 b0 f7 c4 d5 5c 00 be 29 ff f0 d0 ff ff</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        size = &lt;67108864&gt;;</span><br><span class=\"line\">        has-dpd;</span><br><span class=\"line\">        t-enter-dpd = &lt;10000&gt;;</span><br><span class=\"line\">        t-exit-dpd = &lt;5000&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>QSPI Flash选用的驱动为<code>compatible = &quot;nordic,qspi-nor&quot;</code>. SPI Flash选用的驱动为<code>compatible = &quot;jedec,spi-nor</code>。</p>\n<p><strong>如果你选的板子上的外挂flash和开发板自带的不同</strong>，则可以参考<code>$&#123;NCS&#125;/zephyr/samples/driversamples/drivers/jesd216</code>例程。不论你用的是QSPI还是SPI Flash，都把它先挂到SPI上，然后根据此例程的说明运行。例程会自动读取Flash信息，并把对应的设备树配置打印到日志中，复制出来即可。但是Flash一定是需要支持JEDEC的。</p>\n<blockquote>\n<p>JEDEC (Joint Electron Device Engineering Council) 是一个制定半导体行业标准的组织。对于外挂Flash存储器来说，JEDEC标准定义了Flash存储器的接口、性能和功能特性。JEDEC标准确保了不同厂商生产的Flash存储器具有互操作性和兼容性。</p>\n</blockquote>\n<h5 id=\"Partition-Manager\"><a href=\"#Partition-Manager\" class=\"headerlink\" title=\"Partition Manager\"></a>Partition Manager</h5><p>用MCUBoot进行升级时，如果需要把Second slot放到外部Flash，则需要增加以下配置，让Partition Manager知道外部Flash也要参与存储器分区：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">chosen &#123;</span><br><span class=\"line\">    nordic,pm-ext-flash = &amp;mx25r64; // 赋值为你的外部flash的label</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用自定义板子编译\"><a href=\"#用自定义板子编译\" class=\"headerlink\" title=\"用自定义板子编译\"></a>用自定义板子编译</h4><p>VS Code Build界面中出现自定义Board可以选择：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250108181200141.webp\" alt=\"image-20250108181200141\"></p>\n<p>也可以在命令行编译时以当前板子为参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">west build -d build -b my_board/nrf52840 --sysbuild</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h1 id=\"9-编译流程与输出文件\"><a href=\"#9-编译流程与输出文件\" class=\"headerlink\" title=\"9. 编译流程与输出文件\"></a>9. 编译流程与输出文件</h1><h2 id=\"编译流程\"><a href=\"#编译流程\" class=\"headerlink\" title=\"编译流程\"></a>编译流程</h2><p><img src=\"https://docs-be.nordicsemi.com/bundle/ncs-2.9.0/page/nrf/_images/ncs-toolchain.svg?_LANG=enus\" alt=\"nRF Connect SDK tools and configuration\"></p>\n<h2 id=\"输出文件\"><a href=\"#输出文件\" class=\"headerlink\" title=\"输出文件\"></a>输出文件</h2><p>以下均按照开启sysbuild的情况下来看路径：</p>\n<ol>\n<li>当前application工程固件：<code>build/&lt;your_application_name&gt;/zephyr/zephyr.hex</code></li>\n<li>当前多工程编译合并固件：<code>build/merged.hex</code>，如果有多个核，每个核会有自己的<code>merged_&lt;core&gt;.hex</code></li>\n<li>DFU升级文件：<code>build/dfu_application.zip</code>，通过蓝牙等方式升级时使用的升级包</li>\n</ol>\n<p>更多输出文件请参考<a href=\"https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/output_build_files.html\">官方文档</a>.</p>\n<h2 id=\"VS-Code界面\"><a href=\"#VS-Code界面\" class=\"headerlink\" title=\"VS Code界面\"></a>VS Code界面</h2><p>也可以在nRF Connect for VS Code插件界面中查看自己的所有参与<strong>编译的源码</strong>、<strong>配置文件</strong>、<strong>输出文件</strong>：</p>\n<p><img src=\"https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/image-20250107033534650.webp\" alt=\"image-20250107033534650\"></p>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr"]},{"title":"详解Zephyr设备树（DeviceTree）与驱动模型","url":"/jayant97.github.io/2023/03/4b274a50e575/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\tNordic最新的开发包NCS（nRF Connect SDK）相对于原来的nRF5 SDK来说，最大的更新莫过于采用了Zephyr系统。而Zephyr不单单是一个用来做多线程的RTOS，它更大的价值在于其自带的各种开源的协议栈、框架、软件包、驱动代码等。如果不是为了使用这些现成的协议栈和软件包，只是单纯使用RTOS，实际上并不会产生什么价值。可以说，Zephyr是为物联网而生的。</p>\n<p>​\tZephyr采用Kconfig对这些软件包进行管理，可以方便地使能或剪裁。而为了使Zephyr自带的硬件驱动代码能够通用，Zephyr采用了DeviceTree来描述硬件。各个半导体厂商把自己的硬件描述成标准DeviceTree，并且按照Zephyr的接口提供驱动代码，然后一起提交给Zephyr。在方便地使用Zephyr中协议栈的同时，用户还能简单方便地使用到各个半导体厂家的硬件功能，这多是一件美事。</p>\n<p>​\t但由于目前中文互联网上没有一个很详细的从零开始的教程，导致很多人遇到Zephyr的DeviceTree感到很厌烦：「我之前配一下寄存器、调一下库函数就能操作硬件，怎么现在搞这么复杂？」</p>\n<p>​\t但是相信你读完本文后，能够感受到DeviceTree的便利之处。而所谓的<strong>复杂</strong>与<strong>简单</strong>，往往是相对的。人的大脑容量有限，所以我们要不断地对做事的方法进行压缩、抽象，充分利用别人已经完成的工作成果。这也是最早从机器码发展到汇编，再到现在各种高级语言的底层逻辑。</p>\n<p>​\t下面正式开始。</p>\n<h1 id=\"2-从一些习惯开始\"><a href=\"#2-从一些习惯开始\" class=\"headerlink\" title=\"2. 从一些习惯开始\"></a>2. 从一些习惯开始</h1><h2 id=\"硬件的抽象\"><a href=\"#硬件的抽象\" class=\"headerlink\" title=\"硬件的抽象\"></a>硬件的抽象</h2><p>​\t在做传统的嵌入式C语言开发时，我们常会使用宏定义的方式来实现<strong>硬件的抽象</strong>，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;gpio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PORT_LED_1 GPIO_PORT_0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PIN_LED_1 GPIO_PIN_12</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t在实际的应用代码中，如果多次使用到这个GPIO，在想要修改IO的时候，只需要修改宏定义即可，而不需要把每一个用到这个IO的地方都改一遍。这种方法的优点很明显：简单直观。</p>\n<blockquote>\n<p>​\t其实我们写代码，最终都是在CPU上运行，操作的都是外设寄存器，而不是板子上的LED。当我们在代码里写什么LED驱动、屏幕驱动、电机驱动的时候，只是在用<strong>面向对象</strong>的思维方便开发者（也就是我们自己）而已。CPU是不会理解什么是LED、什么是屏幕、什么是电机的，它只是勤勤恳恳按照指令执行代码，从某些地址读写数据而已。</p>\n<p>​\t也就是说，地址、指令和数据才是核心。牢记这一点，才不会被DeviceTree中乱七八糟的硬件节点绕晕。</p>\n</blockquote>\n<p>​\t理解这种简单的操作，其实就已经为理解DeviceTree做好了铺垫。</p>\n<h2 id=\"代码的解耦\"><a href=\"#代码的解耦\" class=\"headerlink\" title=\"代码的解耦\"></a>代码的解耦</h2><p>​\t大家初学代码时，一定有过想要“解耦”开发的想法：把不同的功能写进不同的文件里，封装成模块，然后在主函数里分别调用这些库即可，不同的模块之间完全解耦。</p>\n<p>​\t这种想法在做纯软件时是很容易的。但是，遇到硬件时，往往会遇到一些麻烦。这里举一个例子：假设我们有一个按钮和一个sensor，都需要用到GPIO以及中断，并且我们想实现代码的解耦，如下图。初始化、应用代码、中断服务函数均解耦。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312145925945.png\" alt=\"image-20230312145925945\"></p>\n<p>​\t看似这种解耦很美好，但是实际上是实现不了的。因为，认为按钮和sensor之间有区别，这完全是我们人类的观点。对于MCU来说，它都是在操作外设寄存器，按钮和sensor没什么区别。因此gpio外设只需初始化一次，并且中断服务函数也不能定义在两处。</p>\n<p>​\t实际上，现在很多成熟的SDK，简单来说是用下图这种方式进行实现的解耦：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312150536356.png\" alt=\"image-20230312150536356\" style=\"zoom:80%;\" />\n\n<p>​\t有一个专门的<code>board.c</code>，或者说BSP（Board Support Package，板级支持包），来处理MCU本身的硬件初始化和中断服务函数。然后，剩余的<strong>应用代码</strong>再做解耦，也可以把回调函数注册进中断服务函数中去。<code>board.c</code>可以说是返璞归真，真正的是在面向MCU编程，而不是面向抽象的对象编程。</p>\n<h2 id=\"DeviceTree与Zephyr驱动的引入\"><a href=\"#DeviceTree与Zephyr驱动的引入\" class=\"headerlink\" title=\"DeviceTree与Zephyr驱动的引入\"></a>DeviceTree与Zephyr驱动的引入</h2><p>​\t先说硬件的抽象，前面说的这种宏定义的方式虽然方便，但往往只是方便个人开发者，或者是一个项目内几个同事之间口口相传，没有什么规范可言。不同开发者之间定义宏的方式可能差别很大。</p>\n<p>​\tZephyr不会自己再定义一套新的宏用来描述硬件，那样和各个厂商自己的SDK里的宏也没什么区别，徒增麻烦而已。Zephyr的设计思路就是：能用现成的轮子就不自己造。</p>\n<p>​\t因此，Zephyr引入了DeviceTree这一成熟的方案，像Linux一样，各个半导体厂商自己出DeviceTree来描述自己的产品，并且自己提供各个外设的驱动代码。用户只需调用Zephyr标准驱动，底层就会根据DeviceTree自动找到对应厂商的驱动代码，然后编译进固件中。</p>\n<p>​\t并且，Zephyr支持在系统初始化时就自动初始化好所有驱动。这样系统进入到Application（主线程）时，所有驱动就已经初始化好了，可以直接进行操作。用类比的说法，就是Zephr内置了所有厂商的所有外设的<code>board.c</code>，你只需动动手指改一下DeviceTree，就可以直接做应用开发，不需要自己写这个<code>board.c</code>了。</p>\n<p>​\t\t总的来说，DeviceTree是一个标准的描述硬件的方法，厂商提供了标准的DeviceTree和驱动代码。用户只需配置好DeviceTree，硬件就会自动初始化好。并且只需调用Zephyr通用驱动API，跨平台。</p>\n<h1 id=\"3-DeviceTree的结构和语法\"><a href=\"#3-DeviceTree的结构和语法\" class=\"headerlink\" title=\"3. DeviceTree的结构和语法\"></a>3. DeviceTree的结构和语法</h1><p>本节参考：<a href=\"https://docs.zephyrproject.org/latest/build/dts/intro.html\">Introduction to devicetree — Zephyr Project Documentation</a></p>\n<h2 id=\"3-1-DeviceTree的层次结构\"><a href=\"#3-1-DeviceTree的层次结构\" class=\"headerlink\" title=\"3.1. DeviceTree的层次结构\"></a>3.1. DeviceTree的层次结构</h2><p>​\t先抛开语法本身，我们先用框图的形式理解DeviceTree表达的是什么。如下图是一个示例，描述了一块板子，上面有一颗Soc、一组LED、一组按钮，还有一个I2C接口的RTC时钟ds3231。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312162505279.png\" alt=\"image-20230312162505279\"></p>\n<p>​\t首先，DeviceTree是一个树状结构。那么，树状结构的层次结构是由什么决定的？是什么决定了节点之间的父子关系？</p>\n<p>​\t答案是：<strong>首先看总线的主从关系、其次看硬件的包含关系</strong>。</p>\n<p>​\t具体来说，就是：</p>\n<ol>\n<li>SoC的所有外设都在ARM地址空间内可被<strong>寻址</strong>（AHB总线和APB总线），因此<code>gpio0</code>、<code>i2c0</code>、<code>adc0</code>等外设节点都是<code>SoC</code>的子节点；</li>\n<li><code>ds3231</code> RTC是i2c从机，具有i2c地址，故是<code>i2c</code>外设的子节点；</li>\n<li>Button和LED虽然使用GPIO，但GPIO不是<strong>总线</strong>。并且根据前一章节所述，Button和LED对SoC来说并没有什么意义，它只是便于人类面向对象编程的。因此，这里的<code>Buttons</code>和<code>Leds</code>就根据<strong>硬件的包含关系</strong>，直接挂在板子（也就是根节点<code>/</code>）下面即可；</li>\n<li>同理，如果有某种电压表设备用到了ADC的通道，这里，ADC的通道也不是总线，因此这个电压表设备也应该直接挂在根节点下面。</li>\n</ol>\n<h2 id=\"3-2-DeviceTree的适用范围\"><a href=\"#3-2-DeviceTree的适用范围\" class=\"headerlink\" title=\"3.2. DeviceTree的适用范围\"></a>3.2. DeviceTree的适用范围</h2><p>​\tDeviceTree是为<strong>编译固件</strong>服务的，描述的是这个固件所运行的CPU，所在的板子的硬件信息。因此DeviceTree描述的是<strong>板级</strong>信息。再结合「DeviceTree的层次结构是基于<strong>总线地址</strong>的」，可以得出以下的结论：</p>\n<ol>\n<li><strong>如果一块板子上有两颗MCU，则这两颗MCU固件编译时所采用的DeviceTree不相同。</strong><br>例如nRF9160 DK上有一颗9160，还有一颗52840。在NCS中选择Board时，就有以下两个选项</li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312163613633.png\" alt=\"image-20230312163613633\"></p>\n<ol start=\"2\">\n<li><strong>如果一颗MCU具有两个独立运行固件的CPU，则这两颗CPU不能共用DeviceTree</strong><br>例如nRF5340，具有应用核和网络核，这两颗CPU固件独立。因此选择board时有两个选项。</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312163934665.png\" alt=\"image-20230312163934665\" style=\"zoom:80%;\" />\n\n<ol start=\"3\">\n<li><strong>如果一颗CPU具有两种不同的地址空间（例如Cortex M33的安全地址空间和非安全地址空间），则这两种情况也不能共用DeviceTree</strong></li>\n</ol>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312164104566.png\" alt=\"image-20230312164104566\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312164125085.png\" alt=\"image-20230312164125085\"></p>\n<center>nRF5340的地址空间，分为应用核和网络核</center>\n<center>且每个核的外设还分安全（secure）和非安全（non-secure）</center>\n\n<h2 id=\"3-3-DeviceTree的语法\"><a href=\"#3-3-DeviceTree的语法\" class=\"headerlink\" title=\"3.3. DeviceTree的语法\"></a>3.3. DeviceTree的语法</h2><p>​\tDeviceTree既然是一个标准，那么一定有它的标准文档，如果大家有兴趣可以去官网下载：<a href=\"https://www.devicetree.org/specifications/\">Specifications - DeviceTree</a></p>\n<p>​\t本文就只捡重点讲：</p>\n<h3 id=\"3-1-DeviceTree基本结构示例\"><a href=\"#3-1-DeviceTree基本结构示例\" class=\"headerlink\" title=\"3.1. DeviceTree基本结构示例\"></a>3.1. DeviceTree基本结构示例</h3><p>​\tDeviceTree的源码称为DTS（DeviceTree Source），后缀为<code>.dts</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/dts-v1/</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">    a-node&#123;</span><br><span class=\"line\">        a_node_label: a-sub-node &#123;</span><br><span class=\"line\">            foo = &lt;3&gt;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        another-sub-node &#123;</span><br><span class=\"line\">            foo = &lt;3&gt;;</span><br><span class=\"line\">            bar = &lt;&amp;a_node_label&gt;;</span><br><span class=\"line\">        &#125;;\t</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>/dts-v1/</code>，指明了DeviceTree的版本；</li>\n<li>设备树具有唯一的根节点<code>/</code>；</li>\n<li>节点的<strong>名称</strong>写在大括号之前。如<code>a-node</code>、<code>a-sub-node</code>和<code>another-sub-node</code>；</li>\n<li>节点的<strong>属性</strong>写在大括号内，是键值对（Key-Value Pair）的形式。如<code>foo = &lt;3&gt;;</code>；</li>\n<li>子节点直接写在父节点的大括号内，从而可以表达树状的层次关系；</li>\n<li>可以给节点写一个标签，例如<code>a_node_label</code>，标签与节点之间用冒号<code>:</code>连接。</li>\n</ol>\n<blockquote>\n<p>标签（Label）的意义：</p>\n<ol>\n<li>要指明一个节点，标准的做法必须指明绝对路径，例如：<code>/a-node/a-sub-node</code>。<br>有了标签，就可以省略路径，直接用标签表示一个节点，如<code>a_node_label</code>。</li>\n<li>标签可以被作为<strong>属性</strong>引用，让一个节点成为另一个节点的某个属性的<strong>值</strong>。注意，这里说的是成为「属性的值」，而不是成为「子节点」。</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-DeviceTree节点的名称\"><a href=\"#3-2-DeviceTree节点的名称\" class=\"headerlink\" title=\"3.2. DeviceTree节点的名称\"></a>3.2. DeviceTree节点的名称</h3><p>DeviceTree中的节点名称遵循以下命名规则：<code>name@address</code></p>\n<ol>\n<li><code>name</code>：必须以字母开头。长度在1~31子节。允许大小写字母、数字、<strong>英文逗号、小数点、加号、减号、下划线</strong>；</li>\n<li><code>@address</code>：称为<strong>「Unit Address」</strong>，如果节点有<code>reg</code>属性，则address的值必须与<code>reg</code>描述的<strong>第一个寄存器地址</strong>相等，可以理解为某个外设在它的总线上的首地址。如果某个节点没有reg属性，则<code>@address</code><strong>必须省略</strong>。<br>值得一提的是，address和reg都是16进制。但address不需要写<code>0x</code>前缀，而reg的16进制值需要写<code>0x</code>前缀。</li>\n</ol>\n<blockquote>\n<p>​\t实际上，Zephyr对address有一些特殊的规则，见：<a href=\"https://docs.zephyrproject.org/latest/build/dts/intro-syntax-structure.html#id7\">Unit address</a></p>\n<p>​\t这里也说一下：</p>\n<ul>\n<li><p>挂在SPI总线上的设备：address表示片选线（CS）的编号，如果没有片选线，则为<code>0</code>；</p>\n</li>\n<li><p>RAM：address直接为RAM的物理起始地址，如<code>memory@20000000</code>，表示<code>0x20000000</code>；</p>\n</li>\n<li><p>Flash：address直接为Flash的物理起始地址，如<code>flash@800000</code>，表示<code>0x08000000</code>。</p>\n</li>\n<li><p>Flash分区：可以在DeviceTree里存一个Flash分区表，分区的address是相对于Flash物理首地址的偏移量，如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flash@8000000 &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    partitions &#123;</span><br><span class=\"line\">        partition@0 &#123; /* ... */ &#125;;</span><br><span class=\"line\">        partition@20000 &#123;  /* ... */ &#125;;</span><br><span class=\"line\">        /* ... */</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<p>几个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// address必须和reg首地址相等，无论是ARM地址还是i2c地址</span><br><span class=\"line\">i2c@40003000 &#123;</span><br><span class=\"line\">    reg = &lt;0x40003000 0x1000&gt;;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">    ds3231@68 &#123;</span><br><span class=\"line\">        reg = &lt;0x68&gt;;</span><br><span class=\"line\">        /* ... */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 不带地址的节点，不含@address字段</span><br><span class=\"line\">buttons&#123;</span><br><span class=\"line\">   /* ... */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 英文逗号也是name的一部分</span><br><span class=\"line\">zephyr,user &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-DeviceTree的属性\"><a href=\"#3-3-DeviceTree的属性\" class=\"headerlink\" title=\"3.3. DeviceTree的属性\"></a>3.3. DeviceTree的属性</h3><p>​\tDeviceTree中每个节点可以有几个属性来描述这个节点。</p>\n<p>​\t属性是键值对。属性的名称可以含<strong>大小写字母、数字、逗号、小数点、下划线，加号、减号、问号、”#”号</strong>。</p>\n<p>​\t属性是有<strong>类型</strong>的，并且，Zephyr中的属性类型和标准的DeviceTree还有一定的区别，总之是更详细了，见下表：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>属性示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td><code>a-string=&quot;hello world!&quot;;</code></td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>string-array</td>\n<td><code>a-string-array=&quot;string one&quot;,&quot;string two&quot;.&quot;string three&quot;;</code></td>\n<td>字符串数组</td>\n</tr>\n<tr>\n<td>int</td>\n<td>10进制：<code>an-int = &lt;1&gt;;</code> <br />16进制：<code>an-int = &lt;0xab&gt;;</code></td>\n<td>32bit整数</td>\n</tr>\n<tr>\n<td>array</td>\n<td><code>foo = &lt;0xdeadbeef 1234 0&gt;;</code></td>\n<td>整数数组</td>\n</tr>\n<tr>\n<td>uint8-array</td>\n<td><code>a-byte-array = [00 01 ab];</code></td>\n<td>字节数组，16进制，可省略0x</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>my-true-boolean;</code></td>\n<td>无值属性。值存在则表示<code>true</code>，不存在则表示<code>false</code></td>\n</tr>\n<tr>\n<td>phandle</td>\n<td><code>a-phandle = &lt;&amp;mynode&gt;;</code></td>\n<td>节点句柄，指向其他的节点。可以认为是一个指针（p）或句柄（handle）</td>\n</tr>\n<tr>\n<td>phandles</td>\n<td><code>some-phandles = &lt;&amp;mynode0 &amp;mynode1 &amp;mynode2&gt;;</code></td>\n<td>节点句柄数组</td>\n</tr>\n<tr>\n<td>phandle-array</td>\n<td><code>a-phandle-array = &lt;&amp;mynode0 1 2&gt;,&lt; &lt;&amp;mynode1 3 4&gt;;</code></td>\n<td>见下方详细说明</td>\n</tr>\n</tbody></table>\n<p>​\t其实最基本的属性就是整数、布尔、字符串。以及由它们构成的数组。</p>\n<p>​\t<code>phandle</code>本质也是整数，当给一个节点赋予标签时，其实是给这个节点添加了一个隐藏属性<code>phandle = &lt;n&gt;;</code>。构建系统会确保整个DeviceTree中的<code>n</code>不会重复。所以这里<code>a-phandle = &lt;&amp;mynode&gt;;</code>，<code>&amp;mynode</code>的值就是这个标签指向的节点的隐藏phandle属性的值。</p>\n<p>​\t这里其他的都好理解，值得详细说的是<code>phandle-array</code>类型。其实，将其取名为「结构体数组」更加合适。这个数组的每一个元素都是一个特殊的结构体，结构体的第一个值必定是一个<code>phandle</code>，后续的值可以是任意值，数量也可以任意。Zephyr将这种类型用来做硬件通道的配置，例如<code>&lt;&amp;gpio0 1 GPIO_INPUT&gt;</code>表示gpio0，1号引脚，模式为输入。后续的硬件支持章节会更详细地讲解实例。</p>\n<h3 id=\"3-4-DeviceTree的文件引用\"><a href=\"#3-4-DeviceTree的文件引用\" class=\"headerlink\" title=\"3.4. DeviceTree的文件引用\"></a>3.4. DeviceTree的文件引用</h3><p>​\t<code>.dts</code>可以引用其他的<code>.dts</code>或<code>.dtsi</code>。这样<strong>板卡级dts</strong>就可以引用厂商写好的<strong>芯片级dtsi</strong>，从而减少编写dts的工作量。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312180147944.png\" alt=\"image-20230312180147944\" style=\"zoom:80%;\" />\n\n<p>​\t\t<code>.dts</code>也可以引用C语言头文件，从而使用里面的宏定义和枚举值：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312180310480.png\" alt=\"image-20230312180310480\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312180319140.png\" alt=\"image-20230312180319140\"></p>\n<h1 id=\"4-Zephyr中的DeviceTree文件\"><a href=\"#4-Zephyr中的DeviceTree文件\" class=\"headerlink\" title=\"4. Zephyr中的DeviceTree文件\"></a>4. Zephyr中的DeviceTree文件</h1><p>​\t在Zephyr中，在许多地方都保存的有dts文件。</p>\n<p>​\t首先，在NCS中创建build时，需要选择board，而板子的一系列文件中就包含了<code>.dts</code>文件。</p>\n<h2 id=\"4-1-dts文件\"><a href=\"#4-1-dts文件\" class=\"headerlink\" title=\"4.1. dts文件\"></a>4.1. dts文件</h2><h3 id=\"4-1-1-芯片级dtsi文件\"><a href=\"#4-1-1-芯片级dtsi文件\" class=\"headerlink\" title=\"4.1.1. 芯片级dtsi文件\"></a>4.1.1. 芯片级dtsi文件</h3><p>各个厂商提供的芯片级dtsi文件，对于nordic的产品，其dtsi文件位于<code>$&#123;NCS&#125;/zephyr/dts/arm/nordic/</code>中。</p>\n<h3 id=\"4-1-2-板卡级dts文件\"><a href=\"#4-1-2-板卡级dts文件\" class=\"headerlink\" title=\"4.1.2. 板卡级dts文件\"></a>4.1.2. 板卡级dts文件</h3><p>​\t各个厂商可能会推出一些开发板、评估板。这些板子的dts文件位于<code>$&#123;NCS&#125;/zephyr/board/arm/$&#123;board-name&#125;/</code>中</p>\n<h2 id=\"4-2-overlay文件\"><a href=\"#4-2-overlay文件\" class=\"headerlink\" title=\"4.2. overlay文件\"></a>4.2. overlay文件</h2><h3 id=\"4-2-1-overlay文件的位置\"><a href=\"#4-2-1-overlay文件的位置\" class=\"headerlink\" title=\"4.2.1. overlay文件的位置\"></a>4.2.1. overlay文件的位置</h3><p>​\t在我们开发应用时，往往需要基于厂商的开发板Dts，新增一些功能，或者禁用一些功能。Zephyr提供了overlay的方式让我们可以<strong>覆写</strong>原始的板卡级dts。</p>\n<p>​\t在一些例程中，可以看到<code>boards/&lt;board&gt;.overlay</code>文件：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312182939910.png\" alt=\"image-20230312182939910\"></p>\n<p>​\t如果没有看到，说明这个例程无需修改开发板的原始dts就能实现功能。如果用户想修改，也可以自己在应用根目录创建一个<code>app.overlay</code>：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312183130067.png\" alt=\"image-20230312183130067\"></p>\n<p>​\t其实添加overlay的方式有很多，并且zephyr会按照一定的顺序找这些overlay，如果在多个地方都定义了overlay，可能zephyr只会使用其中的一部分。具体规则请看：<a href=\"https://docs.zephyrproject.org/latest/build/dts/howtos.html#set-devicetree-overlays\">set-devicetree-overlays</a>。</p>\n<h3 id=\"4-2-2-overlay的使用\"><a href=\"#4-2-2-overlay的使用\" class=\"headerlink\" title=\"4.2.2. overlay的使用\"></a>4.2.2. overlay的使用</h3><p><strong>（1）直接在原有节点覆盖&#x2F;新增属性，可以从根节点开始写：</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312192849065.png\" alt=\"image-20230312192849065\"></p>\n<p>​\t也可以直接用label写：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312191745811.png\" alt=\"image-20230312191745811\"></p>\n<p><strong>（2）删除原有的属性</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312192939102.png\" alt=\"image-20230312192939102\"></p>\n<p><strong>（3）删除原有的节点</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312193017699.png\" alt=\"image-20230312193017699\"></p>\n<h2 id=\"4-3-完整的dts文件\"><a href=\"#4-3-完整的dts文件\" class=\"headerlink\" title=\"4.3. 完整的dts文件\"></a>4.3. 完整的dts文件</h2><p>每个项目构建时，编译之前，会在构建目录下生成最终的完整dts。位置为<code>$&#123;project_folder&#125;/build/zephyr/zephyr.dts</code></p>\n<h2 id=\"4-4-最终输出\"><a href=\"#4-4-最终输出\" class=\"headerlink\" title=\"4.4. 最终输出\"></a>4.4. 最终输出</h2><p>​\tLinux的DTS会被编译为DTB，然后在启动时由Bootloader传递给kernel。但Zephyr运行在性能较差的嵌入式平台上，故不可能专门运行一个解析器去读DTB。</p>\n<p>​\t因此，DTS实际上实在编译时被Zephyr的构建系统（一套python脚本）变成了头文件，这个头文件的位置是：</p>\n<p><code>$&#123;project_folder&#125;/build/zephyr/include/generated/devicetree_generated.h</code></p>\n<p>​\t了解即可，实际开发不需要查看这个头文件。</p>\n<h1 id=\"5-用DeviceTree配置硬件信息\"><a href=\"#5-用DeviceTree配置硬件信息\" class=\"headerlink\" title=\"5. 用DeviceTree配置硬件信息\"></a>5. 用DeviceTree配置硬件信息</h1><p>​    从上一节我们可以知道，DeviceTree本身的结构和语法其实非常简单，只是规定了一个形式而已，跟硬件的配置没有任何关系。</p>\n<p>​    要想了解DeviceTree是如何对硬件配置产生影响的，需要了解一些常见的属性和概念。</p>\n<h2 id=\"5-1-标准属性\"><a href=\"#5-1-标准属性\" class=\"headerlink\" title=\"5.1. 标准属性\"></a>5.1. 标准属性</h2><p>​\tDeviceTree中有一些标准的属性，这些属性和Linux是一样的，在DeviceTree Specification中是有定义的。此处简要介绍一下：</p>\n<h3 id=\"reg-address-cells-与-size-cells\"><a href=\"#reg-address-cells-与-size-cells\" class=\"headerlink\" title=\"reg, #address-cells 与 #size-cells\"></a>reg, #address-cells 与 #size-cells</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312200747143.png\" alt=\"image-20230312200747143\"></p>\n<p>  <strong>reg</strong>属性代表此节点在总线上占用的地址和范围。是由<strong>多对</strong> <strong>(address, length)<strong>组合而成的。而</strong>#address-cells</strong> 和**#sieze-cells**则表示了这个总线上的节点的reg属性里，每个address和size要占用多少个uint32单元。</p>\n<p>  如上图，先看父节点<code>soc</code>，可以得知这条总线上，所有寄存器的address和size各占一个uint32单元。则serial有两个寄存器，第一个寄存器首地址是0x0，长度是0x100；第二个寄存器首地址是0x200，长度是0x300。</p>\n<blockquote>\n<p>​\t如果地址长度为64位或更多（即要占用多个Uint32单元），则reg中的写法为大端模式（Big-Endian ），即高地址在前，低地址在后。</p>\n</blockquote>\n<h3 id=\"ranges\"><a href=\"#ranges\" class=\"headerlink\" title=\"ranges\"></a>ranges</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201206619.png\" alt=\"image-20230312201206619\"></p>\n<p>当一个节点定义了ranges属性，那么它的子节点就可以使用<strong>相对地址</strong>，而非<strong>绝对地址</strong>。</p>\n<p>如上图。peripheral基地址为0x40000000。而ADC的地址从0xe000开始，这是一个相对地址。则ADC在ARM地址空间的绝对地址为0x4e000000。</p>\n<blockquote>\n<p>ranges属性的格式为：</p>\n<p><code>ranges = &lt;子空间首地址  父空间首地址 长度&gt;</code></p>\n<p>子空间首地址为0时，子节点的地址就是相对地址。</p>\n<p>至于这三个元素分别要占用几个uint32单元，看图中同色的部分即可。</p>\n</blockquote>\n<p>  一般用户也用不到，了解即可。厂商才会去改芯片内部的dts。</p>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201508849.png\" alt=\"image-20230312201508849\"></p>\n<p>  <strong>status</strong>用来指定是否启用一个设备（节点），根据DeviceTree Spec有以下几个选项：</p>\n<ul>\n<li>“okay” ： 设备是可操作的</li>\n<li>“disabled” ： 设备目前是不可操作的（但未来可能可以操作，比如设备插入、安装后）</li>\n<li>“fail” ： 设备不可操作。设备中检测到错误。</li>\n<li>“fail-sss”：设备不可操作。其中sss的部分会根据不同的设备而变换，用于指定特定的错误码</li>\n<li>“reserved” ： 设备可操作，但不应该使用。通常用于设备被其他软件控制的情况。</li>\n</ul>\n<p>但是实际上Zephyr中基本只会用「okay」和「disabled」 ，用来启用或禁用节点。</p>\n<h3 id=\"compatible\"><a href=\"#compatible\" class=\"headerlink\" title=\"compatible\"></a>compatible</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201647347.png\" alt=\"image-20230312201647347\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201652944.png\" alt=\"image-20230312201652944\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201657935.png\" alt=\"image-20230312201657935\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201702581.png\" alt=\"image-20230312201702581\"></p>\n<p>  <strong>compatible</strong>用来说明一个节点设备的兼容性。它的值是一个字符串或一个字符串数组。</p>\n<p>  Zephyr构建系统就是用它来为每个节点找到合适的驱动程序。其具体的应用后面会讲解。</p>\n<p>  compatible的每个值的通常命名方式是”vendor,device”，即某个供应商的某个产品。这不是强制的要求，也可以没有vendor。</p>\n<p>  如果compatible有多个值，zephyr会按顺序寻找驱动。会使用找到的第一个驱动。</p>\n<h2 id=\"5-2-重要概念——域（Domain）\"><a href=\"#5-2-重要概念——域（Domain）\" class=\"headerlink\" title=\"5.2. 重要概念——域（Domain）\"></a>5.2. 重要概念——域（Domain）</h2><p>  我们知道，DeviceTree是基于<strong>总线地址的层次结构</strong>。然而，实际的硬件之间的关系错综复杂，实为网状结构，如何才能简洁地描述好真实的硬件之间的关系呢？</p>\n<p>  其实，除了DeviceTree本身基于地址的树之外，在逻辑上，还存在一些其他的树，例如GPIO树、中断树、ADC树等等。</p>\n<p>  我们将这种附加在DeviceTree上的，逻辑上的树称为<strong>域（Domain）</strong>。如下图，蓝色为一个按照总线地址的层次结构写好的DeviceTree，但是，在这个树上其实附加了其他的包含关系：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312201750000.png\" alt=\"image-20230312201750000\"></p>\n<p>  很容易发现，每个域都有一个自己的“<strong>根节点</strong>”，称为<strong>控制器（Controller）</strong>。不难发现，其实控制器才是真正的我们编程操作的对象，而域中的子节点，都是我们为了方便理解，而抽象出来的概念，这与本文第2章节的观点是一致的。</p>\n<h3 id=\"域的控制器与子节点\"><a href=\"#域的控制器与子节点\" class=\"headerlink\" title=\"域的控制器与子节点\"></a>域的控制器与子节点</h3><p>​\t控制器节点通常会有一个布尔类型属性 <code>*-controller</code>，来表示自己是某个域的控制器，如下图：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202317603.png\" alt=\"image-20230312202317603\" style=\"zoom:67%;\" />\n\n<p>​\t而域中的子节点，就可以使用<code>phandle-array</code>类型的属性来说明自己属于哪个域。此属性的第一个值是指向<strong>控制器的</strong>句柄。后续的值是此节点在这个域中的<strong>配置</strong>。这一条配置被称为<strong>specifier</strong>。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202350076.png\" alt=\"image-20230312202350076\" style=\"zoom:80%;\" />\n\n<p>控制器节点中会有一个<code>#*-cells</code>属性来指明specifier的大小，需要占用多少个<code>uint32</code>单元。</p>\n<h3 id=\"中断域\"><a href=\"#中断域\" class=\"headerlink\" title=\"中断域\"></a>中断域</h3><p>中断域和GPIO域有点类似，但有点区别：</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312202551215.png\" alt=\"image-20230312202551215\" style=\"zoom:67%;\" />\n\n<p>  首先，我们发现adc的<code>interrupts</code>属性只写了specifier，并没有写controller指向哪里。</p>\n<p>   这是因为，根据DeviceTree标准，构建系统默认把devicetree父节点当作中断域的controller。如果父节点不是controller，则继续向上寻找。直到遇到controller，或者遇到<code>interrupt-parent</code>属性时，才会指定父节点。</p>\n<p>​\t如图可以看出，<code>adc</code>节点向上寻找，遇到<code>soc</code>节点，在<code>soc</code>节点内，指明了其中断域控制器是<code>nvic</code>。于是<code>adc</code>节点中断域的控制器就是nvic。</p>\n<h3 id=\"其他类似的域\"><a href=\"#其他类似的域\" class=\"headerlink\" title=\"其他类似的域\"></a>其他类似的域</h3><p>类似的还有adc域、pwm域、pin-ctrl域等等。这些域的子节点也都采用了<strong>specifier</strong>的方式，来记录配置信息：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202839931.png\" alt=\"image-20230312202839931\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202850193.png\" alt=\"image-20230312202850193\"></p>\n<center>pwm控制器与子节点</center>\n\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202924182.png\" alt=\"image-20230312202924182\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312202928953.png\" alt=\"image-20230312202928953\"></p>\n<center>adc控制器与子节点</center>\n\n<p>​\t不过，这里没有*-controller属性来指明controller节点。</p>\n<blockquote>\n<p>​\t这些域的控制器的写法，可能有细小的差别，但是背后的道理是相通的。用户也不用关心控制器具体的写法，按照手册写好子节点即可。</p>\n</blockquote>\n<h3 id=\"域的总结\"><a href=\"#域的总结\" class=\"headerlink\" title=\"域的总结\"></a>域的总结</h3><p>​\t总之，对于初学者，这里只需记住「specifier是用来写配置的」即可，后面会讲到具体的用法。</p>\n<h2 id=\"5-3-DeviceBinding\"><a href=\"#5-3-DeviceBinding\" class=\"headerlink\" title=\"5.3.  DeviceBinding\"></a>5.3.  DeviceBinding</h2><p>​\t前面讲到<strong>域</strong>的概念，我们会发现不同的域的配置方法有一些共性，但也有一些差异，这让我们感觉devicetree的规则很混乱：</p>\n<p>​    “<em>除了<strong>dts</strong>本身的语法之外，竟然还有其他的<strong>规则</strong>，一个不小心就会写错！”</em></p>\n<p>​\t我想说，规则是双刃剑。既可以说规则带来了麻烦（提高了门槛），又可以说规则创造了便利（在配置时就提前检查dts是否正确，防止编译的时候出错，那时候更难排查）。</p>\n<p>​\t这里的便利性还体现在VS Code编辑器的<strong>代码提示</strong>与<strong>自动补全</strong>，这是Nordic提供的nRF Connect for VS Code插件实现的：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/%E6%8F%90%E7%A4%BA.gif\" alt=\"提示\"></p>\n<center>自动补全（枚举类型可以给出预选项）</center>\n\n<p>![GIF 2023-2-22 23-54-54](&#x2F;imgs&#x2F;详解Zephyr设备树（DeviceTree）与驱动模型.assets&#x2F;GIF 2023-2-22 23-54-54.gif)</p>\n<center>错误提示（specifier多写了一个单元）</center>\n\n<h3 id=\"DeviceBinding文件\"><a href=\"#DeviceBinding文件\" class=\"headerlink\" title=\"DeviceBinding文件\"></a>DeviceBinding文件</h3><p>​\t所谓的<strong>规则</strong>，被称为Device Binding文件。binding文件是yaml格式文件，yaml是标记语言，由多组键值对组成。每个值可以是：</p>\n<ul>\n<li>纯量（单个不可分割的值，如整数、字符串）</li>\n<li>对象（把键值对当成值）</li>\n<li>数组（一组同类型的<strong>值</strong>）</li>\n</ul>\n<p>示例：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204227457.png\" alt=\"image-20230312204227457\"></p>\n<p>简易语法：</p>\n<ul>\n<li>键、值之间用<strong>冒号+空格</strong>分隔</li>\n<li>yaml的层级关系只看缩进（类似python），相同层级的缩进必须相同</li>\n<li>数组元素可以是纯量、对象。对象的成员也可以有数组</li>\n</ul>\n<blockquote>\n<p>​\t可能新手会感觉很麻烦，又冒出来一种语法。但是其实用户无需有畏难情绪，因为这些内容都是使开发更简单，而不是更麻烦的。bingding文件本身的可读性很强，用户只需要能大概看懂即可，编写yaml文件是厂商的工作。</p>\n</blockquote>\n<p>​\tbinding和DeviceTree中的节点，是通过<code>compatible</code>属性实现联动的。**在VS Code中直接Ctrl+鼠标左键点击<code>compatible</code>**，就可以跳转到对应的binding文件中：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/jump.gif\" alt=\"jump\"></p>\n<p>​\tDeviceTree中节点的属性，必须严格按照binding文件中的要求。如下图，我自定义了一个电压传感器设备，需要用到ADC。那么我在binding文件中，要求符合<code>compatible = &quot;jayant,voltage-sensor&quot;</code>的所有节点，都必须具有<code>io-channels</code>属性，且类型必须是<code>phandle-array</code>。从而使得这个节点可以通过写specifier的方式，把自己加入到ADC域中：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204702592.png\" alt=\"image-20230312204702592\"></p>\n<p>​\tdevice binding的约束能力很强大，不仅可以约束节点的属性（指定数据的类型、枚举、甚至强行赋值），还可以约束此compatible节点的子节点的属性。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312204824297.png\" alt=\"image-20230312204824297\" style=\"zoom:80%;\" />\n\n<center>约束一个节点的子节点的属性</center>\n\n<pre><code>  此外，还能给specifier中记录的数值赋予含义。\n</code></pre>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312204820151.png\" alt=\"image-20230312204820151\"></p>\n<center>给gpio specifier中的2个单元赋予含义</center>\n\n<p>  由于内容较多，本文不多赘述，可参考<a href=\"https://docs.zephyrproject.org/latest/build/dts/bindings.html\">Devicetree</a><a href=\"https://docs.zephyrproject.org/latest/build/dts/bindings.html\"> bindings — Zephyr Project Documentation</a>了解更多信息。大家在实际开发过程中，直接通过Ctrl + 鼠标左键跳进binding文件，然后望文生义即可。</p>\n<h3 id=\"DeviceBinding文件的位置\"><a href=\"#DeviceBinding文件的位置\" class=\"headerlink\" title=\"DeviceBinding文件的位置\"></a>DeviceBinding文件的位置</h3><p>zephyr build system会从以下位置寻找binding文件：</p>\n<ul>\n<li><code>$&#123;NCS&#125;/zephyr/dts/bindings/</code></li>\n<li><code>$&#123;board_dir&#125;/dts/bindings/</code></li>\n<li><code>$&#123;project_dir&#125;/dts/bindings/</code></li>\n</ul>\n<p>也可以在CMakeLists.txt中，用 <code>list(APPEND DTS_ROOT /path/to/your/dts) </code>命令增加binding文件的目录</p>\n<p>也可以在编译时，增加选项 <code>west build -b &lt;board_name&gt; -- -DTS_ROOT=&lt;path/to/your/dts&gt;</code></p>\n<p>如果想要自定义设备类型，可以把yaml文件添加到以上位置。文件名推荐和compatible一致，但不是必须的。</p>\n<p>如下图为我自己写的两个bingding文件的位置示例：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205310166.png\" alt=\"image-20230312205310166\"></p>\n<h2 id=\"5-4-特殊节点\"><a href=\"#5-4-特殊节点\" class=\"headerlink\" title=\"5.4. 特殊节点\"></a>5.4. 特殊节点</h2><p>在5.1种描述了一些常见的属性。本节会描述一些常见的特殊节点。这些节点都是虚拟的，不是实际存在的硬件：</p>\n<ul>\n<li><p><code>/chosen</code>：为<strong>Zephyr Kernel</strong>选择特定设备（如日志串口）；<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205611402.png\" alt=\"image-20230312205611402\"></p>\n</li>\n<li><p><code>/aliases</code>：给节点起一个别名，类似label。不过label仍是节点，而aliases中的别名是属性名。<code>/aliases</code>通常是厂商在<strong>开发板级</strong>的驱动代码中操作硬件所需要的。<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205618639.png\" alt=\"image-20230312205618639\"></p>\n</li>\n<li><p><code>/pinctrl</code>：直属于根节点，不属于soc的一个虚拟节点，用于管理<strong>数字IO</strong>的复用（目前不管模拟IO，因为ADC的模拟通道和MCU的硬件引脚往往是绑定死的，不能配置）；</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312210048297.png\" alt=\"image-20230312210048297\"><br>具体的介绍，我后续会写一篇文章专门讲解。大家可以直接Ctrl + 鼠标左键点击dts文件中的<code>pin-ctrl</code>，跳转过去，也能自己看懂。</p>\n</li>\n<li><p><code>/zephyr,user</code>：方便用户开发的节点，此节点无需<code>compatible</code>属性。用户可以直接在里面随便写各种specifier、自定义属性等。于是就可以直接在代码里操作GPIO通道、ADC通道、pwm通道等，或者把自己随便写的配置项读出。这免去了如果自定义一个device，还要自己写binding的麻烦。<br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312205944691.png\" alt=\"image-20230312205944691\"></p>\n</li>\n</ul>\n<h1 id=\"6-在C代码中访问DeviceTree内容\"><a href=\"#6-在C代码中访问DeviceTree内容\" class=\"headerlink\" title=\"6. 在C代码中访问DeviceTree内容\"></a>6. 在C代码中访问DeviceTree内容</h1><p>​\t在4.4小节中，已经介绍过，DeviceTree最终会用来生成<code>devicetree_generated.h</code>头文件，包含了DeviceTree中的所有信息。自然而然的，我们会想到要在C&#x2F;C++代码中访问这些信息。</p>\n<blockquote>\n<p>​\t注意，由于DeviceTree中节点名称、属性名称允许使用的字符集是比C语言变量命名所允许的字符集更广泛的，因此，Zephyr规定，在C语言中访问DeviceTree的内容时，名称内的字母全部都变成<strong>小写字母</strong>、且特殊符号都变成<strong>下划线</strong>。</p>\n<p>​\t例如<code>zephyr,user</code>变为<code>zephyr_user</code>；<code>my-gpio</code>变为<code>my_gpio</code>。</p>\n</blockquote>\n<p>​\t我们无需关心<code>devicetree_generated.h</code>文件本身的内容，因为它不是给人看的，需要使用一套宏函数来将其读出。在需要操作DeviceTree的文件中包含以下头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/devicetree.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这里给出一个示例：</p>\n<ol>\n<li>在overlay文件中新增一个属性，表示自己需要一个GPIO进行测试，属性名称为<code>test-gpios</code>。这是一个gpio specifier。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/&#123;</span><br><span class=\"line\">    zephyr,user &#123;</span><br><span class=\"line\">        test-gpios = &lt;&amp;gpio0 17 0&gt;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在<code>main.c</code>中，获取这个specifier，并操作GPIO</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;zephyr/drivers/gpio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自己想要操作的节点的id，这里想要操作的节点是zephyr,user</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> NODE_ID DT_PATH(zephyr_user)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取到zephyr,user节点的test-gpios属性，并把它作为gpio specifier，读入GPIO驱动。</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">gpio_dt_spec</span> <span class=\"title\">test_io</span> =</span> GPIO_DT_SPEC_GET(NODE_ID, test_gpios);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际代码</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断设备（这里是gpio控制器）是否已初始化完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// 一般情况下，在application运行前，zephyr驱动就已经把控制器初始化好了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!device_is_ready(test_io.port)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新配置IO</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果DeviceTree里写好了，这里也可以不配</span></span><br><span class=\"line\">    gpio_pin_configure_dt(&amp;test_io, GPIO_OUTPUT_INACTIVE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 操作IO</span></span><br><span class=\"line\">    gpio_pin_set_dt(&amp;test_io,<span class=\"number\">1</span>);</span><br><span class=\"line\">    gpio_pin_set_dt(&amp;test_io,<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-1-获取节点ID\"><a href=\"#6-1-获取节点ID\" class=\"headerlink\" title=\"6.1. 获取节点ID\"></a>6.1. 获取节点ID</h2><p>​\tDeviceTree的一切信息都包含在属性之中。要想获得属性，首先要获得节点ID（node identifier）来作为句柄。获得节点id的方式有很多：</p>\n<table>\n<thead>\n<tr>\n<th><strong>获取方式</strong></th>\n<th><strong>示例</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>根节点</td>\n<td><code>DT_ROOT</code></td>\n<td>根节点id</td>\n</tr>\n<tr>\n<td>绝对路径</td>\n<td><code>DT_PATH(soc, serial_40001000)</code></td>\n<td><code>/soc/serial@40001000  </code></td>\n</tr>\n<tr>\n<td>Label</td>\n<td><code>DT_NODELABEL(serial1)</code></td>\n<td>根据dts中定义的label来找到节点</td>\n</tr>\n<tr>\n<td>chosen节点</td>\n<td><code>DT_CHOSEN(zephyr_console)</code></td>\n<td>根据dts中chosen节点的配置：     zephyr,console&#x3D;&amp;uart0</td>\n</tr>\n</tbody></table>\n<p>​\t获得节点id的方式还有很多：通过父节点找子节点、通过子节点找父节点等等。详细不多赘述，可参考：<br> <a href=\"https://docs.zephyrproject.org/latest/build/dts/api-usage.html\">https://docs.zephyrproject.org/latest/build/dts/api-usage.html#node-identifiers</a></p>\n<p>​\t但是有一种方式需要注意，它与最后一节讲的Zephyr驱动自动初始化息息相关。那就是通过<strong>实例ID</strong>的方式获取节点ID。所谓实例，就是指，同一个<code>compatible</code>，可能在一个dts中有多个实体。比如<code>nordic,nrf-timer</code>，可能一颗MCU上有很多timer。把它们按照在dts中出现的顺序进行编号，就是实例ID。实例ID从0开始。</p>\n<p>​\t比如：<code>DT_INST(0, nordic_nrf_timer)</code>，对应的就是<code>nordic,nrf-timer</code>的第0个实例节点。</p>\n<p>​\t通过实例ID获取节点ID的好处在于，可以通过遍历的方式来一次性获取到同一个compatible下所有的节点。这正是Zephyr能够在Application运行前就能找到所有dts中配置好的硬件的基础。</p>\n<blockquote>\n<p>注意，所有Device Tree API都是宏，是预编译的结果。因此：</p>\n<ul>\n<li>API参数必须是常量。不能在<code>for(int i=0;i&lt;n;++i)</code>的<strong>运行时</strong>循环中用变量<code>i</code>去调用INST的API；</li>\n<li>调用API的过程也必须在编译时就完成。也就是说API宏的返回值只能赋值给const变量，不能在<strong>运行时</strong>调用，赋值给非const的任何变量。</li>\n</ul>\n</blockquote>\n<h2 id=\"6-2-获取属性\"><a href=\"#6-2-获取属性\" class=\"headerlink\" title=\"6.2. 获取属性\"></a>6.2. 获取属性</h2><p>利用DeviceTree API，输入节点id和属性名称，就可以获得属性。</p>\n<h3 id=\"检查属性是否存在\"><a href=\"#检查属性是否存在\" class=\"headerlink\" title=\"检查属性是否存在\"></a>检查属性是否存在</h3><p>​\t使用node id和小写、下划线命名的属性名称</p>\n<p>示例：查找<code>i2c1</code>节点的<code>clock-frequency</code>属性。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_NODE_HAS_PROP(DT_NODELABEL(i2c1), clock_frequency)  <span class=\"comment\">/* 宏展开为 1 */</span></span><br><span class=\"line\">DT_NODE_HAS_PROP(DT_NODELABEL(i2c1), not_a_property)   <span class=\"comment\">/* 宏展开为 0 */</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>DTS里允许的所有特殊符号<code>「-」 「,」 「#」 「@」</code>在C源码里都要变成<code>「_」</code>，且字母都要变成小写。</p>\n</blockquote>\n<blockquote>\n<p>如果是布尔类型，直接使用下面介绍的<code>DT_PROP()</code>即可。不要再使用<code>DT_HAS_PROP()</code>判断其是否存在。</p>\n</blockquote>\n<h3 id=\"获取普通属性\"><a href=\"#获取普通属性\" class=\"headerlink\" title=\"获取普通属性\"></a>获取普通属性</h3><p>​\t整数、布尔、字符串、数组、字符串数组都是普通属性，用<code>DT_PROP(node_id)</code>读取。</p>\n<p>整数与字符串示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_PROP(DT_PATH(soc, i2c_40002000), clock_frequency)  <span class=\"comment\">/* 宏展开为 100000, */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C1 DT_NODELABEL(i2c1)</span></span><br><span class=\"line\">DT_PROP(I2C1, status)  <span class=\"comment\">/* 宏展开为 &quot;okay&quot; */</span></span><br></pre></td></tr></table></figure>\n\n<p>数组示例：</p>\n<p>​\t假设dts为</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">foo:</span> <span class=\"title class_\">foo@1234</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        a = <span class=\"params\">&lt;<span class=\"number\">1000</span> <span class=\"number\">2000</span> <span class=\"number\">3000</span>&gt;</span><span class=\"punctuation\">;</span> <span class=\"comment\">/* array */</span></span><br><span class=\"line\">        b = [aa bb cc dd]<span class=\"punctuation\">;</span>    <span class=\"comment\">/* uint8-array */</span></span><br><span class=\"line\">        c = <span class=\"string\">&quot;bar&quot;</span>, <span class=\"string\">&quot;baz&quot;</span><span class=\"punctuation\">;</span>     <span class=\"comment\">/* string-array */</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>则C代码中可以写作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FOO DT_NODELABEL(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = DT_PROP(FOO, a);           <span class=\"comment\">/* &#123;1000, 2000, 3000&#125; */</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> b[] = DT_PROP(FOO, b); <span class=\"comment\">/* &#123;0xaa, 0xbb, 0xcc, 0xdd&#125; */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* c[] = DT_PROP(FOO, c);         <span class=\"comment\">/* &#123;&quot;foo&quot;, &quot;bar&quot;&#125; */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取数组的长度</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> a_len = DT_PROP_LEN(FOO, a); <span class=\"comment\">/* 3 */</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> b_len = DT_PROP_LEN(FOO, b); <span class=\"comment\">/* 4 */</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> c_len = DT_PROP_LEN(FOO, c); <span class=\"comment\">/* 2 */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读取reg属性\"><a href=\"#读取reg属性\" class=\"headerlink\" title=\"读取reg属性\"></a>读取reg属性</h3><ul>\n<li><p>获取reg blocks数量：<code>DT_NUM_REGS(node_id)</code></p>\n</li>\n<li><p>若只有1个block，则直接读取其地址和长度：</p>\n<ul>\n<li><p><code>DT_REG_ADDR(node_id)</code></p>\n</li>\n<li><p><code>DT_REG_SIZE(node_id)</code></p>\n</li>\n</ul>\n</li>\n<li><p>若有多个block，则需要通过下标来索引</p>\n<ul>\n<li><code>DT_REG_ADDR_BY_IDX(node_id, idx)</code></li>\n<li><code>DT_REG_SIZE_BY_IDX(node_id, idx)</code></li>\n</ul>\n<blockquote>\n<p>注意，node_id和idx都必须是常量。因为宏的值在编译时就已经展开，因此不能放在循环里运行。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"读取interrupts属性\"><a href=\"#读取interrupts属性\" class=\"headerlink\" title=\"读取interrupts属性\"></a>读取interrupts属性</h3><ul>\n<li><p>获取interrupt specifier数量：<code>DT_NUM_IRQS(node_id)</code></p>\n</li>\n<li><p>获取interrupt specifier：通过node id，下标和val来访问中断配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT_IRQ_BY_IDX(node_id, idx, val)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>val的含义：</p>\n<p>​\t是中断控制器devicebind文件中规定的结构体成员名。</p>\n<p>​\t以设备树中的<code>/soc/peripheral/adc@e000</code>节点为例，节点中未指明interrupt parent，故从设备树向上推断，推到<code>/soc</code>节点，此节点指明中断控制器是<code>&amp;nivc</code>，即<code>/soc/interrupt-cntroller@e000e100</code>，其device-binding是<code>&quot;arm,v8m-nvic&quot;</code>。</p>\n<p>​\t在<code>ncs/zephyr/dts/bindings/interrupt-controller/&quot;arm,v8m-nvic.yaml&quot;</code>文件中，指明了interrupt specifier的解析方式：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">interrupt-cells:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">irq</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">priority</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>adc</code>节点中的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interrupts = &lt; 0xe 0x1 &gt;;</span><br></pre></td></tr></table></figure>\n\n<p>可被解析为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADC_NODE DT_NODELABEL(adc)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> irq = DT_IRQ_BY_IDX(ADC_NODE, <span class=\"number\">0</span>, irq) <span class=\"comment\">// 中断号是0xe</span></span><br><span class=\"line\"><span class=\"type\">int</span> priority =  DT_IRQ_BY_IDX(ADC_NODE, <span class=\"number\">0</span>, priority) <span class=\"comment\">// 优先级是priority</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"读取phandle属性\"><a href=\"#读取phandle属性\" class=\"headerlink\" title=\"读取phandle属性\"></a>读取phandle属性</h3><p>例如，dts中有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">n1: node-1 &#123;</span><br><span class=\"line\">    foo = &lt;&amp;n2 &amp;n3&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">n2: node-2 &#123; ... &#125;;</span><br><span class=\"line\">n3: node-3 &#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>则可在C代码中，通过<code>n1</code>节点找到另外两个节点的node id：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N1 DT_NODELABEL(n1)\\</span></span><br><span class=\"line\"><span class=\"meta\">DT_PHANDLE_BY_IDX(N1, foo, 0) <span class=\"comment\">// node identifier for node-2</span></span></span><br><span class=\"line\">DT_PHANDLE_BY_IDX(N1, foo, <span class=\"number\">1</span>) <span class=\"comment\">// node identifier for node-3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3-遍历宏\"><a href=\"#6-3-遍历宏\" class=\"headerlink\" title=\"6.3. 遍历宏\"></a>6.3. 遍历宏</h2><p>​\t前面提到，DeviceTree API都是宏，不能在代码运行时用循环语句（for和while）来调用。但是DeviceTree API提供了遍历展开宏。如：</p>\n<ul>\n<li>对设备树中的每一个节点都调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213721605.png\" alt=\"image-20230312213721605\"></li>\n<li>对设备树中的每一个status为okay的节点调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213728227.png\" alt=\"image-20230312213728227\"></li>\n<li>对一个节点的所有子节点遍历调用宏函数<code>fn</code><br><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312213734780.png\" alt=\"image-20230312213734780\"></li>\n</ul>\n<blockquote>\n<p>更多遍历API，请参考： <a href=\"https://docs.zephyrproject.org/latest/build/dts/api/api.html\">https://docs.zephyrproject.org/latest/build/dts/api/api.html#for-each-macros</a></p>\n</blockquote>\n<p>​\t这些API看似是循环，实际上是在预编译时，把所有遍历的可能性全部展开。</p>\n<p>​\t实际上Nordic提供的很多Zephyr驱动，都是用遍历宏来创建外设相关的变量（例如config结构体），从而能调用nrfx api来完成实际的初始化。</p>\n<p>​\t举一个实际的例子，在<code>$&#123;NCS&#125;/zephyr/drivers/led/led_gpio.c</code>中，定义了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_DRV_COMPAT gpio_leds</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t有了这个定义，就可以使用Inst API来访问<code>compatible = &quot;gpio-leds&quot;</code>的所有led，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leds0 &#123;</span><br><span class=\"line\">    compatible = &quot;gpio-leds&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    label = &quot;LED1&quot;;</span><br><span class=\"line\">    led0: led_0 &#123;</span><br><span class=\"line\">        gpios = &lt;&amp;gpio0 4 0&gt;;</span><br><span class=\"line\">        label = &quot;Green LED 1&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">leds1 &#123;</span><br><span class=\"line\">    compatible = &quot;gpio-leds&quot;;</span><br><span class=\"line\">    status = &quot;okay&quot;;</span><br><span class=\"line\">    label = &quot;LED2&quot;;</span><br><span class=\"line\">    led1: led_1 &#123;</span><br><span class=\"line\">        gpios = &lt;&amp;gpio0 5 0&gt;;</span><br><span class=\"line\">        label = &quot;Green LED 2&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>DT_DRV_INST(0)</code>表示led0的Node ID，等价于<code>DT_INST(0, gpio_leds)</code></p>\n<p><code>DT_DRV_INST(1)</code>表示led1的Node ID，等价于<code>DT_INST(1, gpio_leds)</code></p>\n<blockquote>\n<p>因为<code>devicetree.h</code>中，有</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_DRV_INST(inst) DT_INST(inst, DT_DRV_COMPAT)</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\tInst API提供了基于<strong>下标</strong>的访问DeviceTree节点的方式。</p>\n<p>​\t接下来，下图用宏函数的方式定义了一个代码模板，内部定义了led 驱动程序所需的变量、device结构体等。所有内部调用的宏函数都是基于实例ID的INST API。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312214413238.png\" alt=\"image-20230312214413238\"></p>\n<p>​\t最后，用<strong>遍历宏</strong>调用了前面的代码模板。这个遍历宏的效果是：对所有<code>status=&quot;okay&quot;</code>，且<code>compatible=&quot;gpio-leds&quot;</code>的节点，执行一次上面的宏函数。</p>\n<p>​\tzephyr就是用这种方式，在驱动代码中自动遍历所有<code>status=&quot;okay&quot;</code>的节点，提取其信息，然后用遍历宏来定义驱动结构体，在kernel启动之前就把硬件的初始化给完成。</p>\n<h2 id=\"6-4-specifier硬件支持\"><a href=\"#6-4-specifier硬件支持\" class=\"headerlink\" title=\"6.4. specifier硬件支持\"></a>6.4. specifier硬件支持</h2><p>Device Tree API 中还有很多硬件支持的宏，方便你直接读取specifier等。具体可参考：</p>\n<p><a href=\"https://docs.zephyrproject.org/latest/build/dts/api/api.html\">https://docs.zephyrproject.org/latest/build/dts/api/api.html#hardware-specific-apis</a></p>\n<p><a href=\"https://docs.zephyrproject.org/latest/hardware/index.html\">https://docs.zephyrproject.org/latest/hardware/index.html</a></p>\n<p>这里以ADC的硬件支持宏为例。例如，一个节点为：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312214651795.png\" alt=\"image-20230312214651795\"></p>\n<p>使用<code>ADC_DT_SPEC_GET_BY_IDX(node_id, idx)</code>,就会展开为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   .dev = xxxx,</span><br><span class=\"line\">   .channel_id = xxxx,</span><br><span class=\"line\">   .channel_cfg = xxx,</span><br><span class=\"line\">   .vref_mv = xxxxx,</span><br><span class=\"line\">   <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刚好和zephyr的adc驱动中定义的adc channel结构体的成员一致</p>\n<p>这就是为什么我们可以直接写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_0</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_1</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">my_adc_channel_2</span> =</span> ADC_DT_SPEC_GET_BY_IDX(zephyr_user, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果用上前面说的遍历宏，还能更加简单，直接生成数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给一个specifier对应的大括号末尾加上逗号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DT_SPEC_AND_COMMA(node_id, prop, idx) \\</span></span><br><span class=\"line\"><span class=\"meta\">    ADC_DT_SPEC_GET_BY_IDX(node_id, idx), <span class=\"comment\">// &lt;--逗号加在这里</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 使用遍历宏直接把所有specifier读进数组</span></span><br><span class=\"line\"><span class=\"comment\">// 这些宏展开后相当于三个结构体初始化大括号，中间用逗号分隔</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_dt_spec</span> <span class=\"title\">adc_channels</span>[] =</span> &#123;</span><br><span class=\"line\">    DT_FOREACH_PROP_ELEM(DT_PATH(zephyr_user), </span><br><span class=\"line\">                         io_channels,</span><br><span class=\"line\">                 \t\tDT_SPEC_AND_COMMA)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-Zephyr-Driver的实现方式\"><a href=\"#7-Zephyr-Driver的实现方式\" class=\"headerlink\" title=\"7. Zephyr Driver的实现方式\"></a>7. Zephyr Driver的实现方式</h1><h2 id=\"什么是驱动程序？\"><a href=\"#什么是驱动程序？\" class=\"headerlink\" title=\"什么是驱动程序？\"></a><strong>什么是驱动程序？</strong></h2><p>​\t驱动程序是面向对象的。首先要有一个被操作的对象，然后才有驱动程序。这个被操作的对象就是 <strong>device结构体</strong>。 device结构体本身是抽象的，没有具体的含义:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;           <span class=\"comment\">// 设备的名称</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *config;         <span class=\"comment\">// 设备的初始配置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">void</span> *api;            <span class=\"comment\">// 设备的api函数集合</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device_state</span> *<span class=\"title\">state</span>;</span> <span class=\"comment\">// 设备的工作状态</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *data;                 <span class=\"comment\">// 设备的运行数据</span></span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span>                   <span class=\"comment\">// 其他参数，例如电源管理，后续有专门文章讲解</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​\t驱动程序在Appilication程序运行之前，就把硬件初始化做好，然后定义好device结构体的内容。下图中的五个红色的主要级别都是可以定义驱动程序初始化的时间，每个级别内还可以再细分优先级。</p>\n<img src=\"/jayant97.github.io/imgs/详解Zephyr设备树（DeviceTree）与驱动模型.assets/image-20230312215847338.png\" alt=\"image-20230312215847338\" style=\"zoom:67%;\" />\n\n<h2 id=\"在Application中如何拿到Device结构体？\"><a href=\"#在Application中如何拿到Device结构体？\" class=\"headerlink\" title=\"在Application中如何拿到Device结构体？\"></a>在Application中如何拿到Device结构体？</h2><p>​\t如果说，zephyr在系统初始化阶段就能把所有device结构体定义好。那么Application运行后，要如何拿到这些device呢？</p>\n<h3 id=\"（1）通过Name的方式\"><a href=\"#（1）通过Name的方式\" class=\"headerlink\" title=\"（1）通过Name的方式\"></a>（1）通过Name的方式</h3><p>​\t这种方式，可以与DeviceTree完全无关。可以自己定义一个与DeviceTree无关的纯软件设备，也可以编写驱动程序。</p>\n<p>  例程：<code>$&#123;NCS&#125;/zephyr/samples/application_development/out_of_tree_driver</code> 中，介绍了out of tree driver的写法。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220123168.png\" alt=\"image-20230312220123168\"></p>\n<center>驱动程序中，定义了device的name</center>\n\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220147908.png\" alt=\"image-20230312220147908\"></p>\n<center>应用程序中，通过`device_get_binding()`函数获取device指针 </center>\n\n<h3 id=\"（2）通过DeviceTree的方式\"><a href=\"#（2）通过DeviceTree的方式\" class=\"headerlink\" title=\"（2）通过DeviceTree的方式\"></a>（2）通过DeviceTree的方式</h3><p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220418544.png\" alt=\"image-20230312220418544\"></p>\n<p>​\t在驱动程序中，通过<code>DEVICE_DT_DEFINE()</code>，定义了device结构体，并与DeviceTree中的节点绑定：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220359492.png\" alt=\"image-20230312220359492\"></p>\n<p>在Application中，通过<code>DEVICE_DT_GET(node_id) </code>宏来获得这个device结构体</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220423449.png\" alt=\"image-20230312220423449\"></p>\n<h2 id=\"Kconfig与DeviceTree\"><a href=\"#Kconfig与DeviceTree\" class=\"headerlink\" title=\"Kconfig与DeviceTree\"></a>Kconfig与DeviceTree</h2><p>我们修改<code>prj.config</code>中的<code>CONFIG_XXXX</code>选项、修改dts中的<code>status</code>属性，其本质是在做什么？</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220546761.png\" alt=\"image-20230312220546761\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220553466.png\" alt=\"image-20230312220553466\"></p>\n<p>综合前面介绍的device tree、遍历宏的内容，我们可以知道：</p>\n<ol>\n<li>修改driver相关的config选项，其本质是让CMake把驱动程序包含进来。<strong>只要启用了相关config，驱动程序就会载入，固件就会变大。</strong></li>\n<li>修改status为”okay”，其本质是，让驱动程序在使用遍历宏创建device结构体时，能够为这个okay的节点创建device对象。</li>\n</ol>\n<p><strong>只有两者都启用，硬件节点才真正的被驱动了，application中才能真正的操作这个节点。</strong></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220655857.png\" alt=\"image-20230312220655857\"></p>\n<h2 id=\"Zephyr标准驱动\"><a href=\"#Zephyr标准驱动\" class=\"headerlink\" title=\"Zephyr标准驱动\"></a>Zephyr标准驱动</h2><p>Zephyr是一个跨平台的操作系统，自然少不了对各类标准硬件的跨平台支持。</p>\n<p>详见：<a href=\"https://docs.zephyrproject.org/latest/hardware/peripherals/index.html\">https://docs.zephyrproject.org/latest/hardware/peripherals/index.html</a></p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220754929.png\" alt=\"image-20230312220754929\"></p>\n<p>这里以Counter为例：</p>\n<blockquote>\n<p>在Zephyr中，Timer指的是内核软定时器，而Counter指硬件定时器</p>\n</blockquote>\n<p>在<code>zephyr/include/zephyr/drivers/counter.h</code>中，规定了zephyr标准的counter应该具有哪些api。</p>\n<p>在<code>zephyr/drivers/counter/</code>目录下，有各个厂商对自家MCU产品写好的timer驱动，全部都符合zephyr标准的API。</p>\n<p>在Kconfig中启用counter驱动时，zephyr build system就会自动把板子对应厂商的counter驱动编译进来。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312220830650.png\" alt=\"image-20230312220830650\"></p>\n<h2 id=\"Zephyr标准驱动支持硬件的全功能吗？\"><a href=\"#Zephyr标准驱动支持硬件的全功能吗？\" class=\"headerlink\" title=\"Zephyr标准驱动支持硬件的全功能吗？\"></a>Zephyr标准驱动支持硬件的全功能吗？</h2><p>​\t很遗憾，答案是<strong>不能</strong>。Zephyr只支持<strong>最基础</strong>、<strong>最标准</strong>的硬件驱动，不支持各个厂商的硬件特性。</p>\n<p>​\t例如nrf系列的PPI，非常方便，zephyr没有为PPI提供标准驱动，因为其他厂商平台并没有这个功能，所以是不可能有「device tree里写一下配置，PPI就自动连好了」这种操作的。Nordic外设的<code>SHORT</code>寄存器也是同理。</p>\n<p>​\t下面是一段混合代码：</p>\n<ul>\n<li>前半部分，zephyr标准已经自动初始化好timer0，所以可以用counter api，配置计时；</li>\n<li>后半部分，利用nrfx api，来连接short寄存器，让timer0计时结束后，自动触发clear。</li>\n</ul>\n<p><img src=\"/jayant97.github.io/imgs/%E8%AF%A6%E8%A7%A3Zephyr%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88DeviceTree%EF%BC%89%E4%B8%8E%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.assets/image-20230312221017468.png\" alt=\"image-20230312221017468\"></p>\n<blockquote>\n<p>这里还有个注意事项：<br>    nrf timer本身没有overflow事件，所以把channel 0拿去设置top value了；此外，还把channel 1拿去做输入捕获了。</p>\n<p>​\t因此，nrf timer暴露给zephyr标准驱动的通道就少了两个，实际上zephyr counter的通道0，是硬件定时器的通道2。</p>\n</blockquote>\n<h1 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h1><ol>\n<li>DeviceTree描述的是<strong>板卡级</strong>的硬件信息。DeviceTree是树型逻辑结构，层次关系是由<strong>总线的主从关系，</strong>以及<strong>硬件的包含关系</strong>决定的 。</li>\n<li>DeviceTree的基本单元是节点（Node），节点具有一个<strong>名称</strong>和多条<strong>属性</strong>。可以给节点增加标签（label），来便于引用这个节点。</li>\n<li>板卡级的dts文件可以引用芯片级的dtsi文件，也可以引用.h头文件，从而使用其定义的枚举值和宏。</li>\n<li>用户可以在自己的工程里通过写overlay的方式，来覆写原始board dts里的配置</li>\n<li>Zephyr Build System在构建时会合并所有的dts以及overlay，生成最终的zephyr.dts，并导出为devicetree_generated.h头文件</li>\n<li>DeviceTree本身的语法只提供了一个基于总线主从关系的树形层次结构，此外每个节点可以用属性来存储信息。语法本身并没有规定硬件要如何描述。DeviceTree中的一些常见属性，补充了这方面的空缺。<ul>\n<li>reg、ranges、#address-cells、#size-cells这四个属性描述了总线上的地址分布</li>\n<li>status属性描述了设备是否使能</li>\n<li>compatible属性描述了设备的兼容性</li>\n</ul>\n</li>\n<li>在DeviceTree中，除了本身的树形结构以外，还具有一些逻辑上的树形结构，称为域。域具有<strong>控制器</strong>和设备节点，控制器是真正实现域的功能的硬件外设，而设备节点只是为了开发方便解耦而进行的一种抽象。</li>\n<li>真正限制device tree中属性该如何写的，是device binding文件。binding文件是芯片厂商提供的。有了binding文件，就可以在VS Code中实现自动的检查与补全。Zephyr实际构建项目时，也是参考binding文件来检查dts的正确性。只有dts按照正确的规则写了，zephyr的驱动代码才能识别到硬件配置，进行自动初始化。</li>\n<li>zephyr中会有一些特殊的虚拟节点来为开发提供便利。</li>\n<li>要从C语言中访问DeviceTree中的信息，需要先获得node id。用绝对路径、label、chosen、alias等许多方法都可以获取一个节点的node id。其中要注意的是通过实例id的方法（INST）</li>\n<li>有了node id，就可以获取node的属性。普通的属性与reg、phandle、interrupt属性的获取API不相同。</li>\n<li>zephyr还提供了遍历宏，从而可以针对特定条件的节点&#x2F;属性遍历执行宏函数。</li>\n<li>Zephyr用前面提到的通用API，封装出了各种硬件支持API，方便直接读取各种硬件指定的specifier。</li>\n<li>Zephyr驱动程序，在Application运行之前就会执行初始化，并且定义device结构体。</li>\n<li>Application可以通过Name或者Node id的方式，获得device结构体</li>\n<li>我们在Kconfig中使能driver，本质上是载入了驱动程序，固件会变大。在dts中把节点的status设为okay，本质上是让驱动程序在初始化时，能够自动搜到这个节点，并为这个节点创建device实例。</li>\n<li>Zephyr的标准驱动，让各个厂商都实现了相同功能的驱动API代码，从而实现了跨平台的统一驱动。<br> 但是如果想要使用硬件特性的功能，就还是必须使用厂商自己的driver library或者直接写寄存器。</li>\n</ol>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr","DeviceTree"]}]