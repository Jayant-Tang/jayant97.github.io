[{"title":"nRF9160与nRF Cloud应用示例","url":"/jayant97.github.io/2022/12/175d0fa05ecc/","content":"<h1 id=\"1-产品简介\"><a href=\"#1-产品简介\" class=\"headerlink\" title=\"1. 产品简介\"></a>1. 产品简介</h1><h2 id=\"1-1-nRF-Cloud\"><a href=\"#1-1-nRF-Cloud\" class=\"headerlink\" title=\"1.1. nRF Cloud\"></a>1.1. nRF Cloud</h2><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221204174543482.png\" alt=\"image-20221204174543482\" style=\"zoom:50%;\" />\n\n<p>​\tnRF Cloud是Nordic Semiconducotr公司为Nordic无线产品专门优化的物联网云平台，它可以为任何使用Nordic芯片的客户的原型产品、商业产品提供便捷的云连接、云服务。</p>\n<p>​\tnRF Cloud提供<strong>设备注册（Cloud Provisioning）</strong>、<strong>OTA升级</strong>、<strong>数据存储</strong>、<strong>位置定位</strong>等服务。所有这些功能都可通过Web界面进行管理。客户可以为不同的团队配置不同级别的管理权限。</p>\n<p>​\tnRF Cloud目前有Devloper，Pro和Enterprise三种收费计划。其中开发者计划（Developer plan）是<strong>完全免费</strong>的，只要你有Nordic的开发板就可以最快最方便的方式接入并测试例程。</p>\n<p>设备通过nRF Cloud APIs与nRF Cloud进行连接，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221125164136165.png\" alt=\"image-20221125164136165\"></p>\n<p>​\t设备可以直接通过MQTT API或REST API接入到云。nRF Cloud也通过REST API为客户提供了<strong>云-云对接</strong>的接口。</p>\n<p>​\t更多有关nRF Cloud的信息，可以参考：</p>\n<ul>\n<li><a href=\"https://docs.nrfcloud.com/\">nRF Cloud | nRF Cloud Docs</a></li>\n</ul>\n<h2 id=\"1-2-nRF9160-SiP\"><a href=\"#1-2-nRF9160-SiP\" class=\"headerlink\" title=\"1.2. nRF9160 SiP\"></a>1.2. nRF9160 SiP</h2><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-SiP-rev2-1016-front-and-back.webp\" alt=\"application\" style=\"zoom: 50%;\" />\n\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122134533863.png\" alt=\"image-20221122134533863\" style=\"zoom: 33%;\" />\n\n<p>​\tnRF9160是一款高集成度的低功耗SiP（System-in-Package），具有完整的LTE-M&#x2F;NB-IoT Modem、射频前端、电源管理系统，还具有一颗Cortex-M33应用处理器，便于开发自定义应用。nRF9160是目前市面上<strong>最紧凑、最完整、功耗最低</strong>的蜂窝物联网解决方案。</p>\n<p>​\tnRF9160内置的Modem在全球范围内同时支持<strong>LTE-M</strong>和<strong>NB-IoT</strong>，并且在IPv4&#x2F;IPv6下均支持<strong>eDRX和PSM省电模式</strong>，支持到传输安全层（TCP&#x2F;TLS）。支持GNSS（含美国GPS和日本QZSS）。Modem固件可以通过加密OTA进行升级。</p>\n<p>​\tCortex-M33应用处理器具有独享的1 MB Flash，256 KB SRAM和多种外设接口，便于在单颗设备中实现高级应用。</p>\n<p>​\t也可以把nRF9160当作外挂模组，让外部MCU通过AT指令进行操作，拓展连网能力。在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>\n<p>​\t在安全方面：Arm TrustZone技术可为固件和外设提供安全隔离和保护。使应用可实现Secure Boot、受信任固件升级、受信任的Root等安全需求，且不影响性能。Arm CryptoCell通过加密和安全资源来保护物联网应用程序免受各种攻击威胁。</p>\n<p>​\tnRF9160支持SIM和eSIM。</p>\n<p>​\t更多信息，可参考：</p>\n<ul>\n<li><a href=\"https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/Translated-versions/04_nRF9160-SiP-1.4_SC.pdf?la=en&hash=A1F478B9D8593C70FA143C1CA09C2759C8ED51B6\">nRF9160中文brief - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/nRF9160\">nRF9160 - Nordic Semiconductor - nordicsemi.com</a></li>\n<li><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_PS_v2.1.pdf\">nRF9160 Product Specifications v2.1.pdf</a></li>\n<li><a href=\"https://www.nordicsemi.com/Products/Low-power-cellular-IoT/nRF9160-Certifications\">nRF9160 全球认证信息 - nordicsemi.com</a></li>\n</ul>\n<h2 id=\"1-3-nRF9160-DK\"><a href=\"#1-3-nRF9160-DK\" class=\"headerlink\" title=\"1.3. nRF9160 DK\"></a>1.3. nRF9160 DK</h2><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/nRF9160-DK.webp\" alt=\"nRF9160 DK promo\"></p>\n<p>​\tnRF9160 DK是一款优秀设计的预认证开发套件，带有一颗nRF9160 SiP和一颗nRF52840低功耗蓝牙MCU（用于开发BLE网关产品）。</p>\n<p>​\t板载一个支持多个频段的LTE-M和NB-IoT天线、一个GPS贴片天线和一个2.4G陶瓷天线（用于BLE）。其中LTE和2.4G天线接口提供SWF射频连接端子，便于测量RF信号。所有三款连接器均允许使用外部天线。</p>\n<p>​\t开发板引出了所有GPIO和接口，兼容Arduino Uno Rev3。提供可编程LED(4)、按钮(2)、开关(2)。开发板还具有nano SIM卡插槽（J5）和eSIM贴片焊盘（U20）或eSIM直插接口（P28）。</p>\n<p>板载正版Jlink OB，除可下载、调试板载的nRF9160外，也可对外调试其他产品。</p>\n<p>更多信息，可参考：</p>\n<ul>\n<li><p><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN#infotabs\">nRF9160 DK - nordicsemi.com</a></p>\n</li>\n<li><p><a href=\"https://infocenter.nordicsemi.com/pdf/nRF9160_DK_HW_User_Guide_v1.1.0.pdf\">nRF9160 DK HW User Guide v1.1.0.pdf</a></p>\n</li>\n</ul>\n<h2 id=\"1-4-nRF-Connect-SDK\"><a href=\"#1-4-nRF-Connect-SDK\" class=\"headerlink\" title=\"1.4. nRF Connect SDK\"></a>1.4. nRF Connect SDK</h2><p>​\tnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台将支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>\n<p>​\tNCS内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统。利用Device Tree和Kconfig进行项目的硬件、软件配置。使用CMake和大量Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便，并且是跨平台的（Windows&#x2F;Linux&#x2F;OSX）。</p>\n<p>​\tNCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。</p>\n<p>​\t更多信息可参考：</p>\n<ul>\n<li><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html\">About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n</li>\n</ul>\n<h1 id=\"2-示例-使用nRF9160-DK连接到nRF-Cloud\"><a href=\"#2-示例-使用nRF9160-DK连接到nRF-Cloud\" class=\"headerlink\" title=\"2. 示例: 使用nRF9160-DK连接到nRF Cloud\"></a>2. 示例: 使用nRF9160-DK连接到nRF Cloud</h1><p>​\t本节将会在nRF9160-DK开发板上，烧录<code>nrf/applications/asset_tracker_v2</code>例程。根据国内的网络进行配置，然后把板子连接到nRF Cloud上。</p>\n<p>​\t本节只讲如何把例程跑通，关于例程内容的讲解，在下一节。</p>\n<h2 id=\"2-1-前期准备\"><a href=\"#2-1-前期准备\" class=\"headerlink\" title=\"2.1. 前期准备\"></a>2.1. 前期准备</h2><h3 id=\"硬件准备\"><a href=\"#硬件准备\" class=\"headerlink\" title=\"硬件准备\"></a>硬件准备</h3><ul>\n<li><a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK?lang=zh-CN\">nRF9160 DK开发板（本示例使用的版本：v1.1.0）</a>：其中nRF9160 SiP<strong>不能</strong>是Revision 1版本，必须是Revision 2或更高版本。<br>（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110534824.png\" alt=\"image-20221124110534824\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>micro USB线缆一根</p>\n</li>\n<li><p>中国移动NB卡(物联网卡)<br>  <img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221122191558453.png\" alt=\"image-20221122191558453\"></p>\n<ul>\n<li>将电源开关拨到on，并确保调试开关处于”nRF91”挡位</li>\n<li>插好nano SIM卡，并通过microUSB线连接到电脑</li>\n</ul>\n<blockquote>\n<p>注：DK附赠的iBASIS SIM卡为国外运营商产品，国内无法使用。需要另外购买移动NB-IoT物联网卡。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"非硬件准备\"><a href=\"#非硬件准备\" class=\"headerlink\" title=\"非硬件准备\"></a>非硬件准备</h3><ul>\n<li>一台Windows10或以上版本操作系统的电脑，并<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/779143a4bec8/\"><strong>正确安装了NCS开发环境</strong></a></li>\n<li>注册一个 <a href=\"https://nrfcloud.com/#/\">nRF Cloud账号</a></li>\n</ul>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205005305505.png\" alt=\"image-20221205005305505\" style=\"zoom:50%;\" />\n\n<ul>\n<li>已经知道如何打开NCS中的例程，并且知道如何编译、烧写。</li>\n</ul>\n<h2 id=\"2-2-烧录Modem固件\"><a href=\"#2-2-烧录Modem固件\" class=\"headerlink\" title=\"2.2. 烧录Modem固件\"></a>2.2. 烧录Modem固件</h2><p>​\tnRF9160的Modem具有独立的固件，这部分固件是Nordic以zip包的形式提供的。</p>\n<ol>\n<li>在官网<a href=\"https://www.nordicsemi.com/Products/Development-hardware/nRF9160-DK/Download#infotabs\">nRF9160 DK - Downloads - nordicsemi.com</a>界面，选中最新的Modem固件版本并下载（必须大于1.3.0）。</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143324324.png\" alt=\"image-20221123143324324\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"2\">\n<li>打开nRF Connect桌面版，找到Programmer工具并打开</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143424410.png\" alt=\"image-20221123143424410\" style=\"zoom: 67%;\" />\n\n\n\n<ol start=\"3\">\n<li>先选择板卡，然后选择固件文件（.zip），最后烧录</li>\n</ol>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123143649354.png\" alt=\"image-20221123143649354\" style=\"zoom:50%;\" />\n\n\n\n<ol start=\"4\">\n<li>烧录完毕</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123144339925.png\" alt=\"image-20221123144339925\"></p>\n<h2 id=\"2-3-配置、编译并烧录Application固件\"><a href=\"#2-3-配置、编译并烧录Application固件\" class=\"headerlink\" title=\"2.3. 配置、编译并烧录Application固件\"></a>2.3. 配置、编译并烧录Application固件</h2><h3 id=\"2-3-1-以asset-tracker-v2为模板，创建新工程\"><a href=\"#2-3-1-以asset-tracker-v2为模板，创建新工程\" class=\"headerlink\" title=\"2.3.1. 以asset_tracker_v2为模板，创建新工程\"></a>2.3.1. 以asset_tracker_v2为模板，创建新工程</h3><blockquote>\n<p>asset_tracker_v2是applications目录下的例程。这个目录下的都是商业级例程，基本改一下就能作为产品使用了。</p>\n</blockquote>\n<p>​\t创建新工程相比于打开例程的好处，在我的另一篇文章《安装nRF-Connect-SDK》中已经描述了。</p>\n<p>​\t通过nrf connect插件界面的”Create a new application”来创建新的工程。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145304528.png\" alt=\"image-20221123145304528\"></p>\n<p>从上到下，选项依次为：</p>\n<ul>\n<li>NCS路径</li>\n<li>Zephyer SDK工具链路径</li>\n<li>本项目的存储位置</li>\n<li>选取作为模板的sample例程（NCS中的例程）</li>\n<li>本项目的名称</li>\n</ul>\n<p>​\t关于asset_tracker_v2例程的更多信息，可以参考官方的例程说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<blockquote>\n<p>建议把为这个新创建的初始化为git仓库，便于你记录自己修改了什么。</p>\n<p>记得添加<code>.gitignore</code>文件，并且忽略你的<code>build/</code>文件夹</p>\n</blockquote>\n<h3 id=\"2-3-2-为新工程创建build配置\"><a href=\"#2-3-2-为新工程创建build配置\" class=\"headerlink\" title=\"2.3.2. 为新工程创建build配置\"></a>2.3.2. 为新工程创建build配置</h3><p>板卡选择<code>nrf9160dk_nrf9160_ns</code>，然后Build Configuration即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123145942948.png\" alt=\"image-20221123145942948\"></p>\n<h3 id=\"2-3-3-修改配置\"><a href=\"#2-3-3-修改配置\" class=\"headerlink\" title=\"2.3.3. 修改配置\"></a>2.3.3. 修改配置</h3><p>打开工程根目录下的<code>prj.conf</code>文件，进行修改：</p>\n<ol>\n<li>与运营商有关的修改</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 由于使用移动的NB物联网卡，协议关闭LET-M，使用NB-IoT</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_LTE_M_GPS=n  <span class=\"comment\"># 由y改为n</span></span><br><span class=\"line\">CONFIG_LTE_NETWORK_MODE_NBIOT_GPS=y  <span class=\"comment\"># 新增</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NB-IoT对ePCO支持的不好，故使用传统的PCO</span></span><br><span class=\"line\">CONFIG_PDN=y                         <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_PDN_LEGACY_PCO=y              <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>与nRF Cloud连接、注册有关的修改（后面小节会详细说明）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用JWT和UUID的云端注册方式</span></span><br><span class=\"line\">CONFIG_MODEM_JWT=y                              <span class=\"comment\"># 新增</span></span><br><span class=\"line\">CONFIG_NRF_CLOUD_CLIENT_ID_SRC_INTERNAL_UUID=y  <span class=\"comment\"># 新增</span></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>【备注】<code>prj.conf</code>文件的作用：</p>\n<p>在Zephyer编译系统中，Kconfig管理编译选项、各类功能选项的开关，而devicetree用来管理硬件。编译时，通过CMake和ninja会调用一系列python辅助脚本，把Kconfig和device tree变成c代码和头文件。然后进行编译。更多资料，可参考：<a href=\"https://docs.zephyrproject.org/latest/build/index.html#build-and-configuration-systems\">Build and Configuration Systems — Zephyr Project Documentation</a></p>\n<p>开发时，只需关注Kconfig与device tree如何修改即可。Kconfig中的选项非常多，大多数情况下保持默认即可。Kconfig的默认配置保存在NCS中。</p>\n<p><code>prj.conf</code>的作用，就是为这个工程单独修改部分Kconfig配置。编译时，构建系统会优先使用prj.conf里的配置来覆盖默认的Kconfig配置。这样每个工程都可以单独配置，不会影响到NCS中的默认配置。</p>\n<p><code>prj.conf</code>中的选项都必须是Kconfig中可以找到的。</p>\n<p>在VS Code中通过图形界面修改完Kconfig时，也可以通过”Save to file”按钮，来把修改的部分单独保存到<code>prj.conf</code>中，如下图：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123154242926.png\" alt=\"image-20221123154242926\"></p>\n</blockquote>\n<h3 id=\"2-3-4-编译\"><a href=\"#2-3-4-编译\" class=\"headerlink\" title=\"2.3.4. 编译\"></a>2.3.4. 编译</h3><p>使用nRF Connect插件中的Action菜单中的build即可编译</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221205010029256.png\" alt=\"image-20221205010029256\"></p>\n<p>编译成功的结果：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205010439970.png\" alt=\"image-20221205010439970\" style=\"zoom: 50%;\" />\n\n<h3 id=\"2-3-5-烧录\"><a href=\"#2-3-5-烧录\" class=\"headerlink\" title=\"2.3.5. 烧录\"></a>2.3.5. 烧录</h3><p>​\t先把官方的开发板通过USB连接到电脑上，识别到Jlink之后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221123160139273-1670173336700-36.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n<p>​\t也可以通过命令行的形式进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>备注：\t</p>\n<p>​\t这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160245857-1670173336700-37.png\" alt=\"image-20221123160245857\"></p>\n<p>​\t这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。</p>\n<p>​\t全片擦除然后烧录的方式，点击Flash右边的按钮：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123160832598-1670173336700-38.png\" alt=\"image-20221123160832598\"></p>\n<p>​\t或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash --force --erase</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"2-4-联网测试\"><a href=\"#2-4-联网测试\" class=\"headerlink\" title=\"2.4. 联网测试\"></a>2.4. 联网测试</h2><p>​\t在nRF Connect桌面版中，打开LTE Link Monitor工具。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123163321689.png\" alt=\"image-20221123163321689\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t然后左上角选择板卡，然后再打开串口。串口共有三个(都是Jlink提供的虚拟串口，在板子上2个连接到9160，1个连接到52840)，其中9160的串口只有一个用于AT Command。</p>\n<p>需要依次尝试，点击“AT”按钮就会从串口发送一行“AT”命令，如果有回复OK，说明这个串口就是AT指令的串口。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173504262.png\" alt=\"image-20221123173504262\"></p>\n<blockquote>\n<p>在 <a href=\"https://infocenter.nordicsemi.com/topic/ref_at_commands/REF/at_commands/intro.html\">Nordic Info Center</a>可以查看AT指令手册，并可以在右上角下载PDF。</p>\n</blockquote>\n<p>​\t左侧的面板显示了联网状态、IP地址、信号强度等信息：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173600818.png\" alt=\"image-20221123173600818\"></p>\n<p>​\t注意，”<strong>Automatic Request</strong>“需要勾选上。勾选以后，在切换串口、点击“AT+CFUN?”指令时，才会自动发送相关AT指令，查询网络状态信息，面板上的信息才会更新。否则面板可能不更新。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173636098.png\" alt=\"image-20221123173636098\"></p>\n<p>​\t即是说，以下状态灯应当全绿，则说明联网成功。但若不是全绿，也不一定是联网失败，可能只是信息没有刷新，参照上一条勾选“<strong>自动请求</strong>”，然后点击“AT+CFUN?”指令再次查询即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123173817830.png\" alt=\"image-20221123173817830\"></p>\n<blockquote>\n<p>含义：</p>\n<ul>\n<li>UART：串口状态</li>\n<li>Modem：调制解调器状态</li>\n<li>UICC：SIM卡状态</li>\n<li>LTE：LTE联网状态</li>\n<li>PDN：Packet Data Domain联网状态</li>\n</ul>\n</blockquote>\n<h2 id=\"2-5-将设备注册到nRF-Cloud云端\"><a href=\"#2-5-将设备注册到nRF-Cloud云端\" class=\"headerlink\" title=\"2.5. 将设备注册到nRF Cloud云端\"></a>2.5. 将设备注册到nRF Cloud云端</h2><p>​\tIoT设备是需要注册到云端的，并且通信都需要加密认证，否则任何人开发的设备都能连接到你的云，就不安全了。</p>\n<p>​\t设备注册到云端的过程称为<strong>Cloud Provisioning</strong></p>\n<p>​\t设备注册的流程是：</p>\n<ol>\n<li>首先，要有一个自签CA证书，以及对应的密钥文件；</li>\n<li>需要用自签CA证书+设备的UUID，给每个设备单独签发CA证书，并安装单独的私钥到设备中。</li>\n<li>云端持有证书（公钥），这样设备和云端就可以加密通信了。</li>\n</ol>\n<blockquote>\n<p>什么是非对称加密和CA证书？</p>\n<p>CA证书具有证书文件（内含公钥）和私钥文件两个部分，公钥和私钥是用来做非对称加密的。公钥加密的数据，只能用私钥解密；用私钥加密的数据，只能用公钥解密。</p>\n<p>私钥是自己持有的，而公钥公开给所有想与自己通信的对象。</p>\n<p>假设A要给B发送一段消息M：</p>\n<ol>\n<li>对于这段消息M，发送者A先利用MD5或SHA256等方式生成一个数字摘要D，再用私钥把消息M加密得到密文C。最后把C+D一起发给接收者B。</li>\n<li>B收到消息后，先用公钥解密C得到M’，再对比M’的数据摘要和D是否一致，若一致，则说明数据确实是<strong>公钥的所有者</strong>发出的。于是确信M’就是要接收的消息M。</li>\n</ol>\n<p>但B可能拿到假的公钥，黑客发出假的公钥，就可以冒充A给B发消息。为了避免这种情况发生，公钥需要被<strong>认证</strong>，这就是CA证书。</p>\n<p>一个CA证书文件<code>ca1</code>包含公钥P、签名S、所有者信息（国家、城市、单位名称、邮箱等）。<code>ca1</code>的签名S，是用另一个证书<code>ca2</code>的私钥，对<code>ca1</code>的公钥P进行加密得到的。</p>\n<p>所以利用公开的<code>ca2</code>的公钥对S进行解密，如果和P一致，则说明<code>ca1</code>是合法的。<code>ca1</code>的合法性由<code>ca2</code>证明。</p>\n<p>一个CA证书的安全性由另一个CA证书来证明，这样层层递归下去，形成证书链。而最初的CA证书就是<strong>根证书</strong>。具有颁发<strong>根证书</strong>的资质的机关就是CA（Certificate Authority），也叫“证书授权中心”。CA具有根证书，然后给他信任的其他公司颁发CA证书，这些颁发的CA证书里的签名S就是用根证书的私钥加密的。</p>\n</blockquote>\n<p>​\t目前nRF Cloud有两种注册方式，一种是通过JITP的方式（Just-in-Time Provisioning）,另一种是<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>。</p>\n<h3 id=\"JITP方式注册\"><a href=\"#JITP方式注册\" class=\"headerlink\" title=\"JITP方式注册\"></a>JITP方式注册</h3><p>​\tJITP（Just-in-Time Provisioning）的方式利用开发板背面贴纸上的IMEI和PIN码，在云端控制台<strong>手动</strong>生成一个CA证书，然后下载到电脑，并通过LTE Link Monitor 工具生成<strong>设备证书</strong>，并把设备证书的私钥安装到9160中。这样设备就可以直接连接到云端并注册。这种方式便于快速开发、验证，但不适合量产，本文不详细介绍。若有兴趣可参考：<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#just-in-time-provisioning\">Updating The nRF Cloud Certificate</a></p>\n<h3 id=\"预连接方式注册\"><a href=\"#预连接方式注册\" class=\"headerlink\" title=\"预连接方式注册\"></a>预连接方式注册</h3><p>​\t<a href=\"https://docs.nrfcloud.com/Devices/Associations/Provisioning/#preconnect-provisioning\">预连接（preconnect provisioning）</a>，是利用nRF Cloud提供的云端REST接口（接口文档见<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">Provision Devices</a>），进行批量的设备注册。具体步骤为：</p>\n<ol>\n<li>首先需要一个CA证书（不一定要CA正规机构颁发，可以自己生成）；</li>\n<li>电脑连接到nRF9160 AT串口，为设备分配UUID，并通过<strong>CA证书</strong>和<strong>UUID</strong>为每一个设备生成<strong>设备证书</strong>。通过串口安装这些证书，同时把这一批设备的UUID、公钥等信息记录到CSV表格中。</li>\n<li>通过nRF Cloud的云端REST接口，把这一批设备一次性注册到云端，上传公钥。</li>\n</ol>\n<p>​\t<strong>nRF Cloud提供了一套工具来帮助你快速完成上述三项工作，可以用TypeScript脚本或Python脚本</strong>，这套工具在github上，地址为： <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#create-device-credentials\">utils&#x2F;README.md at master · nRFCloud&#x2F;utils (github.com)</a>。</p>\n<p>​\t下面通过Python脚本进行示例：</p>\n<h3 id=\"（1）前期准备\"><a href=\"#（1）前期准备\" class=\"headerlink\" title=\"（1）前期准备\"></a>（1）前期准备</h3><ul>\n<li><p>确保9160SiP 为Revision 2或更高版本（查看SiP封装上的文字，有<strong>B0</strong>则为Rev1版本，有<strong>B1</strong>则为Rev2版本。可参考：<a href=\"https://infocenter.nordicsemi.com/index.jsp?topic=/comp_matrix_nrf9160/COMP/nrf9160/nrf9160_ic_revision_overview.html\">nRF9160 IC Revision Overview</a>）</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124110504562.png\" alt=\"image-20221124110504562\" style=\"zoom: 25%;\" />\n</li>\n<li><p>确保已经按照[2.2](#2.2. 烧录Modem固件)的步骤，烧录了1.3.0或更高版本的Modem固件（这些版本才支持新的安全AT指令，如<code>KEYGEN</code>）</p>\n</li>\n<li><p>确保你已经按照[2.3](#2.3. 配置、编译并烧录Application固件)的步骤，修改了Application固件的配置参数，启用了JWT和UUID；</p>\n</li>\n<li><p>已经按照[2.4](#2.4. 联网测试)的步骤，验证了设备已经成功联网；</p>\n</li>\n<li><p>已经 <a href=\"https://nrfcloud.com/#/\">注册了nRF Cloud账号，并登录</a>。</p>\n</li>\n</ul>\n<h3 id=\"（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\"><a href=\"#（2）获取最新的nRF-Cloud-Utils工具，并安装好依赖\" class=\"headerlink\" title=\"（2）获取最新的nRF Cloud Utils工具，并安装好依赖\"></a>（2）获取最新的nRF Cloud Utils工具，并安装好依赖</h3><p>​\t在一个无中文、无空格、无特殊字符的路径下，从github拷贝仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/nRFCloud/utils.git</span><br></pre></td></tr></table></figure>\n\n<p>​\t进入modem firmware 1.3+ 子文件夹，然后安装其python依赖包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> utils/python/modem-firmware-1.3+/</span><br><span class=\"line\">$ pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）生成你的自签CA证书\"><a href=\"#（3）生成你的自签CA证书\" class=\"headerlink\" title=\"（3）生成你的自签CA证书\"></a>（3）生成你的自签CA证书</h3><p>​\t复制下方的命令，并把对应参数改成你自己需要的信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python create_ca_cert.py \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn nordic.cn \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-p ./my_ca \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义（部分参数未使用）：</p>\n<ul>\n<li><code>-c</code> ：2字符的国家代码，<code>CN</code>为中国</li>\n<li><code>-st</code>：州或省</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：公司&#x2F;组织</li>\n<li><code>-ou</code>：组织部门</li>\n<li><code>-cn</code>：Common Name</li>\n<li><code>-dv</code>：有效天数</li>\n<li><code>-e</code>：电子邮箱地址</li>\n<li><code>-p</code>：CA证书生成后存储的位置</li>\n<li><code>-f</code>：给生成的三个证书文件的文件名添加前缀（字符串）</li>\n</ul>\n</blockquote>\n<p>​\t生成后，可以看到自己指定的目录下已经有了三个证书文件：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123223024181.png\" alt=\"image-20221123223024181\" style=\"zoom: 67%;\" />\n\n<p>​\t其中，ca是证书，prv是私钥，pub是公钥。</p>\n<blockquote>\n<p>本例程中，CA证书是我们自己签发的根证书，能让设备和云端的通信被加密即可。这个CA证书本身并不是CA机构签发的正规证书。</p>\n<p>若想查看CA证书的信息，可以随便找一个<a href=\"https://myssl.com/cert_decode.html\">在线CA查看器</a>，把xxx_ca.pem拖进去就可以看到信息了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123224514523.png\" alt=\"image-20221123224514523\" style=\"zoom: 33%;\" />\n</blockquote>\n<h3 id=\"（4）签发并安装设备证书\"><a href=\"#（4）签发并安装设备证书\" class=\"headerlink\" title=\"（4）签发并安装设备证书\"></a>（4）签发并安装设备证书</h3><p>​\t需要使用<code>utils/python/modem-firmware-1.3+/</code>目录下的<code>device_credentials_installer.py</code>脚本。</p>\n<p>如果想查看最新的脚本使用方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -h</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t此脚本的功能：</p>\n<ol>\n<li>这个脚本会调用同一目录下的<code>create_device_credentials.py</code>，给每个设备单独生成设备证书；</li>\n<li>通过电脑串口，给你的设备发送AT指令，生成一个UUID；</li>\n<li>通过电脑串口，给你的设备发送AT指令，把<strong>设备证书</strong>及其<strong>私钥</strong>安装到你的设备中；</li>\n<li>记录这个设备的信息，把UUID等信息存储到2个csv表格文件中。</li>\n<li>量产时，这个脚本可以重复执行。只需要在每次串口上换一个设备时，就执行一次这个脚本。这个设备就会被安装证书，并且设备的信息会记录到2个表格文件中。<strong>最多允许存1000台设备的信息。</strong></li>\n<li>后续可以把这两个表格文件和证书上传到云端，便于批量注册设备。</li>\n</ol>\n<p>​\t在执行这个脚本之前，确保第（2）步中的CA证书都生成好了。</p>\n<p>脚本使用示例如下（windows环境），你需要根据实际情况改变命令的参数配置。</p>\n<p>注意，示例执行脚本时，并未指定串口。因为脚本在windows下会自动检测哪个串口是AT指令串口。注意不要开着LTE Link Monitor等工具占用着串口导致安装失败。如果在linux下操作，请增加<code>--port /dev/ttyS??</code>来指定串口，详情可参考 <a href=\"https://github.com/nRFCloud/utils/blob/master/python/modem-firmware-1.3+/README.md#device-credentials-installer\">Device Credentials Installer</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python device_credentials_installer.py -d -t <span class=\"string\">&quot;jayant-DK&quot;</span> --ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem --ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem -a --devinfo_append --csv ./jayant_provision.csv --devinfo ./jayant_devinfo.csv --term CRLF</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-d</code>：安装前先从Modem中删除sectag</li>\n<li><code>-t</code>：用于设备分组管理的标签，是一个字符串</li>\n<li><code>-T</code>：设置自定义的子类型，如温湿度传感器等，是一个字符串。此处未设置</li>\n<li><code>--ca</code>：CA证书文件的路径</li>\n<li><code>--ca_key</code>：CA证书私钥的路径(prv)</li>\n<li><code>-a</code>或<code>--append</code>：保存<strong>设备注册信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--devinfo_append </code>：保存<strong>设备信息</strong>到csv表格文件时，向末尾增加新的条目，而不是覆盖csv文件（这个选项是确保你可以重复执行脚本，搜集全部设备信息的基础）</li>\n<li><code>--csv</code>：用于存储设备注册信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、前缀、固件等信息）</li>\n<li><code>--devinfo</code>：用于存储设备信息的CSV表格的文件名，若文件不存在则创建。若文件存在，则根据<code>-a</code>选项，向文件中添加新条目。（存储UUID、Modem固件版本、芯片IMEI等信息）</li>\n<li><code>--term</code>：AT指令的结束符（<code>NULL</code>,<code>CRLF</code>,<code> CR</code> 或<code>LF</code>）</li>\n<li><code>--port</code>：指定AT指令串口</li>\n</ul>\n</blockquote>\n<p>​\t我只有一块开发板，所以只执行一次。</p>\n<h3 id=\"（5）把设备信息批量注册到云端\"><a href=\"#（5）把设备信息批量注册到云端\" class=\"headerlink\" title=\"（5）把设备信息批量注册到云端\"></a>（5）把设备信息批量注册到云端</h3><p>​\t批量的在nRFCloud上进行设备注册（Cloud Provisioning）。</p>\n<p>​\t首先，在<a href=\"https://nrfcloud.com/#/\">nRF Cloud Portal</a> 登录你的nRF Cloud账号（前面应该已经注册好了）。然后获取nRF Cloud REST API key。</p>\n<p>​\t在右上角点击进入个人账户页面，然后在下面可以看到API key，复制出来即可。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123234437620.png\" alt=\"image-20221123234437620\"></p>\n<p>​\t接下来继续执行python脚本，进行云端注册：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python ./nrf_cloud_provision.py --apikey 3c967ecbd9fxxxxxxxxxxxxxxxxa73cf37049983 --chk --csv ./jayant_provision.csv --devinfo jayant_devinfo.csv --set_mfwv --name_imei --name_pref <span class=\"string\">&quot;my_dk_&quot;</span> --res prov.log</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>--apikey</code>：刚刚复制的API key</li>\n<li><code>--chk</code>：<strong>单个设备的注册才使用</strong>，注册前先检查设备是否存在</li>\n<li><code>--csv</code> ：上一步生成的，存储着<strong>设备注册信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li>&#96;–devinfo ：上一步生成的，存储着<strong>设备信息</strong>的csv表格文件，最多允许1000条数据</li>\n<li><code>--set_mfwv</code>：把<code>--devinfo</code>中记录的Modem固件版本存储到云端</li>\n<li><code>--name_imei</code>：把<code>--devinfo</code>中记录的IMEI（芯片ID）作为friendly name</li>\n<li><code>--name_pref</code>：给friendly name添加一个前缀字符串</li>\n<li><code>--res</code>：存储注册结果的日志文件</li>\n</ul>\n</blockquote>\n<p>​\t完成后，可以看到成功注册的结果：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235635167.png\" alt=\"image-20221123235635167\"></p>\n<h3 id=\"（6）在云端查看刚刚注册的设备\"><a href=\"#（6）在云端查看刚刚注册的设备\" class=\"headerlink\" title=\"（6）在云端查看刚刚注册的设备\"></a>（6）在云端查看刚刚注册的设备</h3><p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221123235940868.png\" alt=\"image-20221123235940868\"></p>\n<p>​\t可以在Device界面看到设备已经注册成功，设备的名称是“前缀字符串” + “IMEI”的形式。</p>\n<p>​\t但设备还处于Disconnect的状态。这是因为刚才下载私钥时，把设备设为了离线状态，可以通过LTE Link Monitor输入以下AT指令，也可以简单reset一下设备，或者重新通过LTE Link Monitor查看设备的状态。这样设备应该就会变成已连接了:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">AT%XSYSTEMMODE=0,1,0,0 // 选择NB网络</span><br><span class=\"line\">AT+CEREG=5             // 打开调制解调器</span><br><span class=\"line\">AT+CFUN=1              // 开始联网</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000424393.png\" alt=\"image-20221124000424393\"></p>\n<p>​\t点进设备的详情页面，已经可以看到大量的信息（部分资源在墙外，加载不出属于正常现象，需要代理上网）：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124000623033.png\" alt=\"image-20221124000623033\"></p>\n<p>​\t可以通过terminal窗口，发送json消息，与设备进行交互。也可以进行OTA升级。</p>\n<p>​\t在本例程中，板子上的LED指示灯也可以展示状态：详见<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#led-indication\">Led indication</a>。这里只列出DK板的行为。</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>nRF9160 DK solid LEDs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LTE connection search</td>\n<td>LED1 blinking</td>\n</tr>\n<tr>\n<td>GNSS fix search</td>\n<td>LED2 blinking</td>\n</tr>\n<tr>\n<td>Cloud association</td>\n<td>LED3 double pulse blinking</td>\n</tr>\n<tr>\n<td>Connecting to cloud</td>\n<td>LED3 triple pulse blinking</td>\n</tr>\n<tr>\n<td>Publishing data</td>\n<td>LED3 blinking</td>\n</tr>\n<tr>\n<td>Active mode</td>\n<td>LED4 blinking</td>\n</tr>\n<tr>\n<td>Passive mode</td>\n<td>LED3 and LED4 blinking</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>All 4 LEDs blinking</td>\n</tr>\n<tr>\n<td>FOTA update</td>\n<td>LED1 and LED2 blinking</td>\n</tr>\n<tr>\n<td>Completion of FOTA update</td>\n<td>LED1 and LED2 static</td>\n</tr>\n</tbody></table>\n<h3 id=\"（7）从云端删除设备\"><a href=\"#（7）从云端删除设备\" class=\"headerlink\" title=\"（7）从云端删除设备\"></a>（7）从云端删除设备</h3><p>​\t如果你想从云端删除设备，可以直接在网页端操作，从右上角齿轮除点击删除即可。也可以用云对云的REST API进行删除，后续章节讲解。</p>\n<h1 id=\"3-Asset-Tracker-v2-例程分析\"><a href=\"#3-Asset-Tracker-v2-例程分析\" class=\"headerlink\" title=\"3. Asset Tracker v2 例程分析\"></a>3. Asset Tracker v2 例程分析</h1><p>​\t例程的官方说明：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/asset_tracker_v2_description.html\">Application description — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<h2 id=\"3-1-本例程设计原则\"><a href=\"#3-1-本例程设计原则\" class=\"headerlink\" title=\"3.1. 本例程设计原则\"></a>3.1. 本例程设计原则</h2><ul>\n<li>超低功耗</li>\n<li>离线优先：本例程假设大多数情况下是离线的，连接是不可靠的。因此会有数据重发的机制。</li>\n<li>时间戳机制：多时间源的时间戳机制，离线情况也可以计时</li>\n<li>数据打包：多次数据打包，减少数据发送次数；离线时，数据会被存储，等到下次在线时一起发送</li>\n<li>运行时参数修改：支持在运行时修改部分配置参数（例如加速度计灵敏度，或GNSS超时时间）</li>\n</ul>\n<h2 id=\"3-2-例程实现的功能\"><a href=\"#3-2-例程实现的功能\" class=\"headerlink\" title=\"3.2. 例程实现的功能\"></a>3.2. 例程实现的功能</h2><p>​\t本节概览性的介绍此例程的具体功能：</p>\n<h3 id=\"数据搜集\"><a href=\"#数据搜集\" class=\"headerlink\" title=\"数据搜集\"></a>数据搜集</h3><p>​\t本例程会搜集数据，并上传到云端，下表列出会上传的数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n<th>Identifiers</th>\n<th>String identifier for NOD list</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>位置（Location）</td>\n<td>GNSS坐标</td>\n<td>APP_DATA_GNSS</td>\n<td><code>gnss</code></td>\n</tr>\n<tr>\n<td>环境信息（Environmental）</td>\n<td>温度，湿度</td>\n<td>APP_DATA_ENVIRONMENTAL</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>运动信息（Movement）</td>\n<td>加速度</td>\n<td>APP_DATA_MOVEMENT</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>调制解调器（Modem）</td>\n<td>LTE link data, device data</td>\n<td>APP_DATA_MODEM_DYNAMIC, APP_DATA_MODEM_STATIC</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>电池信息（Battery）</td>\n<td>电压</td>\n<td>APP_DATA_BATTERY</td>\n<td>NA</td>\n</tr>\n<tr>\n<td>Neighbor cells</td>\n<td>Neighbor cell measurements</td>\n<td>APP_DATA_NEIGHBOR_CELLS</td>\n<td><code>ncell</code></td>\n</tr>\n</tbody></table>\n<p>​\t此外，还有一些异步数据：</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>按钮（Button）</td>\n<td>按下的按钮的ID</td>\n</tr>\n<tr>\n<td>冲击（Impact）</td>\n<td>冲击的幅度（单位是重力加速度常数G）</td>\n</tr>\n</tbody></table>\n<h3 id=\"实时配置\"><a href=\"#实时配置\" class=\"headerlink\" title=\"实时配置\"></a>实时配置</h3><p>​\t本例程中的一些选项，支持通过云端进行远程实时配置。</p>\n<table>\n<thead>\n<tr>\n<th>实时配置项</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Device Mode</td>\n<td>主动（Active）或被动（Passive）：Active指一直上报，而Passive只在运动时才上报</td>\n<td>Active</td>\n</tr>\n<tr>\n<td>Active: Wait time</td>\n<td>Active模式下，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement resolution</td>\n<td>Passive模式下，设备在移动时，每次把数据传送到云端的时间间隔</td>\n<td>120秒</td>\n</tr>\n<tr>\n<td>Passive: Movement timeout</td>\n<td>Passive模式下，不论设备是否移动，每次把数据传送到云端的时间间隔</td>\n<td>3600秒</td>\n</tr>\n<tr>\n<td>GNSS timeout</td>\n<td>数据采样时，获取GNSS定位的超时时间</td>\n<td>30秒</td>\n</tr>\n<tr>\n<td>Accelerometer activity threshold</td>\n<td>设备被判定为移动的加速度阈值</td>\n<td>10  m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity threshold</td>\n<td>设备被判定为精致动的加速度阈值</td>\n<td>5 m&#x2F;s^2</td>\n</tr>\n<tr>\n<td>Accelerometer inactivity timeout</td>\n<td>设备被判定为移动的时间阈值，加速度和时间都超过阈值才被判定为移动</td>\n<td>1秒</td>\n</tr>\n<tr>\n<td>No Data List (NOD)</td>\n<td>禁用列表，列表项是Data Type，字符串形式。可以禁用例程上报某一些Data Type的数据</td>\n<td>空</td>\n</tr>\n</tbody></table>\n<p>​\t这些配置可以另外修改，有以下几种方式：</p>\n<ul>\n<li>每次与云端建立连接时，从云端同步</li>\n<li>设备发送更新数据到云端时</li>\n<li>启动后，从flash中另外加载</li>\n</ul>\n<h3 id=\"工作流程图\"><a href=\"#工作流程图\" class=\"headerlink\" title=\"工作流程图\"></a>工作流程图</h3><img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206195856563.png\" alt=\"image-20221206195856563\" style=\"zoom: 67%;\" />\n\n<center>\n 主动模式流程图\n</center>\n\n<p>​\t在<strong>主动模式</strong>下，只要超时，例程就会采样新数据，并发送到云端。</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221206200043536.png\" alt=\"image-20221206200043536\" style=\"zoom:80%;\" />\n\n<center>\n    被动模式流程图\n</center>\n\n\n\n<p>​\t在<strong>被动模式</strong>下，只有两种情况会触发数据上报：</p>\n<ul>\n<li>检测到运动，并且Resolution定时器超时，默认120s</li>\n<li>未检测到运动，并且 timeout定时器超时，默认3600s</li>\n</ul>\n<h3 id=\"用户接口\"><a href=\"#用户接口\" class=\"headerlink\" title=\"用户接口\"></a>用户接口</h3><p>​\t例程提供了一些UI来方便观察系统的状态。例如按键和灯。按键和灯的功能说明见：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html\">User Interface module — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>\n<h3 id=\"A-GPS与P-GPS\"><a href=\"#A-GPS与P-GPS\" class=\"headerlink\" title=\"A-GPS与P-GPS\"></a>A-GPS与P-GPS</h3><blockquote>\n<p>GNSS简介：</p>\n<ul>\n<li>GNSS：全球卫星导航系统，通过多颗同步卫星对地球进行广播。地面上的设备只要接收到三个卫星的信号，根据<strong>预先获得的卫星轨道数据</strong>和<strong>接收到广播的时间差</strong>就可以计算出在地球上的定位。</li>\n<li>GPS：美国的GNSS，每12.5分钟广播一次。</li>\n<li>A-GPS：辅助GPS，适合室外。设备不用等GPS广播，先从附近蜂窝基站获得大概定位。然后从云服务器的AGPS服务下载这个区域的GPS信息。于是可以缩短设备的GNSS模块首次捕获的时间（2~3分钟缩短到几秒）。</li>\n<li>P-GPS：预测GPS。设备可以下载长达2周的预测卫星星历数据，使设备能够准确的知道卫星的轨道位置，而无需每2小时连接到网络。并且还能随时间变化权衡精度的下降。P-GPS也能缩短设备定位所需的时间。</li>\n</ul>\n</blockquote>\n<p>​\tNCS提供nRFCloud <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_agps.html#lib-nrf-cloud-agps\">A-GPS库</a>和<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud_pgps.html#lib-nrf-cloud-pgps\">P-GPS库</a>，让设备能从云端获取这些数据。不论云端是 <a href=\"https://aws.amazon.com/iot-core/\">AWS IoT Core</a>, <a href=\"https://docs.microsoft.com/en-us/azure/iot-hub/\">Azure IoT Hub</a>,还是 <a href=\"https://omaspecworks.org/what-is-oma-specworks/iot/lightweight-m2m-lwm2m/\">LwM2M</a>。这些数据由<a href=\"https://docs.nrfcloud.com/LocationServices/LocationServicesOverview/\">nRF Cloud 位置服务</a>提供。</p>\n<p>​\t上述云端与nRF Cloud通信的接口是REST API，将在本文的最后一节讲解。</p>\n<p>​\t如果例程是直接连nRF Cloud的，就不需要转发了。</p>\n<h2 id=\"3-3-例程的工程结构\"><a href=\"#3-3-例程的工程结构\" class=\"headerlink\" title=\"3.3. 例程的工程结构\"></a>3.3. 例程的工程结构</h2><p>​\tZephyer开发最大的特点是<strong>模块化</strong>。在我的另一篇文章<a href=\"https://jayant-tang.github.io/jayant97.github.io/2022/12/2a39e705bff0/\">《理解Zephyr项目的配置与构建系统》</a>中，我介绍了Zephyr和Nordic提供的库都可以看成是一个模块，每个模块有自己的Kconfig配置。</p>\n<p>​\t如果你自己写一个项目，可以把几个<code>.c</code>源文件和<code>.h</code>头文件丢进<code>CMakeList.txt</code>就行，这样比较简单直接。但如果你想开发好几个独立的复杂模块，并让他们搭配起来工作，就一定要学一下Asset Tracker v2这个例程的写法。</p>\n<p>​\t首先看项目根目录下的<code>Kconfig</code>的包含关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Kconfig</span><br><span class=\"line\">|-- Asset Tracker v2</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modules_common</span><br><span class=\"line\">|   |-- src/modules/Kconfig.app_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.cloud_module</span><br><span class=\"line\">|   |-- src/cloud/Kconfig.lwm2m_integration</span><br><span class=\"line\">|   |-- src/modules/Kconfig.data_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.gnss_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.modem_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.sensor_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.ui_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.util_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.led_module</span><br><span class=\"line\">|   |-- src/modules/Kconfig.debug_module</span><br><span class=\"line\">|   |</span><br><span class=\"line\">|   |-- src/cloud/cloud_codec/Kconfig</span><br><span class=\"line\">|   |-- src/watchdog/Kconfig</span><br><span class=\"line\">|   |-- src/events/Kconfig</span><br><span class=\"line\">|   </span><br><span class=\"line\">|-- Zephyr Kernel  // 操作系统内核的配置</span><br><span class=\"line\">|    |-- Kconfig.zephyr</span><br><span class=\"line\">|</span><br><span class=\"line\">`-- 日志打印等级配置</span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到，除了Zephyr操作系统内核外，还包含了src目录下许多的模组，这些模组<strong>不是官方库</strong>。而是Nordic官方为这个例程开发的应用模组。你也可以照葫芦画瓢开发自己的应用模组。</p>\n<p>​\t直接用图形化界面查看，就可以看到Kconfig中的选项了：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129154636314.png\" alt=\"image-20221129154636314\" style=\"zoom: 67%;\" />\n\n<blockquote>\n<p>​\t分模块开发，除了更加简洁直观、解耦以外，还有一个巨大的好处，那就是每个模组的Log可以在Kconfig中单独开关。这个例程的项目实在是太复杂了，如果所有模组的log都打开，不论是串口还是RTT都是打不下的。</p>\n</blockquote>\n<p>​\t每个模组都可以有自己的线程、初始化代码、回调函数等。</p>\n<h2 id=\"3-4-模组间的配合方式\"><a href=\"#3-4-模组间的配合方式\" class=\"headerlink\" title=\"3.4. 模组间的配合方式\"></a>3.4. 模组间的配合方式</h2><h3 id=\"程序的调用方式\"><a href=\"#程序的调用方式\" class=\"headerlink\" title=\"程序的调用方式\"></a>程序的调用方式</h3><p>​\t我们知道，不同代码之间互相调用的方式有同步调用和异步调用：</p>\n<ul>\n<li>同步调用就是，直接调用几个函数，等到它们依次返回后，你才做最后的处理，然后返回；</li>\n<li>异步调用就是，先把最后的处理写进回调函数，然后通过函数指针注册给其他模组。调用其他模组的函数时不用阻塞，立刻就能返回。等到其他模组处理完后，执行这个回调函数，就成功把参数传回本模组了。</li>\n</ul>\n<p>​\t以上两种方式，常常发生在我们使用官方库的过程中。我们直接调用官方库中的函数（同步调用），或者把回调函数注册进官方库中（异步调用）。</p>\n<h3 id=\"Application-Event-Manager\"><a href=\"#Application-Event-Manager\" class=\"headerlink\" title=\"Application Event Manager\"></a>Application Event Manager</h3><p>​\t对于我们自己开发的application模组，如果互相之间通信还要调用对方的函数，还要做线程间通信，还要做互斥锁、信号量，那就失去模块化的意义了。</p>\n<p>​\tNordic提供了一个叫做Application Event Manager的库，Nordic许多产品级的复杂例程都用到了它。它提供了一个不同模组之间的通信机制：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205013810750.png\" alt=\"image-20221205013810750\" style=\"zoom: 67%;\" />\n\n<p>​\t每个模组只负责与自己有关的应用和驱动。每个模组可以发布（SUBMIT）事件，也可以订阅（SUBSCRIB）其他模组的事件。想让其他模组做什么事的时候，发布一个事件就好。而只要订阅了其他模组的事件，那么就可以从Application Event Manager中收到这些事件，之后，只要编写好处理这些事件的回调函数即可。</p>\n<p>​\t所有的事件都是从Applicarion Event Manager来的，回调函数是注册给Applicarion Event Manager的，不是注册给其他模组。此外，每个模组只需一个回调函数就可以处理所有其他模组来的时间，不用定义一堆事件入口。</p>\n<p>​\t由此我们可以体会这个设计的方便之处，每个模组都是独立的，只用关心自己的业务即可。</p>\n<h3 id=\"模组的线程\"><a href=\"#模组的线程\" class=\"headerlink\" title=\"模组的线程\"></a>模组的线程</h3><p>​\t一个模组，根据其业务复杂程度的不同（比如有无状态机），可能自带线程，也可能不带线程。Application Event Manager对这两种模组都兼容。</p>\n<ul>\n<li>对于带线程的模组。所有的事件都变成消息，存入消息队列。模组的线程里循环等待消息队列的数据，并根据具体情况处理到来的事件。</li>\n<li>对于不带线程的模组，只需写好事件的回调函数，注册进Application Event Manager即可。</li>\n</ul>\n<blockquote>\n<p>​\t对于不带线程的模组，必须确保回调函数执行较快，否则将会阻塞Application Event Manager。如果没法确保这一点，就必须给模组写一个单独的线程来处理消息。</p>\n</blockquote>\n<p>如下图：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203957763.png\" alt=\"image-20221206203957763\"></p>\n<blockquote>\n<p>​\t\t对于带线程的模组：<br>​\t把Event变成Message，并放入消息队列的工作，都是每个模组自己维护的。Application Event Manager只是提供一个事件回调的接口，各个模组自己通过事件回调函数，把事件放入消息队列。</p>\n</blockquote>\n<h3 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h3><p>​\t模组大多使用静态分配的内存。但是本例程会有一些内容使用动态内存，依赖的是 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/memory_management/heap.html#heap-v2\">Zephyr的堆内存池</a>。以下内容是使用了动态内存的：</p>\n<ul>\n<li>模组之间传输的Event</li>\n<li>即将被发送到云端的数据</li>\n</ul>\n<p>​\t要发送到云的数据是最耗内存的。所以如果要修改data模组的缓冲区大小，别忘了同时也修改堆的大小。</p>\n<blockquote>\n<p>使用<code>CONFIG_HEAP_MEM_POOL_SIZE</code>来配置堆的大小。</p>\n</blockquote>\n<h2 id=\"3-5-例程模组介绍\"><a href=\"#3-5-例程模组介绍\" class=\"headerlink\" title=\"3.5. 例程模组介绍\"></a>3.5. 例程模组介绍</h2><p><img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221206203138376.png\" alt=\"image-20221206203138376\"></p>\n<p>​\t如上图，例程中共实现了9个模组。蓝色的是自带线程的，而橙色的是不带线程的。</p>\n<ul>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/app_module.html#asset-tracker-v2-app-module\">Application module</a>：控制何时采集数据、采集什么数据，并且控制整个例程的其他行为</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html#asset-tracker-v2-data-module\">Data module</a>：根据App模块的设定搜集其他模块的数据，存入环形缓冲。并决定何时发送到云端。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/cloud_module.html#asset-tracker-v2-cloud-module\">Cloud module</a>：负责与云端的连接与数据交互</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/sensor_module.html#asset-tracker-v2-sensor-module\">Sensor module</a>：与 <a href=\"thingy:91productpage\">Thingy:91</a>开发板上的传感器交互并获得数据</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/gnss_module.html#asset-tracker-v2-gnss-module\">GNSS module</a>：控制nRF9160的GNSS功能</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/ui_module.html#asset-tracker-v2-ui-module\">User Interface module</a>：利用按键和灯提供简易的用户交互接口</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/util_module.html#asset-tracker-v2-util-module\">Utility module</a>：提供对例程进行管理和监控的工具</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/debug_module.html#asset-tracker-v2-debug-module\">Debug module</a>：此模组订阅了所有事件，方便调试，也支持nCS中的Memfault模组。</li>\n<li><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/modem_module.html#asset-tracker-v2-modem-module\">Modem module</a>：控制LTE连接</li>\n</ul>\n<blockquote>\n<p>要使用debug模组，需要include <code>../overlay-debug.conf</code></p>\n</blockquote>\n<h2 id=\"3-6-例程代码分析\"><a href=\"#3-6-例程代码分析\" class=\"headerlink\" title=\"3.6. 例程代码分析\"></a>3.6. 例程代码分析</h2><p>​\t本小节从一个初学者的角度去查代码，讲解如何分析代码、以及如何查找资料。</p>\n<h3 id=\"3-6-1-main-c文件分析\"><a href=\"#3-6-1-main-c文件分析\" class=\"headerlink\" title=\"3.6.1. main.c文件分析\"></a>3.6.1. main.c文件分析</h3><p>​\t我们进入到<code>src/main.c</code>中的<code>main()</code>函数，可以看到，这里首先是判断是否启用了<code>lwm2m</code>库：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!IS_ENABLED(CONFIG_LWM2M_CARRIER)) &#123;</span><br><span class=\"line\">        handle_nrf_modem_lib_init_ret();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t在[nRF Connect SDK](<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/index.html\">Welcome to the nRF Connect SDK! — nRF Connect SDK 2.1.2 documentation</a>)官方文档中有丰富的资料，所有不懂的东西都可以在里面搜索，我们搜索<code>lwm2m</code>：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129132733110.png\" alt=\"image-20221129132733110\" style=\"zoom: 50%;\" />\n\n\n\n<p>​\t点进第一个搜索结果：</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129132903784.png\" alt=\"image-20221129132903784\" style=\"zoom: 50%;\" />\n\n<p>​\t根据这个页面的内容我们可以知道，Nordic提供一个叫做Cloud wrapper API的东西，它把各种IoT云的客户端库接口都给封装起来，只暴露出发送、连接、断开之类的常用功能，把每个云端特定的接口给隐藏了。</p>\n<p>​\t那么Cloud wrapper API都封装了哪些云端提供的库呢？往下面翻可以看到，有亚马逊AWS IoT、微软Azure IoT Hub、nRF Cloud以及LwM2M。看到这里我们就知道LwM2M应该是某种云的客户端库。再往下就是介绍技术细节了。如果要详细了解LwM2M，就可以去其它搜索引擎继续搜索了。</p>\n<p>​\t由于我们使用的是nRF Cloud，因此本文不再探究LwM2M的内容。</p>\n<blockquote>\n<p>注意：</p>\n<p>我们查资料时一定要注意资料的适用范围：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129160526320.png\" alt=\"image-20221129160526320\"></p>\n<p>从这个资料的路径可以看出，Cloud wrapper API只是Nordic为了 Asset Tracker v2这个项目开发的一个API，是项目内部的一个实现，并非是NCS中通用的库。</p>\n</blockquote>\n<p>​\t接着往下看可以看到，调用了一个App Event Manager的初始化函数。并且注释告诉我们这个App Event Manager必须初始化成功，否则就无法实现功能，需要重启。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (app_event_manager_init()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Without the Application Event Manager, the application will not work</span></span><br><span class=\"line\"><span class=\"comment\">         * as intended. A reboot is required in an attempt to recover.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;Application Event Manager could not be initialized, rebooting...&quot;</span>);</span><br><span class=\"line\">        k_sleep(K_SECONDS(<span class=\"number\">5</span>));</span><br><span class=\"line\">        sys_reboot(SYS_REBOOT_COLD);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        module_set_state(MODULE_STATE_READY);</span><br><span class=\"line\">        SEND_EVENT(app, APP_EVT_START);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t我们假装自己不知道App Event Manager是什么。我们可以右键跳转到对应的代码：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129134046131.png\" alt=\"image-20221129134046131\"></p>\n<p>​\t在VS Code上方文件地址栏，就可以知道Application Event Manager是Nordic提供的<code>nrf</code>仓库下的一个subsystem。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129134230597.png\" alt=\"image-20221129134230597\"></p>\n<p>​\t既然Application Event Manager是一个模组，那么当然在Kconfig中也是可以搜到它的配置的。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129134432904.png\" alt=\"image-20221129134432904\"></p>\n<p>​\t由此我们可以体会到<code>Zephyr</code>这个配置系统的方便之处：只要是官方提供的模组，不论是nrf、zephyr还是第三方的模组，只要用Kconfig包含这个模组，就可以在本项目的Kconfig菜单中轻松的进行配置。</p>\n<p>​\t当然，在NCS官方文档中进行搜索也是可以的，这里给出链接<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/app_event_manager.html#application-event-manager\">Application Event Manager — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129134707130.png\" alt=\"image-20221129134707130\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t接下来，获取当前线程（main函数）的线程id，然后启动本模组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.thread_id = k_current_get();</span><br><span class=\"line\"></span><br><span class=\"line\">err = module_start(&amp;self);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    LOG_ERR(<span class=\"string\">&quot;Failed starting module, error: %d&quot;</span>, err);</span><br><span class=\"line\">    SEND_ERROR(app, APP_EVT_ERROR, err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t这里，我们不知道<code>self</code>是什么意思，就查看前面的变量定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 消息结构体定义（联合体）：</span></span><br><span class=\"line\"><span class=\"comment\"> * 来自其他模块的事件（Event），会被Application Event Manager包装成</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息（Message）。然后放入消息队列，供主程序app处理。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里可以看到消息的来源就有各种模组，包括云、Ui、sensor等</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">app_msg_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cloud_module_event</span> <span class=\"title\">cloud</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ui_module_event</span> <span class=\"title\">ui</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sensor_module_event</span> <span class=\"title\">sensor</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">data_module_event</span> <span class=\"title\">data</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">util_module_event</span> <span class=\"title\">util</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">modem_module_event</span> <span class=\"title\">modem</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">app_module_event</span> <span class=\"title\">app</span>;</span></span><br><span class=\"line\">    &#125; module;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息队列的定义，这种用宏进行定义的方法是Zephyr提供的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">K_MSGQ_DEFINE(msgq_app, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> app_msg_data), APP_QUEUE_ENTRY_COUNT,</span><br><span class=\"line\">          APP_QUEUE_BYTE_ALIGNMENT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 用于保存app模组信息的数据结构。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module_data</span> <span class=\"title\">self</span> =</span> &#123;</span><br><span class=\"line\">    .name = <span class=\"string\">&quot;app&quot;</span>,</span><br><span class=\"line\">    .msg_q = &amp;msgq_app,</span><br><span class=\"line\">    .supports_shutdown = <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​\t我们就可以知道，这个项目把application（main）也当成是一个模组，和其他官方提供模组的地位是等价的。模组之间通过消息队列进行通信。</p>\n<p>​\t接下来就可以看到，由于前面app模组获取的线程id正是main函数的id，所以app模组直接就在main函数中用while(1)循环来处理其他模组的消息了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从队列中取出消息\t</span></span><br><span class=\"line\">    module_get_next_msg(&amp;self, &amp;msg);</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 主状态机</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_INIT:</span><br><span class=\"line\">            on_state_init(&amp;msg);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_RUNNING:</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (sub_state) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SUB_STATE_ACTIVE_MODE:</span><br><span class=\"line\">                    on_sub_state_active(&amp;msg);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SUB_STATE_PASSIVE_MODE:</span><br><span class=\"line\">                    on_sub_state_passive(&amp;msg);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    LOG_WRN(<span class=\"string\">&quot;Unknown application sub state&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            on_state_running(&amp;msg);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_SHUTDOWN:</span><br><span class=\"line\">            <span class=\"comment\">/* The shutdown state has no transition. */</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            LOG_WRN(<span class=\"string\">&quot;Unknown application state&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    on_all_events(&amp;msg); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t接下来，看到在<code>main</code>文件末尾的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里MODULE的值是main</span></span><br><span class=\"line\">APP_EVENT_LISTENER(MODULE, app_event_handler);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_EARLY(MODULE, cloud_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, app_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, data_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, util_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_FINAL(MODULE, ui_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_FINAL(MODULE, sensor_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_FINAL(MODULE, modem_module_event);</span><br></pre></td></tr></table></figure>\n\n<p>​\t根据前面的学习方法（搜索代码、文档），可以知道这些宏就是Application Event Manager库提供的，可以参考其文档。这些宏的大概作用就是：给一个名为“MODULE”的模组（实际宏定义是main），定义了一个事件接收器，然后订阅了剩下那些模组的事件消息。</p>\n<blockquote>\n<p>Zephyr中有大量的在文件末尾通过宏定义进行配置的方法，它们往往都是描述一些<strong>运行时</strong>的配置。例如，把一个函数当作一个线程进行注册，或者把一个函数当成是初始化函数在开机初始化阶段运行。</p>\n<p>例如<code>src/modules/ui_module.c</code>的最后一行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">SYS_INIT(setup, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);</span><br></pre></td></tr></table></figure>\n\n<p>就是让系统在初始化阶段自动调用<code>setup()</code>这个函数，不需要我们在main的开头显式地调用这个函数。假设我们有非常多模组，这样做就可以简化<code>main()</code>函数的代码，便于模块化的开发。</p>\n<p>初始化等级是<code>APPLICATION</code>，这说明这个函数要在Zephyr操作系统的Kernel初始化完毕之后才运行。</p>\n<p><code>CONFIG_APPLICATION_INIT_PRIORITY</code>是·<code>autoconf.h</code>中的，我们知道可以在Kconfig中配置它。在Kconfig菜单中搜索可以知道，这个配置是Zephyr Kernel的一个配置，是所有application级别的init函数的优先级。</p>\n</blockquote>\n<h3 id=\"3-6-2-云端连接相关模组的代码分析\"><a href=\"#3-6-2-云端连接相关模组的代码分析\" class=\"headerlink\" title=\"3.6.2. 云端连接相关模组的代码分析\"></a>3.6.2. 云端连接相关模组的代码分析</h3><p>​\t在<code>src/modules/cloud_module.c</code>中，文件的最下方，可以看到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">K_THREAD_DEFINE(cloud_module_thread, CONFIG_CLOUD_THREAD_STACK_SIZE,</span><br><span class=\"line\">        module_thread_fn, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        K_LOWEST_APPLICATION_THREAD_PRIO, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里MODULE宏的值是cloud_module</span></span><br><span class=\"line\">APP_EVENT_LISTENER(MODULE, app_event_handler);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, data_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, app_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, modem_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_FIRST(MODULE, cloud_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, gnss_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, debug_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_EARLY(MODULE, util_module_event);</span><br></pre></td></tr></table></figure>\n\n<p>​\t和<code>main.c</code>一样，这里也使用Application Event Manager库的功能，创建了一个event lisener，并且订阅了其他模组的消息。</p>\n<p>​\t并且这里定义了一个线程，<code>cloud_module_thread</code>，线程的函数是<code>module_thread_fn()</code>。</p>\n<p>线程函数内部也是一个状态机：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">module_thread_fn</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        module_get_next_msg(&amp;self, &amp;msg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_LTE_INIT:</span><br><span class=\"line\">            on_state_init(&amp;msg);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_LTE_CONNECTED:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_LTE_DISCONNECTED:</span><br><span class=\"line\">            on_state_lte_disconnected(&amp;msg);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> STATE_SHUTDOWN:</span><br><span class=\"line\">            <span class=\"comment\">/* The shutdown state has no transition. */</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            LOG_ERR(<span class=\"string\">&quot;Unknown Cloud module state.&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t经过代码的分析可知，状态开始时从<code>STATE_LTE_INIT</code>进入到<code>STATE_LTE_DISCONNECTED</code>。在断开状态下，如果收到<code>MODEM_EVT_LTE_CONNECTED</code>的消息，就会把状态变为<code>CONNECTED</code>。</p>\n<p>​\t通过定义的跳转和搜索，可以知道<code>MODEM_EVT_LTE_CONNECTED</code>这条消息是从<code>src/modules/modem_module.c</code>中的模组发出的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/modules/modem_module.c 的末尾定义，也是定义了一个线程和1个lisener.</span></span><br><span class=\"line\">K_THREAD_DEFINE(modem_module_thread, CONFIG_MODEM_THREAD_STACK_SIZE,</span><br><span class=\"line\">        module_thread_fn, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        K_LOWEST_APPLICATION_THREAD_PRIO, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">APP_EVENT_LISTENER(MODULE, app_event_handler);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_EARLY(MODULE, modem_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, app_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE(MODULE, cloud_module_event);</span><br><span class=\"line\">APP_EVENT_SUBSCRIBE_FINAL(MODULE, util_module_event);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t层层搜索下去，可知<code>MODEM_EVT_LTE_CONNECTED</code>是PDN模组的消息，只要PDN模组收到了<code>PDN_EVENT_ACTIVATED</code>事件，就说明9160已经联网。PDN模组相关的文档，可参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/modem/pdn.html#pdn\">PDN — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<p>​\t我们再回到<code>src/modules/cloud_module.c</code>中，进入线程的主状态机，可以看到在LTE已连接的状态下，还有两个子状态<code>SUB_STATE_CLOUD_CONNECTED</code>和<code>SUB_STATE_CLOUD_DISCONNECTED</code>。</p>\n<p>​\t为了了解设备是如何从<strong>未连接到云</strong>变成<strong>已连接到云</strong>的，我们进入未连接状态的回调函数。可以看到，它调用了一个连接到云的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">connect_cloud()；</span><br></pre></td></tr></table></figure>\n\n<p>​\t并且，在LTE未连接状态下的回调函数中，第一次成功连网时，也会调用此函数去连云。说明这正是我们要找的连接云的函数:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">connect_cloud</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    err = cloud_wrap_connect();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;cloud_connect failed, error: %d&quot;</span>, err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">/* Start timer to check connection status after backoff */</span></span><br><span class=\"line\">    k_work_reschedule(&amp;connect_check_work, K_SECONDS(backoff_sec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t其中的<code>cloud_wrap_connect()</code>正是前面搜索过的Cloud Wrapper API。</p>\n<p>​\t此函数在<code>src/cloud/cloud_wrapper.h</code>中声明，但是在以下多个文件中都被定义：</p>\n<ul>\n<li>亚马逊 AWS：<code>src/cloud/aws_iot_integration.c</code></li>\n<li>微软 Azure：<code>src/cloud/azure_iot_hub_integration.c</code></li>\n<li>Nordic nRF Cloud：<code>src/cloud/nrf_cloud_integration.c</code></li>\n<li>LwM2M：<code>lwm2m_integration.c</code></li>\n</ul>\n<p>​\t由于在<code>prj.conf</code>中，对Kconfig进行了覆盖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default cloud transport service</span></span><br><span class=\"line\">CONFIG_NRF_CLOUD_MQTT=y</span><br></pre></td></tr></table></figure>\n\n<p>​\t默认选择了nRF Cloud的客户端库。</p>\n<p>​\t而在<code>src/cloud/cloud_codec/Kconfig</code>中，有如下描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">choice</span><br><span class=\"line\">    prompt &quot;Application cloud codec backend&quot;</span><br><span class=\"line\">    default CLOUD_CODEC_NRF_CLOUD if NRF_CLOUD_MQTT</span><br><span class=\"line\">    default CLOUD_CODEC_AWS_IOT if AWS_IOT</span><br><span class=\"line\">    default CLOUD_CODEC_AZURE_IOT_HUB if AZURE_IOT_HUB</span><br><span class=\"line\">    default CLOUD_CODEC_LWM2M if LWM2M_INTEGRATION</span><br></pre></td></tr></table></figure>\n\n<p>​\t即，只要<code>NRF_CLOUD_MQTT</code>被配置为<code>y</code>，就会自动选择<code>CLOUD_CODEC_NRF_CLOUD</code>作为云端。</p>\n<p>​\t我们从Kconfig的图形界面中也可以确认这点，打开Kconfig图形配置页面。在<code>Asset Tracker V2 -&gt; Application cloud codec -&gt; Application cloud codc backend</code>选项，可以看到默认选择了<code>nRF Cloud</code>作为我们的云端：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129155334071.png\" alt=\"image-20221129155334071\"></p>\n<p>​\t而在<code>src\\cloud\\cloud_codec\\CMakeLists.txt</code>中，有如下描述:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">target_sources_ifdef(CONFIG_CLOUD_CODEC_AWS_IOT app</span><br><span class=\"line\">                     PRIVATE <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/aws_iot/aws_iot_codec.c)</span><br><span class=\"line\"></span><br><span class=\"line\">target_sources_ifdef(CONFIG_CLOUD_CODEC_AZURE_IOT_HUB app</span><br><span class=\"line\">                     PRIVATE <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/azure_iot_hub/azure_iot_hub_codec.c)</span><br><span class=\"line\"></span><br><span class=\"line\">target_sources_ifdef(CONFIG_CLOUD_CODEC_NRF_CLOUD app</span><br><span class=\"line\">                     PRIVATE <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/nrf_cloud/nrf_cloud_codec.c)</span><br><span class=\"line\"></span><br><span class=\"line\">target_sources_ifdef(CONFIG_CLOUD_CODEC_LWM2M app</span><br><span class=\"line\">                     PRIVATE <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lwm2m/lwm2m_codec.c)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看出，由于我们只定义了<code>CLOUD_CODEC_NRF_CLOUD</code>，CMake在编译时就只会包含<code>nrf_cloud_codec.c</code>中的函数。也就是wrapper的具体实现，最终只会使用连接到nRF Cloud的函数。</p>\n<p>​\t回到这个函数，在<code>src/cloud/nrf_cloud_integration.c</code>中，<code>cloud_wrap_connect()</code>调用了真正的连接函数，<code>nrf_cloud_connect()</code>。这是NCS库中的，nRF Cloud提供的客户端库提供的函数。关于这个库的介绍，可以参考：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html#nrf-cloud\">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>\n<p>所有连接、与云端通信的内容都是通过这个库完成的，所有资料都可以在上面链接里找到。而这个库是经过wrapper封装的，app代码实际调用的是wrapper。</p>\n<h3 id=\"3-6-3-数据传输相关代码\"><a href=\"#3-6-3-数据传输相关代码\" class=\"headerlink\" title=\"3.6.3. 数据传输相关代码\"></a>3.6.3. 数据传输相关代码</h3><p>​\t以Data模组为例，根据<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/doc/data_module.html\">Asset Tracker v2官方说明</a>，本例程中的Data模组的作用是从其他模组中搜集数据，并上报给云端。而与云端交互的工作是Cloud模组实现的。</p>\n<p>​\t先看Data模组，在<code>src/modules/data_module.c</code>的末尾，可以看到线程的定义。进入到线程函数<code>module_thread_fn()</code>中，也是有一个状态机：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129171438897.png\" alt=\"image-20221129171438897\"></p>\n<p>​\t在已连接到云的状态下（<code>STATE_CLOUD_CONNECTED</code>），查看对应的状态处理函数。当收到<code>DATA_EVT_DATA_READY</code>消息时，就会准备向云端发送数据：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129171800871.png\" alt=\"image-20221129171800871\"></p>\n<p>​\t我们分析这个<code>data_encode()</code>函数</p>\n<ul>\n<li>先使用<code>cloud_codec_encode_batch_data(...)</code>对所有数据进行json编码。由于不同的云端Json格式肯定不一样，所以这个函数也是Cloud API Wrapper提供的。</li>\n<li><code>data_send(DATA_EVT_DATA_SEND_BATCH, &amp;codec)</code>发送这个json。<strong>但这并不是发送到云端</strong>，而是通过Application Event Manager发送到消息池中，事件类型是<code>DATA_EVT_DATA_SEND_BATCH</code>。</li>\n</ul>\n<p>​\t接下来，通过VS Code左侧搜索<code>DATA_EVT_DATA_SEND_BATCH</code>，看这个消息被哪里接收了。可以知道此消息已经传输到Cloud模组，打开<code>src/modules/cloud_module.c</code>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129172213052.png\" alt=\"image-20221129172213052\"></p>\n<p>​\t这里并没有直接发送到云端，而是调用了一个QoS（Quality of Service）库的函数。我们继续去NCS官方文档搜索<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/others/qos.html#quality-of-service\">Quality of Service</a>。</p>\n<p>根据文档内容，我们知道，NCS的QoS只提供两种服务质量：</p>\n<ul>\n<li><code>ACK_DISABLED</code>：只管发送，不管云端是否已收到</li>\n<li><code>ACK_REQUIRED</code>：需要确保云端收到并回复，若超时未回复，需要重发。</li>\n</ul>\n<blockquote>\n<p>还有一种服务质量是，需要确保对方收到，且仅收到一次。但嵌入式设备往往不能提供这样的QoS，而是要算力更强的云端去做消息去重。</p>\n</blockquote>\n<p>文档中的序列图给出了很详细的示例：</p>\n<img src=\"/jayant97.github.io/imgs/使用nRF9160-DK连接nRF-Cloud示例.assets/image-20221205014940647.png\" alt=\"image-20221205014940647\" style=\"zoom: 33%;\" />\n\n<ol>\n<li>当发送一个数据包需要ACK时，Application调用QoS库的<code>qos_add_message()</code>，将消息记录在一个列表中。</li>\n<li>然后QoS库把一个回调函数放入kernel提供的工作队列（<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/zephyr/kernel/services/threads/workqueue.html#c.k_work_reschedule\">Workqueue</a>）中，并且设定为一个延时的工作。</li>\n<li>接下来，QoS库通知给Application，消息已经记录好了，可以发送了。</li>\n<li>Application接收到QoS库的消息<code>QOS_EVT_MESSAGE_NEW</code>，真正的发送数据。</li>\n<li>根据数据的接收方是否按时回复ACK，有两种不同的行为：<ul>\n<li>若接收方按时回复，则 Application 需要调用<code>qos_message_remove</code>函数，从列表中移除这个消息。然后从工作队列中取消之前注册的函数。</li>\n<li>若接收方超时未回复，则工作队列中的回调函数被调用，QoS库发送消息<code>QOS_EVT_MESSAGE_EXPIRED</code>。Application收到此消息后，执行一次重发。</li>\n</ul>\n</li>\n</ol>\n<p>​\t有了上面关于QoS的知识，我们就知道，只有收到QoS库的<code>QOS_EVT_MESSAGE_NEW</code>消息时，Application才会真正的把数据发送到云端：</p>\n<p>​\t在<code>src/moudles/cloud_module.c</code>中，有一个<code>qos_event_handler()</code>函数：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130113448664.png\" alt=\"image-20221130113448664\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130113827493.png\" alt=\"image-20221130113827493\"></p>\n<p>​\t在初始化时，这个<code>qos_event_handler()</code>函数被注册到QoS库中，让Cloud模组能够处理来自QoS的消息。</p>\n<blockquote>\n<p>注意，QoS库与Cloud模组之间消息的传递，并不是通过Application Event Manager来进行的。而是通过回调函数的方式来进行的。</p>\n</blockquote>\n<p>​\t这里又出现一个新的事件，<code>CLOUD_EVT_DATA_SEND_OQS</code>。搜索这个事件，可以发现这个事件是cloud模组接收的。在状态机中，<code>on_sub_state_cloud_connected()</code>和<code>on_sub_state_cloud_disconnected()</code>这两个函数中都有调用：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130114341395.png\" alt=\"image-20221130114341395\"></p>\n<p>​\t在这里，可以看到最初的Batch数据最终是通过Cloud Wrapper API的<code>cloud_wrapper_batch_send()</code>发送到云端。</p>\n<h3 id=\"3-6-4-例程代码总结\"><a href=\"#3-6-4-例程代码总结\" class=\"headerlink\" title=\"3.6.4. 例程代码总结\"></a>3.6.4. 例程代码总结</h3><ul>\n<li><p>Zephyer风格的代码就是把一切都写成模组，每个模组可以有自己的线程、初始化代码。自己编写的模组之间通过Application Event Manager提供的消息机制进行通信。</p>\n</li>\n<li><p>设备和云端的连接是通过Cloud Wrapper API进行的，由于<code>prj.conf</code>中配置了<code>CONFIG_NRF_CLOUD_MQTT=y</code>，所以Kconfig就选择nRF Cloud Library作为客户端。CMake系统也只编译了与nRF Cloud有关的代码，并把其作为wrapper的内容。</p>\n</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130120212409.png\" alt=\"image-20221130120212409\"></p>\n<ul>\n<li><p>设备到云端的数据发送，经历了QoS库的处理，然后通过内部各种事件消息的传输，最终通过Cloud Wrapper API发送到云端。上图仅展示数据是如何发送出去的，未展示QoS超时校验的部分。</p>\n</li>\n<li><p>要了解更多关于此项目的实现内容，可以参考例程的官方说明，非常详细：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/applications/asset_tracker_v2/README.html\">nRF9160: Asset Tracker v2 — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n</li>\n</ul>\n<div style=”page-break-after: always;”></div>\n\n<h1 id=\"4-nRF-Cloud-API介绍\"><a href=\"#4-nRF-Cloud-API介绍\" class=\"headerlink\" title=\"4. nRF Cloud API介绍\"></a>4. nRF Cloud API介绍</h1><p>nRF Cloud 提供 REST 和 MQTT 两种API。</p>\n<ul>\n<li>REST API 用于<strong>用户到云</strong>、<strong>第三方云到云</strong>的连接；其中少部分API也可被设备调用。</li>\n<li>MQTT API用于<strong>设备和云</strong>的连接</li>\n</ul>\n<h2 id=\"4-1-REST-API\"><a href=\"#4-1-REST-API\" class=\"headerlink\" title=\"4.1. REST API\"></a>4.1. REST API</h2><p>nRF Cloud REST API文档，参考：<a href=\"https://api.nrfcloud.com/v1\">nRF Cloud REST API Documentation</a></p>\n<h3 id=\"REST-API-认证方式\"><a href=\"#REST-API-认证方式\" class=\"headerlink\" title=\"REST API 认证方式\"></a>REST API 认证方式</h3><p>​\t在使用REST API时，用户、设备、nRF Cloud、第三方云端之间的通信都是需要认证的。在通讯的消息中需要一个key，来证明消息发出源是可信的。不同类型的对象之间访问，使用不同类型的key：</p>\n<ul>\n<li><p><strong>用户到设备</strong> 或者<strong>用户到云</strong>的认证：这种访问方式需要<strong>API key</strong>来认证，通常是用来做设备注册、获取设备数据、查看用户账户或使用信息的。在<a href=\"#%EF%BC%885%EF%BC%89%E6%8A%8A%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E5%88%B0%E4%BA%91%E7%AB%AF\">2.5-(5)</a>小节中已经介绍如何从网页端获取这个Key；</p>\n</li>\n<li><p><strong>设备到云</strong>（D2C）的认证：使用<a href=\"https://docs.nrfcloud.com/APIs/REST/RESTIntro/#authentication\">JSON Web Token</a> (<strong>JWT</strong>)，确保安全性。</p>\n</li>\n<li><p><strong>云到云</strong>（C2C）的认证：也使用<strong>JWT</strong>进行认证。用来做像是通过代理服务器进行位置服务的集成的功能。云到云的API调用需要购买专业版（Pro）或者企业版（Enterprise）服务。</p>\n</li>\n</ul>\n<h3 id=\"REST-API-调用示例\"><a href=\"#REST-API-调用示例\" class=\"headerlink\" title=\"REST API 调用示例\"></a>REST API 调用示例</h3><p>​\t本小节将使用电脑模拟一台<strong>设备</strong>，通过REST接口注册设备，并使用JWT的认证方式，调用一个REST API。</p>\n<p>整个过程将会调用三个REST API：</p>\n<ul>\n<li>设备注册（Provision）</li>\n<li>检查设备注册的结果</li>\n<li>获取定位信息</li>\n</ul>\n<p>官方文档可参考：<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<blockquote>\n<p>​\t整个注册过程和[2.5小节](#2.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))的流程是一模一样的。但是本小节中展示的注册过程没有使用python脚本，而是使用最基本的HTTP请求来展示REST API调用的过程。</p>\n</blockquote>\n<p>​\t在<strong>开始之前</strong>，找一个<a href=\"https://www.uuidgenerator.net/\">在线UUID生成器</a>，生成一个UUID。本例生成的是：<code>64520de4-e0a0-45cf-bf56-1f43f80a4f37</code>，这个UUID就代表一台设备。</p>\n<p>​\t对于实际的产品，UUID可以是任何字符串。但是Nordic推荐使用9160出厂自带的UUID，你可以在前面加上一些前缀。</p>\n<blockquote>\n<p>nRF Cloud 全球所有的客户的所有设备，都通过UUID来进行区分。所以防止UUID重复是非常必要的。</p>\n</blockquote>\n<p><strong>（1）生成CA证书和设备证书</strong></p>\n<p>​\t在 <a href=\"#%EF%BC%883%EF%BC%89%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E8%87%AA%E7%AD%BECA%E8%AF%81%E4%B9%A6\">2.5-(3)</a> 小节中，我们已经通过 Nordic 提供的 python 脚本生成了一套 CA证书文件和私钥。这套utils工具中也包含一套TypeScript脚本，和pythone脚本的功能是一样的。你也可以两种都不使用，而只使用OpenSSL进行生成，可参考<a href=\"https://docs.nrfcloud.com/Devices/Security/JWT/\">JWT authentication on nRF Cloud | nRF Cloud Docs</a>。</p>\n<p>​\t后面在<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">2.5-(4)</a>中，我们通过这个<strong>CA证书</strong>给nRF9160签发了<strong>设备证书</strong>，给设备安装了设备独立的私钥。</p>\n<p>​\t现在我们要用电脑模拟一台设备，就需要通过刚刚生成的UUID和<strong>CA证书</strong>，来生成一个<strong>新的设备证书</strong>。</p>\n<p>​\t进入 [2.5-(2)](#（2）获取最新的nRF Cloud Utils工具，并安装好依赖) 中安装utils的文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在终端中进入utils文件夹后，再进行后续操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入python工具文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> python/modem-firmware-1.3+/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成设备证书</span></span><br><span class=\"line\">$ python create_device_credentials.py \\</span><br><span class=\"line\">-ca ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_ca.pem \\</span><br><span class=\"line\">-ca_key ./my_ca/Jayant-0x12de89cb5ee9589433c9ba08e74bc0eebdfe9ab4_prv.pem \\</span><br><span class=\"line\">-c CN \\</span><br><span class=\"line\">-l Shanghai \\</span><br><span class=\"line\">-o <span class=\"string\">&quot;Nordic Semiconductor K.K.&quot;</span> \\</span><br><span class=\"line\">-ou <span class=\"string\">&quot;Sales&quot;</span> \\</span><br><span class=\"line\">-cn 64520de4-e0a0-45cf-bf56-1f43f80a4f37 \\</span><br><span class=\"line\">-e jayant.tang@nordicsemi.no \\</span><br><span class=\"line\">-dv 2000 \\</span><br><span class=\"line\">-p ./dev_credentials \\</span><br><span class=\"line\">-f <span class=\"string\">&quot;Jayant-Device-&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数释义：</p>\n<ul>\n<li><code>-ca</code>：CA证书文件</li>\n<li><code>-ca_key</code>：CA证书密钥文件</li>\n<li><code>-c</code>：2字符国家代码</li>\n<li><code>-st</code>：美国、加拿大的州或省代码</li>\n<li><code>-l</code>：地点</li>\n<li><code>-o</code>：组织</li>\n<li><code>-o</code>u：组织部门</li>\n<li><code>-cn</code>：Common Name。使用nRF CLoud Device ID 或者 MQTT Client ID。这里使用UUID。</li>\n<li><code>-e</code>：e-mail</li>\n<li><code>-dv</code>：证书合法天数</li>\n<li><code>-p</code>：用于生成设备证书的目录</li>\n<li><code>-f</code>：生成的证书文件名前缀</li>\n</ul>\n</blockquote>\n<p><strong>（2）生成设备注册信息表格</strong></p>\n<p>​\t本小节参考 <a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">REST 设备注册API （ProvisionDevices）</a>。</p>\n<p>​\t打开Excel，创建一个新的空表格，并另存为csv格式。</p>\n<img src=\"/jayant97.github.io/imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150045752.png\" alt=\"image-20221124150045752\" style=\"zoom: 80%;\" />\n\n<p>​\t在表格中从左往右填入以下内容：</p>\n<ul>\n<li><p>第一列：设备ID，这里是UUID</p>\n</li>\n<li><p>第二列：设备子类型，可以写温湿度传感器之类的文字，可以留空；</p>\n</li>\n<li><p>第三列：用于设备分类的标签，这里填<a href=\"#%EF%BC%884%EF%BC%89%E7%AD%BE%E5%8F%91%E5%B9%B6%E5%AE%89%E8%A3%85%E8%AE%BE%E5%A4%87%E8%AF%81%E4%B9%A6\">3.5-(4)</a>中nRF9160一样的tag名称就行，也可以留空</p>\n</li>\n<li><p>第四列：固件类型，可以和9160例程填一样的，也可以留空</p>\n</li>\n<li><p>第五列：设备证书。从上一小节的设备证书中，把<code>xxxx_crt.pem</code>中的内容拷贝进去即可</p>\n<p>（注意，excel单元格类型要设置成“文本”，否则可能把等号、加号识别为公式）</p>\n</li>\n</ul>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124150540606.png\" alt=\"image-20221124150540606\"></p>\n<p>​\t保存csv表格，此处给出我的csv文件内容，方便对比格式是否正确：</p>\n<p><code>fake-device.csv</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">64520de4-e0a0-45cf-bf56-1f43f80a4f37,fake-device,jayant-DK,APP|MODEM,&quot;-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">MIICPTCCAeICFHx8JF+NRorZfBQF0sr+jzKSmg9gMAoGCCqGSM49BAMCMIGSMQsw</span><br><span class=\"line\">CQYDVQQGEwJDTjERMA8GA1UEBwwIU2hhbmdoYWkxIjAgBgNVBAoMGU5vcmRpYyBT</span><br><span class=\"line\">ZW1pY29uZHVjdG9yIEsuSy4xDjAMBgNVBAsMBVNhbGVzMRIwEAYDVQQDDAlub3Jk</span><br><span class=\"line\">aWMuY24xKDAmBgkqhkiG9w0BCQEWGWpheWFudC50YW5nQG5vcmRpY3NlbWkubm8w</span><br><span class=\"line\">HhcNMjIxMTI0MDY1MjEwWhcNMjgwNTE2MDY1MjEwWjCBrTELMAkGA1UEBhMCQ04x</span><br><span class=\"line\">ETAPBgNVBAcMCFNoYW5naGFpMSIwIAYDVQQKDBlOb3JkaWMgU2VtaWNvbmR1Y3Rv</span><br><span class=\"line\">ciBLLksuMQ4wDAYDVQQLDAVTYWxlczEtMCsGA1UEAwwkNjQ1MjBkZTQtZTBhMC00</span><br><span class=\"line\">NWNmLWJmNTYtMWY0M2Y4MGE0ZjM3MSgwJgYJKoZIhvcNAQkBFhlqYXlhbnQudGFu</span><br><span class=\"line\">Z0Bub3JkaWNzZW1pLm5vMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6OIeO6C0</span><br><span class=\"line\">/kJzfaWUHt/Xg4J6bdAphzmX5sCLGV+oEeSi1sUQKpBLugda2OwG9FxOCikg8ih7</span><br><span class=\"line\">CvMm7C98+fr+nTAKBggqhkjOPQQDAgNJADBGAiEAuCdq6D1K329hwU9e+4S5//2b</span><br><span class=\"line\">upwtaqT+j6Mckpmj6XUCIQCaAqjWRMXMiOd/pXRkcf7SjKyZifBnxoepRqbNyKUG</span><br><span class=\"line\">OA==</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br><span class=\"line\">&quot;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，逗号用于区分每一列，回车用于区分每一行，双引号中的内容为字符串（引号中的回车不算作换行）。</p>\n</blockquote>\n<p><strong>（3）利用REST接口注册设备</strong></p>\n<p>​\t使用<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>接口。这属于<strong>用户到云</strong>的接口调用，需要使用<strong>API key</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 向nRF Cloud发送请求，注册设备。</span></span><br><span class=\"line\">$  curl --request POST --url https://api.nrfcloud.com/v1/devices \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbd9f3cxxxxxxxxxxfa73cf37049983&#x27;</span> \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;content-type: text/csv&#x27;</span> \\</span><br><span class=\"line\">--data-binary @./fake-device.csv</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>把API Key改成你自己的API Key</li>\n<li>用curl发送csv文件时，必须使用二进制流。否则curl可能会丢掉文件末尾的换行符。也可以不用curl，而是通过Postman软件来进行API的调用测试。</li>\n</ul>\n</blockquote>\n<p>​\t云端返回结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;bulkOpsRequestId&quot;:&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t假如这是一次真实的批量注册，这个bulkOpsRequestId需要记录下来，用于调用<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a> API。这个API的作用是用来检查自己批量注册的进度。但是本次是一次模拟，只注册了一个设备，所以不用关心。</p>\n<blockquote>\n<p>FetchBulkOpsRequest使用方法：</p>\n<p>url的最后是上面获取的bulkOpsRequestId</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/bulk-ops-requests/01GK0NECJPXVNDNKVA4XE98HDE \\</span><br><span class=\"line\">-H <span class=\"string\">&quot;Authorization: Bearer 3c967ecbd9fxxxxxxxxxxxxxx3cf37049983&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bulkOpsRequestId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;01GK0NECJPXVNDNKVA4XE98HDE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;status&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;SUCCEEDED&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;endpoint&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;PROVISION_DEVICES&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;requestedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:48.054Z&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 这个时间应该是GMT+1的时间</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;completedAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:51.365Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;uploadedDataUrl&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;https://bulk-ops-requests.nrfcloud.com/a9d25242-adad-479e-b526-xxxxxxxxxxxx/provision_devices/01GK0NECJPXVNDNKVA4XE98HDE.csv&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​\t利用<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>接口来获取新注册的这个设备的信息，其中<code>&#123;device-id&#125;</code>要换成UUID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">--url https://api.nrfcloud.com/v1/devices/&#123;device-id&#125; \\</span><br><span class=\"line\">--header <span class=\"string\">&#x27;Authorization: Bearer 3c967ecbxxxxxxxxxxxxe81cfa73cf37049983&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t返回结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tags&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"string\">&quot;jayant-DK&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tenantId&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;a9d25242-adad-479e-b526-xxxxxxxxxxx&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$meta&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;createdAt&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2022-11-29T03:03:53.127Z&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;64520de4-e0a0-45cf-bf56-1f43f80a4f37&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Generic&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;subType&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;fake-device&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;firmware&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;supports&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;APP&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;MODEM&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;paired&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/d2c&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;prod/a9d25242-adad-479e-b526-777082c5b7c5/m/d/64520de4-e0a0-45cf-bf56-1f43f80a4f37/+/r&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;metadata&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;desired&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;nrfcloud_mqtt_topic_prefix&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;pairing&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;topics&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;d2c&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                        <span class=\"attr\">&quot;c2d&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                            <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span><span class=\"number\">1669691031</span></span><br><span class=\"line\">                        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t可以看到里面包含设备的信息，除了之前自己在CSV表格中填写的信息外，还包括MQTT的topic、时间戳等信息。</p>\n<p>​\t设备注册成功后，在网页端也已经可以看到这个虚拟的设备：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221124154802151.png\" alt=\"image-20221124154802151\"></p>\n<p><strong>（4）生成JWT</strong></p>\n<p><strong>设备到云</strong>（D2C）的API调用需要JWT认证，我们先生成一个JWT：</p>\n<p>打开<a href=\"https://jwt.io/\"> jwt.io</a>，上方选择ES256签名算法，然后PAYLOAD中填入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;sub&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;你的UUID&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下方公钥、私钥区域粘贴上一小节中生成的设备证书的公钥（pub.pem）和私钥（\\prv.pem）的内容。</p>\n<p>（注意，不是CA证书，而是设备证书）</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114051110.png\" alt=\"image-20221129114051110\"></p>\n<p>左下角显示”Signature Verified”，则说明公钥与私钥是成对的。可以把左侧编码好的JWT复制出来，这就是设备与云端通信所需要的 Token：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJFUzI1Nixxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxx78F5NXw</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>（5）测试一个设备API接口</strong></p>\n<p>​\t我们利用<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>来测试接口，在官方API文档页面，我们可以看到：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130102929376.png\" alt=\"image-20221130102929376\"></p>\n<ul>\n<li>展示了URL、参数</li>\n<li>有两种请求方式，Basci Request和 Cuscom Request，后者需要携带更多参数</li>\n<li>提供了<code>curl</code>命令示例，如何携带参数</li>\n<li>展示了认证方式，有 API Key 和 JWT两种，展开有详细说明</li>\n</ul>\n<p>​\t下方是一个Custom Request的调用示例，与API文档中的例子不同，没有使用<code>-d</code>选项，这里是直接把参数写在了URL中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl --request GET \\</span><br><span class=\"line\">  --url <span class=\"string\">&#x27;https://api.nrfcloud.com/v1/location/agps?requestType=custom&amp;customTypes=1%2C3%2C4%2C6%2C7%2C8%2C9&amp;mcc=310&amp;mnc=410&amp;tac=36874&amp;eci=84485647&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Accept: application/octet-stream&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;Authorization: Bearer eyJhbGciOiJFUzI1Nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxm6Hx78F5NXw&#x27;</span> \\</span><br><span class=\"line\">  --header <span class=\"string\">&#x27;range: bytes=0-500&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t请求已经成功返回，但是返回的数据是二进制内容，curl提示我们它不会展示二进制内容，以免打乱终端文字。</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114408304.png\" alt=\"image-20221129114408304\"></p>\n<p>​\t也可以用Postman软件进行测试，结果是一样的，返回206，说明数据请求成功：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221129114544096.png\" alt=\"image-20221129114544096\"></p>\n<p><strong>（6）总结：</strong></p>\n<p>​\t本小节展示了<a href=\"https://api.nrfcloud.com/v1/#tag/IP-Devices/operation/ProvisionDevices\">ProvisionDevices</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/FetchBulkOpsRequest\">FetchBulkOpsRequest</a>，<a href=\"https://api.nrfcloud.com/v1/#tag/All-Devices/operation/FetchDevice\">FetchDevice</a>，<a href=\"https://api.nrfcloud.com/v1/#operation/GetAssistanceData\">GetAssistanceData</a>这5个REST接口的调用。大多数接口都是云到云的，需要用户的APP key来进行认证。最后一个接口展示了设备到云的REST接口调用，需要使用JWT来进行认证。</p>\n<h2 id=\"4-2-MQTT-API\"><a href=\"#4-2-MQTT-API\" class=\"headerlink\" title=\"4.2. MQTT API\"></a>4.2. MQTT API</h2><p>​\tnRF Cloud是部署在亚马逊AWS上的，并且使用<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/iot-gs.html\">AWS IoT Core</a>的MQTT broker。</p>\n<p>MQTT API的通信，只要订阅topic即可。这里需要有2个topic，<code>d2c</code>和<code>c2d</code>。</p>\n<ul>\n<li><code>d2c</code>：设备发布，云端订阅</li>\n<li><code>c2d</code>：云端发布，设备订阅</li>\n</ul>\n<p>​\t只要每个设备能获得这两个topic，就能与云端进行通信。这个topic可以通过REST API获得，下一小节会介绍。但是实际开发应用的时候，并不需要关心，因为nRF Cloud Library已经帮我们封装好了，我们只需调用<code>connect()</code>，<code>send()</code>之类的就好了。</p>\n<h3 id=\"MQTT-topic前缀的获取\"><a href=\"#MQTT-topic前缀的获取\" class=\"headerlink\" title=\"MQTT topic前缀的获取\"></a>MQTT topic前缀的获取</h3><p>​\t用户可以通过REST API获取topic前缀，接口是 <a href=\"https://api.nrfcloud.com/v1/#operation/FetchAccountInfo\">FetchAccountInfo</a>。需要使用用户的API Key进行认证。接口会返回很多数据，其中就包含：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttEndpoint&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;mqtt.nrfcloud.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mqttTopicPrefix&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;prod/a5592ec1-18ae-4d9d-bc44-xxxxxxxxx/&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t不用REST API，也可以在网页端获取。点击右上角下拉菜单-Teams：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E4%BD%BF%E7%94%A8nRF9160-DK%E8%BF%9E%E6%8E%A5nRF-Cloud%E7%A4%BA%E4%BE%8B.assets/image-20221130132356346.png\" alt=\"image-20221130132356346\"></p>\n<p>​\t可以看到Team的信息，其中就有team id。<code>mqttTopicPrefix</code>就是<code>prod/&lt;team_id&gt;</code>。</p>\n<h3 id=\"云端的认证\"><a href=\"#云端的认证\" class=\"headerlink\" title=\"云端的认证\"></a>云端的认证</h3><p>​\t所有到AWS IoT MQTT broker的连接都必须使用在8883端口上进行的Mutual TLS。所有用MQTT的设备都必须有一个<a href=\"https://docs.nrfcloud.com/Devices/Security/Security/#authentication\">X.509 device certificate</a>，并且已经<strong>注册到云端（Provisioned）</strong>。这正是我们在[3.5](#3.5. 将设备注册到nRF Cloud云端 (Cloud Provisioning))和[6.1](#REST API 调用示例 )中已经介绍过的部分。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>​\tnRF Cloud部署在AWS上，除了<a href=\"https://docs.aws.amazon.com/iot/latest/developerguide/reserved-topics.html\">AWS保留的topic</a>外，还有一些是nRF Cloud自定义的。官方文档请参考：</p>\n<p><a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/\">nRF Cloud MQTT topics | nRF Cloud Docs</a></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>​\t有关nRF Cloud Library底层的细节，官方文档为 <a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/libraries/networking/nrf_cloud.html\">nRF Cloud — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a>。</p>\n<p>​\t在[3.5.3](#3.5.3. 数据传输相关代码)中，我们知道9160是通过Cloud Wrapper API包装了nRF Cloud Library相关的接口进行的。其中发送到云端就是<code>cloud_wrap_batch_send()</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">cloud_wrap_batch_send</span><span class=\"params\">(<span class=\"type\">char</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">bool</span> ack, <span class=\"type\">uint32_t</span> id)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> err;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nrf_cloud_tx_data</span> <span class=\"title\">msg</span> =</span> &#123;</span><br><span class=\"line\">        .data.ptr = buf,</span><br><span class=\"line\">        .data.len = len,</span><br><span class=\"line\">        .id = id,</span><br><span class=\"line\">        .qos = ack ? MQTT_QOS_1_AT_LEAST_ONCE : MQTT_QOS_0_AT_MOST_ONCE,</span><br><span class=\"line\">        .topic_type = NRF_CLOUD_TOPIC_BULK,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = nrf_cloud_send(&amp;msg);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        LOG_ERR(<span class=\"string\">&quot;nrf_cloud_send, error: %d&quot;</span>, err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t这里面，准备好要发送的数据<code>msg</code>即可，数据类型是<code>nrf_cloud_tx_data_msg</code>。Topic是<code>NRF_CLOUD_TOPIC_BULK</code>。</p>\n<p>​\t这恰好就是<a href=\"https://docs.nrfcloud.com/APIs/MQTT/Topics/#message-topics\">官方MQTT API手册</a>中的topic，作用是发送一组bulk数据。只要仿照wrapper中的格式，就可以写出自己的发送函数。</p>\n","categories":["Nordic","LTE"],"tags":["Nordic","nRF91","nRF_Cloud"]},{"title":"安装nRF-Connect-SDK","url":"/jayant97.github.io/2022/12/779143a4bec8/","content":"<p>​\tnRF Connect SDK，简称NCS，是Nordic最新的SDK平台，该平台将支持Nordic所有产品线，包括低功耗蓝牙，蜂窝网，WiFi，GPS，2.4G，蓝牙Mesh，Zigbee，Thread，Matter, Homekit, FindMy等。</p>\n<p>​\tNCS 内嵌Zephyr RTOS，并沿用了Zephyr project的编译系统。利用Device Tree和Kconfig进行项目的硬件、软件配置。使用CMake和大量Python脚本辅助生成一些头文件、代码和Hex。一旦上手，开发调试起来非常方便，并且是跨平台的（Windows&#x2F;Linux&#x2F;OSX）。</p>\n<p>​\tNCS在Github上托管，包含多个仓库。其主仓库（Manifest）是nrf（含Nordic产品驱动与各类无线协议栈等），此外还有Zephyr、MCUBoot、mbedtls、nrfxlib等其他仓库。</p>\n<p>​\t更多信息可参考：</p>\n<ul>\n<li><p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/introduction.html\">About the nRF Connect SDK — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n</li>\n</ul>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>​\t本节将会详细介绍如何在一台<strong>Windows</strong> 11的电脑上安装NCS开发环境（Windows 10也适用），包含NCS、编译器以及其他工具。<em>如果你已经安装好NCS开发环境，可以跳过本节</em>。</p>\n<p>​\t完整的中文教程，也可参考这篇文章：<a href=\"https://www.cnblogs.com/iini/p/14174427.html\">开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序 - iini - 博客园 (cnblogs.com)</a></p>\n<p>​\t也可参考官方安装教程：<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html\">Getting started — nRF Connect SDK 2.1.2 documentation (nordicsemi.com)</a></p>\n<p>​\t需要安装的内容列表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">软件</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></td>\n<td>代码文本编辑器，并且通过安装插件的方式为其他开发调试工具提供可视化界面</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-command-line-tools\">nRF Command Line Tools</a></td>\n<td>Jlink驱动、nrfjprog等命令行工具和DLL</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://www.nordicsemi.com/Products/Development-tools/nrf-connect-for-desktop\">nRF Connect for Desktop</a></td>\n<td>桌面工具集合，含SDK安装器、功耗评估、射频抓包等工具</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><a href=\"https://git-scm.com/\">Git</a></td>\n<td>版本管理工具</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><a href=\"https://www.python.org/downloads/release/python-3913/\">Python 3.9</a></td>\n<td>为编译套件的python脚本提供运行环境</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\"><a href=\"https://ninja-build.org/\">Ninja</a></td>\n<td>快速构建工具（类似make）</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\"><a href=\"https://cmake.org/\">CMake</a></td>\n<td>根据配置生成.ninja或Makefile文件的工具</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\"><a href=\"https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html\">Zephyr SDK</a></td>\n<td>交叉编译工具链（编译器、链接器等）</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\"><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/nrf/getting_started.html\">NCS 2.1.2</a></td>\n<td>含nRF产品驱动包、内核、第三方库等代码和编译配置文件等</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\">VS Code: nRF Connect插件包</td>\n<td>在VS Code中为NCS功能提供可视化</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-下载安装包并进行安装\"><a href=\"#2-下载安装包并进行安装\" class=\"headerlink\" title=\"2. 下载安装包并进行安装\"></a>2. 下载安装包并进行安装</h1><p>​\t上述列表中1~3号软件都是使用<strong>安装包</strong>的形式进行安装，点击表格中的链接进入官网，下载安装后可以直接双击安装。安装路径需要无中文、空格或“-”，“_”以外的特殊字符。</p>\n<p>​\tVS Code的安装，这里不做介绍，大家都懂。剩余的两个Nordic的工具，安装方式是类似的。下图仅示例nRF Connect for Desktop的下载方式：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122214235111.png\" alt=\"image-20221122214235111\"></p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122213145436.png\" alt=\"image-20221122213145436\" style=\"zoom: 67%;\" />\n\n<center>“开始”菜单中安装好的工具（未完全展示）</center>\n\n<h1 id=\"3-安装SDK和工具链\"><a href=\"#3-安装SDK和工具链\" class=\"headerlink\" title=\"3. 安装SDK和工具链\"></a>3. 安装SDK和工具链</h1><h2 id=\"3-1-自动安装与手动安装的区别\"><a href=\"#3-1-自动安装与手动安装的区别\" class=\"headerlink\" title=\"3.1. 自动安装与手动安装的区别\"></a>3.1. 自动安装与手动安装的区别</h2><p>​\t列表中4~10号软件有2种安装方式，<strong>自动安装</strong>和<strong>手动安装</strong>。</p>\n<p>​\t自动安装是通过刚才已经装好的<strong>3号</strong>软件 nRF Connect for Desktop 中的工具安装的，这种安装方式会从GitHub拉取NCS仓库的一个特定版本（如v2.1.2），然后会把列表中剩余的软件工具（4~8号）放在toolchains文件夹下，与NCS的目录为并列关系。</p>\n<p>​\t自动安装可以同时安装多个版本的NCS，并在同一个toolchains文件夹下安装对应版本适合的工具，如下图：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122214853721.png\" alt=\"image-20221122214853721\" style=\"zoom:67%;\" />\n\n<center>toolchains下仍有两个NCS单独的工具链</center>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 目录结构如下</span><br><span class=\"line\">.</span><br><span class=\"line\">|-- v2.1.0</span><br><span class=\"line\">|-- v2.1.2</span><br><span class=\"line\">`-- toolchains</span><br><span class=\"line\">    |-- v2.1.0</span><br><span class=\"line\">    `-- v2.1.2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\tNCS大约有2.7GB，而toolchains大约有1.1GB。由于是从GitHub拉取，在国内如果没有网络代理基本很难下载成功，或者下载很慢。</p>\n<blockquote>\n<p>自动安装与手动安装的其他区别：</p>\n<p>​\t自动安装的工具不会添加到Windows全局的<code>PATH</code>环境变量中，因此打开VS Code后需要在nRF Connect插件的设置中选择工具链的路径。并且，随便打开一个终端（Cmd&#x2F;Powershell&#x2F;Git bash）是无法使用toolchains中的工具的。</p>\n</blockquote>\n<blockquote>\n<p>注：全部安装完毕后，可以重启电脑，以应用新的环境变量</p>\n</blockquote>\n<h2 id=\"3-1-自动安装\"><a href=\"#3-1-自动安装\" class=\"headerlink\" title=\"3.1. 自动安装\"></a>3.1. 自动安装</h2><p>​\t打开nRF Connect for Desktop软件，找到<strong>Toolchain Manager</strong>（Toolchain Manager适合Windows和OSX，而Linux适合使用Getting Started Assistant），Install然后Open。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122214549553.png\" alt=\"image-20221122214549553\" style=\"zoom: 50%;\" />\n\n\n\n<p>​\t打开后，先在SETTINGS中选择自己想要存放NCS和toolchains的位置：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122215033170.png\" alt=\"image-20221122215033170\" style=\"zoom: 50%;\" />\n\n\n\n<p>​\t然后，在SDK ENVIRONMENTS中选择想安装的SDK版本进行安装（如①）。<strong>安装过程根据网络状况不同，可能很久，也可能会失败</strong>。安装完毕后，可打开VS Code（如②）。也可以在对应目录下打开终端（如③④）。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122215310523.png\" alt=\"image-20221122215310523\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>注1：</p>\n<p>​\t由于自动安装没有设置全局的<code>PATH</code>环境变量，所以只有从这Toolchain Manager中打开的命令行终端才有环境变量。</p>\n</blockquote>\n<blockquote>\n<p>注2：</p>\n<p>​\t自动安装NCS时，很有可能底层的<code>west update</code>命令会失败，这会导致缺少源文件，后面编译会失败。但是目前这个桌面程序不会给任何失败提示。</p>\n<p>​\t如果出现缺文件的情况，就要从这里打开终端，执行<code>west update</code>进行下载。如果报错，就重复执行，因为往往是国内的墙导致下载失败。重复执行，每次都能下载一点点，文件是可以累积的。</p>\n</blockquote>\n<p>​\t点击“打开VS Code”，它会弹窗提示，帮你自动安装VS Code的nRF Connect插件包，如下图：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221123161445490.png\" alt=\"image-20221123161445490\" style=\"zoom: 50%;\" />\n\n\n\n\n\n<h2 id=\"3-2-手动安装方式\"><a href=\"#3-2-手动安装方式\" class=\"headerlink\" title=\"3.2. 手动安装方式\"></a>3.2. 手动安装方式</h2><p>安装过程需要网络代理（注意，命令行终端也需要被代理）</p>\n<h3 id=\"（1）安装choco\"><a href=\"#（1）安装choco\" class=\"headerlink\" title=\"（1）安装choco\"></a>（1）安装choco</h3><p>​\t<code>choco</code>是一个包管理工具，类似于Ubuntu中的<code>apt-get</code>，可以通过命令行安装软件工具，<strong>并自动添加到全局PATH环境变量中</strong>。</p>\n<p>​\t首先右键单击开始菜单，然后打开管理员终端，输入以下命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置脚本执行权限</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">Set-ExecutionPolicy</span> AllSigned</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从网络端执行安装脚本</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">Set-ExecutionPolicy</span> Bypass <span class=\"literal\">-Scope</span> <span class=\"keyword\">Process</span> <span class=\"literal\">-Force</span>; [<span class=\"type\">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class=\"type\">System.Net.ServicePointManager</span>]::SecurityProtocol <span class=\"operator\">-bor</span> <span class=\"number\">3072</span>; <span class=\"built_in\">iex</span> ((<span class=\"built_in\">New-Object</span> System.Net.WebClient).DownloadString(<span class=\"string\">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>测试是否安装成功：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; choco</span><br><span class=\"line\"><span class=\"comment\"># 有版本号输出即为成功</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"（2）利用choco安装其他工具\"><a href=\"#（2）利用choco安装其他工具\" class=\"headerlink\" title=\"（2）利用choco安装其他工具\"></a>（2）利用choco安装其他工具</h3><p>部分工具也可自己去官网下载，并用安装包安装，<strong>注意安装时要勾选“添加到PATH环境变量”</strong>。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置choco</span></span><br><span class=\"line\">&gt; choco feature enable <span class=\"literal\">-n</span> allowGlobalConfirmation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装cmake (也可以把这步替换成从官网下载cmake安装包，注意安装时要勾选添加进PATH环境变量)</span></span><br><span class=\"line\">&gt; choco install cmake <span class=\"literal\">--installargs</span> <span class=\"string\">&#x27;ADD_CMAKE_TO_PATH=System&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装git (也可以把这步替换成从官网下载git安装包，注意安装时要勾选添加到环境变量)</span></span><br><span class=\"line\">&gt; choco install git </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装python (建议把这步换成从官网下载python3.9安装包，并勾选添加到环境变量,通过choco安装容易出错)</span></span><br><span class=\"line\">&gt; choco install python <span class=\"literal\">--version</span>=<span class=\"number\">3.9</span>.<span class=\"number\">13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装其他工具</span></span><br><span class=\"line\">&gt; choco install ninja gperf dtc<span class=\"literal\">-msys2</span> <span class=\"built_in\">wget</span> unzip</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>建议从官网用安装包安装Git，同时勾选安装Git bash。可以让你在windows上使用bash终端，而不是powershell。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221204224509512.png\" alt=\"image-20221204224509512\" style=\"zoom: 50%;\" />\n</blockquote>\n<h3 id=\"（3）安装GN工具（可选）\"><a href=\"#（3）安装GN工具（可选）\" class=\"headerlink\" title=\"（3）安装GN工具（可选）\"></a>（3）安装GN工具（可选）</h3><p>​\tGN工具是开发<a href=\"https://www.nordicsemi.com/Products/Matter\">Matter</a>所需的工具。</p>\n<p>​\t从<a href=\"https://gn.googlesource.com/gn/#getting-a-binary\">GN网站</a>下载编译好的Windows压缩包（Getting a binary），推荐在用户目录（<code>C:\\Users\\&lt;用户名&gt;</code>）下解压。并且添加到PATH环境变量即可。</p>\n<blockquote>\n<p>如果你的Windows用户名是中文，那还是换个无中文的地方吧。</p>\n</blockquote>\n<h3 id=\"（4）安装west\"><a href=\"#（4）安装west\" class=\"headerlink\" title=\"（4）安装west\"></a>（4）安装west</h3><p>​\twest是一个多仓库管理工具（类似Android的repo），支持添加自定义插件。在NCS中，除了可以管理NCS仓库外，也通过插件实现了板卡选择、触发编译动作、触发flash烧写的功能。</p>\n<p>利用Python的pip进行安装</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;  pip3 install west</span><br><span class=\"line\"><span class=\"comment\"># 若python版本不对，这一步可能会报错</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（5）安装NCS\"><a href=\"#（5）安装NCS\" class=\"headerlink\" title=\"（5）安装NCS\"></a>（5）安装NCS</h3><p>nRF Connect SDK前面已经介绍过，含驱动、内核以及第三方库的源码。</p>\n<ol>\n<li>在一个无中文、无空格的合适路径下打开终端（powershell或bash）：</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">#创建并进入文件夹</span></span><br><span class=\"line\">&gt; mkdir ncs</span><br><span class=\"line\">&gt; <span class=\"built_in\">cd</span> ncs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化仓库（从github拉取）</span></span><br><span class=\"line\">&gt; west init <span class=\"literal\">-m</span> https://github.com/nrfconnect/sdk<span class=\"literal\">-nrf</span> <span class=\"literal\">--mr</span> v2.<span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"comment\"># 也可选择其他版本，如：</span></span><br><span class=\"line\"><span class=\"comment\"># west init -m https://github.com/nrfconnect/sdk-nrf --mr main</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>备注：</p>\n<ul>\n<li>这一步如果下载失败想重新下载，<strong>需要把创建的ncs文件夹下的所有内容删除干净</strong>，尤其是<code>.west</code>隐藏文件夹。然后再次执行<code>west init</code>即可；</li>\n<li>如果网络实在差，可以从百度网盘下载，见<a href=\"https://www.cnblogs.com/iini/p/14174427.html\">《开发你的第一个nRF Connect SDK(NCS)&#x2F;Zephyr应用程序》 - iini - 博客园 (cnblogs.com)</a></li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>更新仓库</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#更新仓库</span></span><br><span class=\"line\">&gt; west update</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​\t由于国内网络原因，这一步也<strong>经常</strong>失败，但是没关系，每次<code>west update</code>都能下载一点点，如果失败了，就重复<code>west update</code>就行了。不需要像<code>west init</code>失败一样删除干净重新下载。</p>\n</blockquote>\n<ol start=\"3\">\n<li>导出Zephyr CMake package，便于CMake自动识别Zephyr的模板，后续生成工程</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; west zephyr<span class=\"literal\">-export</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"4\">\n<li>安装额外的python依赖</li>\n</ol>\n<blockquote>\n<p>​\t安装python依赖之前，还需要安装”Microsoft Visual C++ Build Tools 14.0”或更高版本：<a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\">Microsoft C++ Build Tools - Visual Studio</a>，用来编译这些python工具。在上述微软链接下载，会获得一个VS安装工具。只在Workloads栏里选择 **”Desktop Development with C++”**，然后安装即可。</p>\n</blockquote>\n<p>​\t安装python依赖包：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; pip3 install <span class=\"literal\">-r</span> zephyr/scripts/requirements.txt</span><br><span class=\"line\">&gt; pip3 install <span class=\"literal\">-r</span> nrf/scripts/requirements.txt</span><br><span class=\"line\">&gt; pip3 install <span class=\"literal\">-r</span> bootloader/mcuboot/scripts/requirements.txt</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"5\">\n<li><p>切换到任意的正式版本</p>\n<blockquote>\n<p>​    NCS利用west管理多个git仓库（nrf, zephyr等），其中nrf是主仓库（Manifest）。主仓库的版本即代表整个west仓库（也就是SDK）的版本。</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看nfr仓库下有多少版本</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">cd</span> nrf</span><br><span class=\"line\">&gt; git tag  <span class=\"comment\"># 按键盘上下键翻阅，按q退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检出想要的版本</span></span><br><span class=\"line\">&gt; git checkout v2.<span class=\"number\">1.2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新整个仓库</span></span><br><span class=\"line\">&gt; west update</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"（6）安装Zephyr-SDK工具链\"><a href=\"#（6）安装Zephyr-SDK工具链\" class=\"headerlink\" title=\"（6）安装Zephyr SDK工具链\"></a>（6）安装Zephyr SDK工具链</h3><p>​\tZephyr SDK是编译器、链接器等工具。建议放在用户目录下（同样的，如果你的用户名是中文，还是换个目录吧）。</p>\n<p>​\t下方展示了通过Poweshell命令下载Zephyr SDK的方式。其中Zephyr工具链的版本是我安装时使用的版本。你需要获取最新的版本，最新版本的下载地址可从 <a href=\"https://docs.zephyrproject.org/3.2.0/develop/toolchains/zephyr_sdk.html#install-zephyr-sdk-on-windows\">Zephyr SDK — Zephyr Project Documentation</a> 获取。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入到用户目录（c:\\Users\\[用户名]）</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">cd</span> <span class=\"variable\">$HOME</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是你的终端是bash而非powershell，则命令为</span></span><br><span class=\"line\"><span class=\"comment\"># cd ~</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载（最新版本的下载地址可从官网链接获取）</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">wget</span> https://github.com/zephyrproject<span class=\"literal\">-rtos</span>/sdk<span class=\"literal\">-ng</span>/releases/download/v0.<span class=\"number\">15.1</span>/zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span>_windows<span class=\"literal\">-x86_64</span>.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">&gt; unzip zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span>_windows<span class=\"literal\">-x86_64</span>.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置</span></span><br><span class=\"line\">&gt; <span class=\"built_in\">cd</span> zephyr<span class=\"literal\">-sdk-0</span>.<span class=\"number\">15.1</span></span><br><span class=\"line\">setup.cmd</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li><code>setup.cmd</code>只需执行一次。如果改变了安装位置，需要再次执行。</li>\n<li>Zephyr SDK安装完成后，会发现：如果在前面安装了ncs的目录下执行<code>west --help</code>会比其他目录下执行<code>west --help</code>多出一些扩展指令，如<code>build</code>,<code>board</code>等等。这是因为NCS中的<code>.west</code>文件夹的配置了Zephyer的base路径，提供了这个仓库独有的插件。这些扩展的指令就是调用了插件进行编译、调试、烧写等工作。<br>为了让其他目录下也能使用Zephyr工具，需要设置全局环境变量：<br><strong>在Windows环境变量中新建<code>ZEPHYR_BASE</code>环境变量，并把其值设置为<code>ncs</code>安装目录下的<code>zephyr</code>目录的路径即可。</strong></li>\n</ul>\n<p>（这个效果和执行一次<code>ncs</code>目录下的<code>zephyr/zephyr-env.cmd</code>脚本是一样的，但这个脚本设置环境变量只是临时生效，关闭终端再另开一个终端就不起作用了。而设置全局环境变量是永久生效。）</p>\n</blockquote>\n<h3 id=\"（7）安装VS-Code插件\"><a href=\"#（7）安装VS-Code插件\" class=\"headerlink\" title=\"（7）安装VS Code插件\"></a>（7）安装VS Code插件</h3><p>​\t打开VS Code，在插件中心搜索nRF Connect for VS Code Extension Pack，这个插件包会自动安装其他nRF Connect 所需的VS Code插件。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122220619736.png\" alt=\"image-20221122220619736\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t可以在VS Code的设置中，对插件进行单独的设置，例如可以设置使用工具链的路径。可以对<strong>全局</strong>进行设置（USER），也可以单独对某个<strong>工作区</strong>进行设置（WORKSPACE）。</p>\n<p><img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122220941604.png\" alt=\"image-20221122220941604\" style=\"zoom: 80%;\" />\t由于我们是手动安装的，已经设置了<code>PATH</code>环境变量。所以把插件设置的工具链路径设为<code>PATH</code>即可。</p>\n<h1 id=\"4-打开一个或多个例程\"><a href=\"#4-打开一个或多个例程\" class=\"headerlink\" title=\"4. 打开一个或多个例程\"></a>4. 打开一个或多个例程</h1><p>​\t在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择 “adding an existing application”：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122225724875.png\" alt=\"image-20221122225724875\"></p>\n<p>​\t从ncs的<code>nrf</code>或者<code>zephyr</code>目录的<code>sample</code>子目录下随便选取一个项目，打开文件夹即可：</p>\n<p>​\t项目创建完毕后，默认存储在一个UNTITLED <strong>workspace</strong>中，这是一个<strong>临时的</strong>workspace。</p>\n<h2 id=\"4-1-理解VS-Code的Workspace\"><a href=\"#4-1-理解VS-Code的Workspace\" class=\"headerlink\" title=\"4.1. 理解VS Code的Workspace\"></a>4.1. 理解VS Code的Workspace</h2><blockquote>\n<p>​\tworkspace是VS Code中的一种设计，是许多同类项目（目录）的集合。这种设计，方便同一类项目统一设定工具链路径、插件是否启用等。</p>\n<p>​\t在VS Code的settings中，可以看到设置分为User, Workspace, Folder三个级别。User就是全局的设置，Worksdpace和Folder就依次是更细一级的设置。后者可以覆盖前者的设置。</p>\n<p>​\t例如，可以只创建一个Nordic NCS专用的workspace，只在这里面启用ncs 插件。在其他workspace中不启用。这样VS Code就可以在不同workspace下进行不同语言、不同领域的开发。</p>\n<p>​\t具体方法是：在不打开任何workspace的情况下，在插件管理中禁用nRF Connect for VS Code Extension pack，然后打开workspace时，在插件管理中选择Enable(workspace)，就可以只在这个workspace中使用ncs插件了。</p>\n<p>​\tVS Code中，工具栏”File”菜单中有workspace添加、保存等选项。</p>\n<p>​\t如果之前没接触过workspace，只是单独打开一个文件夹（File —&gt; Open Foledr…），那么就没有Workspace这一个层级，仅有Folder层级。Folder级别的设置存储在当前目录的<code>.vscode/settings.json</code>中。</p>\n</blockquote>\n<p>​\t我们刚刚只打开了一个项目（Folder），但是NCS插件自动帮我们新建了一个workspace，这个workspace是临时的，标记为UNTITLED。</p>\n<p>​\t可以在VS Code菜单栏中选择 File &gt; Save Workspace As … ，将工作区另存为一个<code>xxxxx.code-workspace</code>文件。这样每次打开这个<code>.code-workspace</code>文件就能打开整个工作区。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122225912476.png\" alt=\"image-20221122225912476\"></p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122225949921.png\" alt=\"image-20221122225949921\"></p>\n<p>​\t并且，工作区的所有配置都是写在这个<code>xxxx.code-workspace</code>文件中的。workspace中的配置可以覆盖全局的配置。</p>\n<p>​\t可以从工作区内移除项目：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122230432396.png\" alt=\"image-20221122230432396\" style=\"zoom: 50%;\" />\n\n\n\n<p>也可以向工作区内添加项目文件夹：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122230541745.png\" alt=\"image-20221122230541745\" style=\"zoom:50%;\" />\n\n<blockquote>\n<p>注意:</p>\n<ul>\n<li>workspace只是一个集合，用<code>.code-workspace</code>文件来记录所有项目的位置。并不一定是一个真实存在的大文件夹，更不需要所有的项目文件夹都是workspace的子文件夹。</li>\n<li>如果已经保存了workspace，那么下次再打开这个workspace中的项目时，不要再用”adding an existing application”。因为这又会把此项目放入一个临时的UNTITLED workspace内。直接从上次保存的<code>xxxx.code-workspace</code>文件重新打开工作区即可。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-2-理解nRF-Connect的workspace\"><a href=\"#4-2-理解nRF-Connect的workspace\" class=\"headerlink\" title=\"4.2. 理解nRF Connect的workspace\"></a>4.2. 理解nRF Connect的workspace</h2><p>​\t上一节讲过，VS Code的workspace本质上是文件夹的集合，VS Code并不在乎文件夹里面的内容是什么。</p>\n<p>​\t但是nRF Connect插件是另外的管理方式。在nRF Connect插件的APPLICATION视图中，可以看到当前工作区内NCS项目的集合，这些文件夹必须是可以编译的NCS项目，如下图：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122231125385.png\" alt=\"image-20221122231125385\"></p>\n<p>​\t有时在VS Code的workspace中添加、移除文件夹，nRF connect插件的APPLICATIONS视图<strong>不会一起同步</strong>。这时可以在APPLICATION视图中进行单独的添加或右键移除。“+”按钮的效果和“Add an existing application”是一样的。</p>\n<p>​\t此外，也可以在左下角齿轮Settings中，当前WORKSPACE下的<code>nrfconnect.applications</code>配置中，对当前工作区中的项目进行增删管理：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122231837769.png\" alt=\"image-20221122231837769\" style=\"zoom:80%;\" />\n\n\n\n<h1 id=\"5-创建一个新工程并用git管理\"><a href=\"#5-创建一个新工程并用git管理\" class=\"headerlink\" title=\"5. 创建一个新工程并用git管理\"></a>5. 创建一个新工程并用git管理</h1><p>​\t上一节讲解了如何<strong>打开</strong>一个例程。如果我们只是打开例程，例程的文件夹还是在ncs仓库内部，受到ncs的git仓库的管理。如果想自己开发项目，并用git管理版本，就需要<strong>创建</strong>新工程。</p>\n<p>​\tNCS支持把例程当作模板，复制到NCS外部，并创建新工程。</p>\n<h2 id=\"5-1-创建新工程\"><a href=\"#5-1-创建新工程\" class=\"headerlink\" title=\"5.1. 创建新工程\"></a>5.1. 创建新工程</h2><p>​\tNCS支持以例程作为模板，复制并创建新的工程。</p>\n<p>​\t在 VS Code中，选择左侧nRF Connect for VS Code插件，进入Welcome页面，选择 Create a new application：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122232512218.png\" alt=\"image-20221122232512218\" style=\"zoom:80%;\" />\n\n<ul>\n<li>需要设置项目的名称、路径。</li>\n<li>需要从ncs的例程中选择一个作为模板（可以是<code>nrf/sample/</code>,<code> nrf/application/</code>, <code>zephyr/sample/</code>, <code>zephyr/application/</code>目录下的例程）</li>\n<li>需要设置Application Type</li>\n</ul>\n<blockquote>\n<h4 id=\"理解Application-Type\"><a href=\"#理解Application-Type\" class=\"headerlink\" title=\"理解Application Type:\"></a>理解Application Type:</h4><p>新项目的创建方式有freestanding和workspace两种：</p>\n<ul>\n<li>freestanding 就是不使用工作区，只使用文件夹来保存一个单独的工程。这种方式，要求电脑上已经装了一个NCS。</li>\n<li>workspace就是在创建这个项目时，同时创建一个工作区，并且要设定这个工作区的名称。这种方式不需要你已经安装一个NCS，因为它要直接从github上拉取一个新的NCS。</li>\n</ul>\n<p>​    <strong>如果创建新工程时，当前VS Code已经打开了一个workspace （UNTITLED临时的也算），那么就只能选择freestanding，不能选择workspace创建方式。并且这个freestanding的工程会强行加入到目前已经打开的workspace中。</strong>如果想避免这种情况，可以在VS Code菜单栏的File…选项中选择关闭当前workspace，或者打开一个新VS Code窗口，再进行操作。</p>\n</blockquote>\n<h2 id=\"5-2-使用git管理你的新工程\"><a href=\"#5-2-使用git管理你的新工程\" class=\"headerlink\" title=\"5.2. 使用git管理你的新工程\"></a>5.2. 使用git管理你的新工程</h2><p>​\t创建好的新工程，可以使用git管理，按Ctrl + “`“ （波浪线那个键）打开终端，然后进入你刚刚创建的新工程的目录（打开终端时，默认的目录可能是workspace中其他的目录，需要手动切过去）。</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122233158710.png\" alt=\"image-20221122233158710\" style=\"zoom: 67%;\" />\n\n\n\n<p>​\t如果你从没用过git，需要先配置用户名和邮箱。这个用户名和邮箱不是登陆什么网站用的，而是一个签名，用于提交代码时标记这段代码是谁提交的。这个配置存在你电脑的本地，并且是<strong>全局</strong>的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">&quot;Jayant.Tang&quot;</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">&quot;jayant.tang@nordicsemi.no&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>​\t把这个工程文件夹当成git仓库进行初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122233614502.png\" alt=\"image-20221122233614502\" style=\"zoom:50%;\" />\n\n<center>如果你的终端是git bash，可以看到右边已经出现了分支名</center>\n\n<p>​\t初始化好仓库后，如果你之前build过，就可以看到左侧git窗口有大量的新文件。Git图标上有“1K+”的提示，表示有1000多个文件被修改了：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122233758040.png\" alt=\"image-20221122233758040\" style=\"zoom:50%;\" />\n\n<p>​\t使用<code>git status</code>命令查看也会告诉你，当前有很多未被git仓库跟踪的文件。</p>\n<p>​\t这其中很多文件是编译过程中自动生成的，甚至有些是二进制文件。我们并不关心这些文件的内容如何变化，因此可以在当前工程的根目录下创建一个<code>.gitignore</code>文件来忽略这些不需要被跟踪的文件：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122234108052.png\" alt=\"image-20221122234108052\" style=\"zoom:67%;\" />\n\n<p>​\t例如<code>build/</code>就是忽略build下所有的文件的变化。支持正则表达式，例如<code>*.log</code>。增加完后，可以看到，左侧的Git图标上只有17个文件修改了，这些就是我们这个项目的源码和配置文件。</p>\n<p>​\t在Git插件的面板，对某个仓库的某一批Changes点“+”号，可以把所有修改都添加到暂存区（效果等同于<code>git add .</code>）：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221122234334470.png\" alt=\"image-20221122234334470\" style=\"zoom:67%;\" />\n\n\n\n<p>​\t可以把暂存区的修改全部提交，并添加描述（效果等同于<code>git commit -m &quot;init a new project&quot;</code> ）</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122234752701.png\" alt=\"image-20221122234752701\"></p>\n<p>​\t如果安装了git history插件，就可以查看提交历史：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122235338251.png\" alt=\"image-20221122235338251\"></p>\n<p>​\tGit History提供了很方便的视图，可以看到每次commit都改动了哪些代码和配置（左侧是旧的，右侧是新的）：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221122235416865.png\" alt=\"image-20221122235416865\"></p>\n<p>​\t更多Git的使用，可以去网上了解其他教程。本文不再赘述。</p>\n<h1 id=\"6-编译工程\"><a href=\"#6-编译工程\" class=\"headerlink\" title=\"6. 编译工程\"></a>6. 编译工程</h1><p>​\t不论是<strong>打开</strong>的示例工程，还是<strong>创建</strong>的新工程，都遵循下列步骤进行编译和调试等工作。</p>\n<h2 id=\"6-1-创建一个Build\"><a href=\"#6-1-创建一个Build\" class=\"headerlink\" title=\"6.1. 创建一个Build\"></a>6.1. 创建一个Build</h2><p>​\t所谓Build的配置，就是一个项目要如何编译、有哪些编译参数。比如同一个项目，你可以创建一个Debug Build和一个ReleaseBuild，采用不同的优化等级。</p>\n<p>​\t创建Build，需要选择自己使用的板卡，Zephyr自带Nordic官方的开发板，和一些其他厂商的官方开发板。Zephyr也支持使用自定义的板子，但是本文不介绍如何自定义板子。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123135000141.png\" alt=\"image-20221123135000141\"></p>\n<h2 id=\"6-2-进行构建\"><a href=\"#6-2-进行构建\" class=\"headerlink\" title=\"6.2. 进行构建\"></a>6.2. 进行构建</h2><p>​\t在APPLICATIONS栏选中自己要构建的工程。然后在ACTIONS栏通过build<strong>按钮</strong>进行项目的构建。</p>\n<blockquote>\n<p>按Build旁的圆圈箭头按钮，可以全部重新编译。</p>\n</blockquote>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123140646521.png\" alt=\"image-20221123140646521\"></p>\n<blockquote>\n<p>​\t前面提到，<strong>自动安装</strong>SDK时，可能由于网络原因而缺少文件，并且nRF Connect桌面版不会给出任何提示。如果编译时提示：<code>No Such File or Directory...</code>之类的错误时，很可能就是SDK中缺少文件。</p>\n<p>​\t这时需要在SDK目录下打开终端，并执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看nfr仓库下有多少版本</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nrf</span><br><span class=\"line\">git tag  <span class=\"comment\"># 按键盘上下键翻阅，按q退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检出想要的版本</span></span><br><span class=\"line\">git checkout v2.1.2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新整个仓库</span></span><br><span class=\"line\">west update</span><br></pre></td></tr></table></figure>\n\n<p>​\t如果更新时出现问题，往往是网络问题，重复多次<code>west update</code>直到下载完毕即可。</p>\n</blockquote>\n<p>​\t另外，也可以通过Ctrl + ` 打开终端，通过命令行的方式进行构建：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west build</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"7-烧录hex\"><a href=\"#7-烧录hex\" class=\"headerlink\" title=\"7. 烧录hex\"></a>7. 烧录hex</h1><p>​\t先把官方的开发板通过USB连接到电脑上，识别到Jlink之后，可以通过ACTIONS栏中的<code>Flash</code>按钮触发烧录动作：</p>\n<img src=\"/jayant97.github.io/imgs/安装nRF-Connect-SDK.assets/image-20221123160139273.png\" alt=\"image-20221123160139273\" style=\"zoom: 80%;\" />\n\n<p>​\t也可以通过命令行的形式进行烧录:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>备注：\t</p>\n<p>​\t这样直接烧录，有一部分项目可能会烧写失败，显示：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123160245857.png\" alt=\"image-20221123160245857\"></p>\n<p>​\t这是因为，Nordic的MCU中通常都有一个用于存储用户信息的寄存器（UICR），可以认为是一块特殊的flash区域，存储了客户自己的加密密钥、引脚配置等产品信息。由于信息安全的原因，是不允许在保持UICR不变的情况下烧写新的固件的。因此这种情况下只能全片擦除然后再烧录。</p>\n<p>​\t全片擦除然后烧录的方式，点击Flash右边的按钮：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E5%AE%89%E8%A3%85nRF-Connect-SDK.assets/image-20221123160832598.png\" alt=\"image-20221123160832598\"></p>\n<p>​\t或者使用命令行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ west flash --force --erase</span><br></pre></td></tr></table></figure>\n</blockquote>\n","categories":["Nordic","NCS"],"tags":["Nordic","NCS"]},{"title":"搭建自己的静态博客并自动部署","url":"/jayant97.github.io/2022/12/b42baba50896/","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>本文讲解本博客的搭建方式</p>\n<table>\n<thead>\n<tr>\n<th>部件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://hexo.io/zh-cn/\">Hexo</a></td>\n<td>把.md文章转换为页面，并且快速部署到平台</td>\n</tr>\n<tr>\n<td>GitHub Pages</td>\n<td>提供从GitHub仓库创建网站的服务</td>\n</tr>\n<tr>\n<td>GitHub Actions</td>\n<td>GitHub提供的免费持续集成服务</td>\n</tr>\n</tbody></table>\n<h2 id=\"Hexo-Github-Pages\"><a href=\"#Hexo-Github-Pages\" class=\"headerlink\" title=\"Hexo + Github Pages\"></a>Hexo + Github Pages</h2><p>先从简单的讲起，看图：</p>\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202224730111.png\" alt=\"image-20221202224730111\" style=\"zoom: 50%;\" />\n\n<p>简而言之：</p>\n<ul>\n<li>Hexo是一个博客框架，存放在你的电脑上，能把你的markdown文章转换成网站源码，并存入一个git仓库</li>\n<li>Github Pages是GitHub提供的免费静态网站服务，能让你展示文档。你只需要把网站源码存入一个repository，并且启用这个服务，GitHub就会帮你建一个静态网站，分配一个网址。别人从这个网址就能看到你的博客了。</li>\n<li>Hexo能一键把本地的网站源码推送到GitHub，让GitHub自动将其部署为Pages</li>\n</ul>\n<h2 id=\"GitHub-Actions\"><a href=\"#GitHub-Actions\" class=\"headerlink\" title=\"GitHub Actions\"></a>GitHub Actions</h2><p>​    前面的方法，网站所有的资源都存在本地，除了markdown文章和图片这种<strong>资源文件</strong>以外，网站的<strong>美化主题</strong>、<strong>配置</strong>等也存在本地。</p>\n<p>​    这会产生几个问题：</p>\n<ul>\n<li><p>数据容易丢失，一旦硬盘损坏，你的博客就灰飞烟灭了</p>\n</li>\n<li><p>只能在一台电脑上写文章，多台电脑之间hexo文件夹不好同步</p>\n</li>\n<li><p>网站的配置文件修改，没有历史记录追踪</p>\n</li>\n<li><p>由于网站的美化主题本身就是Github上的项目，每次要手动更新，很麻烦</p>\n</li>\n<li><p>每次写完文章，都要用hexo命令生成网站，还要用hexo命令部署网站，重复操作</p>\n</li>\n</ul>\n<p>​    所以，<strong>最好把hexo文件夹本身也当作Git项目，并放在GitHub托管</strong>。并且，还要把hexo部署的操作给自动化，让我们每次写完markdown文章，一 Push 就能自动部署页面。</p>\n<p>​    这就要用到GitHub Actions，它是GitHub提供的<strong>持续集成</strong>（Continuous integration， CI）服务。这里不详述CI&#x2F;CD的概念，你只需要知道，GitHub提供的这个服务，可以让你的仓库在特定条件下（例如push时），触发对应的<strong>动作（Actions）</strong>。</p>\n<p>​    所谓的Actions，可以认为就是一条一条的Linux命令（也可以是Windows CMD命令）或者脚本，并且GitHub给你一个虚拟服务器去自动执行这一条一条的命令，这个虚拟服务器具有2核CPU，7GB内存，14GB硬盘。</p>\n<p>​    你可以写自己的Actions，也可以用别人的Actions。Github提供了一个Action商店。</p>\n<p>​    最终的效果应该如下图：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221203224217145.png\" alt=\"image-20221203224217145.png\" style=\"zoom: 50%;\" />\n\n<p>配置完成后的效果：</p>\n<ul>\n<li>写完文章后，直接本地hexo仓库<code>commit</code>，然后<code>push</code></li>\n<li>GitHub上的hexo仓库由<code>push</code>触发Actions，自动在虚拟服务器中生成网站源码，然后部署到网站仓库中</li>\n<li>网站仓库（xxxx.github.io）更新时，自动更新Github Pages</li>\n<li>hexo的美化主题，作为hexo的git submodule，每次push时自动checkout最新分支</li>\n</ul>\n<h1 id=\"2-搭建步骤\"><a href=\"#2-搭建步骤\" class=\"headerlink\" title=\"2. 搭建步骤\"></a>2. 搭建步骤</h1><p>一些简单的步骤就只简略提一下。</p>\n<h2 id=\"2-1-在GitHub创建仓库并启用Pages\"><a href=\"#2-1-在GitHub创建仓库并启用Pages\" class=\"headerlink\" title=\"2.1. 在GitHub创建仓库并启用Pages\"></a>2.1. 在GitHub创建仓库并启用Pages</h2><ol>\n<li>注册一个GitHub账号</li>\n<li>在GitHub创建两个仓库<code>&lt;site_name&gt;.github.io</code>和<code>my-hexo</code><br> 前者是GitHub Pages仓库，命名必须以<code>github.io</code>结尾，后者是hexo仓库，可随意取名。<br> 两个仓库都留空，不创建任何文件。</li>\n<li>然后设置Pages，在<code>&lt;site_name&gt;.github.io</code>仓库中：</li>\n</ol>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221202233043747.png\" alt=\"image-20221202233043747\"></p>\n<p>在仓库的Settings中，选择Pages，下方选择哪个分支的哪个目录被识别为网站的根目录。</p>\n<blockquote>\n<p>GitHub现在的主分支是<code>main</code>而不是<code>master</code>了，我是自己创建了一个<code>master</code>分支，因为我本地的git默认主分支还是master。</p>\n</blockquote>\n<h2 id=\"2-2-本地部署hexo\"><a href=\"#2-2-本地部署hexo\" class=\"headerlink\" title=\"2.2. 本地部署hexo\"></a>2.2. 本地部署hexo</h2><h3 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h3><p>首先安装依赖，需要安装的软件：</p>\n<ul>\n<li><a href=\"https://git-scm.com/\">Git (git-scm.com)</a>：版本管理</li>\n<li><a href=\"https://nodejs.org/en/download/\">Node.js</a>：hexo所需的平台</li>\n</ul>\n<blockquote>\n<p>Windows用户安装时，一定要勾选<code>Add to PATH </code>选项</p>\n</blockquote>\n<p>然后安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm  install -g hexo-cli <span class=\"comment\"># 全局安装</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于Node.js和hexo的版本依赖关系，请参考：<a href=\"https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6\">文档 | Hexo</a></p>\n</blockquote>\n<h3 id=\"初始化hexo\"><a href=\"#初始化hexo\" class=\"headerlink\" title=\"初始化hexo\"></a>初始化hexo</h3><p>找个喜欢的地方创建一个文件夹用于存放hexo项目，例如<code>my-hexo</code>。</p>\n<p>进入这个仓库，然后进行hexo初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建文件夹</span></span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> my-hexo &amp;&amp; <span class=\"built_in\">cd</span> my-hexo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化hexo，执行这步之前，需确保文件夹是空的</span></span><br><span class=\"line\">$ hexo init ./</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖的node.js插件</span></span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>hexo初始化要求文件夹为空，因此必须先初始化hexo，再初始化git。否则<code>.git/</code>的存在将导致hexo无法初始化</li>\n<li><code>hexo init</code>时，产生了文件<code>package.json</code>，里面记录了hexo所依赖的npm包的具体来源和版本号</li>\n<li><code>npm install</code>时，就根据<code>package.json</code>记录的内容进行了包的安装。包的具体安装情况记录在<code>package-lock.json</code>中</li>\n</ul>\n</blockquote>\n<p>安装完毕后，目录结构应该如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- _config.landscape.yml  # landscape主题配置文件</span><br><span class=\"line\">|-- _config.yml            # 网站配置文件</span><br><span class=\"line\">|-- node_modules           # node.js插件包</span><br><span class=\"line\">|-- package-lock.json      # node.js插件包记录</span><br><span class=\"line\">|-- package.json           # node.js插件包记录</span><br><span class=\"line\">|-- scaffolds/             # 文章、页面模板文件夹</span><br><span class=\"line\">|-- source/                # 网站静态资源（文章、图片等）</span><br><span class=\"line\">`-- themes/                # 网站美化主题文件夹</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"初始化git并传到远程仓库\"><a href=\"#初始化git并传到远程仓库\" class=\"headerlink\" title=\"初始化git并传到远程仓库\"></a>初始化git并传到远程仓库</h3><blockquote>\n<p>如果你从没用过git，需要配置本地的git用户和邮箱：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;$ git config --global user.name &lt;用户名&gt;</span><br><span class=\"line\">&gt;$ git config --global user.email &lt;邮箱&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个用户名和邮箱只是本地提交代码时记录修改人是谁，并非是要登录什么网站</p>\n</blockquote>\n<p>​    还是在这个目录，进行Git仓库初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本文不解释git及其相关概念，后续使用git命令时，即使是复制，也务必明白你在做什么</p>\n<p>另外，记得确认仓库中的<code>.gitignore</code>文件，它是<code>hexo init &lt;文件夹&gt;</code>时生成的，其内容包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/         # 安装的npm包</span><br><span class=\"line\">public/               # 生成的静态网站源码目录</span><br><span class=\"line\">.deploy*/             # xxxx.github.io仓库</span><br><span class=\"line\">_multiconfig.yml</span><br></pre></td></tr></table></figure>\n\n<p>​    这是让git不要去追踪一些自动生成的内容，这些内容与文章、站点配置无关。</p>\n</blockquote>\n<p>​    然后再<code>commit</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;init&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​    还记得前面在GitHub创建的<code>my-hexo</code>仓库还是空的吗，现在需要把本地<code>my-hexo</code>仓库绑定到GitHub仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin https://github.com/&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br><span class=\"line\">$ git branch -M master  <span class=\"comment\"># 默认主分支我改名为master</span></span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"本地预览hexo网站页面\"><a href=\"#本地预览hexo网站页面\" class=\"headerlink\" title=\"本地预览hexo网站页面\"></a>本地预览hexo网站页面</h3><p>依次输入以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean      <span class=\"comment\"># 清理hexo缓存</span></span><br><span class=\"line\">$ hexo g          <span class=\"comment\"># 生成hexo网站源码</span></span><br><span class=\"line\">$ hexo s --debug  <span class=\"comment\"># 在本地开启网站的访问端口</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">16:49:54.435 DEBUG Generator: tag</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: category</span><br><span class=\"line\">16:49:54.436 DEBUG Generator: index</span><br><span class=\"line\">16:49:54.445 INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>\n\n<p>终端中会打印本地网站的地址，Ctrl+鼠标左键点击访问即可：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203005355143.png\" alt=\"image-20221203005355143\"></p>\n<p>可以看到默认页面即为成功，首页的唯一一篇文章是hexo自带的<code>source/_post/hello-world.md</code>.</p>\n<blockquote>\n<p>终端按Ctrl + C停止本地服务器</p>\n</blockquote>\n<h2 id=\"2-3-配置hexo\"><a href=\"#2-3-配置hexo\" class=\"headerlink\" title=\"2.3.  配置hexo\"></a>2.3.  配置hexo</h2><h3 id=\"安装主题\"><a href=\"#安装主题\" class=\"headerlink\" title=\"安装主题\"></a>安装主题</h3><p>​    hexo有很多美化主题，可以在<a href=\"https://hexo.io/themes/\">Themes | Hexo</a>找到喜欢的主题，也可以在GitHub上搜索其他主题。我选择的主题是<a href=\"https://butterfly.js.org/\">Butterfly - A Simple and Card UI Design theme for Hexo</a>。主题除了美化外，往往还提供许多其他功能的配置。</p>\n<p>​    主题放在themes文件夹下。<strong>不论安装什么主题，一定要注意</strong>：</p>\n<ul>\n<li>虽然主题的官方教程一般都是让用<code>git clone</code>到themes文件夹下，但是我们的hexo文件夹已经是一个git仓库了，所以要以<code>git submodule</code>的形式安装；</li>\n<li><code>themes</code>下的主题文件夹必须以<code>&lt;主题名&gt;</code>来命名，而不是GitHub仓库的名称，如<code>hexo-theme-&lt;主题名&gt;</code>。</li>\n<li>很多主题的官方说明会要求安装其他的npm包。使用<code>npm</code>安装这些包时，一定要带<code>--save</code>选项。这样这些包才会被记录到<code>package.json</code>中，这样我们以后push时，GitHub Actions上面的虚拟服务器才会帮我们完整的安装这些依赖。</li>\n<li>主题本身的配置文件在<code>themes/&lt;主题名&gt;/_config.yml</code>中，但这个文件是被主题仓库管理的，不会被hexo仓库管理，无法推送到GitHub。而且主题仓库更新后我们修改的配置也会丢失。所以我们应当在hexo根目录下创建<code>_config.&lt;主题名&gt;.yml</code>文件，并把主题中的配置文件拷贝进去。这样配置文件就会被hexo仓库管理。（但是原来主题文件夹里的_config.yml也不要删除）</li>\n</ul>\n<p>下面是我安装butterfly的步骤:</p>\n<ol>\n<li>把butterfly作为git submodule安装到hexo中</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git submodule add -b master https://github.com/jerryc127/hexo-theme-butterfly.git ./themes/butterfly</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：<code>git submodule add</code>时，一定要指定主题的文件夹名称，将其命名为主题的名称，此处为<code>themes/butterfly</code>。若不这样做，将会变成其GitHub仓库的名称，如<code>hexo-theme-butterfly</code>，这样是不行的。</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装渲染器</li>\n</ol>\n<p>根据butterfly的官方文档，需要安装渲染器。其他主题可能需要其他渲染器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一定要带<code>--save</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>拷贝<strong>主题配置</strong>文件</li>\n</ol>\n<p>把<code>themes/&lt;主题名&gt;/_config.yml</code>配置拷到hexo根目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>应用主题</li>\n</ol>\n<p>修改<strong>hexo配置文件</strong>，<code>my-hexo</code>根目录下的<code>_config.yml</code>，找到<code>theme</code>项并修改：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">butterfly</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>yml格式的<code>:</code>后面一定要有一个空格</p>\n</blockquote>\n<ol start=\"5\">\n<li>查看效果</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203191314829.png\" alt=\"image-20221203191314829\"></p>\n<ol start=\"6\">\n<li>其他修改</li>\n</ol>\n<p>根据主题的官方说明，进行其他的自定义配置。所有的修改都在my-hexo根目录下<code>_config.&lt;主题名&gt;.yml</code>中修改。 </p>\n<blockquote>\n<p><code>themes/&lt;主题名&gt;/_config.yml</code>虽然不生效，但是也不能删除。</p>\n</blockquote>\n<h3 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h3><p>​    hexo本身的配置，需要修改<code>my-hexo</code>根目录下的<code>_config.yml</code>文件。可以修改站点名称、作者等，具体可以参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a>。</p>\n<p>​    这里提一些与Github Pages还有markdown文章插入相关的配置。</p>\n<h4 id=\"网站url与root\"><a href=\"#网站url与root\" class=\"headerlink\" title=\"网站url与root\"></a>网站url与root</h4><p>目前，GitHub Pages提供的网站url为：</p>\n<p><code>https://&lt;用户名&gt;.github.io/&lt;仓库名&gt;/</code></p>\n<p>例如：</p>\n<p><code>https://jayant-tang.github.io/jayant97.github.io/</code></p>\n<p>所以，要配置hexo的目录：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://jayant-tang.github.io/jayant97.github.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/jayant97.github.io/</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​    不同环境，访问资源的根目录是不同的。hexo的所有资源文件都应该放在<code>&lt;hexo文件夹&gt;/source</code>下，生成网页时，会自动拷贝到网页的根目录下。</p>\n<p>​    例如，有一张图片资源的路径是：<code>&lt;hexo文件夹&gt;/source/foo/bar/image.png</code>：</p>\n<ul>\n<li>对于你的markdown文章，可以设置根目录为<code>&lt;hexo文件夹&gt;/source</code></li>\n<li>对于网站，刚才已经配置了根目录为<code>/jayant97.github.io/</code></li>\n</ul>\n<p>只要设置好根目录，markdown和网页就可以使用<strong>相同的路径</strong>来访问到<strong>相同的资源</strong>了，如<code>/foo/bar/image.png</code>。</p>\n</blockquote>\n<h4 id=\"hexo的部署方式介绍\"><a href=\"#hexo的部署方式介绍\" class=\"headerlink\" title=\"hexo的部署方式介绍\"></a>hexo的部署方式介绍</h4><p>通常情况下，hexo的部署流程是这样的：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203195710806.png\" alt=\"image-20221203195710806\"></p>\n<ol>\n<li><code>hexo g</code>，生成网页源码，并存储在<code>/public</code>文件夹中</li>\n<li><code>hexo d</code>，把public同步到本地git仓库，然后推送到github仓库。</li>\n</ol>\n<p>先安装git部署的插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后需要给hexo配置github仓库的路径和权限，打开<strong>hexo配置文件</strong>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">    <span class=\"comment\">#repo: https://github.com/Jayant-Tang/jayant97.github.io</span></span><br><span class=\"line\">     <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td>部署类型，可以设置多个要部署的目标</td>\n</tr>\n<tr>\n<td>branch</td>\n<td>分支名称</td>\n</tr>\n<tr>\n<td>repo</td>\n<td>仓库名称，这里有ssh和https两种方式。使用ssh方式。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>GitHub认证方式：</p>\n<ul>\n<li>https方式，任何人可以随便clone，但是push时需要在弹窗中输入账号密码，认证身份；</li>\n<li>ssh方式，需要ssh key，公钥放在GitGub，私钥自己持有。只要持有私钥就可以用ssh访问GitHub仓库，纯命令行操作，不会弹窗。</li>\n</ul>\n<p>因为后面要用GitHub Actions在虚拟服务器里自动部署，所以需要用ssh的方式。</p>\n</blockquote>\n<h4 id=\"ssh密钥对的生成\"><a href=\"#ssh密钥对的生成\" class=\"headerlink\" title=\"ssh密钥对的生成\"></a>ssh密钥对的生成</h4><p>​     然后需要生成两对ssh  key，第一对用于<strong>电脑</strong>和<strong>GitHub</strong>之间的认证，第二对用于<strong>GitHub my-hexo仓库</strong> 和<strong>GitHub xxxx.github.io仓库</strong>之间的认证。</p>\n<p>​    生成key：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/github_ed25519</span><br><span class=\"line\"><span class=\"comment\"># 输入后一直回车</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ssh-keygen -t ed25519 -C <span class=\"string\">&quot;your_email@example.com&quot;</span> -f ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>-t</code>：选择加密算法，ed25519比较安全</p>\n<p><code>-C</code>:  密钥的备注说明文字。Github要求这里要填上git config时配置的邮箱，同时也必须是GitHub中已经配置的认证邮箱。</p>\n<p><code>-f</code>：生成的私钥文件名</p>\n</blockquote>\n<p>执行完毕后，<code>~/.ssh</code>下应该有4个新文件，其中带有<code>.pub</code>后缀的是公钥，不带的是私钥:</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"code\"><pre><span class=\"line\">~/.ssh</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">|-github<span class=\"built_in\">_</span>ed25519.pub</span><br><span class=\"line\">|-hexo<span class=\"built_in\">_</span>ed25519</span><br><span class=\"line\">`-hexo<span class=\"built_in\">_</span>ed25519.pub</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"GitHub-ssh-key设置\"><a href=\"#GitHub-ssh-key设置\" class=\"headerlink\" title=\"GitHub ssh key设置\"></a>GitHub ssh key设置</h4><p>配置你的电脑ssh访问GitHub的权限。GitHub点击右上角头像-Settings，然后点击New SSH key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203202950352.png\" alt=\"image-20221203202950352\"></p>\n<p>然后，把<code>github_ed25519.pub</code>的内容粘贴进去，其他都不用填，确认即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203203135033.png\" alt=\"image-20221203203135033\" style=\"zoom: 50%;\" />\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\"><span class=\"comment\"># Attempts to ssh to GitHub</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; The authenticity of host <span class=\"string\">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class=\"string\">&#x27;t be established.</span></span><br><span class=\"line\"><span class=\"string\">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class=\"line\"><span class=\"string\">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br><span class=\"line\"><span class=\"string\"># 这里输入yes然后回车</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; Hi USERNAME! You&#x27;</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>有以上输出说明权限配置成功。</p>\n<h3 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h3><p>根据你所使用的主题的官方文档来配置。建议把后面的其他部署都完成后，再研究主题的配置。</p>\n<h2 id=\"2-4-从电脑部署hexo\"><a href=\"#2-4-从电脑部署hexo\" class=\"headerlink\" title=\"2.4. 从电脑部署hexo\"></a>2.4. 从电脑部署hexo</h2><p>前面的步骤都完成后，可以执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>这时，hexo应该已经可以把网站配置到<code>xxxx.github.io</code>上了，过一会从网页端就可以看到网站页面了。</p>\n<h2 id=\"2-5-GitHub-Actions自动部署\"><a href=\"#2-5-GitHub-Actions自动部署\" class=\"headerlink\" title=\"2.5. GitHub Actions自动部署\"></a>2.5. GitHub Actions自动部署</h2><h4 id=\"pages仓库添加公钥\"><a href=\"#pages仓库添加公钥\" class=\"headerlink\" title=\"pages仓库添加公钥\"></a>pages仓库添加公钥</h4><p>​     我们需要设置<code>my-hexo</code>仓库访问<code>xxxx.github.io</code>的权限，后面才能利用GitHub Actions，在push完<code>my-hexo</code>之后，自动部署到Pages。</p>\n<p>​    首先进入<code>xxxx.github.io</code>仓库页面，找到Settings - Deploy Keys，然后点击Add deploy key：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204246535.png\" alt=\"image-20221203204246535\"></p>\n<p>把<code>hexo_ed25519.pub</code>的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519.pub</span><br></pre></td></tr></table></figure>\n\n<img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204425639.png\" alt=\"image-20221203204425639.png\" style=\"zoom:50%;\" />\n\n<p>Title填写<code>HEXO_DEPLOY_PUB</code></p>\n<h4 id=\"hexo仓库添加私钥\"><a href=\"#hexo仓库添加私钥\" class=\"headerlink\" title=\"hexo仓库添加私钥\"></a>hexo仓库添加私钥</h4><p>​    然后进入<code>my-hexo</code>仓库，找到Settings - Secrets - Actions，然后点击New repository secret.</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204626463.png\" alt=\"image-20221203204626463\"></p>\n<p>把私钥<code>hexo_ed25519</code>中的内容粘贴进去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/hexo_ed25519</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203204859957.png\" alt=\"image-20221203204859957.png\"></p>\n<p><strong>注意，Name要记住，后面需要用到</strong>。我这里配置的是<code>HEXO_DEPLOY_PRI</code>.</p>\n<h4 id=\"编写Actions\"><a href=\"#编写Actions\" class=\"headerlink\" title=\"编写Actions\"></a>编写Actions</h4><p>在本地my-hexo文件夹中，创建一个文件<code>.github/workflows/deploy.yml</code>，填入以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在master分支上收到push时，开始执行流程</span></span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">      - master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">env</span>:</span><br><span class=\"line\">  GIT_USER: Jayant.Tang</span><br><span class=\"line\">  GIT_EMAIL: jayant.tang@nordicsemi.no</span><br><span class=\"line\">  DEPLOY_REPO: Jayant-Tang/jayant97.github.io</span><br><span class=\"line\">  DEPLOY_BRANCH: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 具体步骤</span></span><br><span class=\"line\"><span class=\"built_in\">jobs</span>:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    name: Build on node <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125; and <span class=\"variable\">$&#123;&#123; matrix.os &#125;</span>&#125;</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\">    strategy:</span><br><span class=\"line\">      matrix:</span><br><span class=\"line\">        os: [ubuntu-latest]</span><br><span class=\"line\">        node_version: [18.12.1] <span class=\"comment\"># 修改好node js版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">      - name: Checkout</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          submodules: recursive</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Checkout deploy repo</span><br><span class=\"line\">        uses: actions/checkout@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          repository: <span class=\"variable\">$&#123;&#123; env.DEPLOY_REPO &#125;</span>&#125;</span><br><span class=\"line\">          ref: <span class=\"variable\">$&#123;&#123; env.DEPLOY_BRANCH &#125;</span>&#125;</span><br><span class=\"line\">          path: .deploy_git</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Use Node.js <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\">        uses: actions/setup-node@v3</span><br><span class=\"line\">        with:</span><br><span class=\"line\">          node-version: <span class=\"variable\">$&#123;&#123; matrix.node_version &#125;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Configuration environment</span><br><span class=\"line\">        <span class=\"built_in\">env</span>:</span><br><span class=\"line\">          HEXO_DEPLOY_PRI: <span class=\"variable\">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          sudo timedatectl set-timezone <span class=\"string\">&quot;Asia/Shanghai&quot;</span></span><br><span class=\"line\">          <span class=\"built_in\">mkdir</span> -p ~/.ssh/</span><br><span class=\"line\">          <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_ed25519</span><br><span class=\"line\">          <span class=\"built_in\">chmod</span> 600 ~/.ssh/id_ed25519</span><br><span class=\"line\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"line\">          git config --global user.name <span class=\"variable\">$GIT_USER</span></span><br><span class=\"line\">          git config --global user.email <span class=\"variable\">$GIT_EMAIL</span></span><br><span class=\"line\">          <span class=\"comment\">#cp _config.theme.yml themes/concise/_config.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Install dependencies</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm install</span><br><span class=\"line\"></span><br><span class=\"line\">      - name: Deploy hexo</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          npm run deploy</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>内容修改：</p>\n<ol>\n<li><p>修改环境变量，改成你自己的用户名(GIT_USER)、邮箱(GIT_EMAIL)、pages仓库、pages分支</p>\n</li>\n<li><p>修改node_version: [xxxx]，填上你电脑本地安装的Nodejs的版本</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看本地Node.js版本</span></span><br><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改时区，如果在中国就不用改了</p>\n</li>\n</ol>\n<p>内容解释：</p>\n<ol>\n<li>在hexo仓库的master分支收到push时，触发job</li>\n<li>在Ubuntu环境中，checkout本仓库的最新内容，并且同时自动获取各个submodle的仓库。这里的<code>actions/checkout@v3</code>是Actions商店提供的，我们只需要用<code>with</code>传参数进去就行了。商店页面<a href=\"https://github.com/marketplace/actions/checkout\">Checkout · Actions · GitHub Marketplace</a>。</li>\n<li>checkout pages仓库，并把它放到.deploy_git路径中</li>\n<li>安装指定版本的Node.js</li>\n<li>配置环境变量：添加私钥、配置git用户和邮箱。注意，这里的私钥的名称就是<code>$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</code>，与前面配置的<code>HEXO_DEPLOY_PRI</code>一致。</li>\n<li>根据package.json的内容安装npm包</li>\n<li>部署hexo博客</li>\n</ol>\n<p>其他说明：</p>\n<ul>\n<li>可以使用GitHub官方提供的<a href=\"https://github.com/marketplace/actions/cache\">Cache · Actions · GitHub Marketplace</a>，把<code>node_modules</code>中的包缓存起来，每隔几天才更新一次，这样可以加速第6步。</li>\n<li>我没有使用商店中别人写的自动部署hexo的Actions，因为他们很久没更新了，使用的Node.js版本比较低，也没法通过传参的方式修改其内部使用的Node.js版本。</li>\n</ul>\n</blockquote>\n<h4 id=\"提交修改\"><a href=\"#提交修改\" class=\"headerlink\" title=\"提交修改\"></a>提交修改</h4><p>从一开始到现在，已经修改了不少内容了，将其commit然后push</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;add config&quot;</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>add之前一定要注意检查.gitignore，是否已经让git忽略了<code>db.json</code>，<code>node_modules/</code>，<code>public/</code>。</p>\n</blockquote>\n<p>push之后，在Github Actions页面应该已经可以看到流程了：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212530721.png\" alt=\"image-20221203212530721\"></p>\n<p>你的每次push，都会触发actions。绿色勾说明整个流程没有出现错误（指Ubuntu linux命令没有出现执行错误的）。如果执行失败，会出现红色叉，你可以点进去看详细的执行记录。</p>\n<p>Actions执行完毕后，应该已经部署到Pages仓库了，这里也可以看到网站部署的记录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203212852929.png\" alt=\"image-20221203212852929\"></p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203213623303.png\" alt=\"image-20221203213623303\"></p>\n<p>绿色说明部署成功，网站已经可以访问了。</p>\n<h1 id=\"3-编写并发布文章\"><a href=\"#3-编写并发布文章\" class=\"headerlink\" title=\"3. 编写并发布文章\"></a>3. 编写并发布文章</h1><h2 id=\"3-1-文章的存储与格式\"><a href=\"#3-1-文章的存储与格式\" class=\"headerlink\" title=\"3.1. 文章的存储与格式\"></a>3.1. 文章的存储与格式</h2><p>​    所有要显示的markdown文章都存放在<code>source/_posts/</code>目录下，不展示的文章（草稿）都放在<code>source/_drafts</code>目录下。</p>\n<p>​    新建文章：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>layout: markdown的布局（或者说模板），布局存放在<code>scaffolds/</code>目录下，默认有三种布局：</p>\n<ul>\n<li>post.md: 文章模板</li>\n<li>draft.md：草稿模板</li>\n<li>page.md：页面模板</li>\n</ul>\n<p>title：文章的标题，直接写标题即可，不需要写.md。<em><strong>但是最好不要有空格等特殊字符！！！</strong></em></p>\n</blockquote>\n<h2 id=\"3-2-Front-Matter\"><a href=\"#3-2-Front-Matter\" class=\"headerlink\" title=\"3.2. Front-Matter\"></a>3.2. Front-Matter</h2><p>Front-Matter是文件最上方以两行<code>---</code>分隔的区域，里面需要填写yml格式的文章配置，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Hello World</span><br><span class=\"line\">date: 2013/7/13 20:46:25</span><br><span class=\"line\">tags: </span><br><span class=\"line\"><span class=\"bullet\"> -</span> 嵌入式</span><br><span class=\"line\"><span class=\"section\"> - MCU</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>在Typora编辑器中，直接在文章开头输入<code>---</code>并回车，就可以创建这个区域：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203224247035.png\" alt=\"image-20221203224247035\"></p>\n<p>对于某些主题来说，有些选项是必选的，具体要看对应主题的说明文档。比如，我使用的butterfly主题，就可以配置：</p>\n<ul>\n<li>cover：文章封面图</li>\n<li>tags：文章标签</li>\n<li>categories：文章目录</li>\n<li>……</li>\n</ul>\n<blockquote>\n<p>tags和categories的区别：</p>\n<p>​    tags是无顺序的，categories是一个递归层级。设计好的tags和categories能让读者很方便的从主页索引到对应的文章。</p>\n</blockquote>\n<p>​    这里，我们也可以体会到前面模板的意义：可以在模板里填好Front Matter，这样每次hexo就会自动帮我们生成了。</p>\n<h2 id=\"3-3-Typora在文章中插图的问题\"><a href=\"#3-3-Typora在文章中插图的问题\" class=\"headerlink\" title=\"3.3. Typora在文章中插图的问题\"></a>3.3. Typora在文章中插图的问题</h2><h3 id=\"方案一：云端图床\"><a href=\"#方案一：云端图床\" class=\"headerlink\" title=\"方案一：云端图床\"></a>方案一：云端图床</h3><p>图片全部放在云端图床，markdown和Pages都通过URL查看图片。具体的方式，本文不介绍，可以去网上查阅。</p>\n<h3 id=\"方案二：图片放在本地\"><a href=\"#方案二：图片放在本地\" class=\"headerlink\" title=\"方案二：图片放在本地\"></a>方案二：图片放在本地</h3><p>假设我们在markdown中展示一张图片，其路径为<code>source/imgs/foo/bar/image.png</code>。</p>\n<p>hexo生成网站后，网页会根据 <code>$&#123;root&#125;/imgs/foo/bar/image.png</code>来找这张图片，即是说，source文件夹放的内容，在网页端就是根目录下的内容。</p>\n<blockquote>\n<p>在<a href=\"#%E9%85%8D%E7%BD%AEhexo\">2.3 配置hexo</a>中，我们已经配置了root为<code>&lt;仓库名&gt;</code>了。</p>\n</blockquote>\n<p>​    下面要解决的是，如何在markdown文章和网页中，能用<strong>同样的路径</strong>来访问图片资源。这样本地写文章时和网页端就都可以预览了，而且从markdown转换成html时，路径也是可用的。</p>\n<p>​     解决方式就是根目录，由于hexo的根目录前面已经设置过了，我们只需要设置markdown编辑器的根目录就好。设置完毕后，而这就都可以通过<code>/imgs/foo/bar/image.png</code>来访问同一张图片了。</p>\n<p><strong>（1）设置markdown文章访问图片时的根目录</strong></p>\n<p>​    我使用的Markdown编辑器是Typora，Typora支持<strong>针对每一篇文章单独设置</strong>根目录。</p>\n<p>直接在Front-Matter中填入以下内容即可：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-root-url:</span> <span class=\"string\">./..</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于文章的路径是<code>source/_post</code>，所以<code>./..</code>就是<code>source</code>了。</p>\n</blockquote>\n<p>你可以把这一行配置直接写进<code>scaffolds/post.md</code>中，这样下次模板就自动帮你填了。</p>\n<p>以上设置，直接从菜单栏设置是一样的，Typora会自动帮你写这一行：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221125176.png\" alt=\"image-20221203221125176\"></p>\n<p><strong>（2）设置Typora粘贴图片时的行为</strong></p>\n<p>直接在Front-Matter中写入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">typora-copy-images-to:</span> <span class=\"string\">../../source/imgs/$&#123;filename&#125;.assets/</span></span><br></pre></td></tr></table></figure>\n\n<p>这个效果和下图中的偏好设置是一样的，<strong>但是不要去偏好设置里去配置，因为那是全局的配置</strong>：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222104681.png\" alt=\"image-20221203222104681\"></p>\n<blockquote>\n<p>只需要在  Front-Matter 中写就行，不要去偏好设置里设置成上图的样子！！！</p>\n</blockquote>\n<p><strong>（3）检查效果</strong></p>\n<p>​    在Front-Matter中填入以上配置之后，每次粘贴图片到typora时，就会自动帮你把图片拷贝到<code>source/imgs/&lt;文章名&gt;.assets/</code>文件夹中。</p>\n<p>​    我们可以粘贴一张图片到typora中，检查图片位置：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203221924602.png\" alt=\"image-20221203221924602\"></p>\n<p>然后，检查markdown访问图片的路径，查看markdown源码：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222001274.png\" alt=\"image-20221203222001274\"></p>\n<p>可以看到，路径名直接是从<code>/imgs</code>开始的，这说明根目录已经是<code>source</code>了。</p>\n<blockquote>\n<p>以上配置全部写在Front-Matter中，把这两行配置写入<code>scaffolds/post.md</code>的Front-Matter中，这样模板就创建好了。这些配置就只对hexo中的markdown有影响，对你平时用typora写其他文章没有任何影响。</p>\n<p>参考资料：<a href=\"https://support.typoraio.cn/YAML/\">YAML Front Matter - Typora Support (typoraio.cn)</a></p>\n</blockquote>\n<h2 id=\"3-4-Typora中的html标签插图\"><a href=\"#3-4-Typora中的html标签插图\" class=\"headerlink\" title=\"3.4. Typora中的html标签插图\"></a>3.4. Typora中的html标签插图</h2><p>​    如果你在Typora中右键点击一张图片，然后进行缩放，它就会从Markdown语法的图片:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片名称</span>](<span class=\"link\">图片路径</span>)</span><br></pre></td></tr></table></figure>\n\n<p>​    变成html格式的img标签，比如缩小到50%：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;图片路径&quot;</span> alt=<span class=\"string\">&quot;图片名称&quot;</span> style=<span class=\"string\">&quot;zoom: 50%;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​\thexo在把<code>.md</code>文章转换成html的时候，会自动根据我们设置的根目录来替换markdown格式图片的路径。</p>\n<p>​\t以本博客为例，<code>![测试图片](/imgs/image.png)</code>会被转换成<code>/jayant97.github.io/imgs/image.png</code>。</p>\n<p>​\t但是，如果<code>.md</code>文章里的图片本来就是html格式的标签，<strong>hexo不会对其进行任何转换</strong>。这就导致，在网站上，图片的路径还是<code>/imgs/image.png</code>，所以网站上就找不到图片了。</p>\n<p>​\t为了解决这个问题，网上解法很多。但我想了想，还是用Linux的sed命令来对文本进行替换，毕竟我并不懂JavaScripts。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br><span class=\"line\">sed  -i <span class=\"string\">&#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/&lt;仓库名&gt;/imgs/#g&#x27;</span> ./source/_posts/*.md</span><br></pre></td></tr></table></figure>\n\n<p>​\t以上三个命令会把<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code> 和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>和<code>&lt;img src=&quot;/jayant97.github.io/imgs/</code>都替换成 <code>&lt;img src=&quot;/&lt;仓库名&gt;/imgs/</code>。</p>\n<blockquote>\n<p>默认情况下：</p>\n<ul>\n<li><p><code>./imgs</code>和<code>imgs</code>是一样的，在转换的时候都会被hexo变成<code>&lt;文章路径&gt;/imgs</code>。</p>\n</li>\n<li><p><code>/imgs</code>不会被转换，在网页端还是<code>/imgs</code></p>\n</li>\n</ul>\n<p>以上两种方式都访问不到图片，只有<code>/jayant97.github.io/imgs</code>才能访问到图片</p>\n</blockquote>\n<p>​    把这些命令加到GitHub Actions中，这样我们本地用typora的时候还是能看到图片，push到远程的时候网页也能看到图片。</p>\n<p>​    首先在GitHub Actions的.yml文件中增加一个环境变量，方便后面更改：</p>\n<img src=\"/jayant97.github.io/imgs/搭建自己的静态博客并自动部署.assets/image-20221204210311635.png\" alt=\"image-20221204210311635\" style=\"zoom: 67%;\" />\n\n<p>​\t然后，在hexo部署的步骤之前，加入sed命令：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Sed</span> <span class=\"string\">img</span> <span class=\"string\">label</span></span><br><span class=\"line\">  <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br><span class=\"line\"><span class=\"string\">    sed  -i &#x27;s#&lt;img src=&quot;/jayant97.github.io/imgs/#&lt;img src=&quot;/$&#123;&#123; env.IMG_ROOT &#125;&#125;/imgs/#g&#x27;  ./source/_posts/*.md</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样云端部署的时候就会自动帮你替换路径了。</p>\n<blockquote>\n<p>​\t但是，本地<code>hexo s --debug</code>去查看网页的时候，由于没有Actions帮你转换，图片还是看不了的。这个问题倒没什么影响。</p>\n</blockquote>\n<h2 id=\"3-5-Typora云端和本地图片互转\"><a href=\"#3-5-Typora云端和本地图片互转\" class=\"headerlink\" title=\"3.5. Typora云端和本地图片互转\"></a>3.5. Typora云端和本地图片互转</h2><p>如果你有一篇文章，以前所有的图片是放在云端的，现在想放在本地。可以批量操作：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203222340559.png\" alt=\"image-20221203222340559.png\"></p>\n<p>同理，也可以批量把本地图片上传到云端（需要提前设置好上传方式），<strong>文章内所有的图片路径都会自动更新</strong>。</p>\n<h2 id=\"3-6-文章的发布\"><a href=\"#3-6-文章的发布\" class=\"headerlink\" title=\"3.6. 文章的发布\"></a>3.6. 文章的发布</h2><p>文章写好以后，可以<code>hexo s --debug</code>在本地查看一下。也可以<code>hexo d</code>直接从本地发布。</p>\n<p>但是既然我们已经搭建好CI系统，可以直接add，commit然后push，后面的事情就交给GitHub Actions完成了。</p>\n<h1 id=\"4-网站的其他设置\"><a href=\"#4-网站的其他设置\" class=\"headerlink\" title=\"4. 网站的其他设置\"></a>4. 网站的其他设置</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>​    博客除了<strong>文章</strong>外，还有<strong>页面</strong>。页面的模板就是<code>scaffolds/post.md</code>。可以有时间线、标签、目录等页面，页面也存放在<code>source</code>目录下。</p>\n<p>​    在<code>_config.yml</code>中，配置了这些页面的目录：</p>\n<p><img src=\"/jayant97.github.io/./imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221203225905257.png\" alt=\"image-20221203225905257\"></p>\n<p>​    基本上所有的配置你都可以在<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置 | Hexo</a> 和你所用的主题的官方文档中找到。</p>\n<h2 id=\"文章的永久链接（Permalinks）\"><a href=\"#文章的永久链接（Permalinks）\" class=\"headerlink\" title=\"文章的永久链接（Permalinks）\"></a>文章的永久链接（Permalinks）</h2><p>​\thexo默认的文章URL格式是<code>/年/月/日/文章标题</code>，如果你的文章标题有中文，这个URL就会巨长无比：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204210811289.png\" alt=\"image-20221204210811289\"></p>\n<p>​\t我的方案是改成用文章标题+日期的hash值去命名url，这样更简洁。</p>\n<p>​\t打开<strong>站点配置</strong><code>_config.yml</code>，修改：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:hash/</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t这样，文章的URL就会变成：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.assets/image-20221204211202297.png\" alt=\"image-20221204211202297\"></p>\n<p>​\t这样URL就比较短了。</p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><ul>\n<li><p>所有文章标题、文件名、目录名都不要有空格等特殊字符！！！</p>\n</li>\n<li><p>本博客使用了Gitalk作为评论系统，把页面仓库的Github Issue变成一个评论区。会有一些API key之类的东西，明文配置在hexo仓库中，所以我把hexo仓库的权限设为私有了</p>\n</li>\n<li><p>Front-Matter是yml格式，冒号<code>:</code>后面一定要加一个空格，不然识别不了</p>\n</li>\n<li><p>不要在Typora中右键点击图片然后缩放。这会把markdown格式插入的图片变成html格式，转换成hexo博客网站后识别不到图片。目前没看到比较好的缩放方案。</p>\n</li>\n</ul>\n","categories":["其他"],"tags":["hexo","GitHub Pages","GitHub Actions","Typora","博客搭建"]},{"title":"理解Zephyr项目的配置与构建系统","url":"/jayant97.github.io/2022/12/2a39e705bff0/","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>​\tZephyr Project是Linux基金会推出的一个Apache2.0开源项目，版权非常友好，适合用于商业项目开发。包含RTOS、编译系统、Zephyr组件。NCS中的例程基本都跑在[Zephyr RTOS](<a href=\"https://docs.zephyrproject.org/latest/kernel/index.html\">Kernel — Zephyr Project Documentation</a>)上。</p>\n<p>​\t对于之前只接触过MCU裸机开发的读者来说，Zephyr的配置和编译系统可能比较令人费解，因为这些工作都被Keil、IAR之类的IDE给封装好了。但是一旦你能掌握，就会发现它的方便之处。</p>\n<p>​\t本文会以最容易理解的方式讲解 Zephyr 的构建系统（Build System）。</p>\n<h1 id=\"2-ARM编译过程简介\"><a href=\"#2-ARM编译过程简介\" class=\"headerlink\" title=\"2. ARM编译过程简介\"></a>2. ARM编译过程简介</h1><p>​\t本节简要介绍一下通用的ARM固件编译过程，力求以最通俗易懂的方式来提供一些背景知识。</p>\n<h2 id=\"2-1-ARM程序的编译与链接\"><a href=\"#2-1-ARM程序的编译与链接\" class=\"headerlink\" title=\"2.1. ARM程序的编译与链接\"></a>2.1. ARM程序的编译与链接</h2><p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20221204234551290.png\" alt=\"image-20221204234551290\"></p>\n<p>简要步骤：</p>\n<ol>\n<li>你写的源码（<code>.c</code>，<code>.s</code>等），被编译器编译成目标文件(<code>.o</code>，<code>.lib</code>,<code>.a</code>等)</li>\n<li>目标文件里，函数被编译为机器码，变量也在其中。但是这时这些机器码还不知道要存放在flash中的哪个位置，变量也不知道要放在内存中的哪个位置。这时他们都还只是<strong>符号</strong>。即使是调用其他文件中的函数，也只是调用了一个符号而已，每个目标文件都不知道其他文件的函数具体的机器码是什么。</li>\n<li>链接脚本（<code>.ld</code>）描述了不同类型的二进制数据应该<strong>存放</strong>在ROM的哪个位置，运行时又应该<strong>加载</strong>到RAM中的哪个位置。这些二进制的数据包括代码、全局变量、堆、栈等。然后链接器根据链接脚本，把所有的目标文件和第三方库链接起来，生成最终的elf文件。</li>\n<li>elf文件是可执行文件，是机器码，也包含一些调试信息。为了方便烧录，也会使用<code>objcopy</code>工具将其转换成hex和bin，hex和bin是纯机器码。</li>\n</ol>\n<blockquote>\n<p>这些编译器、链接器就包含在之前安装的Zephyr工具链中</p>\n</blockquote>\n<h2 id=\"2-2-构建规则\"><a href=\"#2-2-构建规则\" class=\"headerlink\" title=\"2.2. 构建规则\"></a>2.2. 构建规则</h2><p>​\t实际的一个复杂项目构建的时候，会有很复杂的依赖关系。<code>.elf</code>文件依赖一堆<code>.o</code>和<code>.lib</code>和链接脚本文件才能生成，而<code>.o</code>和<code>.lib</code>文件又依赖<code>.c</code>和<code>.s</code>文件才能生成。</p>\n<p>​\t所有的依赖构成一个树形的关系。如果我们只改动了几个文件，那么就只编译要依赖这些源文件的目标文件，其他的目标文件就使用上次编译的，这样可以节约时间。</p>\n<p>​\t构建工具的作用，就是让我们把这些<strong>依赖关系</strong>和<strong>生成方式</strong>提前写进一个文件，然后构建工具自动根据这个文件的内容，如果发现一个source比一个target的文件日期新，那么就执行写好的命令，把target重新生成出来。</p>\n<p>​\t最有名的构建工具应该是Make，使用<code>Makefile</code>来描述各个文件之间的依赖关系，并且写明了该用什么命令来生成文件。之后只需敲一个<code>make</code>命令，它就会自动帮你把所有文件生成出来。</p>\n<p>​\tNCS中使用的工具是Ninja，其项目配置文件是<code>.ninja</code>。</p>\n<h1 id=\"3-Zephyr构建系统模块介绍\"><a href=\"#3-Zephyr构建系统模块介绍\" class=\"headerlink\" title=\"3. Zephyr构建系统模块介绍\"></a>3. Zephyr构建系统模块介绍</h1><h2 id=\"3-1-CMake\"><a href=\"#3-1-CMake\" class=\"headerlink\" title=\"3.1. CMake\"></a>3.1. CMake</h2><p>​\t目前，Zephyer中有成千上万的文件，如果要维护一组<code>Makefile</code>或者<code>.ninja</code>可能要累死。CMake的作用就是通过配置自动生成<code>Makefile</code>或者<code>.ninja</code>。</p>\n<p>​\t项目的CMake配置文件是<code>CMakeList.txt</code>，它可以引用库中其他组件的<code>CMakeList.txt</code>。可能你觉得这有点套娃，怎么又来个配置的配置。关于这一点，我认为，配置的<strong>灵活性</strong>和<strong>直接性</strong>总是不能兼得的，如果想简单粗暴几个选项就搞定，就得有好几层自动化的东西帮你完成其他工作。其实不只是配置，包括写代码，团队管理，社会运行规则都是这样的，这么说，CMake其实还挺哲学。</p>\n<h3 id=\"Zephyr中CMake的具体使用\"><a href=\"#Zephyr中CMake的具体使用\" class=\"headerlink\" title=\"Zephyr中CMake的具体使用\"></a>Zephyr中CMake的具体使用</h3><p>​\t我们不要自己去硬学CMake的语法，学了也记不住。要用的时候照葫芦画瓢或者现场查就好了。这里只介绍一下 Zephyer 中使用 CMake 的常用方式：</p>\n<p>​\tZephyr有自己的操作系统Kernel，所以应用代码是编译成<code>libapp.a</code>的。我们需要知道怎么把自己的源码编译进<code>libapp.a</code>。</p>\n<p>​\t在例程的<code>CMakeList.txt</code>中，可以看到添加自己源文件的方法为：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">target_sources</span>(app PRIVATE src/main.c) <span class=\"comment\"># 指定main.c为app这一target的源码</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>PRIVATE：源文件只被包含在这个app target中，修改源文件后，此target需要重新编译</li>\n<li>PUBLIC：源文件也会被包含进所有与此app链接的其他target中，修改源文件后，所有与app链接的target都要重新编译。一般PUBLIC只用于Include路径的设置。</li>\n</ul>\n</blockquote>\n<p>​\t</p>\n<p>​\t<strong>构建</strong>时，CMake首先处理当前项目文件夹下的<code>CMakeList.txt</code>，而这个<code>CMakeList.txt</code>又包含了NCS中<code>zephyr</code>目录下的<code>CMakeList.txt</code>，并依次包含所有的构建树中的<code>CMakeList.txt</code>。最终生成<code>Ninja</code>配置文件。</p>\n<p>​\t除此之外CMake还会同时调用一些python脚本生成其他文件，用于后续的编译环节。如DeviceTree和Kconfig的处理都是在这一配置阶段进行的。</p>\n<h2 id=\"3-2-DeviceTree\"><a href=\"#3-2-DeviceTree\" class=\"headerlink\" title=\"3.2. DeviceTree\"></a>3.2. DeviceTree</h2><p>​\t还记得我们打开一个例程后，创建一个新的Build时，需要选择一个Board吗？这个Board就是用DeviceTree描述的。</p>\n<p>​\t设备树的好处是，把硬件的详细信息（寄存器地址、引脚分配等）写在了驱动代码之外的地方。这样Zephyr就能提供通用的驱动代码了。</p>\n<p>​\tZephyr像Linux一样使用dts（设备树源码）来描述硬件，但Zephyr并不像Linux一样把dts编译成dtb，而是直接用python脚本把dts处理成头文件，直接编译进固件。</p>\n<blockquote>\n<p>​\t硬件信息包括CPU数量和架构、内存基地址和大小、总线和桥、外设的连接、中断使用情况、GPIO使用情况、时钟使用情况等。最开始这些内容被hard code在Linux内核源码中，但是这让kernel源码非常庞大臃肿。后来就使用DTS来描述硬件，然后在编译时将其编译为DTB，并在运行时由bootloader传递给kernel。</p>\n<p>​\t但Zephyr在MCU上运行，资源受限。所以直接在编译前，构建系统使用python脚本将dts转换为<code>.h</code>头文件，并包含进项目代码。</p>\n</blockquote>\n<p>​\t</p>\n<p>​\t由于dts是描述硬件的，所以<strong>每块板子</strong>都可以用一个dts描述，如<code>nrf9160dk_nrf9160_ns.dts</code>。</p>\n<p>这里有两个点需要注意：</p>\n<ul>\n<li><strong>不同的板子可能有共同的部分</strong>，比如不同的板子使用相同的MCU。所以，dts是可以包含其他dts的，通常描述<strong>芯片</strong>的文件为<code>.dtsi</code>，如<code>nrf9160_common.dtsi</code>。这样不同的使用nrf9160的板子都可以复用这个<code>.dtsi</code>。</li>\n<li><strong>同一块板子可能根据项目的不同，配置成不同的功能</strong>。为了解决这个问题，可以在<strong>当前项目文件夹</strong>下，<code>boards</code>文件夹下的<code>&lt;board&gt;.overlay</code>来进行覆盖。overlay文件中只需要写一小部分要修改的配置，在编译时，如果overlay和原板的dts配置了相同的项目，则优先采用overlay中的配置。</li>\n</ul>\n<p>​\t最终的配置生成顺序如下：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/1366713-20201222155014422-1085261766.png\" alt=\"img\"></p>\n<p>​\t通过板子本身标准的dts，以及覆盖的配置overlay，在<code>build/zephyr</code>路径下合并成完整的<code>zephyr.dts</code>。并最终转换成<code>build/zephyr/include/generated</code>目录下的<code>devicetree_unfixed.h</code>头文件。这就是最终源码中参考的头文件，里面描述了所有的硬件信息。</p>\n<p>​\t<strong>通常我们只修改overlay</strong>，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。</p>\n<p>nRF Connect for VS Code插件提供了查看硬件配置的图形化界面。编译完毕后，就可以查看：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20221128153536593.png\" alt=\"image-20221128153536593\"></p>\n<p>​\t如上图，先选择工作区中想要查看的项目，然后下方就会出现板卡的硬件描述。点进每一个描述，就可以跳转到对应层级的设备树文件中（<code>dtsi</code>,<code>dts</code>或<code>overlay</code>）。</p>\n<blockquote>\n<p>安全特性：</p>\n<p>​\tNordic开发板的硬件描述（dts）有<code>xxxdk_xxx.dts</code>和<code>xxxdk_xxx_ns.dts</code>两种。对应安全（secure）和非安全（<strong>n</strong>on-<strong>s</strong>ecure）两种配置。安全配置用到了TF-M，可参考<a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/2.1.2/tfm/introduction/index.html\">Introduction — Trusted Firmware-M documentation (nordicsemi.com)</a>。</p>\n</blockquote>\n<h2 id=\"3-3-Kconfig\"><a href=\"#3-3-Kconfig\" class=\"headerlink\" title=\"3.3. Kconfig\"></a>3.3. Kconfig</h2><p>​\t我们写代码时，都知道要用<code>#define</code>来定义一些宏，方便我们做配置和修改。但是，假如，我们有上万条配置怎么办？假如，我们要用一堆第三方库，它们每个都有自己的一堆配置怎么办？假如，配置之间还有依赖关系，必须启用一个才能启用另一个怎么办？</p>\n<p>​\tKconfig就给我们提供了一个很好的管理方式：</p>\n<ul>\n<li>Kconfig以菜单的形式来设置宏定义，并且能设置每个选项的依赖关系</li>\n<li>Kconfig可以给选项设置枚举范围，让你不容易配置错</li>\n<li>每个第三方库、模块都自带Kconfig。你的项目包含它们时，你的项目的Kconfig菜单也就把这些模块的Kconfig菜单作为子菜单了，非常方便。</li>\n</ul>\n<p>​\t</p>\n<p>​\t具体来说，<strong>项目文件夹中的<code>Kconfig</code>文件定义了本项目的配置，也定义了了本项目包含了哪些模块。</strong>每个模块（如蓝牙controller、CAN总线controller等）都有自己的Kconfig选项配置，并且成为本项目的子菜单。</p>\n<p>​\tApplication本身的配置、库的配置、编译器的编译选项、链接器的relocation等都可以通过Kconfig来进行。此外，application也可以定义自己的配置项。这样，最终本项目的Kconfig就会组合形成一个有几千个配置项的大菜单。</p>\n<p>​\t当然大多数情况下，我们只使用默认配置就行了。</p>\n<p>​\t和device tree一样，Kconfig也是支持<strong>覆盖</strong>的。Kconfig中大多数都是模块自带的默认配置，要想覆盖其中的某些配置，只需修改项目文件夹下的<code>prj.conf</code>文件即可。</p>\n<p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/1366713-20201222154609536-1676614851.png\" alt=\"img\"></p>\n<p>​\t如上图，<code>.conf</code>是最终合并的Kconfig，位于build目录下。而<code>autoconf.h</code>位于<code>build/zephyr/include/generated</code>目录下。</p>\n<p>​\t通常我们只修改<code>prj.conf</code>，其余部分让python脚本自动生成。这样的好处是可以对错误的配置进行提示。</p>\n<p>接下来，展示如何打开Kconfig的菜单，有三种方式：</p>\n<h3 id=\"1-nRF-Kconfig\"><a href=\"#1-nRF-Kconfig\" class=\"headerlink\" title=\"(1) nRF Kconfig\"></a>(1) nRF Kconfig</h3><p>​\t直接在VS Code中查看，可以在VS Code的NCS Action栏中找到：</p>\n<p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20221128162406563.png\" alt=\"image-20221128162406563\"></p>\n<blockquote>\n<p>右侧三个点也支持使用<code>menuconfig</code>和<code>guiconfig</code>的方式进行查看，这两种方式后面介绍。</p>\n</blockquote>\n<p>​\t保存Kconfig时，有三个选择：</p>\n<img src=\"/jayant97.github.io/imgs/理解Zephyr项目的配置与构建系统.assets/image-20221128162604764.png\" alt=\"image-20221128162604764\" style=\"zoom: 80%;\" />\n\n<ul>\n<li>Save：临时保存到build目录下的<code>.config</code>中。如果下次修改了其他配置，重新编译，此配置就会失效。</li>\n<li>Save to file：只保存修改的部分，可以选择保存到工程目录下的<code>prj.conf</code>或<code>boards/&lt;board&gt;.conf</code>中，后者的配置比前者优先生效。<br>  这个修改是永久的，只对本项目有效，且不会影响到NCS中模块本身的默认Kconfig。</li>\n<li>Save (minimal) to new file：只保存修改的部分到一个新文件中。</li>\n</ul>\n<h3 id=\"2-GuiConfig\"><a href=\"#2-GuiConfig\" class=\"headerlink\" title=\"(2) GuiConfig\"></a>(2) GuiConfig</h3><p>通过Kconfig旁边的三个点按钮，选择gui config，会弹出一个窗口让你进行配置。</p>\n<img src=\"/jayant97.github.io/imgs/理解Zephyr项目的配置与构建系统.assets/image-20221205003825310.png\" alt=\"image-20221205003825310\" style=\"zoom:50%;\" />\n\n<h3 id=\"3-menuconfig\"><a href=\"#3-menuconfig\" class=\"headerlink\" title=\"(3) menuconfig\"></a>(3) menuconfig</h3><p>​\t通过Kconfig旁边的三个点按钮，选择menuconfig，就是在命令行终端中进行配置。</p>\n<img src=\"/jayant97.github.io/imgs/理解Zephyr项目的配置与构建系统.assets/image-20221205004019331.png\" alt=\"image-20221205004019331\" style=\"zoom:50%;\" />\n\n<h3 id=\"Kconfig的查找\"><a href=\"#Kconfig的查找\" class=\"headerlink\" title=\"Kconfig的查找\"></a>Kconfig的查找</h3><p>​\t一个所有初学者都会有的问题是，<code>Kconfig</code>这么多，上哪里去知道它是什么意思？最直接的方式是看代码，Kconfig的选项在代码中都会有一个<code>CONFIG_</code>开头的宏与之对应，通过看代码就知道这个配置具体是做什么的了。</p>\n<p>​\t另一个方式是在NCS官方文档进行搜索：</p>\n<p><a href=\"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/kconfig/index.html\">Kconfig search — Kconfig reference (nordicsemi.com)</a></p>\n<p><img src=\"/jayant97.github.io/imgs/%E7%90%86%E8%A7%A3Zephyr%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F.assets/image-20221205004355203.png\" alt=\"image-20221205004355203\"></p>\n<p>​\t在这个页面直接输入你要查的选项，就可以查到所有Nordic和Zephyr官方库中的Kconfig的作用了。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p>​\t不论Zephyr的构建系统再复杂，最终底层都是编译、链接那一套，以这个为前提去学习，会少踩很多坑。DeviceTree和Kconfig都是<strong>方便</strong>我们开发而设计的，不要有对未知的畏难情绪。不需要硬学语法，开发都是基于Nordic已有的例程进行修改即可，遇到问题了再去查即可。</p>\n","categories":["RTOS","Zephyr"],"tags":["Nordic","Zephyr"]}]