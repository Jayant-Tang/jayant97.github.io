<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>在Matter中添加自己的蓝牙广播与服务 | 一苇万顷</title><meta name="author" content="Jayant Tang,jayant.tang@nordicsemi.no"><meta name="copyright" content="Jayant Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 简介在Matter设备中添加自己的蓝牙广播和服务是常见的需求。主要来自于两个方面： 一是功能的角度，因为Matter规定了每一种设备类型只能有它固定的操作，如果厂商有特殊的配置要传给设备，是没法通过Matter传输的。因为Apple, Google, Samsung等手机的家庭APP里不会有为厂商单独配置的界面。  实际上Matter也支持厂商自定义Cluster，只不过目前各大手机的家庭A">
<meta property="og:type" content="article">
<meta property="og:title" content="在Matter中添加自己的蓝牙广播与服务">
<meta property="og:url" content="https://jayant-tang.github.io/jayant97.github.io/2025/10/1b3f41652d5d/index.html">
<meta property="og:site_name" content="一苇万顷">
<meta property="og:description" content="1. 简介在Matter设备中添加自己的蓝牙广播和服务是常见的需求。主要来自于两个方面： 一是功能的角度，因为Matter规定了每一种设备类型只能有它固定的操作，如果厂商有特殊的配置要传给设备，是没法通过Matter传输的。因为Apple, Google, Samsung等手机的家庭APP里不会有为厂商单独配置的界面。  实际上Matter也支持厂商自定义Cluster，只不过目前各大手机的家庭A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png">
<meta property="article:published_time" content="2025-10-21T07:50:54.000Z">
<meta property="article:modified_time" content="2025-10-28T08:39:07.364Z">
<meta property="article:author" content="Jayant Tang">
<meta property="article:tag" content="Nordic">
<meta property="article:tag" content="Matter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png"><link rel="shortcut icon" href="/jayant97.github.io/img/favicon.png"><link rel="canonical" href="https://jayant-tang.github.io/jayant97.github.io/2025/10/1b3f41652d5d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/jayant97.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/jayant97.github.io/',
  algolia: undefined,
  localSearch: {"path":"/jayant97.github.io/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '在Matter中添加自己的蓝牙广播与服务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-28 16:39:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/jayant97.github.io/imgs/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/jayant97.github.io/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/jayant97.github.io/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/jayant97.github.io/" title="一苇万顷"><span class="site-name">一苇万顷</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">在Matter中添加自己的蓝牙广播与服务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-21T07:50:54.000Z" title="发表于 2025-10-21 15:50:54">2025-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-28T08:39:07.364Z" title="更新于 2025-10-28 16:39:07">2025-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/Matter/">Matter</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title="在Matter中添加自己的蓝牙广播与服务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/jayant97.github.io/2025/10/1b3f41652d5d/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在Matter设备中添加自己的蓝牙广播和服务是常见的需求。主要来自于两个方面：</p>
<p>一是功能的角度，因为Matter规定了每一种设备类型只能有它固定的操作，如果厂商有特殊的配置要传给设备，是没法通过Matter传输的。因为Apple, Google, Samsung等手机的家庭APP里不会有为厂商单独配置的界面。</p>
<blockquote>
<p>实际上Matter也支持厂商自定义Cluster，只不过目前各大手机的家庭APP无法操作这些自定义Cluster。</p>
</blockquote>
<p>二是生态的角度，智能家具厂商往往都有自己的手机APP。虽然Matter出现的目标是打破生态壁垒，但厂商肯定还是不愿意放弃自己的APP生态的，主打一个“我全都要”。</p>
<p>本文将会基于nRF Connect SDK v3.0.2说明如何在Nordic芯片平台上给Matter工程添加自己的蓝牙广播和服务。</p>
<h1 id="2-多蓝牙广播方案分析"><a href="#2-多蓝牙广播方案分析" class="headerlink" title="2. 多蓝牙广播方案分析"></a>2. 多蓝牙广播方案分析</h1><p>对于Matter over Wi-Fi 设备，Wi-Fi和BLE不是同一个射频硬件，只要互相不干扰就行。</p>
<p>对于Matter over Thread 设备，Nordic只需要一颗MCU，就可以实现BLE和Thread共用射频硬件，它们实际上在物理层是分时共存的：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined7e99575576b0cf2b4da41e00a995e054.png" alt="image-20251021162011675"></p>
<p>在Matter例程里，BLE广播只有2个应用场景：</p>
<ol>
<li>Matter配网阶段的设备发现：配网阶段，手机扫码后根据二维码信息扫描附近的BLE广播，确认要连接的是哪个设备。BLE连接后传输网络密钥，设备通过网络密钥链接到对应的网络后（Thread或者Wi-Fi），BLE的使命就结束了。设备入网后，BLE就关闭，只保留Thread或者Wi-Fi。</li>
<li>设备OTA升级：通过Zephyr的MCUMgr SMP Server蓝牙服务升级，需要手机APP中集成了MCUMgr SMP Client来对设备进行升级。</li>
</ol>
<p>我们会发现例程本身就有“Matter广播与私有广播共存”的用法了，因为SMP服务并不是Matter标准规定的，而是 Zephyr 通用的BLE OTA升级方案。</p>
<p>除此之外，nRF Connect SDK还支持多广播集（Multi ADV sets）共存，直接分时发出多个广播，可以各自具有不同的地址，从外部看起来就像是有多台BLE设备在广播一样。</p>
<p>因此，在Matter里面添加广播，有两个方案。</p>
<h2 id="方案一：Matter-蓝牙广播仲裁器"><a href="#方案一：Matter-蓝牙广播仲裁器" class="headerlink" title="方案一：Matter 蓝牙广播仲裁器"></a>方案一：Matter 蓝牙广播仲裁器</h2><p>Matter已经把SDK平台提供的蓝牙功能封装成了自己的API，其具体的实现位于：</p>
<p><code>v3.0.2\modules\lib\matter\src\platform\Zephyr\BLEManagerImpl.cpp</code></p>
<p>其中，有一个功能叫做广播仲裁器（Advertising Arbiter），是一个C++类。广播还是同一个广播，但是可以让你替换广播数据，从而实现替换广播名称、广播的UUID等等，在NCS中甚至还能改MAC地址（需要修改SDK源码）。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedb5958e874aa216464360d5bc9927f605.png" alt="image-20251021165035555"></p>
<p>这个是Matter本身就提供的功能，也是推荐使用的方案。在Matter（CHIP）协议栈初始化之后，CHIP Server启动之前，可以通过仲裁器注册一组广播请求，包含广播数据、广播间隔、回调函数、优先级等等。</p>
<p>CHIP Server启动后，每个需要蓝牙广播的软件模块可以主动插入请求（Insert Request）或者取消请求（Cancel Request）。仲裁器会根据优先级排列当前所有的插入请求的广播，并执行优先级最高的（top-priority）广播。</p>
<p>比如你可以这样设置优先级：</p>
<ul>
<li>Matter配网广播：0，最高</li>
<li>私有BLE广播：1</li>
<li>OTA广播：uint8_max</li>
</ul>
<p>当一个广播成为优先级最高的广播时，会触发提前注册好的<code>onStarted</code>回调函数；或者不再成为优先级最高的广播时，会触发提前注册好的<code>onStopped</code>回调函数。</p>
<p>整个框架都是完善的，Matter SDK已经提供好了。全程只有一个蓝牙广播，只需切换它的内容。</p>
<h2 id="方案二：Zephyr多广播集（Multi-ADV-sets）"><a href="#方案二：Zephyr多广播集（Multi-ADV-sets）" class="headerlink" title="方案二：Zephyr多广播集（Multi ADV sets）"></a>方案二：Zephyr多广播集（Multi ADV sets）</h2><p>Matter蓝牙仲裁器的方案有一个小缺点，就是没办法让产品一开机就同时广播Matter配网和厂商的私有蓝牙，需要用户先进行某种操作。比如，有以下几种方案：</p>
<ul>
<li>通过产品上的按钮来选择当前应该进行哪个广播</li>
<li>先发出Matter配网广播，等产品配网成功后，再发出厂商自己的广播供APP连接</li>
<li>先发出厂商自己广播，等连接完厂商的APP之后，再去APP里操作开启Matter配网广播</li>
</ul>
<p>如果你不能接受这个小缺点，可以看Nordic的多广播共存方案，可以直接开启多个广播：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined52b5be21062af907892d2e21c37deedc.png" alt="image-20251021170819938"></p>
<p>这时，使用的蓝牙广播API就不是普通的<code>bt_le_adv_start()</code>，而是<code>bt_le_ext_adv_start()</code>。用这个API可以创建多个广播集。</p>
<blockquote>
<p>可能有人对这里的API名字中的”扩展广播“有误解，这里需要解释一下。</p>
<p>在Bluetooth Core Spec 5.0中，有一个新特性叫做扩展广播（Extended Advertising），它其实包含四个部分：</p>
<ol>
<li>允许255字节的广播数据PDU和扫描响应数据PDU，但是必须位于0-36信道。原来的广播信道37, 38, 39仍然只有31字节的PDU。</li>
<li>允许通过多个扩展广播包形成链的形式，广播至多1650字节数据 。初始的广播包在37，38，39信道，然后跳到0-36信道。</li>
<li>允许广播有多个实例集合，这个广播实例可以是普通广播也可以是前面第1项描述的”变长“的广播</li>
<li>新特性：周期性广播。让广播间隔不再随机，这样observer端就可以不用持续开启扫描窗口，从而节省功耗</li>
</ol>
<p>因此<strong>扩展广播（Extended Advertising）</strong>指的是以上4个功能，而不是很多科普文章只提到的1号的功能。</p>
<p>参考连接：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bluetooth.com/zh-cn/bluetooth-resources/bluetooth-core-5-0-go-faster-go-further/">蓝牙™ Core 5.0功能 增强版 |蓝牙™ 技术网站</a></p>
<p>Zephyr 的<code>bt_le_ext_adv</code> API可以实现以上所有4个功能。我们这里需要用到的是功能3。具体的链路层广播分时共存是由Nordic SoftDevice Controller自动实现的。</p>
</blockquote>
<p>如果要使用这个方案，就需要修改NCS中的Matter源代码，把蓝牙广播仲裁器里面使用的广播的API改成<code>bt_le_ext_adv_start()</code>。</p>
<p>此外，扩展广播的<code>connected()</code>回调函数定义是不一样的，除了要记录<code>conn</code>之外，还能知道是从哪个广播连进来的：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined9bf37427840f60ad73a8cf5660288d89.png" alt="image-20251021183010806"></p>
<p>实际应用开发中，我们可能有多个蓝牙业务的软件模块，每个模块里面各自有自己的广播和服务。软件模块可以各自注册不同的<code>bt_le_ext_adv_cb</code>。</p>
<h1 id="3-多蓝牙连接与多蓝牙服务方案分析"><a href="#3-多蓝牙连接与多蓝牙服务方案分析" class="headerlink" title="3. 多蓝牙连接与多蓝牙服务方案分析"></a>3. 多蓝牙连接与多蓝牙服务方案分析</h1><p>Zephyr的蓝牙只有一个GATT Server。因此，无论你用前面的哪个蓝牙多广播方案，无论外部的BLE主机是通过哪个广播连接进来的，看到的蓝牙服务都是一样的。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedcbec65bc87613ac3d663fa5805e7fdb6.png" alt="image-20251021180814475"></p>
<h2 id="普通广播连接时回调"><a href="#普通广播连接时回调" class="headerlink" title="普通广播连接时回调"></a>普通广播连接时回调</h2><p>在普通的蓝牙广播（<code>bt_le_adv_start()</code>）场景下，蓝牙连接成功时，在<code>connected()</code>回调函数里，一定要把<code>conn</code>记录下来作为句柄：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined856ea6b709377794ad6d8e8ebe50685a.png" alt="image-20251021181113185"></p>
<p>如果从机被多个主机连接，开发者应该保存每个<code>conn</code>指针。后续进行GATT特征读写的时候，就靠<code>conn</code>来指定发送数据给哪个主机，同时也靠<code>conn</code>来判断数据是从哪台主机发来的。</p>
<p>注意，这种<code>connected()</code>回调函数可以注册很多个，形成链表。当连接成功时，所有<code>connected()</code>函数会依次执行。任何软件模块都可以注册自己的<code>connected()</code>来获取蓝牙连接、断开相关的事件。</p>
<blockquote>
<p>代码里的<code>bt_conn_ref()</code>是给<code>conn</code>指针增加引用计数，防止其资源被操作系统自动释放。连接断开后再用<code>bt_conn_unref()</code>减少引用计数即可。</p>
<p><strong>如果一个连接被多次引用，那么后续连接断开后，一定要释放相同的次数，否则将会出现内存泄漏</strong>。</p>
<p>一般在<code>connected()</code>回调函数里面调用了一次<code>bt_conn_ref()</code>，那么就在<code>disconnected()</code>回调函数里面调用一次<code>bt_conn_unref()</code>即可。</p>
<p>即使有多个软件模块各自注册了自己的<code>connected()</code>和<code>disconnected()</code>，在里面各自执行<code>bt_conn_ref()</code>和<code>bt_conn_unref()</code>也没关系。只要保证它们的数量是成对的即可</p>
</blockquote>
<h2 id="扩展广播连接时回调"><a href="#扩展广播连接时回调" class="headerlink" title="扩展广播连接时回调"></a>扩展广播连接时回调</h2><p>与普通广播的回调函数不同，扩展广播的<code>connected()</code>回调函数<strong>不是放在一个链表里，而是独立的。</strong></p>
<p>这意味着，当你有多个扩展广播时，如果一个蓝牙主机连接其中一个扩展广播，那么只有那个扩展广播的<code>connected()</code>回调函数会执行，这就避免了混乱。</p>
<blockquote>
<p>但是如果此时还有已注册的普通<code>connected()</code>回调，还是会把整个链表都调用一遍。</p>
</blockquote>
<p>但是，所有的<code>disconnect()</code>回调函数仍然是处于同一个链表的。因此一定要在<code>disconnected()</code>回调函数里面判断一下当前的<code>*conn</code>句柄是不是建立连接的时候保存的那个，如果是，再进行相关释放动作。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_le_ext_adv</span> *<span class="title">ext_adv1</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_conn</span> *<span class="title">ext_conn1</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时回调</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">connected1</span><span class="params">(<span class="keyword">struct</span> bt_le_ext_adv *extadv,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> bt_le_ext_adv_connected_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    ext_conn1 = bt_conn_ref(info-&gt;conn);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给扩展广播注册connected回调</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bt_le_ext_adv_cb</span> <span class="title">adv_ext_cb1</span> =</span> &#123;</span><br><span class="line">    .connected = connected1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开时</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disconnected</span><span class="params">(<span class="keyword">struct</span> bt_conn *conn, <span class="type">uint8_t</span> reason)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 连接断开不属于当前业务，不处理</span></span><br><span class="line">    <span class="keyword">if</span>(conn != ext_conn1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加释放动作等</span></span><br><span class="line">    bt_conn_unref(ext_conn1);</span><br><span class="line">    ext_conn1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通广播方式，不注册connected</span></span><br><span class="line">BT_CONN_CB_DEFINE(conn_callbacks) = &#123;</span><br><span class="line">    .connected    = <span class="literal">NULL</span>,</span><br><span class="line">    .disconnected = disconnected,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-多蓝牙地址分析"><a href="#4-多蓝牙地址分析" class="headerlink" title="4. 多蓝牙地址分析"></a>4. 多蓝牙地址分析</h1><p>要让自己的蓝牙广播和Matter共存，并且两者的蓝牙设备地址不同。</p>
<p>Zephyr本身就支持多蓝牙地址，在Zephyr中它被称为蓝牙身份（Bluetooth Identity）。</p>
<p>蓝牙身份保存在一个数组中，数组长度是<code>CONFIG_BT_ID_MAX</code>，默认是1。</p>
<p>可以通过各种方式，在蓝牙协议栈初始化（<code>bt_enable()</code>）之前或之后，创建各种蓝牙地址，并保存到蓝牙身份数组。</p>
<p>这一方面详细的介绍，请参考《<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/articles/19166250">NCS(Zephyr)中的蓝牙地址详解</a>》。</p>
<h2 id="蓝牙广播地址切换"><a href="#蓝牙广播地址切换" class="headerlink" title="蓝牙广播地址切换"></a>蓝牙广播地址切换</h2><p>不论是普通广播还是扩展广播，在开启广播时都要使用<code>bt_le_adv_param</code>作为广播相关的配置参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** LE Advertising Parameters. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bt_le_adv_param</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Local identity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span>  id;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广播参数结构体的第一个成员就是<code>id</code>。大多数蓝牙例程的广播参数都使用<code>0</code>作为<code>id</code>，也就是使用蓝牙身份数组的第1个身份。</p>
<p>在开启广播的时候，我们可以修改设置广播参数中的<code>id</code>来选择自己用哪个蓝牙身份。</p>
<h2 id="Matter使用的蓝牙身份"><a href="#Matter使用的蓝牙身份" class="headerlink" title="Matter使用的蓝牙身份"></a>Matter使用的蓝牙身份</h2><p>首先我们要明确几个要求：</p>
<ul>
<li>Matter标准规定，Matter的配网广播必须使用<strong>Random Static Address</strong>，且每次上电都要变化，从而确保隐私。</li>
</ul>
<p>在<code>v3.0.2/modules/lib/matter/src/platform/Zephyr/BLEAdvertisingArbiter.cpp</code>中，可以看到每次广播开启时都设置了使用的<code>id</code>。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined51746b4f706d5d682b2ea2016ba3a766.png" alt="image-20251026205602364"></p>
<h2 id="Matter创建的蓝牙身份"><a href="#Matter创建的蓝牙身份" class="headerlink" title="Matter创建的蓝牙身份"></a>Matter创建的蓝牙身份</h2><p>前面使用的<code>sBtIid</code>是在<code>v3.0.2/modules/lib/matter/src/platform/Zephyr/BLEManagerImpl.cpp</code>中赋值的：</p>
<p>在<code>CHIP_ERROR BLEManagerImpl::_Init()</code>函数中，有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BT_BONDABLE</span></span><br><span class="line">    <span class="type">bt_addr_le_t</span> idsAddr[CONFIG_BT_ID_MAX];</span><br><span class="line">    <span class="type">size_t</span> idsCount = CONFIG_BT_ID_MAX;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">bt_enable</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VerifyOrReturnError</span>(err == <span class="number">0</span>, <span class="built_in">MapErrorZephyr</span>(err));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">settings_load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bt_id_get</span>(idsAddr, &amp;idsCount);</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">InitRandomStaticAddress</span>(idsCount &gt; <span class="number">1</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VerifyOrReturnError</span>(err == <span class="number">0</span> &amp;&amp; id == kMatterBleIdentity, <span class="built_in">MapErrorZephyr</span>(err));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    err = <span class="built_in">InitRandomStaticAddress</span>(<span class="literal">false</span>, id);</span><br><span class="line">    <span class="built_in">VerifyOrReturnError</span>(err == <span class="number">0</span> &amp;&amp; id == kMatterBleIdentity, <span class="built_in">MapErrorZephyr</span>(err));</span><br><span class="line">    err = <span class="built_in">bt_enable</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">VerifyOrReturnError</span>(err == <span class="number">0</span>, <span class="built_in">MapErrorZephyr</span>(err));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CONFIG_BT_BONDABLE</span></span></span><br></pre></td></tr></table></figure>

<p>首先，Matter的蓝牙广播是不允许绑定的。Matter协议栈会根据系统的其他蓝牙广播是否支持绑定（<code>CONFIG_BT_BONDABLE</code>）来执行不同的初始化过程：</p>
<ul>
<li><p>如果系统没有蓝牙绑定功能，则在<code>bt_enable()</code>之前先尝试用随机数创建<code>id=0</code>的蓝牙身份</p>
</li>
<li><p>如果系统有蓝牙绑定功能，则先等<code>bt_enable()</code>和<code>settings_load()</code>创建<code>id=0</code>创建蓝牙身份，然后Matter再用随机数创建<code>id=1</code>的蓝牙身份</p>
</li>
</ul>
<p>创建完毕后，在初始化Matter蓝牙广播仲裁器时传入参数，给<code>sBtId</code>赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BLEAdvertisingArbiter::<span class="built_in">Init</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(id));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，不要直接打开或者关闭<code>CONFIG_BT_BONDABLE</code>。这只是一个中间的临时选项。</p>
<p>要开启蓝牙绑定功能：开启<code>CONFIG_BT_SMP=y</code>，它会自动select开启<code>CONFIG_BT_BONDABLE</code>。</p>
</blockquote>
<h1 id="5-双蓝牙共存方案实例"><a href="#5-双蓝牙共存方案实例" class="headerlink" title="5. 双蓝牙共存方案实例"></a>5. 双蓝牙共存方案实例</h1><p>基于前面对Matter源代码的分析，以及《<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/articles/19166250">NCS(Zephyr)中的蓝牙地址详解</a>》中对Zephyr初始化蓝牙地址的介绍。我们会发现双蓝牙地址共存的方案有很多影响因素：</p>
<ol>
<li>使用前面介绍的“蓝牙仲裁器方案”或“多扩展广播方案”？</li>
<li>自己的蓝牙服务是否需要绑定？</li>
<li>自己的私有蓝牙广播是否需要使用公共地址（Public Address）？</li>
<li>自己的芯片是单核蓝牙SoC（如nRF54L15）还是双核蓝牙SoC（如nRF5340）？</li>
</ol>
<p>这样一共是2×2×2×2，有16种可能性的组合，实在太多，本文无法一一分析介绍。</p>
<p>本文在这里列出2种比较常见的方案，读者可以举一反三，实现自己的多蓝牙地址方案。</p>
<h2 id="案例一：“蓝牙仲裁器方案”-需绑定-使用公共地址-单核SoC"><a href="#案例一：“蓝牙仲裁器方案”-需绑定-使用公共地址-单核SoC" class="headerlink" title="案例一：“蓝牙仲裁器方案” + 需绑定 + 使用公共地址 + 单核SoC"></a>案例一：“蓝牙仲裁器方案” + 需绑定 + 使用公共地址 + 单核SoC</h2><h3 id="（1）设置两个地址"><a href="#（1）设置两个地址" class="headerlink" title="（1）设置两个地址"></a>（1）设置两个地址</h3><p>首先，设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_ID_MAX=2</span><br><span class="line">CONFIG_BT_SMP=y</span><br><span class="line">CONFIG_BT_MAX_CONN=2</span><br></pre></td></tr></table></figure>

<p><code>#include &lt;zephyr/bluetooth/controller.h&gt;</code></p>
<p>单核Soc，直接在Matter初始化之前设置公共地址到Controller层。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedb6587de7976c1524cc5c378771aaa111.png" alt="image-20251027150520780"></p>
<p>由于我们开启了蓝牙绑定<code>CONFIG_BT_SMP=y</code>功能，Matter协议栈里面会先执行<code>bt_enable()</code>和<code>settings_load()</code>，从而设置好<code>id=0</code>的蓝牙公共地址。</p>
<p>然后Matter会再创建自己用的<code>id=1</code>的随机静态地址。</p>
<h3 id="（2）使用广播仲裁器编写自己的蓝牙广播c-代码"><a href="#（2）使用广播仲裁器编写自己的蓝牙广播c-代码" class="headerlink" title="（2）使用广播仲裁器编写自己的蓝牙广播c++代码"></a>（2）使用广播仲裁器编写自己的蓝牙广播c++代码</h3><p>写了一个c++类<code>AppBle</code>，使用单例模式，部分代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BT_CONN_CB_DEFINE</span>(conn_callbacks) = &#123;</span><br><span class="line">    .connected = AppBle::Connected,</span><br><span class="line">    .disconnected = AppBle::Disconnected,</span><br><span class="line">    .le_param_updated = AppBle::LeParamUpdated,</span><br><span class="line">    .security_changed = AppBle::SecurityChanged,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> kFlags = BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> k_ccs_uuid[] = &#123;BT_COMMUNICATION_SERVICE&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> k_adv_name[] = <span class="string">&quot;My_ADV&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ::chip;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ::chip::DeviceLayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AppBle::Init</span><span class="params">(<span class="type">uint8_t</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 设置广播数据，以及当前广播成为top广播时的回调函数</span></span><br><span class="line">    mAdvData[<span class="number">0</span>] = <span class="built_in">BT_DATA</span>(BT_DATA_FLAGS, &amp;kFlags, <span class="built_in">sizeof</span>(kFlags));</span><br><span class="line">    mAdvData[<span class="number">1</span>] = <span class="built_in">BT_DATA</span>(BT_DATA_NAME_COMPLETE, k_adv_name, <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(<span class="built_in">strlen</span>(k_adv_name)));    </span><br><span class="line">    mScanRespData[<span class="number">0</span>] = <span class="built_in">BT_DATA</span>(BT_DATA_UUID128_ALL, k_ccs_uuid,  <span class="built_in">sizeof</span>(k_ccs_uuid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用public地址时，广播参数要携带 BT_LE_ADV_OPT_USE_IDENTITY</span></span><br><span class="line">    mAdvertisingRequest.priority = priority;</span><br><span class="line">    mAdvertisingRequest.options = (BT_LE_ADV_OPT_USE_IDENTITY | BT_LE_ADV_OPT_CONN);</span><br><span class="line">    mAdvertisingRequest.minInterval = mAdvIntervalMin;</span><br><span class="line">    mAdvertisingRequest.maxInterval = mAdvIntervalMax;</span><br><span class="line">    mAdvertisingRequest.advertisingData = ::chip::<span class="built_in">Span</span>&lt;bt_data&gt;(mAdvData);</span><br><span class="line">    mAdvertisingRequest.scanResponseData = ::chip::<span class="built_in">Span</span>&lt;bt_data&gt;(mScanRespData);</span><br><span class="line"></span><br><span class="line">    mAdvertisingRequest.onStarted = [](<span class="type">int</span> rc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">Instance</span>().mIsStarted = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">LOG_INF</span>(<span class="string">&quot;private advertising started.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG_ERR</span>(<span class="string">&quot;Failed to start Private BLE advertising: %d&quot;</span>, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mAdvertisingRequest.onStopped = []() &#123;</span><br><span class="line">        <span class="built_in">Instance</span>().mIsStarted = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">LOG_INF</span>(<span class="string">&quot;Private advertising stopped.&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向Matter BLE仲裁器申请开启广播. 当没有优先级更高的广播时,将适用本广播的数据和参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AppBle::StartServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Instance</span>().mConn = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PlatformMgr</span>().<span class="built_in">LockChipStack</span>();</span><br><span class="line">    CHIP_ERROR ret = BLEAdvertisingArbiter::<span class="built_in">InsertRequest</span>(mAdvertisingRequest);</span><br><span class="line">    <span class="built_in">PlatformMgr</span>().<span class="built_in">UnlockChipStack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CHIP_NO_ERROR != ret) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERR</span>(<span class="string">&quot;Could not start private advertising&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向Matter BLE仲裁器申请关闭当前广播.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppBle::StopServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mIsStarted)&#123;</span><br><span class="line">        <span class="built_in">LOG_WRN</span>(<span class="string">&quot;private ADV was already stopped&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PlatformMgr</span>().<span class="built_in">LockChipStack</span>();</span><br><span class="line">    BLEAdvertisingArbiter::<span class="built_in">CancelRequest</span>(mAdvertisingRequest);</span><br><span class="line">    <span class="built_in">PlatformMgr</span>().<span class="built_in">UnlockChipStack</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppBle::Connected</span><span class="params">(bt_conn *conn, <span class="type">uint8_t</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Instance</span>().mIsStarted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err || !conn) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERR</span>(<span class="string">&quot;private ADV connection failed (err %u)&quot;</span>, err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOG_INF</span>(<span class="string">&quot;## private ADV connected: %s ##&quot;</span>, <span class="built_in">LogAddress</span>(conn));</span><br><span class="line">        <span class="built_in">LOG_INF</span>(<span class="string">&quot;Will disconnect if no data transfer after %ds&quot;</span>, AppBle::<span class="built_in">Instance</span>().mDisconnectTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前连接</span></span><br><span class="line">        <span class="built_in">Instance</span>().mConn = <span class="built_in">bt_conn_ref</span>(conn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发起绑定</span></span><br><span class="line">        <span class="built_in">bt_conn_set_security</span>(conn, BT_SECURITY_L3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppBle::Disconnected</span><span class="params">(bt_conn *conn, <span class="type">uint8_t</span> reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Instance</span>().mIsStarted) &#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;private Adv not started&quot;</span>);</span><br><span class="line">        <span class="built_in">Instance</span>().mConn = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="built_in">Instance</span>().mConn) &#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;Not private Connection&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INF</span>(<span class="string">&quot;## private ADV disconnected: %s&quot;</span>, <span class="built_in">LogAddress</span>(conn));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Instance</span>().mConn != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">bt_conn_unref</span>(<span class="built_in">Instance</span>().mConn);</span><br><span class="line">        <span class="built_in">Instance</span>().mConn = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppBle::SecurityChanged</span><span class="params">(bt_conn *conn, <span class="type">bt_security_t</span> level, <span class="keyword">enum</span> bt_security_err err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Instance</span>().mIsStarted)&#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;private Adv not started&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="built_in">Instance</span>().mConn) &#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;Not private Connection&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="built_in">LOG_INF</span>(<span class="string">&quot;BT Security changed: %s level %u&quot;</span>, <span class="built_in">LogAddress</span>(conn), level);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERR</span>(<span class="string">&quot;BT Security failed: level %u err %d&quot;</span>, level, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppBle::LeParamUpdated</span><span class="params">(<span class="keyword">struct</span> bt_conn *conn, <span class="type">uint16_t</span> interval, <span class="type">uint16_t</span> latency, <span class="type">uint16_t</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Instance</span>().mIsStarted)&#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;private Adv not started&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="built_in">Instance</span>().mConn) &#123;</span><br><span class="line">        <span class="built_in">LOG_DBG</span>(<span class="string">&quot;Not private Connection&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_INF</span>(<span class="string">&quot;private ADV conn interval changed with %s&quot;</span>, <span class="built_in">LogAddress</span>(conn));</span><br><span class="line">    <span class="built_in">LOG_INF</span>(<span class="string">&quot;interval=%d, latency=%d, timeout=%d&quot;</span>, interval, latency, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">AppBle::LogAddress</span><span class="params">(bt_conn *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LOG</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> addr[BT_ADDR_LE_STR_LEN];</span><br><span class="line">    <span class="built_in">bt_addr_le_to_str</span>(<span class="built_in">bt_conn_get_dst</span>(conn), addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>AppTask.cpp</code>中，注册自己的私有广播：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CHIP_ERROR <span class="title">AppTask::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize Matter stack */</span></span><br><span class="line">    <span class="built_in">ReturnErrorOnFailure</span>(Nrf::Matter::<span class="built_in">PrepareServer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ReturnErrorOnFailure</span>(Nrf::Matter::<span class="built_in">RegisterEventHandler</span>(AppTask::DefaultMatterEventHandler, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化私有广播，优先级1，比Matter配网广播更低</span></span><br><span class="line">    AppBle::<span class="built_in">Instance</span>().<span class="built_in">Init</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启蓝牙配网广播，任务入队列</span></span><br><span class="line">    Nrf::<span class="built_in">PostTask</span>([] &#123;</span><br><span class="line">        AppTask::<span class="built_in">Instance</span>().<span class="built_in">StartBLEAdvertisement</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启私有广播，任务入队列</span></span><br><span class="line">    Nrf::<span class="built_in">PostTask</span>([] &#123;</span><br><span class="line">        AppBle::<span class="built_in">Instance</span>().<span class="built_in">StartServer</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动Matter协议栈</span></span><br><span class="line">    <span class="keyword">return</span> Nrf::Matter::<span class="built_in">StartServer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）修改广播仲裁器源码"><a href="#（3）修改广播仲裁器源码" class="headerlink" title="（3）修改广播仲裁器源码"></a>（3）修改广播仲裁器源码</h3><p>在<code>v3.0.2/modules/lib/matter/src/platform/Zephyr/BLEAdvertisingArbiter.h</code></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedd5b2ea434f2ea7e51d6cd05e87033227.png" alt="image-20251027153951723"></p>
<p>修改广播仲裁器源码，当检测到广播参数包含我们设置的<code>BT_LE_ADV_OPT_USE_IDENTITY</code>时，就临时切换到<code>id=0</code>的蓝牙身份（公共地址）。其他情况下，就正常使用Matter自己的<code>id=1</code>的蓝牙身份。</p>
<blockquote>
<p>蓝牙广播仲裁器方案的优势是，对SDK的修改最少，只有上面展示的部分。并且这种修改完全不影响正常的Matter例程</p>
</blockquote>
<h2 id="案例二：“扩展广播方案”-需绑定-使用公共地址-双核SoC"><a href="#案例二：“扩展广播方案”-需绑定-使用公共地址-双核SoC" class="headerlink" title="案例二：“扩展广播方案” + 需绑定 + 使用公共地址 + 双核SoC"></a>案例二：“扩展广播方案” + 需绑定 + 使用公共地址 + 双核SoC</h2><h3 id="（1）设置两个地址-1"><a href="#（1）设置两个地址-1" class="headerlink" title="（1）设置两个地址"></a>（1）设置两个地址</h3><p>首先，设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_ID_MAX=2</span><br><span class="line">CONFIG_BT_SMP=y</span><br></pre></td></tr></table></figure>

<p>由于是双核SoC，必须在<code>bt_enable()</code>和<code>settings_load()</code>之间用HCI命令设置公共地址。</p>
<p>在<code>v3.0.2/modules/lib/matter/src/platform/Zephyr/BLEManagerImpl.cpp</code>中：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefined60067f1a4db598f3ecd1f2ccc87c6282.png" alt="image-20251027154808135"></p>
<p>由于我们开启了蓝牙绑定<code>CONFIG_BT_SMP=y</code>功能，把《<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/articles/19166250">NCS(Zephyr)中的蓝牙地址详解</a>》介绍的HCI设置公共地址的函数插入到上图的位置。那么在<code>settings_load()</code>时就会自动创建<code>id=0</code>的公共地址蓝牙身份。在后续的<code>InitRandomStaticAddress()</code>中，会创建<code>id=1</code>的静态随机地址蓝牙身份，供Matter使用。</p>
<h3 id="（2）把Matter广播改成扩展广播"><a href="#（2）把Matter广播改成扩展广播" class="headerlink" title="（2）把Matter广播改成扩展广播"></a>（2）把Matter广播改成扩展广播</h3><p>先设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_EXT_ADV=y</span><br><span class="line">CONFIG_BT_EXT_ADV_MAX_ADV_SET=2</span><br><span class="line">CONFIG_BT_MAX_CONN=2</span><br></pre></td></tr></table></figure>

<p><code>v3.0.2\modules\lib\matter\src\platform\Zephyr\BLEManagerImpl.h</code>:</p>
<p>把connected回调函数从C++私有成员（private）改成C++公共成员（public）。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedf5178032ab16701130068acb45ee84a2.png" alt="image-20251027155806635"></p>
<p><code>v3.0.2\modules\lib\matter\src\platform\Zephyr\BLEManagerImpl.cpp</code>：</p>
<p>把connected回调函数取消注册，因为后面要在扩展广播里面注册：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedff30110b3494195396ee7239bde87d89.png" alt="image-20251027155919624"></p>
<p>先extern声明一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> bt_conn *matter_conn;</span><br></pre></td></tr></table></figure>

<p>然后在disconnected回调函数中，添加判断：当前断开事件是不是属于Matter广播的断开事件，如果不是就不管。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/undefinedd61d2864bfe01dd42569bd24f4683874.png" alt="image-20251027160111687"></p>
<p>最后是<code>v3.0.2\modules\lib\matter\src\platform\Zephyr\BLEAdvertisingArbiter.cpp</code>，这个改动就太大了，直接贴全部代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Copyright (c) 2023 Project CHIP Authors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *    you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *    You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *    See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *    limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BLEAdvertisingArbiter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib/support/CodeUtils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib/support/logging/CHIPLogging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;platform/CHIPDeviceLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;platform/Zephyr/BLEManagerImpl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system/SystemError.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/bluetooth/conn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bt_le_ext_adv *matter_ext_adv = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bt_conn</span> *matter_conn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">matter_ext_adv_connected_cb</span><span class="params">(<span class="keyword">struct</span> bt_le_ext_adv *extadv,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">struct</span> bt_le_ext_adv_connected_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __ASSERT(extadv == matter_ext_adv, <span class="string">&quot;Matter adv wrong&quot;</span>);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;## Matter ext adv connected %p ##\n&quot;</span>, info-&gt;conn);</span><br><span class="line">    matter_conn = info-&gt;conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move the original connected() callback here</span></span><br><span class="line">    chip::DeviceLayer::Internal::BLEManagerImpl::<span class="built_in">HandleConnect</span>(matter_conn, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bt_le_ext_adv_cb</span> adv_matter_cb = &#123;</span><br><span class="line">    .connected = matter_ext_adv_connected_cb</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> chip &#123;</span><br><span class="line"><span class="keyword">namespace</span> DeviceLayer &#123;</span><br><span class="line"><span class="keyword">namespace</span> BLEAdvertisingArbiter &#123;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of advertising requests ordered by priority</span></span><br><span class="line"><span class="type">sys_slist_t</span> sRequests;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> sIsInitialized    = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> sWasDisconnection = <span class="literal">false</span>;</span><br><span class="line"><span class="type">uint8_t</span> sBtId          = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast an intrusive list node to the containing request object</span></span><br><span class="line"><span class="function"><span class="type">const</span> BLEAdvertisingArbiter::Request &amp; <span class="title">ToRequest</span><span class="params">(<span class="type">const</span> <span class="type">sys_snode_t</span> * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;<span class="type">const</span> BLEAdvertisingArbiter::Request *&gt;(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify application about stopped advertising if the callback has been provided</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyAdvertisingStopped</span><span class="params">(<span class="type">const</span> <span class="type">sys_snode_t</span> * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">VerifyOrReturn</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Request &amp; request = <span class="built_in">ToRequest</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.onStopped != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        request.<span class="built_in">onStopped</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restart advertising using the top-priority request</span></span><br><span class="line"><span class="function">CHIP_ERROR <span class="title">RestartAdvertising</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> first_time = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (first_time) &#123;</span><br><span class="line">        first_time = <span class="literal">false</span>; </span><br><span class="line">        bt_le_adv_param first_param = <span class="built_in">BT_LE_ADV_PARAM_INIT</span>(BT_LE_ADV_OPT_CONN, BT_GAP_ADV_FAST_INT_MIN_1, BT_GAP_ADV_FAST_INT_MAX_1,<span class="literal">NULL</span>);</span><br><span class="line">        first_param.id = sBtId;</span><br><span class="line">        err = <span class="built_in">bt_le_ext_adv_create</span>(&amp;first_param, &amp;adv_matter_cb, &amp;matter_ext_adv);</span><br><span class="line">        <span class="keyword">if</span> (err)&#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;===Failed to create a connectable advertising set (err %d)\n&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: bt_le_adv_stop() returns success when the advertising was not started</span></span><br><span class="line">    <span class="comment">//ReturnErrorOnFailure(System::MapErrorZephyr(bt_le_adv_stop()));</span></span><br><span class="line">    <span class="built_in">ReturnErrorOnFailure</span>(System::<span class="built_in">MapErrorZephyr</span>(<span class="built_in">bt_le_ext_adv_stop</span>(matter_ext_adv)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ReturnErrorCodeIf</span>(<span class="built_in">sys_slist_is_empty</span>(&amp;sRequests), CHIP_NO_ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Request &amp; top    = <span class="built_in">ToRequest</span>(<span class="built_in">sys_slist_peek_head</span>(&amp;sRequests));</span><br><span class="line">    bt_le_adv_param params = <span class="built_in">BT_LE_ADV_PARAM_INIT</span>(top.options, top.minInterval, top.maxInterval, <span class="literal">nullptr</span>);</span><br><span class="line">    params.id              = sBtId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Change to ext_adv instead of normal one */</span>   </span><br><span class="line">    <span class="comment">// const int result = bt_le_adv_start(&amp;params, top.advertisingData.data(), top.advertisingData.size(), top.scanResponseData.data(),</span></span><br><span class="line">    <span class="comment">//                                    top.scanResponseData.size());</span></span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">bt_le_ext_adv_set_data</span>(matter_ext_adv, top.advertisingData.<span class="built_in">data</span>(), top.advertisingData.<span class="built_in">size</span>(), top.scanResponseData.<span class="built_in">data</span>(),</span><br><span class="line">                                       top.scanResponseData.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;===Failed to set advertising data (err %d)\n&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">bt_le_ext_adv_update_param</span>(matter_ext_adv, &amp;params);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;===Update Matter adv param (err %d)\n&quot;</span>, err);		</span><br><span class="line">    &#125;		</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> result = <span class="built_in">bt_le_ext_adv_start</span>(matter_ext_adv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;===Failed to start advertising (err %d)\n&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ChipLogProgress</span>(DeviceLayer, <span class="string">&quot;Advertising start failed, will retry once connection is released&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top.onStarted != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        top.<span class="built_in">onStarted</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> System::<span class="built_in">MapErrorZephyr</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BT_CONN_CB_DEFINE</span>(conn_callbacks) = &#123;</span><br><span class="line">    .disconnected = [](<span class="keyword">struct</span> bt_conn * conn, <span class="type">uint8_t</span> reason) &#123; sWasDisconnection = <span class="literal">true</span>; &#125;,</span><br><span class="line">    .recycled =</span><br><span class="line">        []() &#123;</span><br><span class="line">            <span class="comment">// In this callback the connection object was returned to the pool and we can try to re-start connectable</span></span><br><span class="line">            <span class="comment">// advertising, but only if the disconnection was detected.</span></span><br><span class="line">            <span class="keyword">if</span> (sWasDisconnection)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">SystemLayer</span>().<span class="built_in">ScheduleLambda</span>([] &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">sys_slist_is_empty</span>(&amp;sRequests))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Starting from Zephyr 4.0 Automatic advertiser resumption is deprecated,</span></span><br><span class="line">                        <span class="comment">// so the BLE Advertising Arbiter has to take over the responsibility of restarting the advertiser.</span></span><br><span class="line">                        <span class="comment">// Restart advertising in this callback if there are pending requests after the connection is released.</span></span><br><span class="line">                        <span class="built_in">RestartAdvertising</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// Reset the disconnection flag to avoid restarting advertising multiple times</span></span><br><span class="line">                sWasDisconnection = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">CHIP_ERROR <span class="title">Init</span><span class="params">(<span class="type">uint8_t</span> btId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sIsInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CHIP_ERROR_INCORRECT_STATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sBtId          = btId;</span><br><span class="line">    sIsInitialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CHIP_NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CHIP_ERROR <span class="title">InsertRequest</span><span class="params">(Request &amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sIsInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> CHIP_ERROR_INCORRECT_STATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CancelRequest</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">sys_snode_t</span> * prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">sys_snode_t</span> * node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find position of the request in the list that preserves ordering by priority</span></span><br><span class="line">    <span class="built_in">SYS_SLIST_FOR_EACH_NODE</span>(&amp;sRequests, node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.priority &lt; <span class="built_in">ToRequest</span>(node).priority)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NotifyAdvertisingStopped</span>(<span class="built_in">sys_slist_peek_head</span>(&amp;sRequests));</span><br><span class="line">        <span class="built_in">sys_slist_prepend</span>(&amp;sRequests, &amp;request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sys_slist_insert</span>(&amp;sRequests, prev, &amp;request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the request is top-priority, restart the advertising</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sys_slist_peek_head</span>(&amp;sRequests) == &amp;request)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RestartAdvertising</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CHIP_NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelRequest</span><span class="params">(Request &amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sIsInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isTopPriority = (<span class="built_in">sys_slist_peek_head</span>(&amp;sRequests) == &amp;request);</span><br><span class="line">    <span class="built_in">VerifyOrReturn</span>(<span class="built_in">sys_slist_find_and_remove</span>(&amp;sRequests, &amp;request));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If cancelled request was top-priority, restart the advertising.</span></span><br><span class="line">    <span class="keyword">if</span> (isTopPriority)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RestartAdvertising</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace BLEAdvertisingArbiter</span></span><br><span class="line">&#125; <span class="comment">// namespace DeviceLayer</span></span><br><span class="line">&#125; <span class="comment">// namespace chip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要思路：</p>
<ol>
<li>一开始要用<code>bt_le_ext_adv_create</code>创建扩展广播</li>
<li>广播停止的API要改成扩展广播停止API</li>
<li>广播启动API要改成一系列扩展广播的数据更新、参数更新、扩展广播启动API。注意到广播参数中的id用的是<code>sBtId</code>，也就是<code>1</code>.</li>
<li>要在扩展广播专属的connected回调函数中，调用前一步我们取消注册的Matter自己的<code>HandleConnect</code>函数。这也是为什么前面我们要把它改成C++公共成员。</li>
</ol>
<h3 id="（3）再添加自己的扩展广播"><a href="#（3）再添加自己的扩展广播" class="headerlink" title="（3）再添加自己的扩展广播"></a>（3）再添加自己的扩展广播</h3><p>前一步修改已经让Matter可以运行了。再在自己的文件里等待蓝牙初始化完成，然后创建自己的广播即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/bluetooth/bluetooth.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/bluetooth/conn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">bt_le_ext_adv *my_ext_adv = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bt_conn</span> *my_conn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> mfg_data[] = &#123; <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x32</span>,<span class="number">0x33</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">bt_data</span> ad[] = &#123;</span><br><span class="line">    <span class="built_in">BT_DATA_BYTES</span>(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),</span><br><span class="line">    <span class="built_in">BT_DATA</span>(BT_DATA_NAME_COMPLETE, <span class="string">&quot;Common&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;Common&quot;</span>) - <span class="number">1</span>),</span><br><span class="line">    <span class="built_in">BT_DATA</span>(BT_DATA_MANUFACTURER_DATA, mfg_data, <span class="built_in">sizeof</span>(mfg_data)),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnected</span><span class="params">(<span class="keyword">struct</span> bt_conn *conn, <span class="type">uint8_t</span> reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅处理自己的连接断开事件</span></span><br><span class="line">    <span class="keyword">if</span> (conn != my_conn) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;## My private disconnected (reason 0x%02x) ##\n&quot;</span>, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_conn) &#123;</span><br><span class="line">        <span class="built_in">bt_conn_unref</span>(my_conn);</span><br><span class="line">        my_conn = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BT_CONN_CB_DEFINE</span>(conn_callbacks) = &#123;</span><br><span class="line">    .connected    = <span class="literal">NULL</span>,</span><br><span class="line">    .disconnected = disconnected,</span><br><span class="line">    .security_changed = <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_ext_adv_connected_cb</span><span class="params">(<span class="keyword">struct</span> bt_le_ext_adv *extadv,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">struct</span> bt_le_ext_adv_connected_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __ASSERT(extadv == my_ext_adv, <span class="string">&quot;My private adv wrong&quot;</span>);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;## My private ext adv connected %p ##\n&quot;</span>, info-&gt;conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前conn，以便自己的蓝牙服务识别</span></span><br><span class="line">    my_conn = <span class="built_in">bt_conn_ref</span>(info-&gt;conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bt_le_ext_adv_cb</span> my_ext_adv_cb = &#123;</span><br><span class="line">    .connected = my_ext_adv_connected_cb</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_private_ble_thread_entry</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">bt_is_ready</span>()) &#123;</span><br><span class="line">        <span class="built_in">k_sleep</span>(<span class="built_in">K_MSEC</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bt_le_adv_param</span> adv_param0 = </span><br><span class="line">        &#123;</span><br><span class="line">            .id = <span class="number">0</span>,</span><br><span class="line">            .sid = <span class="number">0U</span>, <span class="comment">/* Supply unique SID when creating advertising set */</span></span><br><span class="line">            .secondary_max_skip = <span class="number">0U</span>,</span><br><span class="line">            .options = (BT_LE_ADV_OPT_USE_IDENTITY | BT_LE_ADV_OPT_CONN),</span><br><span class="line">            .interval_min = <span class="number">600</span>,</span><br><span class="line">            .interval_max = <span class="number">800</span>,</span><br><span class="line">            .peer = <span class="literal">NULL</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">        </span><br><span class="line">    err = <span class="built_in">bt_le_ext_adv_create</span>(&amp;adv_param0, &amp;my_ext_adv_cb, &amp;my_ext_adv);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;Create my ext adv (err %d)\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">bt_le_ext_adv_set_data</span>(my_ext_adv, ad , <span class="built_in">ARRAY_SIZE</span>(ad), <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;Set my ext adv data (err %d)\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start extended advertising set */</span></span><br><span class="line">    err = <span class="built_in">bt_le_ext_adv_start</span>(my_ext_adv,</span><br><span class="line">                BT_LE_EXT_ADV_START_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;Start common adv (err %d)\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;## My private ext adv started ##\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">K_THREAD_DEFINE</span>(my_private_ble_thread_id, <span class="number">4096</span>,</span><br><span class="line">            my_private_ble_thread_entry, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>注意自己的蓝牙服务和connected回调函数里面，仅需处理<code>conn == my_conn</code>的情况即可。</p>
<blockquote>
<p>可以发现这种方式对SDK改动较大，编译其他Matter工程时要注意</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io">Jayant Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io/2025/10/1b3f41652d5d/">https://jayant-tang.github.io/jayant97.github.io/2025/10/1b3f41652d5d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jayant-tang.github.io/jayant97.github.io" target="_blank">一苇万顷</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/jayant97.github.io/tags/Nordic/">Nordic</a><a class="post-meta__tags" href="/jayant97.github.io/tags/Matter/">Matter</a></div><div class="post_share"><div class="social-share" data-image="/jayant97.github.io/imgs/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/jayant97.github.io/2025/10/a6cc85dce7a1/" title="Matter OTA固件升级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Matter OTA固件升级</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/jayant97.github.io/2025/10/a6cc85dce7a1/" title="Matter OTA固件升级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="title">Matter OTA固件升级</div></div></a></div><div><a href="/jayant97.github.io/2025/09/daaf6f53cdc2/" title="Matter证书体系与量产设备证书烧录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-26</div><div class="title">Matter证书体系与量产设备证书烧录</div></div></a></div><div><a href="/jayant97.github.io/2025/01/5645a5cab10c/" title="NCS Matter例程详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">NCS Matter例程详解</div></div></a></div><div><a href="/jayant97.github.io/2025/09/6376457096fe/" title="在WSL2中搭建Matter CHIP Tool环境"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-24</div><div class="title">在WSL2中搭建Matter CHIP Tool环境</div></div></a></div><div><a href="/jayant97.github.io/2025/01/22618b91ecf6/" title="NCS(Zephyr)中的蓝牙地址"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="title">NCS(Zephyr)中的蓝牙地址</div></div></a></div><div><a href="/jayant97.github.io/2025/01/aeb1d94c5ebc/" title="NCS 低功耗日志打印"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="title">NCS 低功耗日志打印</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%A4%9A%E8%93%9D%E7%89%99%E5%B9%BF%E6%92%AD%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">2. 多蓝牙广播方案分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AMatter-%E8%93%9D%E7%89%99%E5%B9%BF%E6%92%AD%E4%BB%B2%E8%A3%81%E5%99%A8"><span class="toc-text">方案一：Matter 蓝牙广播仲裁器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9AZephyr%E5%A4%9A%E5%B9%BF%E6%92%AD%E9%9B%86%EF%BC%88Multi-ADV-sets%EF%BC%89"><span class="toc-text">方案二：Zephyr多广播集（Multi ADV sets）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A4%9A%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%A4%9A%E8%93%9D%E7%89%99%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">3. 多蓝牙连接与多蓝牙服务方案分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%B9%BF%E6%92%AD%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%9B%9E%E8%B0%83"><span class="toc-text">普通广播连接时回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%B9%BF%E6%92%AD%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%9B%9E%E8%B0%83"><span class="toc-text">扩展广播连接时回调</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A4%9A%E8%93%9D%E7%89%99%E5%9C%B0%E5%9D%80%E5%88%86%E6%9E%90"><span class="toc-text">4. 多蓝牙地址分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80%E5%88%87%E6%8D%A2"><span class="toc-text">蓝牙广播地址切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Matter%E4%BD%BF%E7%94%A8%E7%9A%84%E8%93%9D%E7%89%99%E8%BA%AB%E4%BB%BD"><span class="toc-text">Matter使用的蓝牙身份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Matter%E5%88%9B%E5%BB%BA%E7%9A%84%E8%93%9D%E7%89%99%E8%BA%AB%E4%BB%BD"><span class="toc-text">Matter创建的蓝牙身份</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8F%8C%E8%93%9D%E7%89%99%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88%E5%AE%9E%E4%BE%8B"><span class="toc-text">5. 双蓝牙共存方案实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E2%80%9C%E8%93%9D%E7%89%99%E4%BB%B2%E8%A3%81%E5%99%A8%E6%96%B9%E6%A1%88%E2%80%9D-%E9%9C%80%E7%BB%91%E5%AE%9A-%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E5%9C%B0%E5%9D%80-%E5%8D%95%E6%A0%B8SoC"><span class="toc-text">案例一：“蓝牙仲裁器方案” + 需绑定 + 使用公共地址 + 单核SoC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AE%BE%E7%BD%AE%E4%B8%A4%E4%B8%AA%E5%9C%B0%E5%9D%80"><span class="toc-text">（1）设置两个地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BB%B2%E8%A3%81%E5%99%A8%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E8%93%9D%E7%89%99%E5%B9%BF%E6%92%ADc-%E4%BB%A3%E7%A0%81"><span class="toc-text">（2）使用广播仲裁器编写自己的蓝牙广播c++代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BF%AE%E6%94%B9%E5%B9%BF%E6%92%AD%E4%BB%B2%E8%A3%81%E5%99%A8%E6%BA%90%E7%A0%81"><span class="toc-text">（3）修改广播仲裁器源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E2%80%9C%E6%89%A9%E5%B1%95%E5%B9%BF%E6%92%AD%E6%96%B9%E6%A1%88%E2%80%9D-%E9%9C%80%E7%BB%91%E5%AE%9A-%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E5%9C%B0%E5%9D%80-%E5%8F%8C%E6%A0%B8SoC"><span class="toc-text">案例二：“扩展广播方案” + 需绑定 + 使用公共地址 + 双核SoC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AE%BE%E7%BD%AE%E4%B8%A4%E4%B8%AA%E5%9C%B0%E5%9D%80-1"><span class="toc-text">（1）设置两个地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8A%8AMatter%E5%B9%BF%E6%92%AD%E6%94%B9%E6%88%90%E6%89%A9%E5%B1%95%E5%B9%BF%E6%92%AD"><span class="toc-text">（2）把Matter广播改成扩展广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%86%8D%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%89%A9%E5%B1%95%E5%B9%BF%E6%92%AD"><span class="toc-text">（3）再添加自己的扩展广播</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Jayant Tang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/jayant97.github.io/js/utils.js"></script><script src="/jayant97.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c91ce0493b5c3e886110',
      clientSecret: '7599decf69128ba1a83c1f3ef0923395a9bd8a60',
      repo: 'jayant97.github.io',
      owner: 'Jayant-Tang',
      admin: ['Jayant-Tang'],
      id: '842ff1b8391a9ae9ded732430b446318',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/jayant97.github.io/js/search/local-search.js"></script></div></div></body></html>