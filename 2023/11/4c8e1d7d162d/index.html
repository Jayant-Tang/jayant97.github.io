<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Zephyr驱动与设备树实战——串口 | 一苇万顷</title><meta name="author" content="Jayant Tang,jayant.tang@nordicsemi.no"><meta name="copyright" content="Jayant Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2025.7.26更新：  新增54L15串口硬件介绍 新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。 增加全新的串口例程代码并上传GitHub  2025.5.5更新：  增加了对串口硬件的介绍 增加串口API更详细的介绍与图示   1. 前言之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephy">
<meta property="og:type" content="article">
<meta property="og:title" content="Zephyr驱动与设备树实战——串口">
<meta property="og:url" content="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html">
<meta property="og:site_name" content="一苇万顷">
<meta property="og:description" content="2025.7.26更新：  新增54L15串口硬件介绍 新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。 增加全新的串口例程代码并上传GitHub  2025.5.5更新：  增加了对串口硬件的介绍 增加串口API更详细的介绍与图示   1. 前言之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephy">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png">
<meta property="article:published_time" content="2023-11-12T09:48:56.000Z">
<meta property="article:modified_time" content="2025-08-01T10:48:42.997Z">
<meta property="article:author" content="Jayant Tang">
<meta property="article:tag" content="Nordic">
<meta property="article:tag" content="Zephyr">
<meta property="article:tag" content="DeviceTree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png"><link rel="shortcut icon" href="/jayant97.github.io/img/favicon.png"><link rel="canonical" href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/jayant97.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/jayant97.github.io/',
  algolia: undefined,
  localSearch: {"path":"/jayant97.github.io/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Zephyr驱动与设备树实战——串口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-01 18:48:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/jayant97.github.io/imgs/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/jayant97.github.io/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/jayant97.github.io/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/jayant97.github.io/" title="一苇万顷"><span class="site-name">一苇万顷</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Zephyr驱动与设备树实战——串口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T09:48:56.000Z" title="发表于 2023-11-12 17:48:56">2023-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-01T10:48:42.997Z" title="更新于 2025-08-01 18:48:42">2025-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/">RTOS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/Zephyr/">Zephyr</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title="Zephyr驱动与设备树实战——串口"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/jayant97.github.io/2023/11/4c8e1d7d162d/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>2025.7.26更新：</p>
<ul>
<li>新增54L15串口硬件介绍</li>
<li>新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。</li>
<li>增加全新的串口例程代码并上传GitHub</li>
</ul>
<p>2025.5.5更新：</p>
<ul>
<li>增加了对串口硬件的介绍</li>
<li>增加串口API更详细的介绍与图示</li>
</ul>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。</p>
<p>今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中<code>zephyr/samples/hello_world</code>例程为基础。分别添加<strong>串口</strong>、<strong>USB CDC ACM</strong>、<strong>低功耗串口</strong>的功能。采用<strong>完全相同的应用层代码</strong>，只需要修改config和dts即可切换。</p>
<h1 id="2-Hello-world解析—printk如何输出"><a href="#2-Hello-world解析—printk如何输出" class="headerlink" title="2. Hello world解析—printk如何输出"></a>2. Hello world解析—printk如何输出</h1><p>开发板我选择nRF52840DK。首先以<code>zephyr/samples/hello_world</code>例程为模板，创建一个新工程，我在这里把工程命名为<code>learning_zephyr_serial</code>。</p>
<h2 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">|  |</span><br><span class="line">|  `--main.c</span><br><span class="line">|--CMakeLists.txt</span><br><span class="line">`--prj.conf</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>中先把Zephyr作为包来导入，然后把main.c添加为源码。</p>
<p><code>prj.conf</code>目前是空的，在这里可以写一些配置用来覆盖默认的Kconfig。</p>
<p>例程默认没使用<code>Kconfig</code>菜单文件，是因为本工程太简单，没有自己的配置项，所以不需要自己的Kconfig文件。这种情况完全等价于Kconfig文件中只写了下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>

<p>相当于项目中只有Zephyr的菜单，可以让我们配置Zephyr系统的配置项，以及SDK中各个module的的配置项。选择板子，编译并烧录后，打开串口，reset一下，就能看到刚启动时串口输出的hello world了。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8065d44b86cceb9ff0e8b1ab1417eda2.png" alt="image-20231112183822534"></p>
<h2 id="printk输出配置"><a href="#printk输出配置" class="headerlink" title="printk输出配置"></a>printk输出配置</h2><p>很多新上手Zephyr的读者会有疑惑，这工程里几乎没什么代码，也没看到CONFIG和device tree文件，串口到底是怎么输出的？</p>
<p>其实，在我们选择板子时，板子就已经自带了默认的device tree和config文件。因此编译时采用的全部是板子和Zephyr系统的默认值，我们的工程中并没有对这些默认值进行修改。</p>
<p>我们可以在<code>build/zephyr/</code>目录下看到<code>.config</code>文件和<code>zephyr.dts</code>文件。这个就是项目最终编译采用的配置项和设备树。</p>
<p>在<code>.config</code>中，我们可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_PRINTK=y</span><br></pre></td></tr></table></figure>

<p>也就是启用了<code>printk()</code>输出的功能。</p>
<p>我们把这一行复制到prj.conf中（这个行为本身没有意义，因为默认就是y），然后就可以用<strong>Ctrl+鼠标左键</strong>点击这个选项，跳转到这个配置项定义的地方，就可以看到这个配置项的说明：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a2ee0a066378d3944f23bccfebfedc5f.png" alt="image-20231112184745524"></p>
<p>当然，你也可以在Kconfig GUI中找到这个配置项：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/09529eaa5aec7ff3197ab355163f7b47.png" alt="image-20231112184921595"></p>
<blockquote>
<p>到这里，是否对“<code>Kconfig</code>定义了一个菜单，而<code>prj.conf</code>文件是对菜单中配置项的默认值进行修改”这句话有了一定的感受呢？</p>
</blockquote>
<h2 id="console设备与console驱动"><a href="#console设备与console驱动" class="headerlink" title="console设备与console驱动"></a>console设备与console驱动</h2><p>根据此配置项的说明，我们知道<code>printk()</code>是Zephyr的一个内核服务，它可以让通过<code>printk()</code>函数打印的内容通过”console”输出。这里的console指的是一个设备，可以让Zephyr系统输入和输出字节流。</p>
<p>通过查看<code>build/zephyr/zephyr.dts</code>，可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">   ...</span><br><span class="line">    chosen &#123;</span><br><span class="line">        ...</span><br><span class="line">        zephyr,console = &amp;uart0;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>/chosen</code>节点下，有很多<strong>属性</strong>。Zephyr系统内核的代码在运行一些功能时，并不在乎底层的硬件具体是什么，它只从<code>/chosen</code>节点下找到对应的硬件。只要这个硬件已经在RTOS初始化之前就被驱动程序初始化了，具有Zephyr标准外设接口，那么Zephyr内核就可以操作这个硬件。</p>
<p>例如，要想获得这里的console设备的DeviceTree Node ID，就可以用<code>DT_CHOSEN(zephyr_console)</code>。</p>
<p>我们自然可以联想到，可以把console换成其他<strong>串口设备</strong>，就可以让日志从其他串口输出了。这里，可以参考我的另一篇随笔<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/p/17784156.html">《Zephyr重定向日志打印到USB串口》</a>。</p>
<p>如果你只是修改设备树中的console设备，那么不管如何修改，输出日志的设备都必须是一个“串口”（在Zephyr中USB CDC ACM设备也是串口，后文会解释）。在<code>build/zephyr/.config</code>中，我们还可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p>原来，在当前配置下，Zephyr默认的console后端都必须是“串口”设备。</p>
<p>我们可以尝试把console后端改成RTT，在<code>prj.conf</code>中，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/551a9a209c0745054d3342e2217c28c8.png" alt="image-20231112191457497"></p>
<p>然后就可以看到，printk()的日志从RTT中打印出来了。</p>
<p>对于探究心强的读者，到这里肯定又会有疑问：为什么把console后端改成了RTT，只改了config，设备树就不用改了？</p>
<p>关于这个问题，我想先传达出一个观点，那就是一个系统无论使用了什么样的框架，<strong>最终一定要落实到代码</strong>。通过在NCS中全局搜索<code>CONFIG_RTT_CONSOLE</code>和<code>CONFIG_UART_CONSOLE</code>，我们最终能找到这样的一个文件，<code>$&#123;NCS&#125;/zephyr/drivers/console/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_RTT_CONSOLE rtt_console.c)</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_UART_CONSOLE uart_console.c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>console本身作为一个中间件，也是要通过驱动程序向Zephyr提供标准console API的。在这里，CMake根据不同的CONFIG配置项，添加了不同的console驱动源码进入系统之中，进行编译。</p>
<p>在uart_console.c中，我们明显能看到，此驱动代码需要通过device tree来找到标准的串口设备，然后调用标准的串口API来通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">const</span> <span class="title">uart_console_dev</span> =</span></span><br><span class="line">    DEVICE_DT_GET(DT_CHOSEN(zephyr_console));</span><br></pre></td></tr></table></figure>

<p>而在rtt_console.c中，我们可以看到此代码不需要获取任何device tree的信息。因此，当我们选择RTT作为后端时，无论device tree中的<code>/chosen</code>节点中如何选择<code>zephyr,console</code>，对于RTT console驱动代码来说都是没有意义的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过前面的分析，我们可以有以下结论：</p>
<p>首先，在Zephyr系统中有许多功能，我们可以用Kconfig的方式进行配置或裁减。</p>
<p>此外，Zephyr中有非常明显的“分层设计”，例如，Nordic提交nrf系列串口驱动代码，提供Zephyr标准串口API；Zephyr有console驱动代码，向更上层提供标准console API；如果console是串口驱动，它还会调用标准串口 API来把日志输出到底层串口中；由于API是标准的，因此console驱动代码并不在乎底层到底是物理串口还是USB CDC ACM设备。</p>
<p>前面分析了Hello world是如何通过console输出的。在Zephyr中，console主要是用来做一些字节流的传输，用来实现一些更上层的服务，例如自定义<code>shell</code>命令。而用户要开发自己的程序，肯定是需要自己直接操作串口，而不是用什么printf。</p>
<h1 id="3-Nordic串口硬件"><a href="#3-Nordic串口硬件" class="headerlink" title="3. Nordic串口硬件"></a>3. Nordic串口硬件</h1><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/47b66b8aa6839171773ff5e5abf53fb5.png" alt="image-20250505231527537"></p>
<p>UART是最简单的硬件串口功能。图中小正方形为对外的硬件引脚，而箭头代表串口在MCU内部的输入、输出信号。</p>
<ul>
<li><p><strong>接收</strong>：在串口接收已经使能（STARTRX）的状态下，从RX线来的数据会被放入RXD寄存器，并产生RXDRDY事件。​</p>
<p>接收FIFO长度为6。RXD的数据被CPU读取后，立即从FIFO中把下一个数据填入RXD，并产生RXDRDY事件。（若使能流控，会在FIFO还剩4个空位时把RTS拉高以阻止对方发送）</p>
</li>
<li><p><strong>发送</strong>：在串口发送已使能（STARTTX）的情况下，向TXD写入1个字节就会发送。发送完毕后，UART产生TXDRDY事件。</p>
</li>
</ul>
<p>这些事件都能用来触发中断，或者作为PPI信号触发其他外设的task。</p>
<h2 id="UARTE"><a href="#UARTE" class="headerlink" title="UARTE"></a>UARTE</h2><p>UARTE和UART是不同的外设，但是共用了部分寄存器和电路。在使用时，这种具有相同地址的外设被称为同一个<strong>实例（Instance）</strong>，<strong>不能同时使能</strong>。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fc3805662646766f565b4b9f4c4e2c3b.png" alt="image-20250505232121430"></p>
<p>他们的ENABLE寄存器地址是相同的，但是使能所用的bit不同：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fcca18a4a9b88168f161c24e7088e1cc.png" alt="image-20250505232133627"></p>
<p>UARTE (UART with EasyDMA) 功能和UART是类似的，只不过有了EasyDMA的帮助，可以自动从RAM中取出数据发出；也可以把收到的数据直接存入RAM。无需CPU参与单个字节的收发处理，提升了效率，降低了功耗。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0a3a5712a20c3b9b9dda64a66061394e.png" alt="image-20250505232323499"></p>
<h3 id="UARTE发送逻辑"><a href="#UARTE发送逻辑" class="headerlink" title="UARTE发送逻辑"></a>UARTE发送逻辑</h3><p> <img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3b12c40231d46b93b26dffabd1d6874c.png" alt="image-20250505232526893"></p>
<ol>
<li>TXD.PTR填入数据在RAM中的首地址，TXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>
<li>使用STARTTX来启动自动的传输</li>
<li>传输完毕后，有ENDTX事件提示</li>
<li>中间每个字节的TXDRDY事件，CPU可以无视</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li><strong>串口的发送功能</strong>只在<strong>STARTTX和ENDTX之间</strong>有功耗，其余时间几乎不产生电流消耗</li>
<li>EasyDMA只能在RAM和外设之间传输数据，不能在RAM之间传输，也不能有FLASH参与。</li>
</ul>
</blockquote>
<h3 id="UARTE接收逻辑"><a href="#UARTE接收逻辑" class="headerlink" title="UARTE接收逻辑"></a>UARTE接收逻辑</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4a1b1a2b4f6c7d42deed43321b23e45f.png" alt="image-20250505232812582"></p>
<ol>
<li>RXD.PTR填入数据首地址，RXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>
<li>使用STARTRX来启动自动的接收</li>
<li>传输完毕后（指RAM中存的数据长度已经达到了MAXCNT），有ENDRX事件提示</li>
<li>中间每个字节的RXDRDY事件，无需再使能中断（从而降低功耗，提高CPU效率）</li>
</ol>
<p>特别地，RXD.PTR具有双缓存（影子寄存器）。也就是说，不用等到传输完成，只需在第一次接收开始后（RXSTARTED），就马上给RXD.PTR写入下一次要用的buffer首地址。这样下次传输时，就能立刻用上新的buffer。便于应用层实现<strong>双buffer</strong>。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>串口在接收状态（STARTRX）会有功耗，有几百uA。因此需要避免待机时一直开着RX。</li>
<li>UARTE只有在接收完毕（buffer满）时才会产生中断。本身没有空闲帧中断，或者说超时机制。需要其他外设辅助实现。</li>
</ul>
</blockquote>
<h2 id="nRF54系列UARTE硬件新功能"><a href="#nRF54系列UARTE硬件新功能" class="headerlink" title="nRF54系列UARTE硬件新功能"></a>nRF54系列UARTE硬件新功能</h2><p>以nRF54L15为例，有以下功能更新：</p>
<h3 id="（1）-4Mbps串口"><a href="#（1）-4Mbps串口" class="headerlink" title="（1） 4Mbps串口"></a>（1） 4Mbps串口</h3><p>在默认低频时钟域（16MHz）的情况下，串口的波特率可以由寄存器设置，如下最高为1Mbps。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/894689018edad6a0629abdbdda936465.png" alt="image-20250726225627521"></p>
<p>但是，nRF54L15的 <strong>UARTE00</strong> 位于MCU PowerDomain，其时钟频率为128MHz：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/32231108676d0bbe54cf8b10b61a32ea.png" alt="image-20250726225904621"></p>
<p>这时，串口的实际波特率就和寄存器中的定义不相同，实际的公式手册中已经给出。</p>
<p>但是我们做软件开发时无需关心这部分，因为在54L15芯片的原始设备树dtsi中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart00: uart@4a000 &#123;</span><br><span class="line">    compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class="line">    reg = &lt;0x4a000 0x1000&gt;;</span><br><span class="line">    interrupts = &lt;74 NRF_DEFAULT_IRQ_PRIORITY&gt;;</span><br><span class="line">    clocks = &lt;&amp;hfpll&gt;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">    endtx-stoptx-supported;</span><br><span class="line">    frame-timeout-supported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其已经指明了使用的是hfpll时钟。</p>
<p>然后，在最新（目前为NCS v3.0.2）的UARTE的驱动代码<code>uart_nrfx_uarte.c</code>中，已经自动考虑了低频时钟和高频时钟的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When calculating baudrate we need to take into account that high speed instances</span></span><br><span class="line"><span class="comment"> * must have baudrate adjust to the ratio between UARTE clocking frequency and 16 MHz.</span></span><br><span class="line"><span class="comment"> * Additionally, &gt;1Mbaud speeds are calculated using a formula.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UARTE_GET_BAUDRATE2(f_pclk, current_speed)                    \</span></span><br><span class="line"><span class="meta">    ((f_pclk &gt; NRF_UARTE_BASE_FREQUENCY_16MHZ) &amp;&amp; (current_speed &gt; 1000000)) ?	\</span></span><br><span class="line"><span class="meta">        UARTE_GET_CUSTOM_BAUDRATE(f_pclk, current_speed) :			\</span></span><br><span class="line"><span class="meta">        (NRF_BAUDRATE(current_speed) / UARTE_GET_BAUDRATE_DIV(f_pclk))</span></span><br></pre></td></tr></table></figure>

<p>因此我们在软件上是感知不到这个差别的，只需正常配置我们需要的波特率即可。需要4M就配置<code>current-speed = &lt;4000000&gt;</code>；需要115200就配置<code>current-speed = &lt;115200&gt;</code>。</p>
<h3 id="（2）支持4至9bits-帧"><a href="#（2）支持4至9bits-帧" class="headerlink" title="（2）支持4至9bits 帧"></a>（2）支持4至9bits 帧</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/6567df1a02e316811b9c173667ee9705.png" alt="image-20250726231953984"></p>
<p>数据帧支持被配置为4bit ~ 9bit。</p>
<p>其中，当配置为9bit时，第9个bit是地址位。当其为1时，代表前8个bits是地址；当其为0时，代表前8个是数据。</p>
<p>且9bit模式下，只有先收到地址和ADDRESS寄存器匹配的第一个地址包时，才会接收后面的数据包。否则忽略所有收到的串口数据。</p>
<h3 id="（3）帧超时中断"><a href="#（3）帧超时中断" class="headerlink" title="（3）帧超时中断"></a>（3）帧超时中断</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b893b6f7b506da554c2fb02217dda58c.png" alt="image-20250726232649715"></p>
<p>帧超时中断，或者说空闲帧中断，指的是：</p>
<ul>
<li>当连续一定时间没有收到串口数据时，就认为传输已经结束</li>
<li>此时不再等待DMA缓冲存满，而是直接产生DMA传输完成中断</li>
<li>应用层可以及时把数据取出进行处理</li>
</ul>
<p>之前的nRF52和53系列是没有这个功能的，需要操作系统软定时器进行计时，把一个timeout分成5份设定k_timer周期。如果每次软定时器到期，串口已经收到的数据量没有增长，那么就说明串口空闲了。这时由驱动层软件主动结束串口接收。这就不如nRF54系列UARTE硬件自带空闲帧超时来的方便。</p>
<p>只有<strong>异步串口</strong>才需要这个功能。因为<strong>阻塞</strong>和<strong>基于中断</strong>的串口都是按字节实时同步接收串口数据的。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/54c73f2e0da701646bbed68f13480de9.png" alt="image-20250726233308626"></p>
<p>空闲帧中断最大超时时间为 2^10 - 1&#x3D; 1023 bits。在115200波特率下，大约是8.88ms。而使用软定时器的方式，可以设置更长时间。</p>
<p>nRF54L15的设备树默认开启了空闲帧的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart20 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    frame-timeout-supported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于支持帧超时中断的串口外设，就直接使用这个功能即可。不要删除这个属性。</p>
<p>异步串口初始化时，通过<code>uart_rx_enable(dev, buf, len, timeout)</code>打开RX时，传入的timeout值（单位：微秒）会经过如下处理：</p>
<ul>
<li>如果开启了空闲帧中断，则取应用层传入的 timeout 和 1023 bits 之中，取时间更短的一个，会被设置到FRAMETIMEOUT寄存器中</li>
<li>如果没开启空闲帧中断，则用k_timer实现此功能，超时值为函数传入的timeout</li>
</ul>
<h1 id="4-Zephyr标准串口API"><a href="#4-Zephyr标准串口API" class="headerlink" title="4. Zephyr标准串口API"></a>4. Zephyr标准串口API</h1><p>上一节以nRF52系列的串口外设为例介绍了硬件部分，Nordic其他产品的串口基本也是一致的。</p>
<p>本节介绍Zephyr中的串口API。</p>
<p>Zephyr中的串口API分为**<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-polling-api">阻塞（Polling）</a><strong>、</strong><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-interrupt-api">基于中断（Interrupt-driven）</a>**、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-async-api"><strong>异步（Asynchronous）</strong></a>三种。</p>
<p>Zephyr串口API是一套软件接口，与硬件细节无关。除了Nordic的UART&#x2F;UARTE硬件可以用这套接口，其他厂商的串口实现也可以支持这套接口。甚至我们后面会介绍到的USB虚拟串口，也支持这套接口。这里给出<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html">Zephyr标准串口API文档</a>，供参考。</p>
<blockquote>
<p>NCS中的例程太多，对于不熟悉的人来说，随便复制代码，很有可能出现：代码里用的是一种API，但CONFIG使能的却是另一种API的情况，最终导致程序无法运行。</p>
<p>一般来说，同一个串口实例，基于中断的和异步的API是不能同时使用的。但是阻塞的API可以和前两者中的一种混用。</p>
</blockquote>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>基于阻塞的API是最简单的API。</p>
<ul>
<li><code>uart_poll_in()</code>：读取时，只读一个字节。有就返回0，无就返回-1，不阻塞；</li>
<li><code>uart_poll_out()</code>：发送时，只发一个字节。发送完毕后才返回，阻塞行为。</li>
</ul>
<h2 id="基于中断"><a href="#基于中断" class="headerlink" title="基于中断"></a>基于中断</h2><p>首先声明，Zephyr串口API是一套软件接口，<strong>与硬件细节无关</strong>。基于中断的API只是抽象地认为有串口外设<strong>应当有</strong>发送ready中断和接收ready中断。具体如何映射到硬件？完全由厂商提供的驱动代码实现，不需要应用开发者实现。这也是USB虚拟串口也能使用这套API的原因。</p>
<p>NCS中，使用串口中断API的例程很多。<strong>但是它们在应用层编写callback函数的方式五花八门，与应用层本身的功能混在一起，这对于初学者来说容易抓不到重点</strong>。这也侧面说明，中断API适合添加一些应用层自定义的东西。因此我在这里总结出基于中断的API的使用流程，方便开发者结合代码进行观看。</p>
<p>以下为流程：</p>
<ol>
<li>开始时，用<code>uart_irq_callback_set()</code>函数设置好“应用层的”中断回调函数，这个函数会在串口ISR中根据情况被串口驱动程序调用。然后，开启<code>uart_irq_rx_enable()</code>，使能接收。</li>
<li>要发送时，先准备好要发送的数据（首地址和长度），然后<code>uart_irq_tx_enable()</code>开启发送中断。</li>
<li>发生中断，进入预先设置好的回调函数时，先用<code>uart_irq_update()</code>更新中断状态，再用<code>uart_irq_is_pending()</code>判断是否有中断（以防是别处误调用了该回调函数）。再之后用<code>uart_irq_tx_ready()</code>和<code>uart_irq_rx_ready()</code>来判断是发送中断还是接收中断。</li>
<li>如果是接收中断，<strong>在中断里</strong>用<code>uart_fifo_read()</code>循环读取，每次读取1个字节（Nordic的驱动实现是只读1个字节），直到返回值为0（表示缓存里已无数据）。</li>
<li>如果是发送中断，说明发送器已经ready，<strong>在中断里</strong>用<code>uart_irq_tx_fill()</code>，把前面准备好要发送的数据传入，即可发送。</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>不要在中断callback里进行耗时的处理和阻塞行为。善用queue和work queue。</li>
<li><code>uart_fifo_read()</code>和<code>uart_fifo_fill()</code>只能在这个中断callback函数内部调用</li>
</ul>
</blockquote>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步API是本文介绍的重点，它带有DMA，因此可以让数据传输时，不影响CPU的运行。但是它的配置最复杂，功能最强大。</p>
<h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b161ff61daac34105ac418a0d8ff86b4.png" alt="image-20250506000430849"></p>
<p>调用<code>uart_tx(dev, *buf, len, timeout)</code>，给定首地址和长度即可，函数不阻塞。Timeout是给流控用的，如果输出被对方的流控阻止，自己能等待多久，如果没有流控就不用在意。</p>
<p>发送过程由驱动层和硬件自动处理。</p>
<p>发送完毕后，回调函数里会收到<strong>UART_TX_DONE</strong>事件。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>注意发送数据buffer的生命周期，不能是局部变量</li>
<li>如果buffer的地址不属于于RAM，Nordic的驱动程序会先自动执行一个拷贝到RAM中的动作。因为硬件不支持RAM以外的地方到外设的DMA。</li>
<li>uart_tx这个行为是低功耗的。只要不在发送，就没有发送行为相关的功耗。无需disable串口。</li>
</ol>
</blockquote>
<p>在DMA传输期间，如果再次执行uart_tx()，函数会返回<code>-EBUSY</code>错误码：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0c8c3cc39029da6d8d7da1eeafbabc38.png" alt="image-20250727000130872"></p>
<p>后续例程会展示如何实现发送缓冲线程。</p>
<h3 id="异步接收"><a href="#异步接收" class="headerlink" title="异步接收"></a>异步接收</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/617d9c8e5b5060c0dcc1e9f741850e20.png" alt="image-20250506000958480"></p>
<ol>
<li>用<code>uart_rx_enable(dev, *buf, len, timeout_us)</code>来首次使能接收。给定Buffer和长度。Buffer收满以后会产生UART_RX_RDY事件。</li>
<li>Timeout是空闲超时机制。在至少收到1个字节之后，即使buffer未满，如果超时，也会产生<code>UART_RX_RDY</code>事件。这是为了方便收取一个小于buffer长度的包的情况。单位是微秒。timeout时间设为SYS_FOREVER_US会关闭这个机制。</li>
<li>如果buffer未满，下次数据接收会继续填充在此buffer内。如果buffer已满，紧接在UART_RX_RDY事件之后，会产生UART_RX_BUF_RELEASED事件。告知应用层，一开始的buffer已经不再使用，可以释放。</li>
<li>异步API也提供双Buffer机制。当每次接收开始时，驱动层会立即产生UART_RX_BUF_REQUEST事件。向应用层请求第二个buffer。应用层有两个选择：<ul>
<li>用uart_rx_buf_rsp(dev, *buf, len)来设置第二个buffer。当第一个buffer满时，驱动层自动开始用第二个buffer。</li>
<li>无视这个请求。那么这次接收完毕时，整个接收会被disable。需要再次enable才能开始接收。</li>
</ul>
</li>
</ol>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/5d9b9ad4db0201e8f1dc44ae7342d418.png" alt="image-20250506000854098"></p>
<h2 id="Zephyr串口驱动"><a href="#Zephyr串口驱动" class="headerlink" title="Zephyr串口驱动"></a>Zephyr串口驱动</h2><p>无论是阻塞、基于中断、还是异步API。它们都是由Nordic的驱动程序提供的。</p>
<p>当<code>CONFIG_SERIAL=y</code>，就使能了Zephyr的串口驱动。Zephyr系统内的CMake规则会自动把相关MCU的串口驱动编译进去。</p>
<p>而Nordic是提供了三种驱动的：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2d16fa1b03901a6cfd6347d0d8b5208b.png" alt="image-20250506001935633"></p>
<p>使用时，注意在device tree中设置正确的compatible，来选择正确的驱动。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2753bd1faeeebb2e7251143b27988756.png" alt="image-20250506001833817"></p>
<blockquote>
<p><strong>设备树的compatible和驱动程序是如何对应的？</strong></p>
<p>​    设备树的compatible属性，在编译阶段会被转换成C语言命名规范允许的形式（特殊符号全变为下划线），如<code>nordic_nrf_uarte</code>。</p>
<p>​    每个驱动程序会用自己的方法遍历设备树中所有compatible与自己相匹配的节点。然后基于这个节点的信息来初始化硬件外设。</p>
<p><strong>uarte和uarte2有什么区别？</strong></p>
<p>​    见<code>zephyr/driver/serial/CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONFIG_UART_NRFX_UARTE)</span><br><span class="line">  <span class="keyword">if</span> (CONFIG_UART_NRFX_UARTE_LEGACY_SHIM)</span><br><span class="line">    zephyr_library_sources(uart_nrfx_uarte.c)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(DEPRECATION</span><br><span class="line">        <span class="string">&quot;Do not set CONFIG_UART_NRFX_UARTE_LEGACY_SHIM=n as this option is deprecated.&quot;</span>)</span><br><span class="line">    zephyr_library_sources(uart_nrfx_uarte2.c)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-异步串口代码示例"><a href="#5-异步串口代码示例" class="headerlink" title="5. 异步串口代码示例"></a>5. 异步串口代码示例</h1><p>示例代码：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Jayant-Tang/learning_zephyr_serial">Jayant-Tang&#x2F;learning_zephyr_serial: An example that shows how to use zephyr Async UART</a></p>
<p>读者可以下载示例代码后，对照阅读本文</p>
<blockquote>
<p>【注意】<br>本文基于NCS v3.0.2。若读者使用v2.4.2或以下版本，代码中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> *)evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>需要改回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>因为版本升级后<code>k_mem_slab_free</code>的实现不同，参数从二级指针变为了一级指针。</p>
</blockquote>
<h2 id="src-x2F-app-uart-x2F-app-uart-c"><a href="#src-x2F-app-uart-x2F-app-uart-c" class="headerlink" title="src&#x2F;app_uart&#x2F;app_uart.c"></a>src&#x2F;app_uart&#x2F;app_uart.c</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先是获得device，这里的方法是用aliases别名来获取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* serial device */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_INST DT_ALIAS(learning_serial)</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> DEVICE_DT_GET(UART_INST);</span><br></pre></td></tr></table></figure>

<p>因为在不同板子的设备树中，都已经选好了对应的串口：</p>
<p><code>nrf54l15dk_nrf54l15_cpuapp.overlay</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart20;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>nrf52840dk_nrf52840.overlay</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart0;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是初始化时，注册异步回调函数，并开启串口接收。这里除了device结构体指针之外，还有两组配置。一个是接收缓存及其长度、一个是超时时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT_US);</span><br></pre></td></tr></table></figure>

<p>接收缓存用的是Zephyr的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/memory_management/slabs.html#memory-slabs">memory slab</a>功能。代码中用<code>K_MEM_SLAB_DEFINE</code>定义了几块静态的缓存区域，可以用allocate和free来进行内存块的分配和释放操作。相当于是一个私有的动态内存区域。在<code>main()</code>函数中，先取出了一块内存，然后传入<code>rx_enable</code>作为接收缓存。</p>
<p>超时时间，指的是串口空闲一定时间，没有新数据来，就直接认为接收完毕。即使DMA接收缓存还未满，也要产生空闲事件，并直接调用callback。<strong>这里为了演示，设置为1秒超时</strong>。</p>
<blockquote>
<p>这个超时功能，一般情况下是用软定时器（k_timer）实现的。</p>
<p>但是，对于nRF54L15这种串口硬件本身支持超时帧中断的情况，会使用硬件本身的超时功能。这时，超时时间的最大值就是UARTE硬件帧中断支持的最大时间。比如54l15的串口，空闲帧的最大值为10个bit宽度，在115200波特率下大约为8.9ms。因此，这种情况下设置所有超过8.9ms的时间都会被缩短到8.9ms。</p>
</blockquote>
<h3 id="串口回调"><a href="#串口回调" class="headerlink" title="串口回调"></a>串口回调</h3><p>在回调函数中，每次接收缓存已满，或者达到了超时时间，就会产生<code>UART_RX_RDY</code>事件。在事件结构体中，<code>buf</code>是缓存的首地址，<code>offset</code>是本次收到的数据在缓存中的位置，<code>len</code>是本次收到的数据的长度。因此，本次接收到的数据的真实首地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br></pre></td></tr></table></figure>

<p>每次接收缓存满时，串口rx驱动代码会向应用层申请新的接收缓存，即<code>UART_RX_BUF_REQUEST</code>事件。这时我们从memory slab中分配一块新的内存给它即可。</p>
<p>当串口驱动获得了新的接收缓存时，它也会向应用层申请释放掉旧的接收缓存，即<code>UART_RX_BUF_RELEASED</code>事件。这时我们用memory slab的free函数将其释放即可。</p>
<blockquote>
<p>这里有一些小细节：</p>
<ol>
<li><p>回调函数的形参evt，在call stack中上一层的驱动代码里是一个局部变量。在回调函数返回后，evt会被释放。因此这里如果要实现回环，需要拷贝一份到静态内中。即<code>static uint8_t buf[128]</code>。</p>
</li>
<li><p>如果某一次接收到了很多数据，超出了buffer的剩余空间。那么这次收到的数据就会被分成两部分，产生两次接收回调。这也意味着，我们必须把接收到的数据看作是“字节流”而不是“包”。开发者应该自己实现字节流解包处理函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evt-&gt;data.rx.len; i++)&#123;</span><br><span class="line">    bytes_to_packet(p[i]); <span class="comment">// 开发者自行实现解包函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c中已经实现了这一点。</p>
</li>
<li><p>回调函数实际上运行在中断服务函数内部，因此不要做一些阻塞的行为。如果真的有计算量大的任务，可以把任务提交到<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html">Workqueue Threads</a>。这样你就能把耗时的任务从<strong>特权模式</strong>移动到<strong>用户模式</strong>，也就是从中断内部移动到线程中。</p>
</li>
</ol>
</blockquote>
<h3 id="串口接收线程"><a href="#串口接收线程" class="headerlink" title="串口接收线程"></a>串口接收线程</h3><p>串口接收到数据时，将数据拷贝并通过消息队列发送到RX线程。然后执行应用层的回调函数。再之后free掉申请的内存。</p>
<h3 id="串口发送线程"><a href="#串口发送线程" class="headerlink" title="串口发送线程"></a>串口发送线程</h3><p>应用层要发送数据时，数据先被拷贝并通过消息队列发送到TX线程，然后进行发送。线程会等待发送完毕，然后free掉申请的内存</p>
<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>通过<code>app_uart_rx_cb_register()</code>注册回调函数。当串口收到数据时，回调函数会<strong>在RX线程中被执行</strong>。</p>
<p>要发送数据时，执行<code>app_uart_tx()</code>。此函数不阻塞且会拷贝数据。因此可以从ISR或Thread中调用，也可以传入局部变量。</p>
<p>收到的串口数据是字节流而不是包。因此通过有限状态机实现了串口数据流解包函数，以连续的CRLF（<code>\r\n</code>）为分界，进行数据的解包。</p>
<h2 id="异步串口配置"><a href="#异步串口配置" class="headerlink" title="异步串口配置"></a>异步串口配置</h2><p><code>prj.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use RTT as console</span></span><br><span class="line">CONFIG_USE_SEGGER_RTT=y</span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> logging</span></span><br><span class="line">CONFIG_LOG=y</span><br><span class="line">CONFIG_LOG_BACKEND_RTT=y</span><br><span class="line">CONFIG_LOG_MODE_DEFERRED=y</span><br><span class="line"></span><br><span class="line">CONFIG_SEGGER_RTT_MODE_NO_BLOCK_SKIP=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use ASYNC uart API</span></span><br><span class="line">CONFIG_SERIAL=y</span><br><span class="line">CONFIG_UART_ASYNC_API=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">need k_malloc</span></span><br><span class="line">CONFIG_HEAP_MEM_POOL_SIZE=4096</span><br></pre></td></tr></table></figure>

<p>首先，把console改为RTT，防止日志和我们的串口数据混在一起。</p>
<p><code>CONFIG_SERIAL=y</code>的作用是，使能Zephyr标准串口驱动；<code>CONFIG_UART_ASYNC_API=y</code>使能了异步API。这两项都是Zephyr的串口配置项，来自于<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig</code>。</p>
<p>由于我们需要用到动态内存分配，因此这里要设置HEAP大小<code>CONFIG_HEAP_MEM_POOL_SIZE=4096</code>。</p>
<p><code>boards/&lt;board&gt;.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_xx_ASYNC=y</span><br><span class="line">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</span><br></pre></td></tr></table></figure>

<p><code>CONFIG_UART_xx_ASYNC=y</code>来自于Nordic的配置<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig.nrfx</code>。Zephyr只提供了全局的串口API选择（异步、中断、阻塞）。但是Nordic允许开发者给不同的串口使用不同的API。因此这里需要给特定的串口实例单独启用ASYNC API。</p>
<h2 id="强化RX功能"><a href="#强化RX功能" class="headerlink" title="强化RX功能"></a>强化RX功能</h2><p>上述第二配置，<strong>对性能和功耗影响很大</strong>。虽说串口API是异步的，但底层驱动的实现却有很多变化。当一个外设通过DMA传输数据时，通常来说是DMA缓存写满了，才产生中断，然后把整个缓存传给应用层。但别忘了，我们的异步串口有<strong>空闲超时功能</strong>，如果DMA缓存还没有写满，但因为串口一直没有收到新的数据，超时了，需要立即把目前已经收到的数据传到应用层。这种情况下，<strong>如何才能知道目前已经接收了多少个字节数据呢？</strong></p>
<p>纯软件的方法就是，每收到一个字节就产生中断，在中断服务函数里，通过软件的方式+1，这也是大多数普通的单片机的做法。<strong>如果你不添加最后两行CONFIG配置，那么<code>uart_nrfx_uarte.c</code>驱动就会采用这种方法</strong>。但是当串口速率很高时（如1Mbps），每一个字节都产生中断一定会大量占用CPU资源，效率极低。</p>
<p>因此这里需要强化版RX（Enhanced RX）功能。在底层驱动代码中，当<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX</code>开启时，单个字节的中断不会被使能：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fe23eea8c563759f1a57c14b8ab88644.png" alt="image-20250727044332567"></p>
<p>这就确保了不会产生单个字节的中断，从而影响CPU性能。</p>
<p>另一方面，在底层驱动的RX enable函数中，使能了连接FRAMETIMEOUT event和 STOP_RX task的SHORT寄存器：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/1bd7e9bcb8d16788c65066091e036adc.png" alt="image-20250727044930863"></p>
<blockquote>
<p>SHORT寄存器（意为短路）就是可以让一个外设的event自动触发该外设的一个task，无需CPU参与。当FRAME_TIMEOUT发生时，外设自动执行STOP_RX。</p>
</blockquote>
<p>对于nRF52系列这种不支持FRAME_TIMEOUT的老系列。超时是靠k_timer软定时器实现的，在rx enable的函数内，把超时时间分成了5份：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">async_rx-&gt;timeout_us = timeout;</span><br><span class="line">async_rx-&gt;timeout_slab = timeout / RX_TIMEOUT_DIV; <span class="comment">// RX_TIMEOUT_DIV = 5</span></span><br></pre></td></tr></table></figure>

<p>底层驱动在RX Started中断里，开始计时：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3237942a0bf438792701ab9bc7ae34b0.png" alt="image-20250727045514187"></p>
<p>如果连续5次都超时，则软件触发STOPRX中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (async_rx-&gt;idle_cnt == (RX_TIMEOUT_DIV - <span class="number">1</span>)) &#123;</span><br><span class="line">    nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和前面的SHORT寄存器是一个思路。</p>
<p>不论是前面二者中的哪种情况，当STOP RX中断发生时，就会进入底层驱动的<code>endrx_isr()</code>。在这里读取DMA的AMOUNT寄存器，就可以在DMA缓存区未满的情况下，获取串口已经收到的字节数了。</p>
<h2 id="硬件计数器（不再推荐）"><a href="#硬件计数器（不再推荐）" class="headerlink" title="硬件计数器（不再推荐）"></a>硬件计数器（不再推荐）</h2><p>在之前版本的文章中，我介绍过Timer+PPI的方式：</p>
<p>Nordic的单片机有独特的功能—— PPI (Programmable peripheral interconnect)。简单来说，就是每个外设都有许多event和task寄存器。event寄存器可以产生中断让CPU去处理；CPU也可以去写task寄存器让外设去执行某些工作。前面介绍过，SHORT寄存器可以把同一个外设的event和它自己的task连接起来。</p>
<p>而PPI可以把两个不同外设的event寄存器和task寄存器连接起来，实现<strong>自动联动，而无需CPU处理</strong>。</p>
<p>如此一来，Nordic串口驱动可以把一个Timer配置为计数器模式（Counter Mode），并且把他的COUNT TASK与串口的接收到单个字节的EVENT通过PPI连接起来。这样计数器就可以自动记录收到了多少个字节。当接收超时的时候，直接从counter中读取计数即可。</p>
<p>在52840中，可以这样配置，将timer2用作uart0的计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_0_ASYNC=y</span><br><span class="line"></span><br><span class="line">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=n</span><br><span class="line"></span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC=y</span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC_TIMER=2</span><br><span class="line"></span><br><span class="line">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>

<p>在54L15中，不推荐用硬件计数，请直接使用<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</code>，这里也不给出配置，经过我实测：</p>
<ul>
<li>54L15使用硬件计数，开启FRAMTIMEOUT时。出现bug，FRAMETIMEOUT不生效，必须收到大于DMA长度的包才能产生中断；</li>
<li>54L15使用硬件计数，关闭FRAMTIMEOUT，k_timer实现超时功能。出现bug，收到的数据包最后2个字节完全错误，且尾部还会再增加一个随机错误字节。</li>
</ul>
<h2 id="异步串口设备树"><a href="#异步串口设备树" class="headerlink" title="异步串口设备树"></a>异步串口设备树</h2><p>我们并不需要额外修改设备树，直接采用默认值即可。我们这里只是给串口起一个别名，方便不同MCU平台统一代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart20;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;uart20 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于这个串口的具体配置，我们可以直接查看编译后的完整设备树，位于<code>build/&lt;application_name&gt;/zephyr/zephyr.dts</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart0: uart@40002000 &#123;</span><br><span class="line">            compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class="line">            reg = &lt; 0x40002000 0x1000 &gt;;</span><br><span class="line">            interrupts = &lt; 0x2 0x1 &gt;;</span><br><span class="line">            status = &quot;okay&quot;;</span><br><span class="line">            current-speed = &lt; 0x1c200 &gt;;</span><br><span class="line">            pinctrl-0 = &lt; &amp;uart0_default &gt;;</span><br><span class="line">            pinctrl-1 = &lt; &amp;uart0_sleep &gt;;</span><br><span class="line">            pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>主要属性介绍：</p>
<ul>
<li><p><code>reg = &lt; 0x40002000 0x1000 &gt;</code>：芯片自带的属性，外设的地址</p>
</li>
<li><p><code>compatible = &quot;nordic,nrf-uarte&quot;</code>：此处选择了uarte的驱动而非uart驱动。因此最终编译时用的代码是uart_nrfx_uarte.c而非uart_nrfx_uart.c</p>
</li>
<li><p><code>status = &quot;okay&quot;</code>：驱动代码自动初始化外设时，只会初始化状态为<code>&quot;okay&quot;</code>的节点。</p>
</li>
<li><p><code>current-speed = &lt; 0x1c200 &gt;</code>：波特率，也就是写十进制<code>current-speed = &lt; 115200 &gt;</code></p>
</li>
</ul>
<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e1f8ca33f0a8e621f288179dd9ab2173.png" alt="image-20221209144123203"></p>
<p>Nordic开发板的串口0默认GPIO都是在板子上直接连接到Jlink上，然后Jlink把串口转发到USB上，因此电脑上看到的是Jlink的USB串口。</p>
<p>右上角开关，nRF Only是只给单片机核心电路供电，外围LED、Jlink等都不供电，用于测量功耗。因此应该拨到DEFAULT档位。</p>
<p>板载Jlink，USB插左边即可。左下角电源开关打开。</p>
<h2 id="异步串口代码运行"><a href="#异步串口代码运行" class="headerlink" title="异步串口代码运行"></a>异步串口代码运行</h2><p>烧录好程序后，分别打开RTT和串口。从串口发送hello（包含回车+换行），串口就会把hello回环打印出来。并且RTT的日志中会显示收到了7字节，发送了7字节：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/d4f6f910dc63966549e3cda4036916b6.png" alt="image-20250727053522774"></p>
<blockquote>
<ul>
<li>不要用VS Code里面nRF插件提供的这个串口终端。在里面按下回车不是<code>\r\n</code>，无法形成完整数据包。可以用nRF Connect for Desktop里面的串口助手。</li>
<li>如果是52840，前面设置了1s超时，hello就会在发送后1s回环打印出来。如果是54L15，不采用这个超时，而是采用空闲帧中断，hello会在1023个bit时间内打印出来（约8.9ms）。</li>
</ul>
</blockquote>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/befde71fdc0717db731e044fb030feb6.png" alt="image-20250727054355433"></p>
<p>如果一次性发送大量数据，则我们可以看到产生了多个接收完毕中断。由于我们的<code>CONFIG_APP_UART_RX_DMA_BLOCK_SIZE</code>设置的是64，因此每收到64字节，串口驱动就会重新申请一块新的内存。</p>
<p>而应用层<code>main.c</code>中，已经实现了解包函数，因此最终是按照一整包回环发送回来的。</p>
<h1 id="6-USB-CDC-ACM串口"><a href="#6-USB-CDC-ACM串口" class="headerlink" title="6. USB CDC ACM串口"></a>6. USB CDC ACM串口</h1><p>前面介绍了硬件串口的异步API，接下来我们介绍USB CDC ACM串口。</p>
<blockquote>
<p> nRF54L15不含USB，后续用nRF52840DK继续。</p>
</blockquote>
<p>应用层代码无需改动。只需修改一些配置就可以把前面的异步串口代码变为USB CDC ACM串口代码。</p>
<h2 id="USB串口设备树"><a href="#USB串口设备树" class="headerlink" title="USB串口设备树"></a>USB串口设备树</h2><p>在<code>usb.overlay</code>中，有如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases &#123;</span><br><span class="line">        my-usb-serial = &amp;usb_serial0;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;zephyr_udc0 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    usb_serial0: cdc_acm_uart0 &#123;</span><br><span class="line">        compatible = &quot;zephyr,cdc-acm-uart&quot;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们给usbd节点新增了一个子节点<code>/soc/usbd@4002700/cdc_acm_uart0</code>，并且也给其添加了一个label：<code>usb_serial0</code>。</p>
<h2 id="USB串口配置"><a href="#USB串口配置" class="headerlink" title="USB串口配置"></a>USB串口配置</h2><p>在<code>prj_usb.conf</code>中，和<code>prj.conf</code>相比增加了以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable USB Device</span></span><br><span class="line">CONFIG_USB_DEVICE_STACK=y</span><br><span class="line">CONFIG_USB_DEVICE_PRODUCT=<span class="string">&quot;Zephyr CDC ACM sample&quot;</span></span><br><span class="line">CONFIG_USB_DEVICE_PID=0x0001</span><br><span class="line">CONFIG_USB_CDC_ACM=y</span><br><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_LINE_CTRL=y</span><br><span class="line">CONFIG_USB_DEVICE_REMOTE_WAKEUP=n</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable USB ASYNC Adapter</span></span><br><span class="line">CONFIG_UART_ASYNC_ADAPTER=y</span><br></pre></td></tr></table></figure>

<p>最后一项是Nordic的一个中间件。<strong>由于USB串口驱动只实现了基于中断的API，没有实现异步API。因此通过这个Adapter给USB CDC ACM串口驱动附加一层异步API。</strong></p>
<h2 id="USB串口代码"><a href="#USB串口代码" class="headerlink" title="USB串口代码"></a>USB串口代码</h2><p>代码和前面的异步串口代码几乎一样。只是换了一个串口设备：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/435dc3353a9dec6cfd3f33f93d2d9508.png" alt="image-20250727062621425"></p>
<p>另外，在初始化阶段使能了usb，并应用了uart_async_adapter:</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b5a8857c9630e54e55050af81ac89af0.png" alt="image-20250727062711807"></p>
<blockquote>
<p>串口异步接收超时的单位是微秒。在老的异步串口API中，而这个async adapter里实现的rx_enable函数，传入的参数单位是毫秒。因此，注意<code>RX_INACTIVE_TIMEOUT</code>的值。</p>
<p>不过最新的NCS v3.0.2已经修复了此问题。现在单位统一为微秒（us）。</p>
</blockquote>
<h2 id="编译USB串口例程"><a href="#编译USB串口例程" class="headerlink" title="编译USB串口例程"></a>编译USB串口例程</h2><p>编译时选好配置文件和设备树：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4f06c74858516b61a28a039ec11affc1.png" alt="image-20250727063009578"></p>
<p>或者用命令编译：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">west build <span class="literal">-d</span> build_usb <span class="literal">-p</span> <span class="literal">-b</span> nrf52840dk/nrf52840 <span class="literal">--sysbuild</span> <span class="literal">--</span> <span class="literal">-DCONF_FILE</span>=<span class="string">&quot;prj_usb.conf&quot;</span> <span class="literal">-DEXTRA_DTC_OVERLAY_FILE</span>=<span class="string">&quot;boards/nrf52840dk_nrf52840.overlay&quot;</span> <span class="literal">-DDTC_OVERLAY_FILE</span>=<span class="string">&quot;usb.overlay&quot;</span> </span><br></pre></td></tr></table></figure>



<h2 id="运行并测试USB串口"><a href="#运行并测试USB串口" class="headerlink" title="运行并测试USB串口"></a>运行并测试USB串口</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8ada0b901ff5c008dd17acc90971ae89.png" alt="image-20231113111154639"></p>
<p>左侧是Jlink USB，下方是nRF52840的USB Device接口。在串口助手里选中USB串口：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a193007588cb8eb0477e7058cbb42c45.png" alt="image-20250727063204480"></p>
<p>可以看到功能和前面的异步串口完全相同：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ffaa699ebd81acdad4bfbc16e3758957.png" alt="image-20250727063250261"></p>
<h1 id="7-串口休眠"><a href="#7-串口休眠" class="headerlink" title="7. 串口休眠"></a>7. 串口休眠</h1><p>待补充。一个是通过GPIO主动使能、关闭串口。一个是用RX引脚数据的下降沿来触发GPIO中断，使能串口。</p>
<h1 id="8-Nordic-LPUART低功耗串口"><a href="#8-Nordic-LPUART低功耗串口" class="headerlink" title="8. Nordic LPUART低功耗串口"></a>8. Nordic LPUART低功耗串口</h1><p>在不开启串口等非必要外设的情况下，Nordic的System On休眠（也就是Zephyr IDLE状态下）的待机功耗只有几微安。但若是开启RX一直等待着数据接收，即使同时没在发送任何数据，大概也会有三百微安左右的功耗。这肯定是低功耗产品不能接受的。</p>
<p>好在，Nordic nrfx异步串口API本身就有一定的低功耗特性：对于发送来说，只要数据发送完毕，tx就会关闭；对于接收来说，只要不被<code>uart_rx_enable()</code>使能，接收也会关闭。发送和接收都关闭时，串口本身就是关闭的，没有功耗。</p>
<p>发送行为本身就已经是低功耗的了，我们不用做任何修改。对于接收行为来说，串口接收空闲超时会产生<code>UART_RX_RDY</code>事件，我们可以在这个事件里关掉串口。但是如何在数据来之前就提前预知，打开串口呢？</p>
<p>一个比较简单的方案是同时把RX引脚配置成下降沿触发的外部中断。当检测到外部中断时，禁用GPIO中断，打开rx；当接收完毕时，关闭rx，打开GPIO中断。</p>
<blockquote>
<p>这种方案，波特率不能超过9600，且GPIO中断内部执行要非常快，连Log也不能打印，否则时间来不及处理。</p>
<p>此外，如果接收到的数据大于缓存剩余的大小，可能会在缓存满时先产生一个<code>UART_RX_RDY</code>事件，等到数据完全接收完毕，空闲超时时又产生一个<code>UART_RX_RDY</code>事件。如何处理这种corner case？还需要开发者去思考一下。</p>
</blockquote>
<h2 id="Nordic-Software-LPUART原理"><a href="#Nordic-Software-LPUART原理" class="headerlink" title="Nordic Software LPUART原理"></a>Nordic Software LPUART原理</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/18e69822c987a7b0bf2b4c81b9f2203f.png" alt="image-20231113114031848"></p>
<p>Nordic提供了一个软件实现的低功耗串口，通过额外的两根线来识别是否有数据发出。由于是对称连接的，这里只给出一个MCU的TX和REQ引脚的实测波形图：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a6d7bd513642ec913005d0f59b25e346.png" alt="image-20231113114358096"></p>
<p>通信步骤：</p>
<ol>
<li>发送端要发送数据前，先拉高REQ引脚；然后把REQ引脚配置为上拉输入模式。</li>
<li>接收端RDY检测到上升沿，把串口RX使能。然后从RDY引脚输出一个几毫秒的负脉冲。然后把RDY引脚配置为上拉输入模式。</li>
<li>发送端REQ引脚检测到上升沿，才通过TX发出数据</li>
<li>发送完毕后，发送端拉低REQ引脚</li>
<li>接收端检测到RDY引脚下降沿，关闭串口RX。并产生<code>UART_RX_RDY</code>事件给应用层。</li>
</ol>
<blockquote>
<p>可以看出，这时<code>UART_RX_RDY</code>事件并不是空闲超时产生的，而是RDY引脚上拉产生的。因此会比普通的异步串口回调更早执行。</p>
</blockquote>
<h2 id="Nordic-LPUART例程"><a href="#Nordic-LPUART例程" class="headerlink" title="Nordic LPUART例程"></a>Nordic LPUART例程</h2><p>相关链接：</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples/peripheral/lpuart/README.html">lpuart例程说明</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/uart_nrf_sw_lpuart.html#uart-nrf-sw-lpuart">lpuart库说明</a></p>
<p>lpuart例程位置：<code>$&#123;NCS&#125;/nrf/samples/peripheral/lpuart</code></p>
<p>例程有<strong>基于中断</strong>和<strong>异步串口</strong>两种模式。相信看完了前面内容的你，看懂这些代码对你来说已经轻而易举了。</p>
<p>这里只再说一些配置相关的内容。</p>
<p>首先是设备树，在<code>boards/nrf52840dk_nrf52840.overlay</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart1 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;uart1_default_alt&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;uart1_sleep_alt&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">    lpuart: nrf-sw-lpuart &#123;</span><br><span class="line">        compatible = &quot;nordic,nrf-sw-lpuart&quot;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">        req-pin = &lt;46&gt;;</span><br><span class="line">        rdy-pin = &lt;47&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在串口1的节点内新增了一个子节点<code>nrf-sw-lpuart</code>，其标签为<code>lpuart</code>，兼容的驱动为<code>&quot;nordic,nrf-sw-lpuart&quot;</code>。</p>
<p>代码里，获取的串口也不再是硬件串口，而是这个子节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">lpuart</span> =</span> DEVICE_DT_GET(DT_NODELABEL(lpuart));</span><br></pre></td></tr></table></figure>

<p>系统在启动时，会自动初始化串口1，并初始化sw-lpuart。应用层获取的device结构体是sw-lpuart驱动初始化的。</p>
<p>后续的代码，和前面的异步串口一样。底层的REQ，RDY引脚操作都不需要用户编写代码，已经在驱动代码里被实现了。</p>
<p>再看一下<code>prj.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_NRF_SW_LPUART=y</span><br><span class="line"></span><br><span class="line">CONFIG_UART_1_ASYNC=y</span><br><span class="line">CONFIG_UART_1_INTERRUPT_DRIVEN=n</span><br><span class="line">CONFIG_UART_1_NRF_HW_ASYNC=y</span><br><span class="line">CONFIG_UART_1_NRF_HW_ASYNC_TIMER=2</span><br><span class="line">CONFIG_UART_1_NRF_ASYNC_LOW_POWER=y</span><br><span class="line">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>

<p>可以看出，和前面的异步串口的config相比，只是多出来了<code>CONFIG_NRF_SW_LPUART=y</code>来使能这个库。</p>
<h2 id="LPUART例程运行"><a href="#LPUART例程运行" class="headerlink" title="LPUART例程运行"></a>LPUART例程运行</h2><p>例程本身需要外部回环，因此你需要用两根杜邦线进行跳线：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e9fb7b22da2ba7a6fddaa96215d7bd23.png" alt="image-20231113120440376"></p>
<p>RDY和REQ引脚一定要接，否则驱动程序内部的状态会乱掉，出现错误。你可以像我这样先跳线，然后外面再用示波器、逻辑分析仪或USB转串口的RX进行监测。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/37beaef79cc277d49537c2a2c7722bfe.png" alt="image-20231113120838710"></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/11fccc413349dcc1ae6cf706ca0c0dff.png" alt="image-20231113121238377"></p>
<h2 id="功耗表现"><a href="#功耗表现" class="headerlink" title="功耗表现"></a>功耗表现</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/dc680e16ca1f22348ab265bc82d7bcfa.png" alt="image-20231113131330118"></p>
<p>可以看到，在空闲无数据传输时，平均功耗在3.74uA左右。</p>
<h1 id="9-开发自己的程序"><a href="#9-开发自己的程序" class="headerlink" title="9. 开发自己的程序"></a>9. 开发自己的程序</h1><h2 id="把串口程序集成到自己的应用中"><a href="#把串口程序集成到自己的应用中" class="headerlink" title="把串口程序集成到自己的应用中"></a>把串口程序集成到自己的应用中</h2><p>本例程已经非常完善，基本上把<code>app_uart</code>文件夹拷贝到自己的工程中，然后在Kconfig和CMakeLists.txt中引用即可。这也是模块化开发的思想。而且本工程思路还是比较清晰的，开发者想增加自己的代码也会非常容易。</p>
<h2 id="阻塞与低功耗"><a href="#阻塞与低功耗" class="headerlink" title="阻塞与低功耗"></a>阻塞与低功耗</h2><p>这里讨论一下软件上的低功耗问题。Zephyr中的操作系统的阻塞行为（比如<code>k_sleep()</code>和这里的<code>k_msgq_get()</code>），都会让线程暂停，让出CPU资源。当除了IDLE线程外，所有的线程都不在运行，则Zephyr会运行IDLE线程。而IDLE线程在很短的一段时间后会自动让进入CPU休眠。</p>
<p>这意味着开发者可以放心大胆地在自己的线程中使用操作系统的阻塞API，Zephyr系统会自动在合适的时候让CPU休眠。</p>
<h2 id="串口API的兼容"><a href="#串口API的兼容" class="headerlink" title="串口API的兼容"></a>串口API的兼容</h2><p>我们前面提到，异步API和基于中断的API是完全不同的两套API。<br>而在串口驱动目录下的<code>Kconfig.nrfx</code>中可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config UART_1_ASYNC</span><br><span class="line">    bool &quot;Asynchronous API support on port 1&quot;</span><br><span class="line">    depends on UART_ASYNC_API &amp;&amp; !UART_1_INTERRUPT_DRIVEN</span><br><span class="line">    default y</span><br><span class="line">    help</span><br><span class="line">      This option enables UART Asynchronous API support on port 1.</span><br></pre></td></tr></table></figure>
<p>要使用异步API，必须单独禁用这个串口的中断API。<br>如果你要使用USB CDC ACM（需要中断API）的同时使用串口0的异步API，则需要这样配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_0_INTERRUPT_DRIVEN=n</span><br></pre></td></tr></table></figure>
<p>意思是，对于整个串口驱动来说，启用中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig）。<br>但是对于串口0来说，关闭中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig.nrfx）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io">Jayant Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/">https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jayant-tang.github.io/jayant97.github.io" target="_blank">一苇万顷</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/jayant97.github.io/tags/Nordic/">Nordic</a><a class="post-meta__tags" href="/jayant97.github.io/tags/Zephyr/">Zephyr</a><a class="post-meta__tags" href="/jayant97.github.io/tags/DeviceTree/">DeviceTree</a></div><div class="post_share"><div class="social-share" data-image="/jayant97.github.io/imgs/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div class="next-post pull-right"><a href="/jayant97.github.io/2023/08/045cdc9c9b10/" title="在nRF7002开发板上运行MQTT例程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在nRF7002开发板上运行MQTT例程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/jayant97.github.io/2024/01/b74491c1a080/" title="Nordic GPIO硬件原理与NCS应用详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-22</div><div class="title">Nordic GPIO硬件原理与NCS应用详解</div></div></a></div><div><a href="/jayant97.github.io/2023/03/4b274a50e575/" title="详解Zephyr设备树（DeviceTree）与驱动模型"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">详解Zephyr设备树（DeviceTree）与驱动模型</div></div></a></div><div><a href="/jayant97.github.io/2025/01/aeb1d94c5ebc/" title="NCS 低功耗日志打印"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="title">NCS 低功耗日志打印</div></div></a></div><div><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div><a href="/jayant97.github.io/2022/12/2a39e705bff0/" title="理解Zephyr项目的配置与构建系统"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-04</div><div class="title">理解Zephyr项目的配置与构建系统</div></div></a></div><div><a href="/jayant97.github.io/2025/01/5645a5cab10c/" title="NCS Matter例程详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">NCS Matter例程详解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Hello-world%E8%A7%A3%E6%9E%90%E2%80%94printk%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA"><span class="toc-text">2. Hello world解析—printk如何输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">工程目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk%E8%BE%93%E5%87%BA%E9%85%8D%E7%BD%AE"><span class="toc-text">printk输出配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console%E8%AE%BE%E5%A4%87%E4%B8%8Econsole%E9%A9%B1%E5%8A%A8"><span class="toc-text">console设备与console驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Nordic%E4%B8%B2%E5%8F%A3%E7%A1%AC%E4%BB%B6"><span class="toc-text">3. Nordic串口硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UART"><span class="toc-text">UART</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UARTE"><span class="toc-text">UARTE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UARTE%E5%8F%91%E9%80%81%E9%80%BB%E8%BE%91"><span class="toc-text">UARTE发送逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UARTE%E6%8E%A5%E6%94%B6%E9%80%BB%E8%BE%91"><span class="toc-text">UARTE接收逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nRF54%E7%B3%BB%E5%88%97UARTE%E7%A1%AC%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">nRF54系列UARTE硬件新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-4Mbps%E4%B8%B2%E5%8F%A3"><span class="toc-text">（1） 4Mbps串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%94%AF%E6%8C%814%E8%87%B39bits-%E5%B8%A7"><span class="toc-text">（2）支持4至9bits 帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B8%A7%E8%B6%85%E6%97%B6%E4%B8%AD%E6%96%AD"><span class="toc-text">（3）帧超时中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Zephyr%E6%A0%87%E5%87%86%E4%B8%B2%E5%8F%A3API"><span class="toc-text">4. Zephyr标准串口API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E6%96%AD"><span class="toc-text">基于中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-text">异步发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6"><span class="toc-text">异步接收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zephyr%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8"><span class="toc-text">Zephyr串口驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">5. 异步串口代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#src-x2F-app-uart-x2F-app-uart-c"><span class="toc-text">src&#x2F;app_uart&#x2F;app_uart.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%9B%9E%E8%B0%83"><span class="toc-text">串口回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-text">串口接收线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">串口发送线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-c"><span class="toc-text">main.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">异步串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%8C%96RX%E5%8A%9F%E8%83%BD"><span class="toc-text">强化RX功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E4%B8%8D%E5%86%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">硬件计数器（不再推荐）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">异步串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">硬件连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C"><span class="toc-text">异步串口代码运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-USB-CDC-ACM%E4%B8%B2%E5%8F%A3"><span class="toc-text">6. USB CDC ACM串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">USB串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">USB串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81"><span class="toc-text">USB串口代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91USB%E4%B8%B2%E5%8F%A3%E4%BE%8B%E7%A8%8B"><span class="toc-text">编译USB串口例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%B9%B6%E6%B5%8B%E8%AF%95USB%E4%B8%B2%E5%8F%A3"><span class="toc-text">运行并测试USB串口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%B8%B2%E5%8F%A3%E4%BC%91%E7%9C%A0"><span class="toc-text">7. 串口休眠</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Nordic-LPUART%E4%BD%8E%E5%8A%9F%E8%80%97%E4%B8%B2%E5%8F%A3"><span class="toc-text">8. Nordic LPUART低功耗串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nordic-Software-LPUART%E5%8E%9F%E7%90%86"><span class="toc-text">Nordic Software LPUART原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nordic-LPUART%E4%BE%8B%E7%A8%8B"><span class="toc-text">Nordic LPUART例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LPUART%E4%BE%8B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">LPUART例程运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97%E8%A1%A8%E7%8E%B0"><span class="toc-text">功耗表现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">9. 开发自己的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%88%90%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD"><span class="toc-text">把串口程序集成到自己的应用中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97"><span class="toc-text">阻塞与低功耗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3API%E7%9A%84%E5%85%BC%E5%AE%B9"><span class="toc-text">串口API的兼容</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Jayant Tang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/jayant97.github.io/js/utils.js"></script><script src="/jayant97.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c91ce0493b5c3e886110',
      clientSecret: '7599decf69128ba1a83c1f3ef0923395a9bd8a60',
      repo: 'jayant97.github.io',
      owner: 'Jayant-Tang',
      admin: ['Jayant-Tang'],
      id: '5749979c1110dfbff33bebe72e76e426',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/jayant97.github.io/js/search/local-search.js"></script></div></div></body></html>