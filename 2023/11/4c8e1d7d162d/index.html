<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Zephyr驱动与设备树实战——串口 | 一苇万顷</title><meta name="author" content="Jayant Tang,jayant.tang@nordicsemi.no"><meta name="copyright" content="Jayant Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2026.1.4更新：  新增54系列GPIO跨域使用配置，以及功耗测试  2025.7.26更新：  新增54L15串口硬件介绍 新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。 增加全新的串口例程代码并上传GitHub  2025.5.5更新：  增加了对串口硬件的介绍 增加串口API更详细的介绍与图示   1. 前言之前写了一篇详细的">
<meta property="og:type" content="article">
<meta property="og:title" content="Zephyr驱动与设备树实战——串口">
<meta property="og:url" content="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html">
<meta property="og:site_name" content="一苇万顷">
<meta property="og:description" content="2026.1.4更新：  新增54系列GPIO跨域使用配置，以及功耗测试  2025.7.26更新：  新增54L15串口硬件介绍 新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。 增加全新的串口例程代码并上传GitHub  2025.5.5更新：  增加了对串口硬件的介绍 增加串口API更详细的介绍与图示   1. 前言之前写了一篇详细的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png">
<meta property="article:published_time" content="2023-11-12T09:48:56.000Z">
<meta property="article:modified_time" content="2026-01-11T08:07:29.794Z">
<meta property="article:author" content="Jayant Tang">
<meta property="article:tag" content="Nordic">
<meta property="article:tag" content="Zephyr">
<meta property="article:tag" content="DeviceTree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png"><link rel="shortcut icon" href="/jayant97.github.io/img/favicon.png"><link rel="canonical" href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/jayant97.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/jayant97.github.io/',
  algolia: undefined,
  localSearch: {"path":"/jayant97.github.io/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Zephyr驱动与设备树实战——串口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-11 16:07:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/jayant97.github.io/imgs/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/jayant97.github.io/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/jayant97.github.io/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/jayant97.github.io/" title="一苇万顷"><span class="site-name">一苇万顷</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Zephyr驱动与设备树实战——串口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T09:48:56.000Z" title="发表于 2023-11-12 17:48:56">2023-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-11T08:07:29.794Z" title="更新于 2026-01-11 16:07:29">2026-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/">RTOS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/Zephyr/">Zephyr</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title="Zephyr驱动与设备树实战——串口"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/jayant97.github.io/2023/11/4c8e1d7d162d/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>2026.1.4更新：</p>
<ul>
<li>新增54系列GPIO跨域使用配置，以及功耗测试</li>
</ul>
<p>2025.7.26更新：</p>
<ul>
<li>新增54L15串口硬件介绍</li>
<li>新增串口增强接收（Enhanced RX）的介绍。不再推荐使用PPI+Timer的形式进行接收数据计数。</li>
<li>增加全新的串口例程代码并上传GitHub</li>
</ul>
<p>2025.5.5更新：</p>
<ul>
<li>增加了对串口硬件的介绍</li>
<li>增加串口API更详细的介绍与图示</li>
</ul>
</blockquote>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。</p>
<p>今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中<code>zephyr/samples/hello_world</code>例程为基础。分别添加<strong>串口</strong>、<strong>USB CDC ACM</strong>、<strong>低功耗串口</strong>的功能。采用<strong>完全相同的应用层代码</strong>，只需要修改config和dts即可切换。</p>
<h1 id="2-Hello-world解析—printk如何输出"><a href="#2-Hello-world解析—printk如何输出" class="headerlink" title="2. Hello world解析—printk如何输出"></a>2. Hello world解析—printk如何输出</h1><p>开发板我选择nRF52840DK。首先以<code>zephyr/samples/hello_world</code>例程为模板，创建一个新工程，我在这里把工程命名为<code>learning_zephyr_serial</code>。</p>
<h2 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">|  |</span><br><span class="line">|  `--main.c</span><br><span class="line">|--CMakeLists.txt</span><br><span class="line">`--prj.conf</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>中先把Zephyr作为包来导入，然后把main.c添加为源码。</p>
<p><code>prj.conf</code>目前是空的，在这里可以写一些配置用来覆盖默认的Kconfig。</p>
<p>例程默认没使用<code>Kconfig</code>菜单文件，是因为本工程太简单，没有自己的配置项，所以不需要自己的Kconfig文件。这种情况完全等价于Kconfig文件中只写了下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>

<p>相当于项目中只有Zephyr的菜单，可以让我们配置Zephyr系统的配置项，以及SDK中各个module的的配置项。选择板子，编译并烧录后，打开串口，reset一下，就能看到刚启动时串口输出的hello world了。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8065d44b86cceb9ff0e8b1ab1417eda2.png" alt="image-20231112183822534"></p>
<h2 id="printk输出配置"><a href="#printk输出配置" class="headerlink" title="printk输出配置"></a>printk输出配置</h2><p>很多新上手Zephyr的读者会有疑惑，这工程里几乎没什么代码，也没看到CONFIG和device tree文件，串口到底是怎么输出的？</p>
<p>其实，在我们选择板子时，板子就已经自带了默认的device tree和config文件。因此编译时采用的全部是板子和Zephyr系统的默认值，我们的工程中并没有对这些默认值进行修改。</p>
<p>我们可以在<code>build/zephyr/</code>目录下看到<code>.config</code>文件和<code>zephyr.dts</code>文件。这个就是项目最终编译采用的配置项和设备树。</p>
<p>在<code>.config</code>中，我们可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_PRINTK=y</span><br></pre></td></tr></table></figure>

<p>也就是启用了<code>printk()</code>输出的功能。</p>
<p>我们把这一行复制到prj.conf中（这个行为本身没有意义，因为默认就是y），然后就可以用<strong>Ctrl+鼠标左键</strong>点击这个选项，跳转到这个配置项定义的地方，就可以看到这个配置项的说明：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a2ee0a066378d3944f23bccfebfedc5f.png" alt="image-20231112184745524"></p>
<p>当然，你也可以在Kconfig GUI中找到这个配置项：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/09529eaa5aec7ff3197ab355163f7b47.png" alt="image-20231112184921595"></p>
<blockquote>
<p>到这里，是否对“<code>Kconfig</code>定义了一个菜单，而<code>prj.conf</code>文件是对菜单中配置项的默认值进行修改”这句话有了一定的感受呢？</p>
</blockquote>
<h2 id="console设备与console驱动"><a href="#console设备与console驱动" class="headerlink" title="console设备与console驱动"></a>console设备与console驱动</h2><p>根据此配置项的说明，我们知道<code>printk()</code>是Zephyr的一个内核服务，它可以让通过<code>printk()</code>函数打印的内容通过”console”输出。这里的console指的是一个设备，可以让Zephyr系统输入和输出字节流。</p>
<p>通过查看<code>build/zephyr/zephyr.dts</code>，可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">   ...</span><br><span class="line">    chosen &#123;</span><br><span class="line">        ...</span><br><span class="line">        zephyr,console = &amp;uart0;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>/chosen</code>节点下，有很多<strong>属性</strong>。Zephyr系统内核的代码在运行一些功能时，并不在乎底层的硬件具体是什么，它只从<code>/chosen</code>节点下找到对应的硬件。只要这个硬件已经在RTOS初始化之前就被驱动程序初始化了，具有Zephyr标准外设接口，那么Zephyr内核就可以操作这个硬件。</p>
<p>例如，要想获得这里的console设备的DeviceTree Node ID，就可以用<code>DT_CHOSEN(zephyr_console)</code>。</p>
<p>我们自然可以联想到，可以把console换成其他<strong>串口设备</strong>，就可以让日志从其他串口输出了。这里，可以参考我的另一篇随笔<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/p/17784156.html">《Zephyr重定向日志打印到USB串口》</a>。</p>
<p>如果你只是修改设备树中的console设备，那么不管如何修改，输出日志的设备都必须是一个“串口”（在Zephyr中USB CDC ACM设备也是串口，后文会解释）。在<code>build/zephyr/.config</code>中，我们还可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p>原来，在当前配置下，Zephyr默认的console后端都必须是“串口”设备。</p>
<p>我们可以尝试把console后端改成RTT，在<code>prj.conf</code>中，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/551a9a209c0745054d3342e2217c28c8.png" alt="image-20231112191457497"></p>
<p>然后就可以看到，printk()的日志从RTT中打印出来了。</p>
<p>对于探究心强的读者，到这里肯定又会有疑问：为什么把console后端改成了RTT，只改了config，设备树就不用改了？</p>
<p>关于这个问题，我想先传达出一个观点，那就是一个系统无论使用了什么样的框架，<strong>最终一定要落实到代码</strong>。通过在NCS中全局搜索<code>CONFIG_RTT_CONSOLE</code>和<code>CONFIG_UART_CONSOLE</code>，我们最终能找到这样的一个文件，<code>$&#123;NCS&#125;/zephyr/drivers/console/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_RTT_CONSOLE rtt_console.c)</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_UART_CONSOLE uart_console.c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>console本身作为一个中间件，也是要通过驱动程序向Zephyr提供标准console API的。在这里，CMake根据不同的CONFIG配置项，添加了不同的console驱动源码进入系统之中，进行编译。</p>
<p>在uart_console.c中，我们明显能看到，此驱动代码需要通过device tree来找到标准的串口设备，然后调用标准的串口API来通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">const</span> <span class="title">uart_console_dev</span> =</span></span><br><span class="line">    DEVICE_DT_GET(DT_CHOSEN(zephyr_console));</span><br></pre></td></tr></table></figure>

<p>而在rtt_console.c中，我们可以看到此代码不需要获取任何device tree的信息。因此，当我们选择RTT作为后端时，无论device tree中的<code>/chosen</code>节点中如何选择<code>zephyr,console</code>，对于RTT console驱动代码来说都是没有意义的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过前面的分析，我们可以有以下结论：</p>
<p>首先，在Zephyr系统中有许多功能，我们可以用Kconfig的方式进行配置或裁减。</p>
<p>此外，Zephyr中有非常明显的“分层设计”，例如，Nordic提交nrf系列串口驱动代码，提供Zephyr标准串口API；Zephyr有console驱动代码，向更上层提供标准console API；如果console是串口驱动，它还会调用标准串口 API来把日志输出到底层串口中；由于API是标准的，因此console驱动代码并不在乎底层到底是物理串口还是USB CDC ACM设备。</p>
<p>前面分析了Hello world是如何通过console输出的。在Zephyr中，console主要是用来做一些字节流的传输，用来实现一些更上层的服务，例如自定义<code>shell</code>命令。而用户要开发自己的程序，肯定是需要自己直接操作串口，而不是用什么printf。</p>
<h1 id="3-Nordic串口硬件"><a href="#3-Nordic串口硬件" class="headerlink" title="3. Nordic串口硬件"></a>3. Nordic串口硬件</h1><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/47b66b8aa6839171773ff5e5abf53fb5.png" alt="image-20250505231527537"></p>
<p>UART是最简单的硬件串口功能。图中小正方形为对外的硬件引脚，而箭头代表串口在MCU内部的输入、输出信号。</p>
<ul>
<li><p><strong>接收</strong>：在串口接收已经使能（STARTRX）的状态下，从RX线来的数据会被放入RXD寄存器，并产生RXDRDY事件。​</p>
<p>接收FIFO长度为6。RXD的数据被CPU读取后，立即从FIFO中把下一个数据填入RXD，并产生RXDRDY事件。（若使能流控，会在FIFO还剩4个空位时把RTS拉高以阻止对方发送）</p>
</li>
<li><p><strong>发送</strong>：在串口发送已使能（STARTTX）的情况下，向TXD写入1个字节就会发送。发送完毕后，UART产生TXDRDY事件。</p>
</li>
</ul>
<p>这些事件都能用来触发中断，或者作为PPI信号触发其他外设的task。</p>
<h2 id="UARTE"><a href="#UARTE" class="headerlink" title="UARTE"></a>UARTE</h2><p>UARTE和UART是不同的外设，但是共用了部分寄存器和电路。在使用时，这种具有相同地址的外设被称为同一个<strong>实例（Instance）</strong>，<strong>不能同时使能</strong>。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fc3805662646766f565b4b9f4c4e2c3b.png" alt="image-20250505232121430"></p>
<p>他们的ENABLE寄存器地址是相同的，但是使能所用的bit不同：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fcca18a4a9b88168f161c24e7088e1cc.png" alt="image-20250505232133627"></p>
<p>UARTE (UART with EasyDMA) 功能和UART是类似的，只不过有了EasyDMA的帮助，可以自动从RAM中取出数据发出；也可以把收到的数据直接存入RAM。无需CPU参与单个字节的收发处理，提升了效率，降低了功耗。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0a3a5712a20c3b9b9dda64a66061394e.png" alt="image-20250505232323499"></p>
<h3 id="UARTE发送逻辑"><a href="#UARTE发送逻辑" class="headerlink" title="UARTE发送逻辑"></a>UARTE发送逻辑</h3><p> <img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3b12c40231d46b93b26dffabd1d6874c.png" alt="image-20250505232526893"></p>
<ol>
<li>TXD.PTR填入数据在RAM中的首地址，TXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>
<li>使用STARTTX来启动自动的传输</li>
<li>传输完毕后，有ENDTX事件提示</li>
<li>中间每个字节的TXDRDY事件，CPU可以无视</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li><strong>串口的发送功能</strong>只在<strong>STARTTX和ENDTX之间</strong>有功耗，其余时间几乎不产生电流消耗</li>
<li>EasyDMA只能在RAM和外设之间传输数据，不能在RAM之间传输，也不能有FLASH参与。</li>
</ul>
</blockquote>
<h3 id="UARTE接收逻辑"><a href="#UARTE接收逻辑" class="headerlink" title="UARTE接收逻辑"></a>UARTE接收逻辑</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4a1b1a2b4f6c7d42deed43321b23e45f.png" alt="image-20250505232812582"></p>
<ol>
<li>RXD.PTR填入数据首地址，RXD.MAXCNT填入要发送的数据长度（nRF52840最大65535，nRF52832最大255）.</li>
<li>使用STARTRX来启动自动的接收</li>
<li>传输完毕后（指RAM中存的数据长度已经达到了MAXCNT），有ENDRX事件提示</li>
<li>中间每个字节的RXDRDY事件，无需再使能中断（从而降低功耗，提高CPU效率）</li>
</ol>
<p>特别地，RXD.PTR具有双缓存（影子寄存器）。也就是说，不用等到传输完成，只需在第一次接收开始后（RXSTARTED），就马上给RXD.PTR写入下一次要用的buffer首地址。这样下次传输时，就能立刻用上新的buffer。便于应用层实现<strong>双buffer</strong>。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>串口在接收状态（STARTRX）会有功耗，有几百uA。因此需要避免待机时一直开着RX。</li>
<li>UARTE只有在接收完毕（buffer满）时才会产生中断。本身没有空闲帧中断，或者说超时机制。需要其他外设辅助实现。</li>
</ul>
</blockquote>
<h2 id="nRF54系列UARTE硬件新功能"><a href="#nRF54系列UARTE硬件新功能" class="headerlink" title="nRF54系列UARTE硬件新功能"></a>nRF54系列UARTE硬件新功能</h2><p>以nRF54L15为例，有以下功能更新：</p>
<h3 id="（1）-4Mbps串口"><a href="#（1）-4Mbps串口" class="headerlink" title="（1） 4Mbps串口"></a>（1） 4Mbps串口</h3><p>在默认低频时钟域（16MHz）的情况下，串口的波特率可以由寄存器设置，如下最高为1Mbps。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/894689018edad6a0629abdbdda936465.png" alt="image-20250726225627521"></p>
<p>但是，nRF54L15的 <strong>UARTE00</strong> 位于MCU PowerDomain，其时钟频率为128MHz：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/32231108676d0bbe54cf8b10b61a32ea.png" alt="image-20250726225904621"></p>
<p>这时，串口的实际波特率就和寄存器中的定义不相同，实际的公式手册中已经给出。</p>
<p>但是我们做软件开发时无需关心这部分，因为在54L15芯片的原始设备树dtsi中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart00: uart@4a000 &#123;</span><br><span class="line">    compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class="line">    reg = &lt;0x4a000 0x1000&gt;;</span><br><span class="line">    interrupts = &lt;74 NRF_DEFAULT_IRQ_PRIORITY&gt;;</span><br><span class="line">    clocks = &lt;&amp;hfpll&gt;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">    endtx-stoptx-supported;</span><br><span class="line">    frame-timeout-supported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其已经指明了使用的是hfpll时钟。</p>
<p>然后，在最新（目前为NCS v3.0.2）的UARTE的驱动代码<code>uart_nrfx_uarte.c</code>中，已经自动考虑了低频时钟和高频时钟的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When calculating baudrate we need to take into account that high speed instances</span></span><br><span class="line"><span class="comment"> * must have baudrate adjust to the ratio between UARTE clocking frequency and 16 MHz.</span></span><br><span class="line"><span class="comment"> * Additionally, &gt;1Mbaud speeds are calculated using a formula.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UARTE_GET_BAUDRATE2(f_pclk, current_speed)                    \</span></span><br><span class="line"><span class="meta">    ((f_pclk &gt; NRF_UARTE_BASE_FREQUENCY_16MHZ) &amp;&amp; (current_speed &gt; 1000000)) ?	\</span></span><br><span class="line"><span class="meta">        UARTE_GET_CUSTOM_BAUDRATE(f_pclk, current_speed) :			\</span></span><br><span class="line"><span class="meta">        (NRF_BAUDRATE(current_speed) / UARTE_GET_BAUDRATE_DIV(f_pclk))</span></span><br></pre></td></tr></table></figure>

<p>因此我们在软件上是感知不到这个差别的，只需正常配置我们需要的波特率即可。需要4M就配置<code>current-speed = &lt;4000000&gt;</code>；需要115200就配置<code>current-speed = &lt;115200&gt;</code>。</p>
<h3 id="（2）支持4至9bits-帧"><a href="#（2）支持4至9bits-帧" class="headerlink" title="（2）支持4至9bits 帧"></a>（2）支持4至9bits 帧</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/6567df1a02e316811b9c173667ee9705.png" alt="image-20250726231953984"></p>
<p>数据帧支持被配置为4bit ~ 9bit。</p>
<p>其中，当配置为9bit时，第9个bit是地址位。当其为1时，代表前8个bits是地址；当其为0时，代表前8个是数据。</p>
<p>且9bit模式下，只有先收到地址和ADDRESS寄存器匹配的第一个地址包时，才会接收后面的数据包。否则忽略所有收到的串口数据。</p>
<h3 id="（3）帧超时中断"><a href="#（3）帧超时中断" class="headerlink" title="（3）帧超时中断"></a>（3）帧超时中断</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b893b6f7b506da554c2fb02217dda58c.png" alt="image-20250726232649715"></p>
<p>帧超时中断，或者说空闲帧中断，指的是：</p>
<ul>
<li>当连续一定时间没有收到串口数据时，就认为传输已经结束</li>
<li>此时不再等待DMA缓冲存满，而是直接产生DMA传输完成中断</li>
<li>应用层可以及时把数据取出进行处理</li>
</ul>
<p>之前的nRF52和53系列是没有这个功能的，需要操作系统软定时器进行计时，把一个timeout分成5份设定k_timer周期。如果每次软定时器到期，串口已经收到的数据量没有增长，那么就说明串口空闲了。这时由驱动层软件主动结束串口接收。这就不如nRF54系列UARTE硬件自带空闲帧超时来的方便。</p>
<p>只有<strong>异步串口</strong>才需要这个功能。因为<strong>阻塞</strong>和<strong>基于中断</strong>的串口都是按字节实时同步接收串口数据的。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/54c73f2e0da701646bbed68f13480de9.png" alt="image-20250726233308626"></p>
<p>空闲帧中断最大超时时间为 2^10 - 1&#x3D; 1023 bits。在115200波特率下，大约是8.88ms。而使用软定时器的方式，可以设置更长时间。</p>
<p>nRF54L15的设备树默认开启了空闲帧的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart20 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    frame-timeout-supported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于支持帧超时中断的串口外设，就直接使用这个功能即可。不要删除这个属性。</p>
<p>异步串口初始化时，通过<code>uart_rx_enable(dev, buf, len, timeout)</code>打开RX时，传入的timeout值（单位：微秒）会经过如下处理：</p>
<ul>
<li>如果开启了空闲帧中断，则取应用层传入的 timeout 和 1023 bits 之中，取时间更短的一个，会被设置到FRAMETIMEOUT寄存器中</li>
<li>如果没开启空闲帧中断，则用k_timer实现此功能，超时值为函数传入的timeout</li>
</ul>
<h1 id="4-Zephyr标准串口API"><a href="#4-Zephyr标准串口API" class="headerlink" title="4. Zephyr标准串口API"></a>4. Zephyr标准串口API</h1><p>上一节以nRF52系列的串口外设为例介绍了硬件部分，Nordic其他产品的串口基本也是一致的。</p>
<p>本节介绍Zephyr中的串口API。</p>
<p>Zephyr中的串口API分为**<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-polling-api">阻塞（Polling）</a><strong>、</strong><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-interrupt-api">基于中断（Interrupt-driven）</a>**、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-async-api"><strong>异步（Asynchronous）</strong></a>三种。</p>
<p>Zephyr串口API是一套软件接口，与硬件细节无关。除了Nordic的UART&#x2F;UARTE硬件可以用这套接口，其他厂商的串口实现也可以支持这套接口。甚至我们后面会介绍到的USB虚拟串口，也支持这套接口。这里给出<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html">Zephyr标准串口API文档</a>，供参考。</p>
<blockquote>
<p>NCS中的例程太多，对于不熟悉的人来说，随便复制代码，很有可能出现：代码里用的是一种API，但CONFIG使能的却是另一种API的情况，最终导致程序无法运行。</p>
<p>一般来说，同一个串口实例，基于中断的和异步的API是不能同时使用的。但是阻塞的API可以和前两者中的一种混用。</p>
</blockquote>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>基于阻塞的API是最简单的API。</p>
<ul>
<li><code>uart_poll_in()</code>：读取时，只读一个字节。有就返回0，无就返回-1，不阻塞；</li>
<li><code>uart_poll_out()</code>：发送时，只发一个字节。发送完毕后才返回，阻塞行为。</li>
</ul>
<h2 id="基于中断"><a href="#基于中断" class="headerlink" title="基于中断"></a>基于中断</h2><p>首先声明，Zephyr串口API是一套软件接口，<strong>与硬件细节无关</strong>。基于中断的API只是抽象地认为有串口外设<strong>应当有</strong>发送ready中断和接收ready中断。具体如何映射到硬件？完全由厂商提供的驱动代码实现，不需要应用开发者实现。这也是USB虚拟串口也能使用这套API的原因。</p>
<p>NCS中，使用串口中断API的例程很多。<strong>但是它们在应用层编写callback函数的方式五花八门，与应用层本身的功能混在一起，这对于初学者来说容易抓不到重点</strong>。这也侧面说明，中断API适合添加一些应用层自定义的东西。因此我在这里总结出基于中断的API的使用流程，方便开发者结合代码进行观看。</p>
<p>以下为流程：</p>
<ol>
<li>开始时，用<code>uart_irq_callback_set()</code>函数设置好“应用层的”中断回调函数，这个函数会在串口ISR中根据情况被串口驱动程序调用。然后，开启<code>uart_irq_rx_enable()</code>，使能接收。</li>
<li>要发送时，先准备好要发送的数据（首地址和长度），然后<code>uart_irq_tx_enable()</code>开启发送中断。</li>
<li>发生中断，进入预先设置好的回调函数时，先用<code>uart_irq_update()</code>更新中断状态，再用<code>uart_irq_is_pending()</code>判断是否有中断（以防是别处误调用了该回调函数）。再之后用<code>uart_irq_tx_ready()</code>和<code>uart_irq_rx_ready()</code>来判断是发送中断还是接收中断。</li>
<li>如果是接收中断，<strong>在中断里</strong>用<code>uart_fifo_read()</code>循环读取，每次读取1个字节（Nordic的驱动实现是只读1个字节），直到返回值为0（表示缓存里已无数据）。</li>
<li>如果是发送中断，说明发送器已经ready，<strong>在中断里</strong>用<code>uart_irq_tx_fill()</code>，把前面准备好要发送的数据传入，即可发送。</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>不要在中断callback里进行耗时的处理和阻塞行为。善用queue和work queue。</li>
<li><code>uart_fifo_read()</code>和<code>uart_fifo_fill()</code>只能在这个中断callback函数内部调用</li>
</ul>
</blockquote>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步API是本文介绍的重点，它带有DMA，因此可以让数据传输时，不影响CPU的运行。但是它的配置最复杂，功能最强大。</p>
<h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b161ff61daac34105ac418a0d8ff86b4.png" alt="image-20250506000430849"></p>
<p>调用<code>uart_tx(dev, *buf, len, timeout)</code>，给定首地址和长度即可，函数不阻塞。Timeout是给流控用的，如果输出被对方的流控阻止，自己能等待多久，如果没有流控就不用在意。</p>
<p>发送过程由驱动层和硬件自动处理。</p>
<p>发送完毕后，回调函数里会收到<strong>UART_TX_DONE</strong>事件。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>注意发送数据buffer的生命周期，不能是局部变量</li>
<li>如果buffer的地址不属于于RAM，Nordic的驱动程序会先自动执行一个拷贝到RAM中的动作。因为硬件不支持RAM以外的地方到外设的DMA。</li>
<li>uart_tx这个行为是低功耗的。只要不在发送，就没有发送行为相关的功耗。无需disable串口。</li>
</ol>
</blockquote>
<p>在DMA传输期间，如果再次执行uart_tx()，函数会返回<code>-EBUSY</code>错误码：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/0c8c3cc39029da6d8d7da1eeafbabc38.png" alt="image-20250727000130872"></p>
<p>后续例程会展示如何实现发送缓冲线程。</p>
<h3 id="异步接收"><a href="#异步接收" class="headerlink" title="异步接收"></a>异步接收</h3><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/617d9c8e5b5060c0dcc1e9f741850e20.png" alt="image-20250506000958480"></p>
<ol>
<li>用<code>uart_rx_enable(dev, *buf, len, timeout_us)</code>来首次使能接收。给定Buffer和长度。Buffer收满以后会产生UART_RX_RDY事件。</li>
<li>Timeout是空闲超时机制。在至少收到1个字节之后，即使buffer未满，如果超时，也会产生<code>UART_RX_RDY</code>事件。这是为了方便收取一个小于buffer长度的包的情况。单位是微秒。timeout时间设为SYS_FOREVER_US会关闭这个机制。</li>
<li>如果buffer未满，下次数据接收会继续填充在此buffer内。如果buffer已满，紧接在UART_RX_RDY事件之后，会产生UART_RX_BUF_RELEASED事件。告知应用层，一开始的buffer已经不再使用，可以释放。</li>
<li>异步API也提供双Buffer机制。当每次接收开始时，驱动层会立即产生UART_RX_BUF_REQUEST事件。向应用层请求第二个buffer。应用层有两个选择：<ul>
<li>用uart_rx_buf_rsp(dev, *buf, len)来设置第二个buffer。当第一个buffer满时，驱动层自动开始用第二个buffer。</li>
<li>无视这个请求。那么这次接收完毕时，整个接收会被disable。需要再次enable才能开始接收。</li>
</ul>
</li>
</ol>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/5d9b9ad4db0201e8f1dc44ae7342d418.png" alt="image-20250506000854098"></p>
<h2 id="Zephyr串口驱动"><a href="#Zephyr串口驱动" class="headerlink" title="Zephyr串口驱动"></a>Zephyr串口驱动</h2><p>无论是阻塞、基于中断、还是异步API。它们都是由Nordic的驱动程序提供的。</p>
<p>当<code>CONFIG_SERIAL=y</code>，就使能了Zephyr的串口驱动。Zephyr系统内的CMake规则会自动把相关MCU的串口驱动编译进去。</p>
<p>而Nordic是提供了三种驱动的：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2d16fa1b03901a6cfd6347d0d8b5208b.png" alt="image-20250506001935633"></p>
<p>使用时，注意在device tree中设置正确的compatible，来选择正确的驱动。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2753bd1faeeebb2e7251143b27988756.png" alt="image-20250506001833817"></p>
<blockquote>
<p><strong>设备树的compatible和驱动程序是如何对应的？</strong></p>
<p>​    设备树的compatible属性，在编译阶段会被转换成C语言命名规范允许的形式（特殊符号全变为下划线），如<code>nordic_nrf_uarte</code>。</p>
<p>​    每个驱动程序会用自己的方法遍历设备树中所有compatible与自己相匹配的节点。然后基于这个节点的信息来初始化硬件外设。</p>
<p><strong>uarte和uarte2有什么区别？</strong></p>
<p>​    见<code>zephyr/driver/serial/CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONFIG_UART_NRFX_UARTE)</span><br><span class="line">  <span class="keyword">if</span> (CONFIG_UART_NRFX_UARTE_LEGACY_SHIM)</span><br><span class="line">    zephyr_library_sources(uart_nrfx_uarte.c)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(DEPRECATION</span><br><span class="line">        <span class="string">&quot;Do not set CONFIG_UART_NRFX_UARTE_LEGACY_SHIM=n as this option is deprecated.&quot;</span>)</span><br><span class="line">    zephyr_library_sources(uart_nrfx_uarte2.c)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-异步串口代码示例"><a href="#5-异步串口代码示例" class="headerlink" title="5. 异步串口代码示例"></a>5. 异步串口代码示例</h1><p>示例代码：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Jayant-Tang/learning_zephyr_serial">Jayant-Tang&#x2F;learning_zephyr_serial: An example that shows how to use zephyr Async UART</a></p>
<p>读者可以下载示例代码后，对照阅读本文</p>
<blockquote>
<p>【注意】<br>本文基于NCS v3.0.2。若读者使用v2.4.2或以下版本，代码中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> *)evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>需要改回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>因为版本升级后<code>k_mem_slab_free</code>的实现不同，参数从二级指针变为了一级指针。</p>
</blockquote>
<h2 id="src-x2F-app-uart-x2F-app-uart-c"><a href="#src-x2F-app-uart-x2F-app-uart-c" class="headerlink" title="src&#x2F;app_uart&#x2F;app_uart.c"></a>src&#x2F;app_uart&#x2F;app_uart.c</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先是获得device，这里的方法是用aliases别名来获取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* serial device */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_INST DT_ALIAS(learning_serial)</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> DEVICE_DT_GET(UART_INST);</span><br></pre></td></tr></table></figure>

<p>因为在不同板子的设备树中，都已经选好了对应的串口：</p>
<p><code>nrf54l15dk_nrf54l15_cpuapp.overlay</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart20;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>nrf52840dk_nrf52840.overlay</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart0;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是初始化时，注册异步回调函数，并开启串口接收。这里除了device结构体指针之外，还有两组配置。一个是接收缓存及其长度、一个是超时时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT_US);</span><br></pre></td></tr></table></figure>

<p>接收缓存用的是Zephyr的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/memory_management/slabs.html#memory-slabs">memory slab</a>功能。代码中用<code>K_MEM_SLAB_DEFINE</code>定义了几块静态的缓存区域，可以用allocate和free来进行内存块的分配和释放操作。相当于是一个私有的动态内存区域。在<code>main()</code>函数中，先取出了一块内存，然后传入<code>rx_enable</code>作为接收缓存。</p>
<p>超时时间，指的是串口空闲一定时间，没有新数据来，就直接认为接收完毕。即使DMA接收缓存还未满，也要产生空闲事件，并直接调用callback。<strong>这里为了演示，设置为1秒超时</strong>。</p>
<blockquote>
<p>这个超时功能，一般情况下是用软定时器（k_timer）实现的。</p>
<p>但是，对于nRF54L15这种串口硬件本身支持超时帧中断的情况，会使用硬件本身的超时功能。这时，超时时间的最大值就是UARTE硬件帧中断支持的最大时间。比如54l15的串口，空闲帧的最大值为10个bit宽度，在115200波特率下大约为8.9ms。因此，这种情况下设置所有超过8.9ms的时间都会被缩短到8.9ms。</p>
</blockquote>
<h3 id="串口回调"><a href="#串口回调" class="headerlink" title="串口回调"></a>串口回调</h3><p>在回调函数中，每次接收缓存已满，或者达到了超时时间，就会产生<code>UART_RX_RDY</code>事件。在事件结构体中，<code>buf</code>是缓存的首地址，<code>offset</code>是本次收到的数据在缓存中的位置，<code>len</code>是本次收到的数据的长度。因此，本次接收到的数据的真实首地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br></pre></td></tr></table></figure>

<p>每次接收缓存满时，串口rx驱动代码会向应用层申请新的接收缓存，即<code>UART_RX_BUF_REQUEST</code>事件。这时我们从memory slab中分配一块新的内存给它即可。</p>
<p>当串口驱动获得了新的接收缓存时，它也会向应用层申请释放掉旧的接收缓存，即<code>UART_RX_BUF_RELEASED</code>事件。这时我们用memory slab的free函数将其释放即可。</p>
<blockquote>
<p>这里有一些小细节：</p>
<ol>
<li><p>回调函数的形参evt，在call stack中上一层的驱动代码里是一个局部变量。在回调函数返回后，evt会被释放。因此这里如果要实现回环，需要拷贝一份到静态内中。即<code>static uint8_t buf[128]</code>。</p>
</li>
<li><p>如果某一次接收到了很多数据，超出了buffer的剩余空间。那么这次收到的数据就会被分成两部分，产生两次接收回调。这也意味着，我们必须把接收到的数据看作是“字节流”而不是“包”。开发者应该自己实现字节流解包处理函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evt-&gt;data.rx.len; i++)&#123;</span><br><span class="line">    bytes_to_packet(p[i]); <span class="comment">// 开发者自行实现解包函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c中已经实现了这一点。</p>
</li>
<li><p>回调函数实际上运行在中断服务函数内部，因此不要做一些阻塞的行为。如果真的有计算量大的任务，可以把任务提交到<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html">Workqueue Threads</a>。这样你就能把耗时的任务从<strong>特权模式</strong>移动到<strong>用户模式</strong>，也就是从中断内部移动到线程中。</p>
</li>
</ol>
</blockquote>
<h3 id="串口接收线程"><a href="#串口接收线程" class="headerlink" title="串口接收线程"></a>串口接收线程</h3><p>串口接收到数据时，将数据拷贝并通过消息队列发送到RX线程。然后执行应用层的回调函数。再之后free掉申请的内存。</p>
<h3 id="串口发送线程"><a href="#串口发送线程" class="headerlink" title="串口发送线程"></a>串口发送线程</h3><p>应用层要发送数据时，数据先被拷贝并通过消息队列发送到TX线程，然后进行发送。线程会等待发送完毕，然后free掉申请的内存</p>
<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>通过<code>app_uart_rx_cb_register()</code>注册回调函数。当串口收到数据时，回调函数会<strong>在RX线程中被执行</strong>。</p>
<p>要发送数据时，执行<code>app_uart_tx()</code>。此函数不阻塞且会拷贝数据。因此可以从ISR或Thread中调用，也可以传入局部变量。</p>
<p>收到的串口数据是字节流而不是包。因此通过有限状态机实现了串口数据流解包函数，以连续的CRLF（<code>\r\n</code>）为分界，进行数据的解包。</p>
<h2 id="异步串口配置"><a href="#异步串口配置" class="headerlink" title="异步串口配置"></a>异步串口配置</h2><p><code>prj.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use RTT as console</span></span><br><span class="line">CONFIG_USE_SEGGER_RTT=y</span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> logging</span></span><br><span class="line">CONFIG_LOG=y</span><br><span class="line">CONFIG_LOG_BACKEND_RTT=y</span><br><span class="line">CONFIG_LOG_MODE_DEFERRED=y</span><br><span class="line"></span><br><span class="line">CONFIG_SEGGER_RTT_MODE_NO_BLOCK_SKIP=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use ASYNC uart API</span></span><br><span class="line">CONFIG_SERIAL=y</span><br><span class="line">CONFIG_UART_ASYNC_API=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">need k_malloc</span></span><br><span class="line">CONFIG_HEAP_MEM_POOL_SIZE=4096</span><br></pre></td></tr></table></figure>

<p>首先，把console改为RTT，防止日志和我们的串口数据混在一起。</p>
<p><code>CONFIG_SERIAL=y</code>的作用是，使能Zephyr标准串口驱动；<code>CONFIG_UART_ASYNC_API=y</code>使能了异步API。这两项都是Zephyr的串口配置项，来自于<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig</code>。</p>
<p>由于我们需要用到动态内存分配，因此这里要设置HEAP大小<code>CONFIG_HEAP_MEM_POOL_SIZE=4096</code>。</p>
<p><code>boards/&lt;board&gt;.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_xx_ASYNC=y</span><br><span class="line">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</span><br></pre></td></tr></table></figure>

<p><code>CONFIG_UART_xx_ASYNC=y</code>来自于Nordic的配置<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig.nrfx</code>。Zephyr只提供了全局的串口API选择（异步、中断、阻塞）。但是Nordic允许开发者给不同的串口使用不同的API。因此这里需要给特定的串口实例单独启用ASYNC API。</p>
<h2 id="强化RX功能"><a href="#强化RX功能" class="headerlink" title="强化RX功能"></a>强化RX功能</h2><p>上述第二配置，<strong>对性能和功耗影响很大</strong>。虽说串口API是异步的，但底层驱动的实现却有很多变化。当一个外设通过DMA传输数据时，通常来说是DMA缓存写满了，才产生中断，然后把整个缓存传给应用层。但别忘了，我们的异步串口有<strong>空闲超时功能</strong>，如果DMA缓存还没有写满，但因为串口一直没有收到新的数据，超时了，需要立即把目前已经收到的数据传到应用层。这种情况下，<strong>如何才能知道目前已经接收了多少个字节数据呢？</strong></p>
<p>纯软件的方法就是，每收到一个字节就产生中断，在中断服务函数里，通过软件的方式+1，这也是大多数普通的单片机的做法。<strong>如果你不添加最后两行CONFIG配置，那么<code>uart_nrfx_uarte.c</code>驱动就会采用这种方法</strong>。但是当串口速率很高时（如1Mbps），每一个字节都产生中断一定会大量占用CPU资源，效率极低。</p>
<p>因此这里需要强化版RX（Enhanced RX）功能。在底层驱动代码中，当<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX</code>开启时，单个字节的中断不会被使能：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/fe23eea8c563759f1a57c14b8ab88644.png" alt="image-20250727044332567"></p>
<p>这就确保了不会产生单个字节的中断，从而影响CPU性能。</p>
<p>另一方面，在底层驱动的RX enable函数中，使能了连接FRAMETIMEOUT event和 STOP_RX task的SHORT寄存器：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/1bd7e9bcb8d16788c65066091e036adc.png" alt="image-20250727044930863"></p>
<blockquote>
<p>SHORT寄存器（意为短路）就是可以让一个外设的event自动触发该外设的一个task，无需CPU参与。当FRAME_TIMEOUT发生时，外设自动执行STOP_RX。</p>
</blockquote>
<p>对于nRF52系列这种不支持FRAME_TIMEOUT的老系列。超时是靠k_timer软定时器实现的，在rx enable的函数内，把超时时间分成了5份：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">async_rx-&gt;timeout_us = timeout;</span><br><span class="line">async_rx-&gt;timeout_slab = timeout / RX_TIMEOUT_DIV; <span class="comment">// RX_TIMEOUT_DIV = 5</span></span><br></pre></td></tr></table></figure>

<p>底层驱动在RX Started中断里，开始计时：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3237942a0bf438792701ab9bc7ae34b0.png" alt="image-20250727045514187"></p>
<p>如果连续5次都超时，则软件触发STOPRX中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (async_rx-&gt;idle_cnt == (RX_TIMEOUT_DIV - <span class="number">1</span>)) &#123;</span><br><span class="line">    nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和前面的SHORT寄存器是一个思路。</p>
<p>不论是前面二者中的哪种情况，当STOP RX中断发生时，就会进入底层驱动的<code>endrx_isr()</code>。在这里读取DMA的AMOUNT寄存器，就可以在DMA缓存区未满的情况下，获取串口已经收到的字节数了。</p>
<h2 id="硬件计数器（不再推荐）"><a href="#硬件计数器（不再推荐）" class="headerlink" title="硬件计数器（不再推荐）"></a>硬件计数器（不再推荐）</h2><p>在之前版本的文章中，我介绍过Timer+PPI的方式：</p>
<p>Nordic的单片机有独特的功能—— PPI (Programmable peripheral interconnect)。简单来说，就是每个外设都有许多event和task寄存器。event寄存器可以产生中断让CPU去处理；CPU也可以去写task寄存器让外设去执行某些工作。前面介绍过，SHORT寄存器可以把同一个外设的event和它自己的task连接起来。</p>
<p>而PPI可以把两个不同外设的event寄存器和task寄存器连接起来，实现<strong>自动联动，而无需CPU处理</strong>。</p>
<p>如此一来，Nordic串口驱动可以把一个Timer配置为计数器模式（Counter Mode），并且把他的COUNT TASK与串口的接收到单个字节的EVENT通过PPI连接起来。这样计数器就可以自动记录收到了多少个字节。当接收超时的时候，直接从counter中读取计数即可。</p>
<p>在nRF52840上，可以这样配置，将timer2用作uart0的计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_0_ASYNC=y</span><br><span class="line"></span><br><span class="line">CONFIG_UART_NRFX_UARTE_ENHANCED_RX=n</span><br><span class="line"></span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC=y</span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC_TIMER=2</span><br><span class="line"></span><br><span class="line">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>

<p>在nRF54L15上，不推荐用硬件计数，请直接使用<code>CONFIG_UART_NRFX_UARTE_ENHANCED_RX=y</code>，这里也不给出配置，经过我实测：</p>
<ul>
<li>54L15使用硬件计数，开启FRAMTIMEOUT时。出现bug，FRAMETIMEOUT不生效，必须收到大于DMA长度的包才能产生中断；</li>
<li>54L15使用硬件计数，关闭FRAMTIMEOUT，k_timer实现超时功能。出现bug，收到的数据包最后2个字节完全错误，且尾部还会再增加一个随机错误字节。</li>
</ul>
<h2 id="异步串口设备树"><a href="#异步串口设备树" class="headerlink" title="异步串口设备树"></a>异步串口设备树</h2><p>我们并不需要额外修改设备树，直接采用默认值即可。我们这里只是给串口起一个别名，方便不同MCU平台统一代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases&#123;</span><br><span class="line">        learning-serial = &amp;uart20;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;uart20 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于这个串口的具体配置，我们可以直接查看编译后的完整设备树，位于<code>build/&lt;application_name&gt;/zephyr/zephyr.dts</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart0: uart@40002000 &#123;</span><br><span class="line">            compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class="line">            reg = &lt; 0x40002000 0x1000 &gt;;</span><br><span class="line">            interrupts = &lt; 0x2 0x1 &gt;;</span><br><span class="line">            status = &quot;okay&quot;;</span><br><span class="line">            current-speed = &lt; 0x1c200 &gt;;</span><br><span class="line">            pinctrl-0 = &lt; &amp;uart0_default &gt;;</span><br><span class="line">            pinctrl-1 = &lt; &amp;uart0_sleep &gt;;</span><br><span class="line">            pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>主要属性介绍：</p>
<ul>
<li><p><code>reg = &lt; 0x40002000 0x1000 &gt;</code>：芯片自带的属性，外设的地址</p>
</li>
<li><p><code>compatible = &quot;nordic,nrf-uarte&quot;</code>：此处选择了uarte的驱动而非uart驱动。因此最终编译时用的代码是uart_nrfx_uarte.c而非uart_nrfx_uart.c</p>
</li>
<li><p><code>status = &quot;okay&quot;</code>：驱动代码自动初始化外设时，只会初始化状态为<code>&quot;okay&quot;</code>的节点。</p>
</li>
<li><p><code>current-speed = &lt; 0x1c200 &gt;</code>：波特率，也就是写十进制<code>current-speed = &lt; 115200 &gt;</code></p>
</li>
</ul>
<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e1f8ca33f0a8e621f288179dd9ab2173.png" alt="image-20221209144123203"></p>
<p>Nordic开发板的串口0默认GPIO都是在板子上直接连接到Jlink上，然后Jlink把串口转发到USB上，因此电脑上看到的是Jlink的USB串口。</p>
<p>右上角开关，nRF Only是只给单片机核心电路供电，外围LED、Jlink等都不供电，用于测量功耗。因此应该拨到DEFAULT档位。</p>
<p>板载Jlink，USB插左边即可。左下角电源开关打开。</p>
<h2 id="异步串口代码运行"><a href="#异步串口代码运行" class="headerlink" title="异步串口代码运行"></a>异步串口代码运行</h2><p>烧录好程序后，分别打开RTT和串口。从串口发送hello（包含回车+换行），串口就会把hello回环打印出来。并且RTT的日志中会显示收到了7字节，发送了7字节：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/d4f6f910dc63966549e3cda4036916b6.png" alt="image-20250727053522774"></p>
<blockquote>
<ul>
<li>不要用VS Code里面nRF插件提供的这个串口终端。在里面按下回车不是<code>\r\n</code>，无法形成完整数据包。可以用nRF Connect for Desktop里面的串口助手。</li>
<li>如果是52840，前面设置了1s超时，hello就会在发送后1s回环打印出来。如果是54L15，不采用这个超时，而是采用空闲帧中断，hello会在1023个bit时间内打印出来（约8.9ms）。</li>
</ul>
</blockquote>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/befde71fdc0717db731e044fb030feb6.png" alt="image-20250727054355433"></p>
<p>如果一次性发送大量数据，则我们可以看到产生了多个接收完毕中断。由于我们的<code>CONFIG_APP_UART_RX_DMA_BLOCK_SIZE</code>设置的是64，因此每收到64字节，串口驱动就会重新申请一块新的内存。</p>
<p>而应用层<code>main.c</code>中，已经实现了解包函数，因此最终是按照一整包回环发送回来的。</p>
<h1 id="6-USB-CDC-ACM串口"><a href="#6-USB-CDC-ACM串口" class="headerlink" title="6. USB CDC ACM串口"></a>6. USB CDC ACM串口</h1><p>前面介绍了硬件串口的异步API，接下来我们介绍USB CDC ACM串口。</p>
<blockquote>
<p> nRF54L15不含USB，后续用nRF52840DK继续。</p>
</blockquote>
<p>应用层代码无需改动。只需修改一些配置就可以把前面的异步串口代码变为USB CDC ACM串口代码。</p>
<h2 id="USB串口设备树"><a href="#USB串口设备树" class="headerlink" title="USB串口设备树"></a>USB串口设备树</h2><p>在<code>usb.overlay</code>中，有如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    aliases &#123;</span><br><span class="line">        my-usb-serial = &amp;usb_serial0;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;zephyr_udc0 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    usb_serial0: cdc_acm_uart0 &#123;</span><br><span class="line">        compatible = &quot;zephyr,cdc-acm-uart&quot;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们给usbd节点新增了一个子节点<code>/soc/usbd@4002700/cdc_acm_uart0</code>，并且也给其添加了一个label：<code>usb_serial0</code>。</p>
<h2 id="USB串口配置"><a href="#USB串口配置" class="headerlink" title="USB串口配置"></a>USB串口配置</h2><p>在<code>prj_usb.conf</code>中，和<code>prj.conf</code>相比增加了以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable USB Device</span></span><br><span class="line">CONFIG_USB_DEVICE_STACK=y</span><br><span class="line">CONFIG_USB_DEVICE_PRODUCT=<span class="string">&quot;Zephyr CDC ACM sample&quot;</span></span><br><span class="line">CONFIG_USB_DEVICE_PID=0x0001</span><br><span class="line">CONFIG_USB_CDC_ACM=y</span><br><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_LINE_CTRL=y</span><br><span class="line">CONFIG_USB_DEVICE_REMOTE_WAKEUP=n</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable USB ASYNC Adapter</span></span><br><span class="line">CONFIG_UART_ASYNC_ADAPTER=y</span><br></pre></td></tr></table></figure>

<p>最后一项是Nordic的一个中间件。<strong>由于USB串口驱动只实现了基于中断的API，没有实现异步API。因此通过这个Adapter给USB CDC ACM串口驱动附加一层异步API。</strong></p>
<h2 id="USB串口代码"><a href="#USB串口代码" class="headerlink" title="USB串口代码"></a>USB串口代码</h2><p>代码和前面的异步串口代码几乎一样。只是换了一个串口设备：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/435dc3353a9dec6cfd3f33f93d2d9508.png" alt="image-20250727062621425"></p>
<p>另外，在初始化阶段使能了usb，并应用了uart_async_adapter:</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b5a8857c9630e54e55050af81ac89af0.png" alt="image-20250727062711807"></p>
<blockquote>
<p>串口异步接收超时的单位是微秒。在老的异步串口API中，而这个async adapter里实现的rx_enable函数，传入的参数单位是毫秒。因此，注意<code>RX_INACTIVE_TIMEOUT</code>的值。</p>
<p>不过最新的NCS v3.0.2已经修复了此问题。现在单位统一为微秒（us）。</p>
</blockquote>
<h2 id="编译USB串口例程"><a href="#编译USB串口例程" class="headerlink" title="编译USB串口例程"></a>编译USB串口例程</h2><p>编译时选好配置文件和设备树：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4f06c74858516b61a28a039ec11affc1.png" alt="image-20250727063009578"></p>
<p>或者用命令编译：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">west build <span class="literal">-d</span> build_usb <span class="literal">-p</span> <span class="literal">-b</span> nrf52840dk/nrf52840 <span class="literal">--sysbuild</span> <span class="literal">--</span> <span class="literal">-DCONF_FILE</span>=<span class="string">&quot;prj_usb.conf&quot;</span> <span class="literal">-DEXTRA_DTC_OVERLAY_FILE</span>=<span class="string">&quot;boards/nrf52840dk_nrf52840.overlay&quot;</span> <span class="literal">-DDTC_OVERLAY_FILE</span>=<span class="string">&quot;usb.overlay&quot;</span> </span><br></pre></td></tr></table></figure>



<h2 id="运行并测试USB串口"><a href="#运行并测试USB串口" class="headerlink" title="运行并测试USB串口"></a>运行并测试USB串口</h2><p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/8ada0b901ff5c008dd17acc90971ae89.png" alt="image-20231113111154639"></p>
<p>左侧是Jlink USB，下方是nRF52840的USB Device接口。在串口助手里选中USB串口：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/a193007588cb8eb0477e7058cbb42c45.png" alt="image-20250727063204480"></p>
<p>可以看到功能和前面的异步串口完全相同：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ffaa699ebd81acdad4bfbc16e3758957.png" alt="image-20250727063250261"></p>
<h1 id="7-休眠与串口低功耗"><a href="#7-休眠与串口低功耗" class="headerlink" title="7. 休眠与串口低功耗"></a>7. 休眠与串口低功耗</h1><p>要实现系统低功耗的本质就两件事：</p>
<ul>
<li>CPU在无事可做时进入low-power standby状态（ARM的WFE指令或者WFI指令）。</li>
<li>除了CPU以外的外设，不使用时，直接disable</li>
</ul>
<p>前者是Zephyr自带的功能，当IDLE线程之外的其他线程都阻塞等待或sleep时，IDLE线程会自动让CPU进入低功耗休眠模式。之后，CPU被RTC或者串口、GPIO等中断唤醒时，会自动向后执行代码。</p>
<p>后者就是需要代码来控制，在不用的时候把串口关掉。</p>
<blockquote>
<p>除了System ON状态的CPU IDLE之外，Nordic还支持System OFF，直接关闭CPU和所有外设。可以称之为深度睡眠。这种情况只能被GPIO或reset pin唤醒（54系列也可以被GRTC唤醒）。并且唤醒后必定从reset handler开始执行。</p>
</blockquote>
<h2 id="Zephyr设备电源管理（PM-DEVICE）"><a href="#Zephyr设备电源管理（PM-DEVICE）" class="headerlink" title="Zephyr设备电源管理（PM_DEVICE）"></a>Zephyr设备电源管理（PM_DEVICE）</h2><p>Zephyr的外设是被驱动程序自动初始化的，这发生在main()函数之前。因此我们基本上看不到Zephyr驱动提供<code>init</code>或者<code>uninit</code>这种函数。因为我们不需要在应用层初始化或者关闭某个外设。</p>
<p>取而代之的是Zephyr提供了一套电源管理机制，需要使能:<code>CONFIG_PM_DEVICE=y</code>。可以操作每个外设的device指针，使其挂起或者恢复。</p>
<p>比如说，用串口打印日志时，这个串口是被console驱动管理的。console并没有开放API给应用层开启或者关闭串口。但是，应用层可以用Zephyr的设备电源管理来控制这个串口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/pm/device.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">console_dev</span> =</span> DEVICE_DT_GET(DT_CHOSEN(zephyr_console));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    pm_device_action_run(console_dev, PM_DEVICE_ACTION_SUSPEND);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    pm_device_action_run(console_dev, PM_DEVICE_ACTION_RESUME);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>休眠时，首先Zephyr驱动会负责把外设本身关闭。其次，Zephyr驱动还会把外设分配的GPIO配置成提前预设好的Sleep模式，也就是设备树里预设好的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart0 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    current-speed = &lt;115200&gt;;</span><br><span class="line">    /delete-property/ hw-flow-control;</span><br><span class="line">    zephyr,pm-device-runtime-auto;</span><br><span class="line">    pinctrl-0 = &lt;&amp;uart0_default&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;uart0_sleep&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// write pinctrl again to remove RTS and CTS pin</span><br><span class="line">&amp;pinctrl &#123;</span><br><span class="line">    uart0_default &#123;</span><br><span class="line">        group1 &#123;</span><br><span class="line">            psels = &lt;NRF_PSEL(UART_TX, 0, 6)&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">        group2 &#123;</span><br><span class="line">            psels = &lt;NRF_PSEL(UART_RX, 0, 8)&gt;;</span><br><span class="line">            bias-pull-up;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    uart0_sleep &#123;</span><br><span class="line">        group1 &#123;</span><br><span class="line">            psels = &lt;NRF_PSEL(UART_TX, 0, 6)&gt;,</span><br><span class="line">                &lt;NRF_PSEL(UART_RX, 0, 8)&gt;;</span><br><span class="line">            low-power-enable;</span><br><span class="line">            // bias-pull-up;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你想控制串口空闲态是低电平还是高电平时，就是在pinctrl的sleep引脚组配置。</p>
</blockquote>
<p>我们可以看出，PM_DEVICE的设计目标是提供API，<strong>让应用层负责管理</strong>外设的开启或者关闭。</p>
<h2 id="Zephyr运行时设备电源管理"><a href="#Zephyr运行时设备电源管理" class="headerlink" title="Zephyr运行时设备电源管理"></a>Zephyr运行时设备电源管理</h2><p>Zephyr还提供了自动的外设功耗管理，即<code>PM_DEVICE_RUNTIME</code>。需要通过<code>CONFIG_PM_DEVICE_RUNTIME=y</code>开启。</p>
<p>这种情况下，就不需要应用层来控制外设的开关了。每次应用层要操作外设时，驱动层会利用PM子系统对引用计数+1；操作完毕后，引用计数-1。当引用计数等于0时，PM子系统会负责执行 <code>PM_DEVICE_ACTION_SUSPEND</code> 或者 <code>PM_DEVICE_ACTION_RESUME</code>。</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c8ba696e6e8be37c5dbf85f12198c08a.png" alt="image-20250802145845580"></p>
<p>除了要开启<code>CONFIG_PM_DEVICE_RUNTIME=y</code>之外，还要给对应的设备初始化运行时电源管理的功能，以下两种方法二选一：</p>
<ul>
<li>给对应的device执行<code>pm_device_runtime_enable()</code></li>
<li>在设备树节点内增加一条<code>zephyr,pm-device-runtime-auto;</code>的属性。</li>
</ul>
<h2 id="例程低功耗代码解析"><a href="#例程低功耗代码解析" class="headerlink" title="例程低功耗代码解析"></a>例程低功耗代码解析</h2><p><code>app_uart.c</code>里面提供了两个休眠相关的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">app_uart_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = uart_rx_disable(uart_dev);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;Failed to disable RX: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME)</span></span><br><span class="line">    <span class="comment">// give some time for UART callback</span></span><br><span class="line">    k_sleep(K_MSEC(<span class="number">10</span>)); </span><br><span class="line">    err = pm_device_action_run(uart_dev, PM_DEVICE_ACTION_SUSPEND);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;Failed to suspend device: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_PM_DEVICE_RUNTIME */</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">app_uart_wakeup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *buf;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME)</span></span><br><span class="line">    err = pm_device_action_run(uart_dev, PM_DEVICE_ACTION_RESUME);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;Failed to resume device: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_PM_DEVICE_RUNTIME */</span></span></span><br><span class="line"></span><br><span class="line">    err = k_mem_slab_alloc(&amp;uart_slab, (<span class="type">void</span> **)&amp;buf, K_NO_WAIT);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;Failed to allocate RX buffer: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT_US);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;Failed to enable RX: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先考虑<code>CONFIG_PM_DEVICE_RUNTIME=n</code>的情况。</p>
<p>休眠时：</p>
<ol>
<li>首先<code>uart_rx_disable()</code>：异步串口需要单独关闭RX，因为与RX关联的有应用层Buffer，timeout定时器等功能，都需要单独关闭</li>
<li>然后等待10ms：等待异步串口的callback执行完毕，释放RX buffer等等</li>
<li>最后<code>pm_device_action_run(uart_dev, PM_DEVICE_ACTION_SUSPEND)</code>，挂起串口</li>
</ol>
<p>恢复时：</p>
<ol>
<li>先<code>pm_device_action_run(uart_dev, PM_DEVICE_ACTION_RESUME)</code>恢复串口</li>
<li>然后按照正常流程申请RX buffer并开启RX</li>
</ol>
<p>然后，讨论开启<code>CONFIG_PM_DEVICE_RUNTIME=y</code>的情况。这种情况下只需要开关RX就好了，因为当RX被关闭，同时又没有在TX的时候，PM Device Runtime系统会自动挂起串口的，因此我们应用层没必要再调用<code>pm_device_action_run()</code>函数了。</p>
<h2 id="实测串口低功耗休眠功能"><a href="#实测串口低功耗休眠功能" class="headerlink" title="实测串口低功耗休眠功能"></a>实测串口低功耗休眠功能</h2><p>本工程是否开启<code>CONFIG_PM_DEVICE_RUNTIME</code>没有影响，结果相同。</p>
<p>nRF52840DK连接方式：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ec0b40219d3dbfbf8a00641f44938b10.png" alt="image-20250802152806259"></p>
<p>nRF54L15DK连接方式：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/61f16d8b88bc7f7528d0b1820e9cd02f.png" alt="image-20250802153317606"></p>
<p><strong>52840DK：</strong></p>
<ul>
<li>按button1进入休眠</li>
<li>按button2退出休眠</li>
</ul>
<p>功耗：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/450a17004249ea1bcc33e0f08d5fe6f2.png" alt="image-20250802153612494"></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/5edac99904281fc12335f46cb7f48f03.png" alt="image-20250802153653735"></p>
<blockquote>
<p>注：52840手册标注system ON, CPU IDLE的电流为2.35uA</p>
</blockquote>
<p><strong>54L15DK：</strong></p>
<ul>
<li>按button0进入休眠</li>
<li>按button1退出休眠</li>
</ul>
<p>功耗：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/3ad100bad01b9ef6436c5fcb9ad7d7e8.png" alt="image-20250802153818504"></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4f75d321684bb78231cf558b8602bb37.png" alt="image-20250802153859464"></p>
<blockquote>
<p>注：54L15手册标注，3V条件下，System ON, Wake on pin, 256 KB RAM retained情况下CPU IDLE的电流为3uA.</p>
</blockquote>
<h1 id="8-nRF54系列GPIO跨域使用"><a href="#8-nRF54系列GPIO跨域使用" class="headerlink" title="8. nRF54系列GPIO跨域使用"></a>8. nRF54系列GPIO跨域使用</h1><h2 id="电源时钟域"><a href="#电源时钟域" class="headerlink" title="电源时钟域"></a>电源时钟域</h2><p>以nRF54L15为例：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b103504c883e6aad2064cc56ba55db14.png" alt="image-20260104003405320"></p>
<p>nRF54系列片上有多个电源时钟域：</p>
<ul>
<li><strong>MCU Power Domain</strong>：时钟频率最高（128MHz），拥有高速外设（SPI 32MHz）和高速GPIO（P2）</li>
<li><strong>RADIO Power Domain</strong>：射频外设以及无线协议栈所需的外设，无GPIO</li>
<li><strong>PERI Power Domain</strong>：主要的低功耗外设域，有大量低功耗外设，对应GPIO P1</li>
<li><strong>LP Power Domain</strong>：低功耗外设域，和PERI PD相比，其时钟和MCU PD是<strong>异步</strong>的。可以在其他电源域都休眠的情况下，LP PD仍能保持工作，从而低功耗唤醒系统其余部分。对应GPIO P0</li>
</ul>
<p>在每个时钟域内部，外设基本上可以任意选取GPIO使用，就像nRF52系列一样。</p>
<h2 id="GPIO跨域引脚选择"><a href="#GPIO跨域引脚选择" class="headerlink" title="GPIO跨域引脚选择"></a>GPIO跨域引脚选择</h2><p>我们会发现PERI PD中需要GPIO的外设非常多，而MCU PD中需要GPIO的外设非常少。这会导致有时候GPIO P1上的引脚数量不够用，而GPIO P2上的引脚有空余。</p>
<p>因此，nRF54系列允许一部分PERI PD的外设使用MCU PD 的 P2 口，即跨域使用。这种情况下，需严格按照datasheet中规定的引脚分配，例如：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/ae28c3e3bbf43ae3501aeb7c56783b06.png" alt="image-20260104012415611"></p>
<blockquote>
<p>nRF54系列跨域的其他要求：</p>
<ol>
<li>注意SPI&#x2F;I2C等外设的时钟信号需要特别选择标注为clock pin的引脚，见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.nordicsemi.com/bundle/ps_nrf54L15/page/chapters/pin.html#ariaid-title3">nRF54L15 - Clock pins</a>。UART不需要clock pin。</li>
<li>GPIO P2没有输入中断的能力</li>
</ol>
</blockquote>
<h2 id="GPIO跨域软件配置"><a href="#GPIO跨域软件配置" class="headerlink" title="GPIO跨域软件配置"></a>GPIO跨域软件配置</h2><p>跨域使用时，还需要显式配置CPU的电源模式为<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.nordicsemi.com/bundle/ps_nrf54L15/page/pmu.html#ariaid-title3">Constant Laytency</a> 。</p>
<blockquote>
<p>System ON模式下，有两个子电源模式：</p>
<ul>
<li><strong>Constant Latency</strong> ：确保所有PPI响应时间和CPU唤醒延迟为固定值，且最短</li>
<li><strong>Low-power</strong>：自动以最低功耗状态运行，但PPI响应时间和CPU唤醒时间可能会变化。<strong>Low-power是默认模式</strong>。</li>
</ul>
<p>其中<strong>Constant Latency</strong>模式。需要在idle状态下保持部分寄存器，功耗略高。</p>
</blockquote>
<p>原始文档：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54l/pinmap.html">nRF54L pin mapping</a></p>
<p>首先开启配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_NRF_SYS_EVENT=y</span><br></pre></td></tr></table></figure>

<p>然后，在需要Constant Laytency模式的代码部分，申请此电源模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nrf_sys_event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Request constlat. The API is reference counted. */</span></span><br><span class="line">        nrf_sys_event_request_global_constlat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Use peripherals which have pins mapped across power-domains */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Release constlat */</span></span><br><span class="line">        nrf_sys_event_release_global_constlat();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个API采用的是“引用计数器”。也就是说有多个线程同时申请此模式时，usage+1；释放此模式时，usage-1。只要usage不为0，那么CPU就会处于Constant Laytency电源模式。</p>
<blockquote>
<p>注：以上介绍的是NCS v3.1.x之后的最新API。</p>
<p>NCS v3.0.x需要使用以下API：</p>
<p><code>CONFIG_NRFX_POWER=y</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nrfx_power.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Request constlat. The API is reference counted. */</span></span><br><span class="line">        nrfx_power_constlat_mode_request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Use peripherals which have pins mapped across power-domains */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Release constlat */</span></span><br><span class="line">        nrfx_power_constlat_mode_free();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="例程测试"><a href="#例程测试" class="headerlink" title="例程测试"></a>例程测试</h2><p>在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Jayant-Tang/learning_zephyr_serial">我的例程</a>中也有跨域使用的案例。</p>
<p>首先把<code>prj.conf</code>中注释的配置打开：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/32d7169c90040d23b4a3d8d5684c17bd.png" alt="image-20260104014017195"></p>
<p>开发者需要明确的知道自己正在使用跨域GPIO，因此我做了一个应用层配置项：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/c0db7fa1430b3959706938be019ca895.png" alt="image-20260104014637600"></p>
<p>开启<code>CONFIG_APP_UART_GPIO_CROSS_DOMAIN=y</code>之后，会自动通过<code>select</code>的方式连锁开启<code>CONFIG_NRF_SYS_EVENT=y</code></p>
<p>然后在<code>boards/nrf54l15dk_nrf54l15_cpuapp.overlay</code>中，注释掉原本的引脚分配，并把跨域的引脚分配打开：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/99c0e6210032fb9a481e6027a7565fa2.png" alt="image-20260104014855545"></p>
<p>实际代码在刚初始化完毕时就开启了Constant Laytency，并在后续根据按钮情况开启或关闭：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/806e6b1966b9f065d0f7bc6b0e34622a.png" alt="image-20260104021927532"></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/bc0dc820ffa9baa96ecad56581e5bebf.png" alt="image-20260104022006350"></p>
<p>重新编译，软件部分就完成了。</p>
<p>至于硬件部分，<strong>由于P2.0-P2.5在开发板上被分配给了外部Flash，因此需要一定调整</strong>：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/4d06e3b2f79acb4cb92c71706c78b318.png" alt="image-20260104015113052"></p>
<p>对于较老的开发板（如0.9.1, 0.9.2），需要割开SPI Flash附近的焊盘。</p>
<p>对于最新的开发板（1.0.0），是 Interface MCU（也就是J-Link Debugger）来控制电子开关。通过nRF Connect for Desktop中的Board Configurator控制：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/220f03bebfc0477f6bd4fd6a5928138f.png" alt="image-20260104015421288"></p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/e23d2d541e8635b77dc6d30e36de3bf0.png" alt="image-20260104015656307"></p>
<p>首先把外部存储器（External Memory）关掉；然后把GPIO电源改为3.3V，因为我们修改了串口引脚，就不能继续使用 J-link 自带的USB转串口了。</p>
<blockquote>
<p>配置完毕后一定要写入配置，<strong>然后一定要退出Board Configurator，否则功耗测量会有问题。</strong></p>
</blockquote>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/41430ac4deaa16d89842ca6c1cad6913.png" alt="image-20260104020140622"></p>
<p>测试：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/2500a838cf23326fc398aff5dd2cc902.png" alt="image-20260104020726626"></p>
<p>功能正常回环。后面长文本断开，是因为超出了应用层按照<code>\r\n</code>进行解包函数的Buffer长度（256Bytes），实际上接收是没问题的：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/b2b8619f476ae9d2188a0b1521588a1c.png" alt="image-20260104020919891"></p>
<p>RX接收开启时，54L15跨域使用功耗约为400uA，比前面章节测得不跨域使用（150uA）要高250uA：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/41f075076c571639ba332a9e26909faf.png" alt="image-20260104021813610"></p>
<p>串口休眠时，无变化（因为代码里在关闭串口时也关闭了constant laytency模式）：</p>
<p><img src="https://jayant-blog-imgs.oss-cn-hangzhou.aliyuncs.com/35bfdbd5619f847490626739a4a11e44.png" alt="image-20260104021722458"></p>
<h1 id="9-开发自己的程序"><a href="#9-开发自己的程序" class="headerlink" title="9. 开发自己的程序"></a>9. 开发自己的程序</h1><h2 id="串口API的兼容"><a href="#串口API的兼容" class="headerlink" title="串口API的兼容"></a>串口API的兼容</h2><p>我们前面提到，异步API和基于中断的API是完全不同的两套API。如果有的串口想用异步API，有的串口想用中断API（如USB CDC ACM，Shell等）怎么办？</p>
<p>在串口驱动目录下的<code>Kconfig.nrfx</code>中可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config UART_1_ASYNC</span><br><span class="line">    bool &quot;Asynchronous API support on port 1&quot;</span><br><span class="line">    depends on UART_ASYNC_API &amp;&amp; !UART_1_INTERRUPT_DRIVEN</span><br><span class="line">    default y</span><br><span class="line">    help</span><br><span class="line">      This option enables UART Asynchronous API support on port 1.</span><br></pre></td></tr></table></figure>
<p>要使用异步API，必须单独禁用这个串口的中断API。<br>如果你要使用USB CDC ACM（需要中断API）的同时使用串口0的异步API，则需要这样配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_0_INTERRUPT_DRIVEN=n</span><br></pre></td></tr></table></figure>
<p>意思是，对于<strong>整个串口驱动</strong>来说，启用中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig）。<br>但是对于串口0来说，关闭中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig.nrfx）。这样就实现了每个串口的单独配置。</p>
<h2 id="把串口程序集成到自己的应用中"><a href="#把串口程序集成到自己的应用中" class="headerlink" title="把串口程序集成到自己的应用中"></a>把串口程序集成到自己的应用中</h2><p>本例程已经非常完善，把<code>app_uart</code>文件夹拷贝到自己的工程中，然后在Kconfig和CMakeLists.txt中引用即可。这也是模块化开发的思想。而且本工程思路还是比较清晰的，开发者想增加自己的代码也会非常容易。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io">Jayant Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/">https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jayant-tang.github.io/jayant97.github.io" target="_blank">一苇万顷</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/jayant97.github.io/tags/Nordic/">Nordic</a><a class="post-meta__tags" href="/jayant97.github.io/tags/Zephyr/">Zephyr</a><a class="post-meta__tags" href="/jayant97.github.io/tags/DeviceTree/">DeviceTree</a></div><div class="post_share"><div class="social-share" data-image="/jayant97.github.io/imgs/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div class="next-post pull-right"><a href="/jayant97.github.io/2023/08/045cdc9c9b10/" title="在nRF7002开发板上运行MQTT例程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在nRF7002开发板上运行MQTT例程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/jayant97.github.io/2024/01/b74491c1a080/" title="Nordic GPIO硬件原理与NCS应用详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-22</div><div class="title">Nordic GPIO硬件原理与NCS应用详解</div></div></a></div><div><a href="/jayant97.github.io/2023/03/4b274a50e575/" title="详解Zephyr设备树（DeviceTree）与驱动模型"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">详解Zephyr设备树（DeviceTree）与驱动模型</div></div></a></div><div><a href="/jayant97.github.io/2025/01/aeb1d94c5ebc/" title="NCS 低功耗日志打印"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="title">NCS 低功耗日志打印</div></div></a></div><div><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div><a href="/jayant97.github.io/2022/12/2a39e705bff0/" title="理解Zephyr项目的配置与构建系统"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-04</div><div class="title">理解Zephyr项目的配置与构建系统</div></div></a></div><div><a href="/jayant97.github.io/2025/10/a6cc85dce7a1/" title="Matter OTA固件升级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-20</div><div class="title">Matter OTA固件升级</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Hello-world%E8%A7%A3%E6%9E%90%E2%80%94printk%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA"><span class="toc-text">2. Hello world解析—printk如何输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">工程目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk%E8%BE%93%E5%87%BA%E9%85%8D%E7%BD%AE"><span class="toc-text">printk输出配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console%E8%AE%BE%E5%A4%87%E4%B8%8Econsole%E9%A9%B1%E5%8A%A8"><span class="toc-text">console设备与console驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Nordic%E4%B8%B2%E5%8F%A3%E7%A1%AC%E4%BB%B6"><span class="toc-text">3. Nordic串口硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UART"><span class="toc-text">UART</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UARTE"><span class="toc-text">UARTE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UARTE%E5%8F%91%E9%80%81%E9%80%BB%E8%BE%91"><span class="toc-text">UARTE发送逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UARTE%E6%8E%A5%E6%94%B6%E9%80%BB%E8%BE%91"><span class="toc-text">UARTE接收逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nRF54%E7%B3%BB%E5%88%97UARTE%E7%A1%AC%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">nRF54系列UARTE硬件新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-4Mbps%E4%B8%B2%E5%8F%A3"><span class="toc-text">（1） 4Mbps串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%94%AF%E6%8C%814%E8%87%B39bits-%E5%B8%A7"><span class="toc-text">（2）支持4至9bits 帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B8%A7%E8%B6%85%E6%97%B6%E4%B8%AD%E6%96%AD"><span class="toc-text">（3）帧超时中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Zephyr%E6%A0%87%E5%87%86%E4%B8%B2%E5%8F%A3API"><span class="toc-text">4. Zephyr标准串口API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E6%96%AD"><span class="toc-text">基于中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-text">异步发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6"><span class="toc-text">异步接收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zephyr%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8"><span class="toc-text">Zephyr串口驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">5. 异步串口代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#src-x2F-app-uart-x2F-app-uart-c"><span class="toc-text">src&#x2F;app_uart&#x2F;app_uart.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%9B%9E%E8%B0%83"><span class="toc-text">串口回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-text">串口接收线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">串口发送线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-c"><span class="toc-text">main.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">异步串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%8C%96RX%E5%8A%9F%E8%83%BD"><span class="toc-text">强化RX功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E4%B8%8D%E5%86%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">硬件计数器（不再推荐）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">异步串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">硬件连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C"><span class="toc-text">异步串口代码运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-USB-CDC-ACM%E4%B8%B2%E5%8F%A3"><span class="toc-text">6. USB CDC ACM串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">USB串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">USB串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81"><span class="toc-text">USB串口代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91USB%E4%B8%B2%E5%8F%A3%E4%BE%8B%E7%A8%8B"><span class="toc-text">编译USB串口例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%B9%B6%E6%B5%8B%E8%AF%95USB%E4%B8%B2%E5%8F%A3"><span class="toc-text">运行并测试USB串口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BC%91%E7%9C%A0%E4%B8%8E%E4%B8%B2%E5%8F%A3%E4%BD%8E%E5%8A%9F%E8%80%97"><span class="toc-text">7. 休眠与串口低功耗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zephyr%E8%AE%BE%E5%A4%87%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88PM-DEVICE%EF%BC%89"><span class="toc-text">Zephyr设备电源管理（PM_DEVICE）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zephyr%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AE%BE%E5%A4%87%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">Zephyr运行时设备电源管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B%E4%BD%8E%E5%8A%9F%E8%80%97%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">例程低功耗代码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%B5%8B%E4%B8%B2%E5%8F%A3%E4%BD%8E%E5%8A%9F%E8%80%97%E4%BC%91%E7%9C%A0%E5%8A%9F%E8%83%BD"><span class="toc-text">实测串口低功耗休眠功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-nRF54%E7%B3%BB%E5%88%97GPIO%E8%B7%A8%E5%9F%9F%E4%BD%BF%E7%94%A8"><span class="toc-text">8. nRF54系列GPIO跨域使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E6%97%B6%E9%92%9F%E5%9F%9F"><span class="toc-text">电源时钟域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E8%B7%A8%E5%9F%9F%E5%BC%95%E8%84%9A%E9%80%89%E6%8B%A9"><span class="toc-text">GPIO跨域引脚选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E8%B7%A8%E5%9F%9F%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-text">GPIO跨域软件配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-text">例程测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">9. 开发自己的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3API%E7%9A%84%E5%85%BC%E5%AE%B9"><span class="toc-text">串口API的兼容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%88%90%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD"><span class="toc-text">把串口程序集成到自己的应用中</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2026 By Jayant Tang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/jayant97.github.io/js/utils.js"></script><script src="/jayant97.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c91ce0493b5c3e886110',
      clientSecret: '7599decf69128ba1a83c1f3ef0923395a9bd8a60',
      repo: 'jayant97.github.io',
      owner: 'Jayant-Tang',
      admin: ['Jayant-Tang'],
      id: '5749979c1110dfbff33bebe72e76e426',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/jayant97.github.io/js/search/local-search.js"></script></div></div></body></html>