<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Zephyr驱动与设备树实战——串口 | 一苇万顷</title><meta name="author" content="Jayant Tang,jayant.tang@nordicsemi.no"><meta name="copyright" content="Jayant Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 前言之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。 今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中zephyr&#x2F;sample">
<meta property="og:type" content="article">
<meta property="og:title" content="Zephyr驱动与设备树实战——串口">
<meta property="og:url" content="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html">
<meta property="og:site_name" content="一苇万顷">
<meta property="og:description" content="1. 前言之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。 今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中zephyr&#x2F;sample">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png">
<meta property="article:published_time" content="2023-11-12T09:48:56.000Z">
<meta property="article:modified_time" content="2024-04-17T09:03:18.760Z">
<meta property="article:author" content="Jayant Tang">
<meta property="article:tag" content="Nordic">
<meta property="article:tag" content="Zephyr">
<meta property="article:tag" content="DeviceTree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jayant-tang.github.io/jayant97.github.io/imgs/head.png"><link rel="shortcut icon" href="/jayant97.github.io/img/favicon.png"><link rel="canonical" href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/jayant97.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/jayant97.github.io/',
  algolia: undefined,
  localSearch: {"path":"/jayant97.github.io/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Zephyr驱动与设备树实战——串口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-17 17:03:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/jayant97.github.io/imgs/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/jayant97.github.io/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/jayant97.github.io/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/jayant97.github.io/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/jayant97.github.io/" title="一苇万顷"><span class="site-name">一苇万顷</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/jayant97.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/jayant97.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Zephyr驱动与设备树实战——串口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T09:48:56.000Z" title="发表于 2023-11-12 17:48:56">2023-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-17T09:03:18.760Z" title="更新于 2024-04-17 17:03:18">2024-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/">RTOS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/jayant97.github.io/categories/RTOS/Zephyr/">Zephyr</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title="Zephyr驱动与设备树实战——串口"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/jayant97.github.io/2023/11/4c8e1d7d162d/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>之前写了一篇详细的博文，详细介绍了Zephyr设备树（DeviceTree）的语法和Zephyr驱动模型的原理。但有些读者反馈，内容还是比较泛且杂，只感觉多了一些新的语法和规则，没有感受到这设备树和驱动模型的意义所在，希望能够结合实例来讲解。</p>
<p>今天本文就通过串口这样一个最常见的外设，来实际感受一下Zephyr的驱动模型。本文将会以nRF Connect SDK中<code>zephyr/samples/hello_world</code>例程为基础。分别添加<strong>串口</strong>、<strong>USB CDC ACM</strong>、<strong>低功耗串口</strong>的功能。采用<strong>完全相同的应用层代码</strong>，只需要修改config和dts即可切换。</p>
<h1 id="2-Hello-world工程解析"><a href="#2-Hello-world工程解析" class="headerlink" title="2. Hello world工程解析"></a>2. Hello world工程解析</h1><p>开发板我选择nRF52840DK。首先以<code>zephyr/samples/hello_world</code>例程为模板，创建一个新工程，我在这里把工程命名为<code>learning_zephyr_serial</code>。</p>
<h2 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">|  |</span><br><span class="line">|  `--main.c</span><br><span class="line">|--CMakeLists.txt</span><br><span class="line">`--prj.conf</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>中先把Zephyr作为包来导入，然后把main.c添加为源码。</p>
<p><code>prj.conf</code>目前是空的，在这里可以写一些配置用来覆盖默认的Kconfig。</p>
<p>例程默认没使用<code>Kconfig</code>菜单文件，是因为本工程太简单，没有自己的配置项，所以不需要自己的Kconfig文件。这种情况完全等价于Kconfig文件中只写了下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;Kconfig.zephyr&quot;</span><br></pre></td></tr></table></figure>

<p>相当于项目中只有Zephyr的菜单，可以让我们配置Zephyr系统的配置项，以及SDK中各个module的的配置项。选择板子，编译并烧录后，打开串口，reset一下，就能看到刚启动时串口输出的hello world了。</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112183822534.png" alt="image-20231112183822534"></p>
<h2 id="printk输出配置"><a href="#printk输出配置" class="headerlink" title="printk输出配置"></a>printk输出配置</h2><p>很多新上手Zephyr的读者会有疑惑，这工程里几乎没什么代码，也没看到CONFIG和device tree文件，串口到底是怎么输出的？</p>
<p>其实，在我们选择板子时，板子就已经自带了默认的device tree和config文件。因此编译时采用的全部是板子和Zephyr系统的默认值，我们的工程中并没有对这些默认值进行修改。</p>
<p>我们可以在<code>build/zephyr/</code>目录下看到<code>.config</code>文件和<code>zephyr.dts</code>文件。这个就是项目最终编译采用的配置项和设备树。</p>
<p>在<code>.config</code>中，我们可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_PRINTK=y</span><br></pre></td></tr></table></figure>

<p>也就是启用了<code>printk()</code>输出的功能。</p>
<p>我们把这一行复制到prj.conf中（这个行为本身没有意义，因为默认就是y），然后就可以用<strong>Ctrl+鼠标左键</strong>点击这个选项，跳转到这个配置项定义的地方，就可以看到这个配置项的说明：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112184745524.png" alt="image-20231112184745524"></p>
<p>当然，你也可以在Kconfig GUI中找到这个配置项：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112184921595.png" alt="image-20231112184921595"></p>
<blockquote>
<p>到这里，是否对“<code>Kconfig</code>定义了一个菜单，而<code>prj.conf</code>文件是对菜单中配置项的默认值进行修改”这句话有了一定的感受呢？</p>
</blockquote>
<h2 id="console设备与console驱动"><a href="#console设备与console驱动" class="headerlink" title="console设备与console驱动"></a>console设备与console驱动</h2><p>根据此配置项的说明，我们知道<code>printk()</code>是Zephyr的一个内核服务，它可以让通过<code>printk()</code>函数打印的内容通过”console”输出。这里的console指的是一个设备，可以让Zephyr系统输入和输出字节流。</p>
<p>通过查看<code>build/zephyr/zephyr.dts</code>，可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">   ...</span><br><span class="line">    chosen &#123;</span><br><span class="line">        ...</span><br><span class="line">        zephyr,console = &amp;uart0;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>/chosen</code>节点下，有很多<strong>属性</strong>。Zephyr系统内核的代码在运行一些功能时，并不在乎底层的硬件具体是什么，它只从<code>/chosen</code>节点下找到对应的硬件。只要这个硬件已经在RTOS初始化之前就被驱动程序初始化了，具有Zephyr标准外设接口，那么Zephyr内核就可以操作这个硬件。</p>
<p>例如，要想获得这里的console设备的DeviceTree Node ID，就可以用<code>DT_CHOSEN(zephyr_console)</code>。</p>
<p>我们自然可以联想到，可以把console换成其他<strong>串口设备</strong>，就可以让日志从其他串口输出了。这里，可以参考我的另一篇随笔<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/p/17784156.html">《Zephyr重定向日志打印到USB串口》</a>。</p>
<p>如果你只是修改设备树中的console设备，那么不管如何修改，输出日志的设备都必须是一个“串口”（在Zephyr中USB CDC ACM设备也是串口，后文会解释）。在<code>build/zephyr/.config</code>中，我们还可以看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p>原来，在当前配置下，Zephyr默认的console后端都必须是“串口”设备。</p>
<p>我们可以尝试把console后端改成RTT，在<code>prj.conf</code>中，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br></pre></td></tr></table></figure>

<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112191457497.png" alt="image-20231112191457497"></p>
<p>然后就可以看到，printk()的日志从RTT中打印出来了。</p>
<p>对于探究心强的读者，到这里肯定又会有疑问：为什么把console后端改成了RTT，只改了config，设备树就不用改了？</p>
<p>关于这个问题，我想先传达出一个观点，那就是一个系统无论使用了什么样的框架，<strong>最终一定要落实到代码</strong>。通过在NCS中全局搜索<code>CONFIG_RTT_CONSOLE</code>和<code>CONFIG_UART_CONSOLE</code>，我们最终能找到这样的一个文件，<code>$&#123;NCS&#125;/zephyr/drivers/console/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_RTT_CONSOLE rtt_console.c)</span><br><span class="line">zephyr_library_sources_ifdef(CONFIG_UART_CONSOLE uart_console.c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>console本身作为一个中间件，也是要通过驱动程序向Zephyr提供标准console API的。在这里，CMake根据不同的CONFIG配置项，添加了不同的console驱动源码进入系统之中，进行编译。</p>
<p>在uart_console.c中，我们明显能看到，此驱动代码需要通过device tree来找到标准的串口设备，然后调用标准的串口API来通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">const</span> <span class="title">uart_console_dev</span> =</span></span><br><span class="line">    DEVICE_DT_GET(DT_CHOSEN(zephyr_console));</span><br></pre></td></tr></table></figure>

<p>而在rtt_console.c中，我们可以看到此代码不需要获取任何device tree的信息。因此，当我们选择RTT作为后端时，无论device tree中的<code>/chosen</code>节点中如何选择<code>zephyr,console</code>，对于RTT console驱动代码来说都是没有意义的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过前面的分析，我们可以有以下结论：</p>
<p>首先，在Zephyr系统中有许多功能，我们可以用Kconfig的方式进行配置或裁减。</p>
<p>此外，Zephyr中有非常明显的“分层设计”，例如，Nordic提交nrf系列串口驱动代码，提供Zephyr标准串口API；Zephyr有console驱动代码，向更上层提供标准console API；如果console是串口驱动，它还会调用标准串口 API来把日志输出到底层串口中；由于API是标准的，因此console驱动代码并不在乎底层到底是物理串口还是USB CDC ACM设备。</p>
<h1 id="3-Zephyr标准异步串口"><a href="#3-Zephyr标准异步串口" class="headerlink" title="3. Zephyr标准异步串口"></a>3. Zephyr标准异步串口</h1><h2 id="Zephyr串口API分类"><a href="#Zephyr串口API分类" class="headerlink" title="Zephyr串口API分类"></a>Zephyr串口API分类</h2><p>前面分析了Hello world是如何通过console输出的。在Zephyr中，console主要是用来做一些字节流的传输，用来实现一些更上层的服务，例如自定义<code>shell</code>命令。</p>
<p>用户要开发自己的程序，肯定是需要自己直接操作串口的。这里给出<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html">Zephyr标准串口API文档</a>，供参考。</p>
<p>从文档中我们知道，Zephyr串口有三种不同的接口：</p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-polling-api">阻塞（Polling）</a>：阻塞发送一个字节，发送完毕后才返回；接收时，有数据则读取，无数据则返回-1，接收函数不阻塞。</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-interrupt-api">基于中断（Interrupt-driven）</a>：串口外设在产生<strong>发送使能完毕</strong>、<strong>发送完毕</strong>和<strong>接收完毕</strong>等事件时都会产生中断信号，用户需要在中断服务函数（ISR）中处理这些事件。通常来说，如果是发送完毕，则看应用层是否还有新数据要发，若有则向fifo填入新的数据；如果是接收完毕事件，则把收到的数据传给应用层。这里的中断服务函数是需要用户自己实现，然后注册的，并且由于这些事件都还是比较偏向于<strong>硬件底层</strong>的事件，因此<strong>代码编写的自由度较高</strong>。我们如果在NCS中全局搜索基于中断的串口API函数，会看到各种不同的中断服务函数写法。</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/hardware/peripherals/uart.html#uart-async-api">异步（Asynchronous）</a>：如果你没有什么非常定制化的硬件相关的操作，比如非得在某个事件出现时调用一些别的功能，只是想简单高效的进行串行通信，那么更推荐用异步API。异步API是基于DMA传输的：发送时，函数不会阻塞；接收时，直接从回调函数中获取收到的数据。整个过程非常简单直观。</li>
</ul>
<blockquote>
<p>NCS中的例程太多，对于不熟悉的人来说，随便复制代码，很有可能出现：代码里用的是一种API，但CONFIG使能的却是另一种API的情况，最终导致程序无法运行。</p>
</blockquote>
<p>本节只介绍异步串口的使用。</p>
<h2 id="异步串口代码"><a href="#异步串口代码" class="headerlink" title="异步串口代码"></a>异步串口代码</h2><p>这里我给出修改后的hello world例程代码：</p>
<blockquote>
<p>【注意】<br>本文基于NCS v2.4.2。若读者使用v2.5.0或以上版本。下面代码中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>需要改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> *)evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>因为版本升级后<code>k_mem_slab_free</code>的实现不同，参数从二级指针变为了一级指针。</p>
</blockquote>
<p><code>main.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2012-2014 Wind River Systems, Inc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_INACTIVE_TIMEOUT_US 2000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// serial buffer pool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 64</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">K_MEM_SLAB_DEFINE</span><span class="params">(uart_slab, BUF_SIZE, <span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serial device</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> DEVICE_DT_GET(DT_NODELABEL(uart0));</span><br><span class="line"></span><br><span class="line"><span class="comment">// async serial callback</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uart_callback</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> uart_event *evt,</span></span><br><span class="line"><span class="params">              <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart</span> =</span> user_data;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (evt-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> UART_TX_DONE:</span><br><span class="line">        printk(<span class="string">&quot;Tx sent %d bytes\n&quot;</span>, evt-&gt;data.tx.len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_TX_ABORTED:</span><br><span class="line">        printk(<span class="string">&quot;Tx aborted\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_RDY:</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Received data %d bytes\n&quot;</span>, evt-&gt;data.rx.len);</span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">uint8_t</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(buf, p, evt-&gt;data.rx.len);</span><br><span class="line">        uart_tx(dev, buf, evt-&gt;data.rx.len, SYS_FOREVER_US);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_BUF_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line">        err = k_mem_slab_alloc(&amp;uart_slab, (<span class="type">void</span> **)&amp;buf, K_NO_WAIT);</span><br><span class="line">        __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to allocate slab\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        err = uart_rx_buf_rsp(uart, buf, BUF_SIZE);</span><br><span class="line">        __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to provide new buffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">        k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_DISABLED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_STOPPED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_ready(uart_dev)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;device %s is not ready; exiting\n&quot;</span>, uart_dev-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = uart_callback_set(uart_dev, uart_callback, (<span class="type">void</span> *)uart_dev);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to set callback&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate buffer and start rx</span></span><br><span class="line">    err = k_mem_slab_alloc(&amp;uart_slab, (<span class="type">void</span> **)&amp;buf, K_NO_WAIT);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to alloc slab&quot;</span>);</span><br><span class="line">    err = uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT_US);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to enable rx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        k_sleep(K_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码非常简单，首先是获得device，这里的方法是用设备树节点的标签来获取节点对应的device对象：<code>DEVICE_DT_GET(DT_NODELABEL(uart0))</code>。</p>
<p>在<code>main()</code>函数中，注册异步回调函数。然后开启串口接收。这里除了device结构体指针之外，还有两项配置。一个是接收缓存、一个是超时时间。</p>
<p>接收缓存可以直接用Zephyr的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/memory_management/slabs.html#memory-slabs">memory slab</a>功能。代码中用<code>K_MEM_SLAB_DEFINE</code>定义了3块静态的缓存区域，可以用allocate和free来进行内存块的分配和释放操作。相当于是一个私有的动态内存区域。在<code>main()</code>函数中，先取出了一块内存，然后传入<code>rx_enable</code>作为接收缓存。</p>
<p>超时时间，指的是异步串口产生回调的时间。如果串口空闲，没有新数据来，超过了一定的时间，那么会直接产生回调事件，即使接收缓存还未满。<strong>这里为了演示，设置为2秒超时</strong>。</p>
<p>在回调函数中，每次接收缓存已满，或者达到了超时时间，就会产生<code>UART_RX_RDY</code>事件。在事件结构体中，<code>buf</code>是缓存的首地址，<code>offset</code>是本次收到的数据在缓存中的位置，<code>len</code>是本次收到的数据的长度。因此，本次接收到的数据的真实首地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br></pre></td></tr></table></figure>

<p>每次接收缓存满时，串口rx驱动代码会向应用层申请新的接收缓存，即<code>UART_RX_BUF_REQUEST</code>事件。这时我们从memory slab中分配一块新的内存给它即可。</p>
<p>当串口驱动获得了新的接收缓存时，它也会向应用层申请释放掉旧的接收缓存，即<code>UART_RX_BUF_RELEASED</code>事件。这时我们用memory slab的free函数将其释放即可。</p>
<p>本代码实现了一个回环，会把串口收到的数据继续从串口发出。</p>
<blockquote>
<p>这里有一些小细节：</p>
<ol>
<li><p>回调函数的形参evt，在call stack中上一层的驱动代码里是一个局部变量。在回调函数返回后，evt会被释放。因此这里如果要实现回环，需要拷贝一份到静态内中。即<code>static uint8_t buf[128]</code>。</p>
</li>
<li><p>如果某一次接收到了很多数据，超出了buffer的剩余空间。那么这次收到的数据就会被分成两部分，产生两次接收回调。这也意味着，我们必须把接收到的数据看作是“字节流”而不是“包”。开发者应该自己实现字节流解包处理函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; evt-&gt;data.rx.len; i++)&#123;</span><br><span class="line">    bytes_to_packet(p[i]); <span class="comment">// 开发者自行实现解包函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回调函数实际上运行在中断服务函数内部，因此不要做一些阻塞的行为。如果真的有计算量大的任务，可以把任务提交到<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html">Workqueue Threads</a>。这样你就能把耗时的任务从<strong>特权模式</strong>移动到<strong>用户模式</strong>，也就是从中断内部移动到线程中。</p>
</li>
</ol>
</blockquote>
<h2 id="异步串口配置"><a href="#异步串口配置" class="headerlink" title="异步串口配置"></a>异步串口配置</h2><p><code>prj.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use RTT as console</span></span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use ASYNC uart API</span></span><br><span class="line">CONFIG_SERIAL=y</span><br><span class="line">CONFIG_UART_ASYNC_API=y</span><br><span class="line">CONFIG_UART_0_ASYNC=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use hardware bytes counter <span class="keyword">for</span> async uart</span></span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC=y</span><br><span class="line">CONFIG_UART_0_NRF_HW_ASYNC_TIMER=2</span><br></pre></td></tr></table></figure>

<p>首先，把console改为RTT，防止日志和我们的串口数据混在一起。</p>
<p><code>CONFIG_SERIAL=y</code>的作用是，使能Zephyr标准串口驱动；<code>CONFIG_UART_ASYNC_API=y</code>使能了异步API。这两项都是Zephyr的串口配置项，来自于<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig</code>。</p>
<p><code>CONFIG_UART_0_ASYNC=y</code>来自于Nordic的配置<code>$&#123;NCS&#125;/zephyr/drivers/serial/Kconfig.nrfx</code>。在同目录下的Nordic的驱动代码<code>uart_nrfx_uarte.c</code>中，可以让不同的串口用不同类型的API，这完全是由驱动代码实现的。因此Nordic也提供了配置项来供开发者选择。</p>
<p>关于最后两项配置，<strong>对性能和功耗影响很大</strong>。虽说串口API是异步的，但底层驱动的设计却有很多变化。当一个外设通过DMA传输数据时，通常来说是DMA缓存写满了，才产生中断，然后把整个缓存传给应用层。但别忘了，我们的异步串口有<strong>空闲超时功能</strong>，如果DMA缓存还没有写满，但因为串口一直没有收到新的数据，超时了，需要立即把目前已经收到的数据传到应用层。这种情况下，<strong>如何才能知道目前已经接收了多少个字节数据呢？</strong></p>
<p>纯软件的方法就是，每收到一个字节就产生中断，在中断服务函数里，通过软件的方式+1，这也是大多数普通的单片机的做法。<strong>如果你不添加最后两行CONFIG配置，那么<code>uart_nrfx_uarte.c</code>驱动就会采用这种方法</strong>。</p>
<p>但Nordic的单片机有独特的功能—— PPI (Programmable peripheral interconnect)。简单来说，就是每个外设都有许多event和task寄存器。event寄存器可以产生中断让CPU去处理；CPU也可以去写task寄存器让外设去执行某些工作。而PPI可以把一个外设的event寄存器和另一个外设的task寄存器连接起来，实现<strong>自动联动，而无需CPU处理</strong>。</p>
<blockquote>
<p>有关PPI的内容，请参考各个Nordic MCU芯片手册的外设PPI或DPPI章节。</p>
</blockquote>
<p>如此一来，Nordic串口驱动可以把一个Timer配置为计数器模式（Counter Mode），并且把他的COUNT TASK与串口的接收到单个字节的EVENT通过PPI连接起来。这样计数器就可以自动记录收到了多少个字节。当接收超时的时候，直接从counter中读取计数即可。</p>
<p>这里的配置<code>CONFIG_UART_0_NRF_HW_ASYNC=y</code>就是让串口0使用硬件计数器。而<code>CONFIG_UART_0_NRF_HW_ASYNC_TIMER=2</code>就是让Timer2来用作串口0的计数器。</p>
<blockquote>
<p>我们可以看出，其实应用层操作的uart0这个串口，其实底层并不仅仅只有UARTE0这一个外设。而是由UARTE0+TIMER2+PPI组成的复合外设。因此，不要在device tree中再去初始化timer2去做别的用途了。</p>
<p>到了这里，相信你也能体会到Zephyr把应用和驱动进行分层的意义。</p>
</blockquote>
<h2 id="异步串口设备树"><a href="#异步串口设备树" class="headerlink" title="异步串口设备树"></a>异步串口设备树</h2><p>我们并不需要额外修改设备树，直接采用默认值即可。我们可以直接查看一下我们目前使用的串口0的设备树，位于<code>build/zephyr/zephyr.dts</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart0: uart@40002000 &#123;</span><br><span class="line">            compatible = &quot;nordic,nrf-uarte&quot;;</span><br><span class="line">            reg = &lt; 0x40002000 0x1000 &gt;;</span><br><span class="line">            interrupts = &lt; 0x2 0x1 &gt;;</span><br><span class="line">            status = &quot;okay&quot;;</span><br><span class="line">            current-speed = &lt; 0x1c200 &gt;;</span><br><span class="line">            pinctrl-0 = &lt; &amp;uart0_default &gt;;</span><br><span class="line">            pinctrl-1 = &lt; &amp;uart0_sleep &gt;;</span><br><span class="line">            pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>主要属性介绍：</p>
<ul>
<li><p><code>reg = &lt; 0x40002000 0x1000 &gt;</code>：芯片自带的属性，外设的地址</p>
</li>
<li><p><code>compatible = &quot;nordic,nrf-uarte&quot;</code>：此处选择了uarte的驱动而非uart驱动。因此最终编译时用的代码是uart_nrfx_uarte.c而非uart_nrfx_uart.c</p>
</li>
<li><p><code>status = &quot;okay&quot;</code>：驱动代码自动初始化外设时，只会初始化状态为<code>&quot;okay&quot;</code>的节点。</p>
</li>
<li><p><code>current-speed = &lt; 0x1c200 &gt;</code>：波特率，也就是写十进制<code>current-speed = &lt; 115200 &gt;</code></p>
</li>
</ul>
<p>其余属性，与中断、引脚分配、Zephyr低功耗有关。将在今后的文章中介绍。</p>
<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20221209144123203.png" alt="image-20221209144123203"></p>
<p>Nordic开发板的串口0默认GPIO都是在板子上直接连接到Jlink上，然后Jlink把串口转发到USB上，因此电脑上看到的是Jlink的USB串口。</p>
<p>右上角开关，nRF Only是只给单片机核心电路供电，外围LED、Jlink等都不供电，用于测量功耗。因此应该拨到DEFAULT档位。</p>
<p>板载Jlink，USB插左边即可。左下角电源开关打开。</p>
<h2 id="异步串口代码运行"><a href="#异步串口代码运行" class="headerlink" title="异步串口代码运行"></a>异步串口代码运行</h2><p>烧录好程序后，分别打开RTT和串口。鼠标选择串口的窗口，通过键盘敲入hello，等待2s超时，串口就会把hello回环打印出来。并且RTT的日志中会显示收到了5字节，发送了5字节。</p>
<blockquote>
<ul>
<li>VS Code里面nRF插件提供的这个串口终端的行为类似于PuTTY，按下键盘立即发送，但不会显示出自己发送了什么。</li>
<li>要超时2s，是因为前面在<code>uart_rx_enable()</code>时设置了2s空闲超时。</li>
</ul>
</blockquote>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112211302750.png" alt="image-20231112211302750"></p>
<h1 id="4-USB-CDC-ACM串口"><a href="#4-USB-CDC-ACM串口" class="headerlink" title="4. USB CDC ACM串口"></a>4. USB CDC ACM串口</h1><p>前面介绍了硬件串口的异步API，接下来我们介绍USB CDC ACM串口。</p>
<h2 id="USB串口设备树"><a href="#USB串口设备树" class="headerlink" title="USB串口设备树"></a>USB串口设备树</h2><p>通过查看<code>build/zephyr/zephyr.dts</code>，我们可以看到USBD外设的状态：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231112225500662.png" alt="image-20231112225500662"></p>
<p>这个节点有两个label，一个是<code>usbd</code>，一个是<code>zephyr_udc0</code>，我们任选一个使用就好。我们可以参考USB例程<code>$&#123;NCS&#125;/zephyr/samples/subsys/usb/cdc_acm/</code>来修改设备树。</p>
<p>先在项目根目录下新建<code>app.overlay</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;zephyr_udc0 &#123;</span><br><span class="line">    usb_serial0: cdc_acm_uart0 &#123;</span><br><span class="line">        compatible = &quot;zephyr,cdc-acm-uart&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们给usbd节点新增了一个子节点<code>/soc/usbd@4002700/cdc_acm_uart0</code>，并且也给其添加了一个label：<code>usb_serial0</code>。</p>
<h2 id="USB串口配置"><a href="#USB串口配置" class="headerlink" title="USB串口配置"></a>USB串口配置</h2><p>再然后，是不是直接在prj.conf里使能一下USB，再去代码里把device结构体指针改成<code>DEVICE_DT_GET(DT_NODELABEL(usb_serial0))</code>就万事大吉了吗？</p>
<p>可惜，对于USB来说，事情没这么简单。从例程<code>$&#123;NCS&#125;/zephyr/samples/subsys/usb/cdc_acm/</code>中，我们发现，似乎USB CDC ACM只有基于中断（interrupt-driven）的串口API，没有异步串口API可以用。</p>
<p>再去USB驱动代码<code>$&#123;NCS&#125;/zephyr/subsys/usb/device/class/cdc_acm.c</code>中查看一下，会发现这里根本没有写异步API。<code>struct uart_driver_api</code>里也没有给异步API的函数指针赋值。</p>
<p>虽然Zephyr的USB CDC ACM驱动没有异步API，但Nordic提供了异步API。<strong>本质上，你调用的所有Zephyr标准串口驱动API，都来自于<code>struct uart_driver_api</code>这个结构体中的函数指针</strong>。如果驱动程序在系统启动之前没有给异步API赋值，那么我们自己实现异步API，然后把异步API赋值给这个结构体内的函数指针不就好了？</p>
<p>这个异步代码就在Nordic经典的蓝牙透传例程中，位于<code>$&#123;NCS&#125;/nrf/samples/bluetooth/peripheral_uart</code>。</p>
<p>我们先把Kconfig中的一个配置项改一下名字抄过来，使我们的Kconfig文件变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;Kconfig.zephyr&quot;</span><br><span class="line"></span><br><span class="line">config USB_UART_ASYNC_ADAPTER</span><br><span class="line">    bool &quot;Enable USB UART async adapter&quot;</span><br><span class="line">    select SERIAL_SUPPORT_ASYNC</span><br><span class="line">    help</span><br><span class="line">      Enables asynchronous adapter for UART drives that supports only</span><br><span class="line">      IRQ interface.</span><br></pre></td></tr></table></figure>

<p>使我们的工程菜单，在Zephyr本身配置菜单的基础上，多一个可配置的选项<code>CONFIG_USB_UART_ASYNC_ADAPTER</code>。然后修改<code>prj.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use RTT as console</span></span><br><span class="line">CONFIG_RTT_CONSOLE=y</span><br><span class="line">CONFIG_UART_CONSOLE=n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use ASYNC uart API</span></span><br><span class="line">CONFIG_SERIAL=y</span><br><span class="line">CONFIG_UART_ASYNC_API=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> USB Device</span></span><br><span class="line">CONFIG_USB_DEVICE_STACK=y</span><br><span class="line">CONFIG_USB_DEVICE_PRODUCT=&quot;Zephyr CDC ACM sample&quot;</span><br><span class="line">CONFIG_USB_DEVICE_PID=0x0001</span><br><span class="line">CONFIG_USB_CDC_ACM=y</span><br><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_LINE_CTRL=y</span><br><span class="line">CONFIG_USB_DEVICE_REMOTE_WAKEUP=n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> USB ASYNC Adapter</span></span><br><span class="line">CONFIG_USB_UART_ASYNC_ADAPTER=y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能你会疑惑，为什么要自定义一个配置项，然后通过select的方式连锁使能<code>SERIAL_SUPPORT_ASYNC</code>？为什么不直接配置<code>CONFIG_SERIAL_SUPPORT_ASYNC=y</code>？</p>
<p>如果你看过我之前的文章<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jayant97/articles/17794813.html">《理解Zephyr编译与配置系统》</a>，就会明白，<code>SERIAL_SUPPORT_ASYNC</code>是一个<strong>隐性配置项</strong>，不允许用户直接修改。只能通过其他配置项连锁使能。</p>
<p>隐性配置项存在的意义就是为了防止不懂的新手开发者乱改配置，导致出现很难定位的bug。但是各位看到这里，相信已经属于是懂这套系统的开发者了。</p>
</blockquote>
<h2 id="USB串口代码"><a href="#USB串口代码" class="headerlink" title="USB串口代码"></a>USB串口代码</h2><p>首先把<code>$&#123;NCS&#125;/nrf/samples/bluetooth/peripheral_uart/src/</code>目录下的uart_async_adapter.c和uart_async_adapter.h拷贝到自己工程的src目录下。</p>
<p>然后在CMakeLists.txt中将其添加为源码，同时添加include路径：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Zephyr REQUIRED HINTS $ENV&#123;ZEPHYR_BASE&#125;)</span><br><span class="line"><span class="keyword">project</span>(hello_world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(app PRIVATE </span><br><span class="line">    src/main.c</span><br><span class="line">    src/uart_async_adapter.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(app PRIVATE </span><br><span class="line">    src)</span><br></pre></td></tr></table></figure>

<p>然后，给出略加修改后的main.c：</p>
<blockquote>
<p>【注意】<br>本文基于NCS v2.4.2。若读者使用v2.5.0或以上版本。下面代码中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>需要改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">    k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> *)evt-&gt;data.rx_buf.buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>因为版本升级后<code>k_mem_slab_free</code>的实现不同，参数从二级指针变为了一级指针。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2012-2014 Wind River Systems, Inc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/devicetree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/drivers/uart.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr/usb/usb_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart_async_adapter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// usb async adapter use millisecond as timeout</span></span><br><span class="line"><span class="comment">// but uart use microsecond as timeout</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(CONFIG_USB_UART_ASYNC_ADAPTER)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> RX_INACTIVE_TIMEOUT 2000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> RX_INACTIVE_TIMEOUT 2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// serial buffer pool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 64</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">K_MEM_SLAB_DEFINE</span><span class="params">(uart_slab, BUF_SIZE, <span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serial device</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> DEVICE_DT_GET_ONE(zephyr_cdc_acm_uart);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async serial callback</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uart_callback</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> uart_event *evt,</span></span><br><span class="line"><span class="params">              <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart</span> =</span> user_data;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (evt-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> UART_TX_DONE:</span><br><span class="line">        printk(<span class="string">&quot;Tx sent %d bytes\n&quot;</span>, evt-&gt;data.tx.len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_TX_ABORTED:</span><br><span class="line">        printk(<span class="string">&quot;Tx aborted\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_RDY:</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;Received data %d bytes\n&quot;</span>, evt-&gt;data.rx.len);</span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">uint8_t</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">uint8_t</span> *p = &amp;(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(buf, p, evt-&gt;data.rx.len);</span><br><span class="line">        uart_tx(dev, buf, evt-&gt;data.rx.len, SYS_FOREVER_US);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_BUF_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line">        err = k_mem_slab_alloc(&amp;uart_slab, (<span class="type">void</span> **)&amp;buf, K_NO_WAIT);</span><br><span class="line">        __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to allocate slab\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        err = uart_rx_buf_rsp(uart, buf, BUF_SIZE);</span><br><span class="line">        __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to provide new buffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_BUF_RELEASED:</span><br><span class="line">        k_mem_slab_free(&amp;uart_slab, (<span class="type">void</span> **)&amp;evt-&gt;data.rx_buf.buf);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_DISABLED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UART_RX_STOPPED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">uart_test_async_api</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver_api</span> *<span class="title">api</span> =</span></span><br><span class="line">            (<span class="type">const</span> <span class="keyword">struct</span> uart_driver_api *)dev-&gt;api;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (api-&gt;callback_set != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_USB_UART_ASYNC_ADAPTER</span></span><br><span class="line">UART_ASYNC_ADAPTER_INST_DEFINE(async_adapter);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">const</span> <span class="title">async_adapter</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">uint8_t</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!device_is_ready(uart_dev)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;device %s is not ready; exiting\n&quot;</span>, uart_dev-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_USB_DEVICE_STACK)) &#123;</span><br><span class="line">        err = usb_enable(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &amp;&amp; (err != -EALREADY)) &#123;</span><br><span class="line">            printk(<span class="string">&quot;Failed to enable USB\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_USB_UART_ASYNC_ADAPTER) &amp;&amp; !uart_test_async_api(uart_dev)) &#123;</span><br><span class="line">        <span class="comment">/* Implement API adapter */</span></span><br><span class="line">        uart_async_adapter_init(async_adapter, uart_dev);</span><br><span class="line">        uart_dev = async_adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = uart_callback_set(uart_dev, uart_callback, (<span class="type">void</span> *)uart_dev);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to set callback&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wait for USB plug in</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_UART_LINE_CTRL)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Wait for DTR\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> dtr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            uart_line_ctrl_get(uart_dev, UART_LINE_CTRL_DTR, &amp;dtr);</span><br><span class="line">            <span class="keyword">if</span> (dtr) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Give CPU resources to low priority threads. */</span></span><br><span class="line">            k_sleep(K_MSEC(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;DTR set\n&quot;</span>);</span><br><span class="line">        err = uart_line_ctrl_set(uart_dev, UART_LINE_CTRL_DCD, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            printk(<span class="string">&quot;Failed to set DCD, ret code %d\n&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        err = uart_line_ctrl_set(uart_dev, UART_LINE_CTRL_DSR, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            printk(<span class="string">&quot;Failed to set DSR, ret code %d\n&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate buffer and start rx</span></span><br><span class="line">    err = k_mem_slab_alloc(&amp;uart_slab, (<span class="type">void</span> **)&amp;buf, K_NO_WAIT);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to alloc slab&quot;</span>);</span><br><span class="line">    err = uart_rx_enable(uart_dev, buf, BUF_SIZE, RX_INACTIVE_TIMEOUT);</span><br><span class="line">    __ASSERT(err == <span class="number">0</span>, <span class="string">&quot;Failed to enable rx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        k_sleep(K_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li><p>获取设备树节点对应的device结构体指针，之前已经介绍过用Node ID的方法。这里再介绍一种新的方法，那就是根据节点的<code>compatible</code>属性来获取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> DEVICE_DT_GET_ONE(zephyr_cdc_acm_uart);</span><br></pre></td></tr></table></figure>

<p>此宏可以获得一个<code>compatible</code>属性为<code>&quot;zephyr,cdc-acm-uart&quot;</code>的设备树节点对应的device结构体指针。</p>
</li>
<li><p><code>main()</code>函数中，首先初始化USB。这时，USB虚拟串口的API还是只有基于中断的API。</p>
</li>
<li><p>然后通过<code>uart_async_adapter_init</code>函数，为这个USB虚拟串口套一层异步API。</p>
</li>
<li><p>之后的操作，就和前面操作普通串口一样。只不过多了一个Line Ctrl。这是为了等待USB插入，然后设置DCD和DSR信号。</p>
</li>
<li><p>注意到，USB串口的回调函数完全没有改动，和前面的异步串口用的回调函数是一模一样的。</p>
</li>
<li><p>最后，是一个小改动：异步串口API中，串口接收超时的单位是微秒；而这个async adapter里实现的rx_enable函数，传入的参数单位是毫秒。因此，注意<code>RX_INACTIVE_TIMEOUT</code>的值。</p>
</li>
</ul>
<h2 id="运行并测试USB串口"><a href="#运行并测试USB串口" class="headerlink" title="运行并测试USB串口"></a>运行并测试USB串口</h2><p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113111154639.png" alt="image-20231113111154639"></p>
<p>左侧是Jlink USB，下方是nRF52840的USB Device接口。</p>
<p>我在Linux系统中查看串口，会发现多了一个新的串口<code>/dev/ttyACM2</code>：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113111319070.png" alt="image-20231113111319070"></p>
<p>通过minicom或其他串口软件打开这个串口，其行为和前面介绍的异步串口是一样的：发送任意内容，然后等待2s左右，同样的数据从串口回环打印出来：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113111516742.png" alt="image-20231113111516742"></p>
<h1 id="5-低功耗串口"><a href="#5-低功耗串口" class="headerlink" title="5. 低功耗串口"></a>5. 低功耗串口</h1><p>在不开启串口等非必要外设的情况下，Nordic的System On休眠（也就是Zephyr IDLE状态下）的待机功耗只有几微安。但若是开启RX一直等待着数据接收，即使同时没在发送任何数据，大概也会有三百微安左右的功耗。这肯定是低功耗产品不能接受的。</p>
<p>好在，Nordic nrfx异步串口API本身就有一定的低功耗特性：对于发送来说，只要数据发送完毕，tx就会关闭；对于接收来说，只要不被<code>uart_rx_enable()</code>使能，接收也会关闭。发送和接收都关闭时，串口本身就是关闭的，没有功耗。</p>
<p>发送行为本身就已经是低功耗的了，我们不用做任何修改。对于接收行为来说，串口接收空闲超时会产生<code>UART_RX_RDY</code>事件，我们可以在这个事件里关掉串口。但是如何在数据来之前就提前预知，打开串口呢？</p>
<p>一个比较简单的方案是同时把RX引脚配置成下降沿触发的外部中断。当检测到外部中断时，禁用GPIO中断，打开rx；当接收完毕时，关闭rx，打开GPIO中断。</p>
<blockquote>
<p>这种方案，波特率不能超过9600，且GPIO中断内部执行要非常快，连Log也不能打印，否则时间来不及处理。</p>
<p>此外，如果接收到的数据大于缓存剩余的大小，可能会在缓存满时先产生一个<code>UART_RX_RDY</code>事件，等到数据完全接收完毕，空闲超时时又产生一个<code>UART_RX_RDY</code>事件。如何处理这种corner case？还需要开发者去思考一下。</p>
</blockquote>
<h2 id="Nordic-Software-LPUART原理"><a href="#Nordic-Software-LPUART原理" class="headerlink" title="Nordic Software LPUART原理"></a>Nordic Software LPUART原理</h2><p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113114031848.png" alt="image-20231113114031848"></p>
<p>Nordic提供了一个软件实现的低功耗串口，通过额外的两根线来识别是否有数据发出。由于是对称连接的，这里只给出一个MCU的TX和REQ引脚的实测波形图：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113114358096.png" alt="image-20231113114358096"></p>
<p>通信步骤：</p>
<ol>
<li>发送端要发送数据前，先拉高REQ引脚；然后把REQ引脚配置为上拉输入模式。</li>
<li>接收端RDY检测到上升沿，把串口RX使能。然后从RDY引脚输出一个几毫秒的负脉冲。然后把RDY引脚配置为上拉输入模式。</li>
<li>发送端REQ引脚检测到上升沿，才通过TX发出数据</li>
<li>发送完毕后，发送端拉低REQ引脚</li>
<li>接收端检测到RDY引脚下降沿，关闭串口RX。并产生<code>UART_RX_RDY</code>事件给应用层。</li>
</ol>
<blockquote>
<p>可以看出，这时<code>UART_RX_RDY</code>事件并不是空闲超时产生的，而是RDY引脚上拉产生的。因此会比普通的异步串口回调更早执行。</p>
</blockquote>
<h2 id="Nordic-LPUART例程"><a href="#Nordic-LPUART例程" class="headerlink" title="Nordic LPUART例程"></a>Nordic LPUART例程</h2><p>相关链接：</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/samples/peripheral/lpuart/README.html">lpuart例程说明</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/drivers/uart_nrf_sw_lpuart.html#uart-nrf-sw-lpuart">lpuart库说明</a></p>
<p>lpuart例程位置：<code>$&#123;NCS&#125;/nrf/samples/peripheral/lpuart</code></p>
<p>例程有<strong>基于中断</strong>和<strong>异步串口</strong>两种模式。相信看完了前面内容的你，看懂这些代码对你来说已经轻而易举了。</p>
<p>这里只再说一些配置相关的内容。</p>
<p>首先是设备树，在<code>boards/nrf52840dk_nrf52840.overlay</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart1 &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;uart1_default_alt&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;uart1_sleep_alt&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span><br><span class="line">    lpuart: nrf-sw-lpuart &#123;</span><br><span class="line">        compatible = &quot;nordic,nrf-sw-lpuart&quot;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">        req-pin = &lt;46&gt;;</span><br><span class="line">        rdy-pin = &lt;47&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在串口1的节点内新增了一个子节点<code>nrf-sw-lpuart</code>，其标签为<code>lpuart</code>，兼容的驱动为<code>&quot;nordic,nrf-sw-lpuart&quot;</code>。</p>
<p>代码里，获取的串口也不再是硬件串口，而是这个子节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">lpuart</span> =</span> DEVICE_DT_GET(DT_NODELABEL(lpuart));</span><br></pre></td></tr></table></figure>

<p>系统在启动时，会自动初始化串口1，并初始化sw-lpuart。应用层获取的device结构体是sw-lpuart驱动初始化的。</p>
<p>后续的代码，和前面的异步串口一样。底层的REQ，RDY引脚操作都不需要用户编写代码，已经在驱动代码里被实现了。</p>
<p>再看一下<code>prj.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_NRF_SW_LPUART=y</span><br><span class="line"></span><br><span class="line">CONFIG_UART_1_ASYNC=y</span><br><span class="line">CONFIG_UART_1_INTERRUPT_DRIVEN=n</span><br><span class="line">CONFIG_UART_1_NRF_HW_ASYNC=y</span><br><span class="line">CONFIG_UART_1_NRF_HW_ASYNC_TIMER=2</span><br><span class="line">CONFIG_UART_1_NRF_ASYNC_LOW_POWER=y</span><br><span class="line">CONFIG_NRFX_TIMER2=y</span><br></pre></td></tr></table></figure>

<p>可以看出，和前面的异步串口的config相比，只是多出来了<code>CONFIG_NRF_SW_LPUART=y</code>来使能这个库。</p>
<h2 id="LPUART例程运行"><a href="#LPUART例程运行" class="headerlink" title="LPUART例程运行"></a>LPUART例程运行</h2><p>例程本身需要外部回环，因此你需要用两根杜邦线进行跳线：</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113120440376.png" alt="image-20231113120440376"></p>
<p>RDY和REQ引脚一定要接，否则驱动程序内部的状态会乱掉，出现错误。你可以像我这样先跳线，然后外面再用示波器、逻辑分析仪或USB转串口的RX进行监测。</p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113120838710.png" alt="image-20231113120838710"></p>
<p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113121238377.png" alt="image-20231113121238377"></p>
<h2 id="功耗表现"><a href="#功耗表现" class="headerlink" title="功耗表现"></a>功耗表现</h2><p><img src="/jayant97.github.io/./imgs/Zephyr%E9%A9%B1%E5%8A%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%A0%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3.assets/image-20231113131330118.png" alt="image-20231113131330118"></p>
<p>可以看到，在空闲无数据传输时，平均功耗在3.74uA左右。</p>
<h1 id="6-开发自己的程序"><a href="#6-开发自己的程序" class="headerlink" title="6. 开发自己的程序"></a>6. 开发自己的程序</h1><h2 id="把串口程序集成到自己的应用中"><a href="#把串口程序集成到自己的应用中" class="headerlink" title="把串口程序集成到自己的应用中"></a>把串口程序集成到自己的应用中</h2><p>如果你要开发自己的程序，千万不要想着怎么在其他程序里调用今天我分享的这些串口程序、怎么把自己的回调函数注册进来。因为，这相当于你又自己写了一个套娃串口驱动程序。</p>
<p>Zephyr是一个RTOS，这意味着，我们可以把今天分享的内容，当作一个<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html">线程</a>。比如，把<code>main()</code>函数改名为<code>serial_thread_task()</code>，然后在文件的结尾，加上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">K_THREAD_DEFINE(serial_task_id, STACKSIZE, serial_thread_task, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        PRIORITY, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>STACKSIZE和PRIORITY请自行定义。</p>
</blockquote>
<p>如果你要做串口发送，可以建一个<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/data_passing/message_queues.html">消息队列（k_msgq）</a>，在线程中循环等待。以下是一段简单的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_serial_evt</span> <span class="title">evt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续等待消息队列的新数据</span></span><br><span class="line">    <span class="type">int</span> err = k_msgq_get(&amp;my_msg_queue, &amp;evt, K_FOREVER);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;k_msgq_get() error: %d&quot;</span>, err);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//收到数据后，可以进行一些打包、添加crc之类的处理，然后从串口发出</span></span><br><span class="line">    my_process(...);</span><br><span class="line">    uart_tx(...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，一个好的编程习惯是，每个message都加一个is_allocated布尔参数</span></span><br><span class="line">    <span class="comment">// 用来指示接收线程是否需要把message中的缓存给free掉</span></span><br><span class="line">    <span class="keyword">if</span> (evt.is_allocated) &#123;</span><br><span class="line">        k_free(evt.payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要做串口接收，前面说了，由于接收缓存的长度和收到数据长度不一定是整数倍关系。当收到接收回调事件时，可能收到的不是发送端的发的完整的包。而是先收到前面一部分，再收到后面一部分。这就要求我们要把接收到的数据当作是字节流而不是包来处理。需要实现自己的解包函数。</p>
<p>如果你的解包函数太复杂，里面还有一些耗时的业务代码要执行。可以考虑把解包函数提交给<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.zephyrproject.org/latest/kernel/services/threads/workqueue.html#how-to-use-workqueues">Workqueue Threads</a>去执行，你可以在NCS的例程文件夹中全局搜索<code>k_work_</code>相关的API，查看它的用法。这样就无须在串口回调函数中占用太多时间了，它是运行在中断服务函数内部的。也可以像发送端一样，解包好后就丢给消息队列即可。</p>
<h2 id="阻塞与低功耗"><a href="#阻塞与低功耗" class="headerlink" title="阻塞与低功耗"></a>阻塞与低功耗</h2><p>硬件上的低功耗问题，前面已经介绍过低功耗串口的方案。这里稍微讨论一下软件上的低功耗问题，Zephyr中的操作系统的阻塞行为（比如<code>k_sleep()</code>和这里的<code>k_msgq_get()</code>），基本上都会让线程暂停。这意味着，这段时间内这个线程不会运行。如果所有线程都不在运行，则Zephyr会运行IDLE线程。而IDLE线程在很短的一段时间后会自动进入休眠。这意味着开发者可以放心大胆地在自己的线程中使用操作系统的阻塞API，不用担心CPU不会进入休眠。</p>
<h2 id="串口API的兼容"><a href="#串口API的兼容" class="headerlink" title="串口API的兼容"></a>串口API的兼容</h2><p>我们前面提到，异步API和基于中断的API是完全不同的两套API。<br>而在串口驱动目录下的<code>Kconfig.nrfx</code>中可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config UART_1_ASYNC</span><br><span class="line">    bool &quot;Asynchronous API support on port 1&quot;</span><br><span class="line">    depends on UART_ASYNC_API &amp;&amp; !UART_1_INTERRUPT_DRIVEN</span><br><span class="line">    default y</span><br><span class="line">    help</span><br><span class="line">      This option enables UART Asynchronous API support on port 1.</span><br></pre></td></tr></table></figure>
<p>要使用异步API，必须单独禁用这个串口的中断API。<br>如果你要使用USB CDC ACM（需要中断API）的同时使用串口0的异步API，则需要这样配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_UART_INTERRUPT_DRIVEN=y</span><br><span class="line">CONFIG_UART_0_INTERRUPT_DRIVEN=n</span><br></pre></td></tr></table></figure>
<p>意思是，对于整个串口驱动来说，启用中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig）。<br>但是对于串口0来说，关闭中断API（这个配置项来源于Zephyr串口驱动目录下的Kconfig.nrfx）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io">Jayant Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/">https://jayant-tang.github.io/jayant97.github.io/2023/11/4c8e1d7d162d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jayant-tang.github.io/jayant97.github.io" target="_blank">一苇万顷</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/jayant97.github.io/tags/Nordic/">Nordic</a><a class="post-meta__tags" href="/jayant97.github.io/tags/Zephyr/">Zephyr</a><a class="post-meta__tags" href="/jayant97.github.io/tags/DeviceTree/">DeviceTree</a></div><div class="post_share"><div class="social-share" data-image="/jayant97.github.io/imgs/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div class="next-post pull-right"><a href="/jayant97.github.io/2023/08/045cdc9c9b10/" title="在nRF7002开发板上运行MQTT例程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在nRF7002开发板上运行MQTT例程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/jayant97.github.io/2024/01/b74491c1a080/" title="Nordic GPIO硬件原理与NCS应用详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-22</div><div class="title">Nordic GPIO硬件原理与NCS应用详解</div></div></a></div><div><a href="/jayant97.github.io/2023/03/4b274a50e575/" title="详解Zephyr设备树（DeviceTree）与驱动模型"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">详解Zephyr设备树（DeviceTree）与驱动模型</div></div></a></div><div><a href="/jayant97.github.io/2023/11/1349f878e408/" title="在NCS中使用NRFX外设驱动库——以I2C为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">在NCS中使用NRFX外设驱动库——以I2C为例</div></div></a></div><div><a href="/jayant97.github.io/2022/12/2a39e705bff0/" title="理解Zephyr项目的配置与构建系统"><img class="cover" src="/jayant97.github.io/imgs/nordic/zephyr.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-04</div><div class="title">理解Zephyr项目的配置与构建系统</div></div></a></div><div><a href="/jayant97.github.io/2022/12/175d0fa05ecc/" title="nRF9160与nRF Cloud应用示例"><img class="cover" src="/jayant97.github.io/imgs/nordic/nrf-cloud.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">nRF9160与nRF Cloud应用示例</div></div></a></div><div><a href="/jayant97.github.io/2023/08/045cdc9c9b10/" title="在nRF7002开发板上运行MQTT例程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="title">在nRF7002开发板上运行MQTT例程</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Hello-world%E5%B7%A5%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">2. Hello world工程解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">工程目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#printk%E8%BE%93%E5%87%BA%E9%85%8D%E7%BD%AE"><span class="toc-text">printk输出配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console%E8%AE%BE%E5%A4%87%E4%B8%8Econsole%E9%A9%B1%E5%8A%A8"><span class="toc-text">console设备与console驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Zephyr%E6%A0%87%E5%87%86%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3"><span class="toc-text">3. Zephyr标准异步串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zephyr%E4%B8%B2%E5%8F%A3API%E5%88%86%E7%B1%BB"><span class="toc-text">Zephyr串口API分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81"><span class="toc-text">异步串口代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">异步串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">异步串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">硬件连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C"><span class="toc-text">异步串口代码运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-USB-CDC-ACM%E4%B8%B2%E5%8F%A3"><span class="toc-text">4. USB CDC ACM串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">USB串口设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">USB串口配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USB%E4%B8%B2%E5%8F%A3%E4%BB%A3%E7%A0%81"><span class="toc-text">USB串口代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%B9%B6%E6%B5%8B%E8%AF%95USB%E4%B8%B2%E5%8F%A3"><span class="toc-text">运行并测试USB串口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BD%8E%E5%8A%9F%E8%80%97%E4%B8%B2%E5%8F%A3"><span class="toc-text">5. 低功耗串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nordic-Software-LPUART%E5%8E%9F%E7%90%86"><span class="toc-text">Nordic Software LPUART原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nordic-LPUART%E4%BE%8B%E7%A8%8B"><span class="toc-text">Nordic LPUART例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LPUART%E4%BE%8B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">LPUART例程运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97%E8%A1%A8%E7%8E%B0"><span class="toc-text">功耗表现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">6. 开发自己的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%88%90%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD"><span class="toc-text">把串口程序集成到自己的应用中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97"><span class="toc-text">阻塞与低功耗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3API%E7%9A%84%E5%85%BC%E5%AE%B9"><span class="toc-text">串口API的兼容</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Jayant Tang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/jayant97.github.io/js/utils.js"></script><script src="/jayant97.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c91ce0493b5c3e886110',
      clientSecret: '7599decf69128ba1a83c1f3ef0923395a9bd8a60',
      repo: 'jayant97.github.io',
      owner: 'Jayant-Tang',
      admin: ['Jayant-Tang'],
      id: '5749979c1110dfbff33bebe72e76e426',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/jayant97.github.io/js/search/local-search.js"></script></div></div></body></html>